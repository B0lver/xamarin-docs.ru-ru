---
ms.assetid: 7C132A7C-4973-4B2D-98DC-3661C08EA33F
title: Жизненный цикл приложения WPF и Xamarin. Forms
description: В этом документе сравниваются сходства и различия между жизненным циклом приложения для Xamarin. Forms и приложений WPF. Он также рассматривает визуальное дерево, графику, ресурсы и стили.
author: davidortinau
ms.author: daortin
ms.date: 04/26/2017
ms.openlocfilehash: 725af8aebb111ac620a7d1ca5eebf73f31ee4a5e
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73016475"
---
# <a name="wpf-vs-xamarinforms-app-lifecycle"></a>Жизненный цикл приложения WPF и Xamarin. Forms

Xamarin. Forms принимает множество руководств по проектированию из платформ на основе XAML, которые были выпущены до этого, особенно в WPF. Тем не менее, в других случаях это сильно отличается от того, что может быть закрепления для пользователей, пытающихся выполнить миграцию. В этом документе предпринимается попытка найти некоторые из этих проблем и предоставлены рекомендации по взаимовозможности моста данных WPF в Xamarin. Forms.

## <a name="app-lifecycle"></a>Жизненный цикл приложения

Жизненный цикл приложения между WPF и Xamarin. Forms аналогичен. Оба запускаются во внешнем коде (на платформе) и запускают пользовательский интерфейс с помощью вызова метода. Отличие заключается в том, что Xamarin. Forms всегда начинается в сборке, зависящей от платформы, которая затем инициализирует и создает пользовательский интерфейс для приложения.

**WPF**

- `Main method > App > MainWindow`

> [!NOTE]
> По умолчанию метод `Main` автоматически создается и не отображается в коде.

**Xamarin.Forms**

- `Main method > AppDelegate > App > ContentPage` &ndash; **iOS**
- `MainActivity > App > ContentPage` &ndash; **Android**
- `Main method > App(UWP) > MainPage(UWP) > App > ContentPage` &ndash; **UWP**

### <a name="application-class"></a>Класс приложения

Как WPF, так и Xamarin. Forms имеют класс `Application`, который создается как одноэлементный. В большинстве случаев приложения будут производными от этого класса для предоставления пользовательского приложения, хотя это не является обязательным в WPF. Оба предоставляют свойство `Application.Current` для нахождение созданного одноэлементного экземпляра.

### <a name="global-properties--persistence"></a>Глобальные свойства и сохраняемость

Как WPF, так и Xamarin. Forms имеют `Application.Properties`ный словарь, в котором можно хранить глобальные объекты уровня приложения, доступные в любом месте приложения. Ключевое различие заключается в том, что Xamarin. Forms _сохранит все типы_ -примитивы, хранящиеся в коллекции, когда приложение будет приостановлено, и перезагрузить их при повторном запуске. WPF не поддерживает такое поведение автоматически. вместо этого большинство разработчиков полагаться на изолированное хранилище или использует встроенную поддержку `Settings`.

## <a name="defining-pages-and-the-visual-tree"></a>Определение страниц и визуального дерева

WPF использует `Window` в качестве корневого элемента для любого визуального элемента верхнего уровня. Это определяет HWND в мире Windows для вывода сведений. В WPF можно создавать и отображать любое количество окон одновременно.

В Xamarin. Forms визуальный элемент верхнего уровня всегда определяется платформой, например в iOS, это `UIWindow`. Xamarin. Forms преобразует содержимое в эти представления машинного кода с помощью класса `Page`. Каждая `Page` в Xamarin. Forms представляет собой уникальную "страницу" в приложении, где только одна видима за раз.

Как Впфс `Window`, так и Xamarin. Forms `Page` включают свойство `Title`, влияющее на отображаемое название, и оба имеют свойство `Icon` для отображения определенного значка для страницы (**Обратите внимание** , что заголовок и значок не всегда видны в Xamarin. Forms). ). Кроме того, можно изменять общие визуальные свойства как для фона, так и для изображения.

Технически можно выполнить визуализацию в двух отдельных представлениях платформы (например, определить два `UIWindow` объектов и получить вторую визуализацию на внешний экран или AirPlay), для этого требуется код, зависящий от платформы, и не является напрямую поддерживаемой функцией Сама по себе Xamarin. Forms.

### <a name="views"></a>Представления

Визуальная иерархия для обеих платформ аналогична. WPF является несколько более глубоким из-за поддержки документов WYSIWYG.

**WPF**

```
DependencyObject - base class for all bindable things
   Visual - rendering mechanics
      UIElement - common events + interactions
         FrameworkElement - adds layout
            Shape - 2D graphics
            Control - interactive controls
```

**Xamarin.Forms**

```
BindableObject - base class for all bindable things
   Element - basic parent/child support + resources + effects
      VisualElement - adds visual rendering properties (color, fonts, transforms, etc.)
         View - layout + gesture support
```

### <a name="view-lifecycle"></a>Жизненный цикл представления

Xamarin. Forms в основном ориентированы на мобильные сценарии. Таким образом, приложения _активируются_, _приостанавливаются_и _повторно активируются_ по мере взаимодействия пользователя с ними. Это похоже на щелчок `Window` в приложении WPF, и существует набор методов и соответствующих событий, которые можно переопределить или подключить для отслеживания этого поведения.

| Цель | Метод WPF | Метод Xamarin. Forms |
|--- |--- |--- |
|Начальная активация|ctor + окно. onloadо|ctor + Page. OnStart|
|Указанного|Window. Исвисиблечанжед|Страница. появляется|
|Hidden|Window. Исвисиблечанжед|Страница. отображается|
|Фокус приостановки или потери|Окно. OnDeactivate|Страница. Переход в спящий режим|
|Активированный/полученный фокус|Окно. onactivateось|Страница. onresume|
|Закрыто|Window. OnClosing + Window. onclosingось|Н/Д|

Обе службы поддерживают скрытие и отображение дочерних элементов управления. в WPF это свойство с тремя состояниями `IsVisible` (видимый, скрытый и свернутый). В Xamarin. Forms он просто видим или скрыт с помощью свойства `IsVisible`.

### <a name="layout"></a>Макет

Макет страницы выполняется в одном 2-проходном (измерении или упорядочении) в WPF. Вы можете присоединиться к макету страницы, переопределив следующие методы в классе `Page` Xamarin. Forms:

| Метод | Цель |
|--- |--- |
|ончилдмеасуреинвалидатед|Предпочтительный размер дочернего элемента изменился.|
|онсизеаллокатед|Странице была назначена ширина и высота.|
|Событие Лайаутчанжед|Изменился макет или размер страницы.|

Нет события глобального макета, которое вызывается сегодня, и не содержит глобального `CompositionTarget.Rendering` события, подобного в WPF.

#### <a name="common-layout-properties"></a>Общие свойства макета

WPF и Xamarin. Forms поддерживают `Margin` для контроля расстояния вокруг элемента, а `Padding` для контроля расстояния _внутри_ элемента. Кроме того, большинство представлений макета Xamarin. Forms имеют свойства для управления пространством (например, строка или столбец).

Кроме того, большинство элементов имеют свойства, которые влияют на то, как они расположены в родительском контейнере:

| WPF | Xamarin.Forms | Цель |
|--- |--- |--- |
|HorizontalAlignment|хоризонталоптионс|Параметры Left, Center, Right/Stretch|
|VerticalAlignment|вертикалоптионс|Параметры Top, Center, Bottom/Stretch|

> [!NOTE]
> Фактическая интерпретация этих свойств зависит от родительского контейнера.

#### <a name="layout-views"></a>Представления макета

WPF и Xamarin. Forms используют элементы управления макета для размещения дочерних элементов. В большинстве случаев они очень близки друг к другу с точки зрения функциональности.

| WPF | Xamarin.Forms | Стиль макета |
|--- |--- |--- |
|StackPanel|StackLayout|Бесконечные стеки с направлением слева направо или сверху вниз|
|Grid|Grid|Табличный формат (строки и столбцы)|
|DockPanel|Н/Д|Закрепить на краях окна|
|Canvas|AbsoluteLayout|Пиксельное и координатное позиционирование|
|WrapPanel|Н/Д|Стек переноса|
|Н/Д|RelativeLayout|Относительное позиционирование на основе правил|

> [!NOTE]
> Xamarin. Forms не поддерживает `GridSplitter`.

В обеих платформах _присоединенные свойства_ используются для точной настройки дочерних элементов.

### <a name="rendering"></a>Отрисовка

Механизм визуализации для WPF и Xamarin. Forms имеет коренные отличия. В WPF элементы управления, создаваемые непосредственно, отображают содержимое в пикселах на экране. WPF поддерживает два графа объектов (_деревьев_) для представления. _логическое дерево_ представляет элементы управления, как определено в коде или XAML, а _визуальное дерево_ — фактическую отрисовку на экране, которая выполняется либо непосредственно элементом визуального элемента (через виртуальный метод Draw) или с помощью определяемого XAML `ControlTemplate`, который можно заменить или настроить. Как правило, визуальное дерево сложнее, так как оно включает границы вокруг элементов управления, метки для неявного содержимого и т. д. В состав WPF входит набор API-интерфейсов (`LogicalTreeHelper` и `VisualTreeHelper`) для изучения этих двух графов объектов.

В Xamarin. Forms элементы управления, определяемые в `Page`, — это просто простые объекты данных. Они похожи на представление логического дерева, но никогда не отображают содержимое самостоятельно. Вместо этого они являются _моделью данных_ , которая влияет на отрисовку элементов. Фактическая визуализация выполняется [отдельным набором _визуальных модулей подготовки_ отчетов, которые сопоставляются с каждым типом элемента управления](~/xamarin-forms/app-fundamentals/custom-renderer/index.md). Эти модули подготовки регистрируются в каждом из проектов для конкретной платформы с помощью сборок Xamarin. Forms, зависящих от платформы. Список можно просмотреть [здесь](~/xamarin-forms/app-fundamentals/custom-renderer/renderers.md). Помимо замены или расширения модуля подготовки отчетов, Xamarin. Forms также поддерживает [эффекты](~/xamarin-forms/app-fundamentals/effects/index.md) , которые можно использовать для повлиять на отрисовку в собственном режиме на уровне платформы.

#### <a name="the-logicalvisual-tree"></a>Логическое или визуальное дерево

Нет доступного API для прохода по логическому дереву в Xamarin. Forms, но можно использовать отражение для получения той же информации. Например, [ниже приведен метод, который может перечислять логические дочерние элементы](https://github.com/xamarinhq/xamu-infrastructure/blob/master/src/XamU.Infrastructure/Extensions/ElementExtensions.cs#L108) с помощью отражения.

## <a name="graphics"></a>Графика

Xamarin. Forms не включает графическую систему для примитивов за пределами простого прямоугольника (`BoxView`). Вы можете включить сторонние библиотеки, такие как [SkiaSharp](~/graphics-games/skiasharp/index.md) , для получения 2D-рисования на разных платформах или [UrhoSharp](~/graphics-games/urhosharp/index.md) для трехмерного.

## <a name="resources"></a>Ресурсы

WPF и Xamarin. Forms имеют концепцию ресурсов и словарей ресурсов. Любой тип объекта можно поместить в `ResourceDictionary` с ключом, а затем выполнить поиск в `{StaticResource}` для тех вещей, которые не изменяются, или `{DynamicResource}` для действий, которые могут измениться в словаре во время выполнения. Использование и механика одинаковы в одном из следующих отличий: Xamarin. Forms требуют определения `ResourceDictionary` для назначения свойству `Resources`, в то время как WPF предварительно создает и назначает его.

Например, см. определение ниже:

**WPF**

```xaml
<Window.Resources>
   <Color x:Key="redColor">#ff0000</Color>
   ...
</Window.Resources>
```

**Xamarin.Forms**

```xaml
<ContentPage.Resources>
   <ResourceDictionary>
      <Color x:Key="redColor">#ff0000</Color>
      ...
   </ResourceDictionary>
</ContentPage.Resources>
```

Если не определить `ResourceDictionary`, возникает ошибка времени выполнения.

## <a name="styles"></a>Стили

Стили также полностью поддерживаются в Xamarin. Forms и могут использоваться для создания темы для элементов Xamarin. Forms, составляющих пользовательский интерфейс. Они поддерживают триггеры (свойство, событие и данные), наследование с помощью `BasedOn`и поиск ресурсов для значений. Стили применяются к элементам явным образом через свойство `Style` или неявно, не указывая ключ ресурса — так же, как WPF.

### <a name="device-styles"></a>Стили устройства

WPF имеет набор предопределенных свойств (хранимых как статические значения для набора статических классов, например `SystemColors`), которые определяют системные цвета, шрифты и метрики в виде значений и ключей ресурсов. Xamarin. Forms аналогичен, но определяет набор [стилей устройств](~/xamarin-forms/user-interface/styles/device.md) для представления тех же вещей. Эти стили предоставляются платформой и устанавливаются в значения, основанные на среде выполнения (например, Специальные возможности).

**WPF**

```xaml
<Label Text="Title" Foreground="{DynamicResource {x:Static SystemColors.DesktopBrushKey}}" />
```

**Xamarin.Forms**

```xaml
<Label Text="Title" Style="{DynamicResource TitleStyle}" />
```
