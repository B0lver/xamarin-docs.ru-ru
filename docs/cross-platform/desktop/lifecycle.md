---
ms.assetid: 7C132A7C-4973-4B2D-98DC-3661C08EA33F
title: WPF и. Жизненный цикл приложения Xamarin.Forms
description: Понимание процесса запуска приложения и работе с состояниями фона
ms.technology: xamarin-crossplatform
author: asb3993
ms.author: amburns
ms.date: 04/26/2017
ms.openlocfilehash: dfcc00fa34d3bd5026653a4550e16634bd2c6238
ms.sourcegitcommit: 4b0582a0f06598f3ff8ad5b817946459fed3c42a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="wpf-vs-xamarinforms-app-lifecycle"></a>WPF и. Жизненный цикл приложения Xamarin.Forms

Руководство по проектированию с платформ на основе XAML, полученные до его, особенно WPF значительно Xamarin.Forms. Тем не менее другие способы его существенном может быть прикрепленные точки для людей, выполнить переход по. В этом документе пытается определить эти проблемы и рекомендации для моста знаний WPF в Xamarin.Forms.

## <a name="app-lifecycle"></a>Жизненный цикл приложения

Аналогично жизненного цикла приложения между WPF и Xamarin.Forms. Как запустить в коде внешние (платформы) и запустить пользовательский Интерфейс через вызов метода. Разница заключается в том, что Xamarin.Forms всегда начинается в сборке платформой, который инициализирует и создает пользовательский Интерфейс для приложения.

**WPF**

- `Main method > App > MainWindow`

> [!NOTE]
> `Main` Метод является, по умолчанию, автоматически созданный и не видны в коде.

**Xamarin.Forms**

- **операций ввода-вывода** &ndash; `Main method > AppDelegate > App > ContentPage`
- **Android** &ndash; `MainActivity > App > ContentPage`
- **UWP** &ndash; `Main method > App(UWP) > MainPage(UWP) > App > ContentPage`

### <a name="application-class"></a>Класс приложения

WPF и Xamarin.Forms имеют `Application` класс, который создается как Singleton-класс. В большинстве случаев приложения будет наследовать от этого класса для предоставления пользовательского приложения, хотя это не является строго обязательным в WPF. Они предоставлять `Application.Current` свойства найдите созданный единственного экземпляра.

### <a name="global-properties--persistence"></a>Глобальные свойства + сохраняемости

WPF и Xamarin.Forms имеют `Application.Properties` словарь доступен хранения глобальных объектов уровня приложения, которые доступны в любом месте приложения. Ключевое различие состоит в который будет Xamarin.Forms _сохранения_ любой простых типов, хранящихся в коллекции, когда приложение приостановлено и загружает их повторно, когда он будет запущен повторно. WPF автоматически не поддерживает такой режим работы - вместо этого, большинство разработчиков полагаться на изолированное хранилище, или используются встроенные `Settings` поддержки.

## <a name="defining-pages-and-the-visual-tree"></a>Определение страниц и визуального дерева

WPF использует `Window` как корневой элемент для любого элемента visual верхнего уровня. Этот параметр определяет HWND в мире Windows для отображения информации. Можно создавать и отображать количество окон одновременно угодно в WPF.

Визуальный элемент верхнего уровня всегда определяется в Xamarin.Forms, платформа — например на iOS, это `UIWindow`. Xamarin.Forms отрисовывает его содержимого в эти представления собственной платформы с помощью `Page` класса. Каждый `Page` в Xamarin.Forms представляет уникальный «страница» в приложении, где только один имеет видимым одновременно.

Оба WPFs `Window` и Xamarin.Forms `Page` включают `Title` повлиять отображаемый заголовок и оба свойства имеют `Icon` свойство для отображения указанного значка для страницы (**Примечание** , Заголовок и значок, не всегда отображаются в Xamarin.Forms). Кроме того можно изменить общие свойства visual на обоих, такие как фоновый цвет или рисунок.

Технически возможно, должны быть отображены два представления отдельной платформы (например определить две `UIWindow` объектов и иметь второй одно визуализации на внешний дисплей или AirPlay), он требует от платформы код для этого и не напрямую, поддерживаемой функцией Xamarin.Forms сам.

### <a name="views"></a>Представления

Аналогично visual иерархии для обеих платформ. WPF — чуть более глубокого из-за его поддержка WYSIWYG документов.

**WPF**

```
DependencyObject - base class for all bindable things
   Visual - rendering mechanics
      UIElement - common events + interactions
         FrameworkElement - adds layout
            Shape - 2D graphics
            Control - interactive controls
```

**Xamarin.Forms**

```
BindableObject - base class for all bindable things
   Element - basic parent/child support + resources + effects
      VisualElement - adds visual rendering properties (color, fonts, transforms, etc.)
         View - layout + gesture support
```

### <a name="view-lifcycle"></a>Представление Lifcycle

Xamarin.Forms преимущественно вокруг сценариев мобильных устройств. Таким образом, приложения, _активации_, _приостановки_, и _повторно_ как пользователь взаимодействует с ними. Это похоже на щелчок мышью из `Window` в приложении WPF и существует набор методов и соответствующих событий, можно переопределить или обработки для наблюдения за это поведение.

| Цель | Метод WPF | Метод Xamarin.Forms |
|--- |--- |--- |
|Первоначальной активации|ctor + Window.OnLoaded|ctor + Page.OnStart|
|Показано|Window.IsVisibleChanged|Page.Appearing|
|Hidden|Window.IsVisibleChanged|Page.Disapearing|
|Приостановить потерянные фокус|Window.OnDeactivated|Page.OnSleep|
|Активировать получено фокус|Window.OnActivated|Page.OnResume|
|Closed|Window.OnClosing + Window.OnClosed|Н/Д|


Поддержки как скрытие/отображение дочерних элементов управления, в WPF это свойство тремя состояниями `IsVisible` (видимым, скрытый и свернутый). В Xamarin.Forms, он является только видимым или скрытым с помощью `IsVisible` свойство.

### <a name="layout"></a>Макет

Макет страницы происходит в одном 2-этап (мер/расположение) происходит в WPF. Можно прикрепить в макет страницы, переопределив следующие методы в Xamarin.Forms `Page` класса:

| Метод | Цель |
|--- |--- |
|OnChildMeasureInvalidated|Предпочтительный размер дочерний элемент был изменен.|
|OnSizeAllocated|Страница назначено ширины или высоты.|
|События LayoutChanged представления|Макет и размер страницы был изменен.|

Существует глобальных макета события, называемый сегодня не не существует глобальной `CompositionTarget.Rendering` найти события, такого как в WPF.

#### <a name="common-layout-properties"></a>Общие свойства макета

WPF и поддерживать Xamarin.Forms `Margin` управления интервала вокруг элемента, и `Padding` интервала управления _внутри_ элемента. Кроме того большая часть представления макета Xamarin.Forms имеет свойства для расстояния (например, строки или столбца).

Кроме того большинство элементов имеют свойства, чтобы повлиять на то, как они расположены в родительском контейнере.

| WPF | Xamarin.Forms | Цель |
|--- |--- |--- |
|HorizontalAlignment|HorizontalOptions|Параметры влево/Center/вправо/Stretch|
|VerticalAlignment|VerticalOptions|Параметры верхнего/Center/нижней или Stretch|

> [!NOTE]
> Фактический интерпретации этих свойств зависит от родительского контейнера.

#### <a name="layout-views"></a>Режимы макетов

WPF и Xamarin.Forms использовать элементы управления макета для размещения дочерних элементов. В большинстве случаев это очень близко друг к другу с точки зрения функциональности.

| WPF | Xamarin.Forms | Стиль макета |
|--- |--- |--- |
|StackPanel|StackLayout|Слева направо и сверху вниз бесконечный размещения|
|Grid|Grid|Табличном формате (строки и столбцы)|
|DockPanel|Н/Д|Закрепить края окна|
|Canvas|AbsoluteLayout|Пиксель и координат позиционирования|
|WrapPanel|Н/Д|Перенос стека|
|Н/Д|RelativeLayout|Относительное основанным на правилах расположение|

> [!NOTE]
> Xamarin.Forms не поддерживает `GridSplitter`.

Обе эти платформы используют _вложенные свойства_ для точной настройки дочерних элементов.

### <a name="rendering"></a>Отрисовка

Механизм отрисовки WPF и Xamarin.Forms коренным образом отличается. В WPF элементы управления, которые непосредственно создать отображать содержимое пикселей на экране. WPF поддерживает два объекта диаграмм (_деревьев_) этого - _логического дерева_ представляет элементы управления, как определено в коде или в XAML и _визуального дерева_ представляет фактического отображения на экране, который является выполнить непосредственно с помощью визуального элемента (с помощью метода draw виртуальный) или через определенные XAML `ControlTemplate` которого можно заменить или настроить. Как правило визуальное дерево сложнее, поскольку он включает такие как границы вокруг элементов управления, метки для неявного содержимого и т. д. WPF включает набор API-интерфейсов (`LogicalTreeHelper` и `VisualTreeHelper`) для проверки, эти два объекта диаграммы.

В Xamarin.Forms, элементы управления определяются в `Page` — это просто простых данных объекты. Они аналогичны представление логического дерева, но никогда не отображают содержимое на свои собственные. Вместо этого они являются _модели данных_ которого влияет на отрисовку элементов. Отображение в действительности выполняется путем [разделения набора _visual модулей подготовки отчетов_ которой сопоставляются каждого типа элемента управления](~/xamarin-forms/app-fundamentals/custom-renderer/index.md). Эти модули подготовки отчетов регистрируются в каждом из проектов платформы сборки Xamarin.Forms конкретную платформу. Можно просмотреть список [здесь](~/xamarin-forms/app-fundamentals/custom-renderer/renderers.md). Кроме замена или расширение модуль подготовки отчетов, Xamarin.Forms имеется также поддержка [эффекты](~/xamarin-forms/app-fundamentals/effects/index.md) которого может использоваться для оказания влияния на собственном визуализации на основе plaform.

#### <a name="the-logicalvisual-tree"></a>Логическое или Visual дерева

Не предоставляется API-интерфейс для прохода по дереву логических в Xamarin.Forms -, но может использовать отражение, чтобы получить те же сведения. Например [здесь — это метод, для которого можно перечислить логических дочерних](https://github.com/xamarinhq/xamu-infrastructure/blob/master/src/XamU.Infrastructure/Extensions/ElementExtensions.cs#L108) с отражением.

## <a name="graphics"></a>Графика

Xamarin.Forms не содержит графической системе для примитивов помимо простого прямоугольника (`BoxView`). Могут включать библиотеки сторонних производителей, например [SkiaSharp](~/graphics-games/skiasharp/index.md) для получения кросс платформенных 2D рисования, или [UrhoSharp](~/graphics-games/urhosharp/index.md) для трехмерной прорисовки.

## <a name="resources"></a>Ресурсы

WPF и Xamarin.Forms имеют концепцию ресурсы и словари ресурсов. Можно разместить любой тип объекта в `ResourceDictionary` с ключом, а затем найдите его с `{StaticResource}` для таких задач, которые не изменится, или `{DynamicResource}` для таких задач, которые можно изменить в словаре во время выполнения. Использование и механизмы совпадают с одним отличием: Xamarin.Forms требует определения `ResourceDictionary` присвоить `Resources` свойство в то время как WPF предварительно создает одну и назначает его для вас.

Например см. Определение ниже:

**WPF**

```xaml
<Window.Resources>
   <Color x:Key="redColor">#ff0000</Color>
   ...
</Window.Resources>
```

**Xamarin.Forms**

```xaml
<ContentPage.Resources>
   <ResourceDictionary>
      <Color x:Key="redColor">#ff0000</Color>
      ...
   </ResourceDictionary>
</ContentPage.Resources>
```

Если вы не задаете `ResourceDictionary`, возникает ошибка времени выполнения.

## <a name="styles"></a>Стили

Стили также полностью поддерживаются в Xamarin.Forms и можно использовать тему Xamarin.Forms элементы, входящие в состав пользовательского интерфейса. Они поддерживают наследование (свойства, события и данные), триггеры, через `BasedOn`и поиск ресурсов для значения. Стили применяются к элементам либо явным образом данном через `Style` свойства или implicitely, не указав ключ ресурса - так же, как WPF.

### <a name="device-styles"></a>Стили устройства

WPF имеет набор стандартных свойств (сохраненных как статические значения в набор статических классов, таких как `SystemColors`) которого определяют системы цвета, шрифты и метрики в виде значения и ключи ресурсов. Xamarin.Forms аналогична, но определяет набор [устройства стили](~/xamarin-forms/user-interface/styles/device.md) для представления и те же действия. Эти стили предоставляемые frameowrk и задайте значения в зависимости от среды выполнения (например, специальные возможности).

**WPF**

```xaml
<Label Text="Title" Foreground="{DynamicResource {x:Static SystemColors.DesktopBrushKey}}" />
```

**Xamarin.Forms**

```xaml
<Label Text="Title" Style="{DynamicResource TitleStyle}" />
```
