---
ms.assetid: 7C132A7C-4973-4B2D-98DC-3661C08EA33F
title: WPF vs. Жизненный цикл приложения Xamarin.Forms
description: В этом документе сравнивается сходств и различий между жизненным циклом приложений для приложений Xamarin.Forms и WPF. Он также сканирует визуального дерева, графики, ресурсы и стили.
author: asb3993
ms.author: amburns
ms.date: 04/26/2017
ms.openlocfilehash: 653e2f849a74948d3636f594eae91cdeabfae138
ms.sourcegitcommit: 7eed80186e23e6aff3ddbbf7ce5cd1fa20af1365
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/11/2018
ms.locfileid: "51526797"
---
# <a name="wpf-vs-xamarinforms-app-lifecycle"></a>WPF vs. Жизненный цикл приложения Xamarin.Forms

Руководство по проектированию из платформы на основе XAML, полученные до нее, особенно WPF значительно Xamarin.Forms. Тем не менее в других целях его существенном которого может стать прикрепленные точкой для людей, попытка перенесем. В этом документе пытается определить эти проблемы и рекомендации для моста знаний WPF в Xamarin.Forms.

## <a name="app-lifecycle"></a>Жизненный цикл приложения

Аналогично жизненного цикла приложения между WPF и Xamarin.Forms. Как запустить в коде external (платформы) и запустить пользовательский Интерфейс посредством вызова метода. Разница заключается в том, что Xamarin.Forms всегда начинается в сборке платформы, который затем инициализирует и создает пользовательский Интерфейс для приложения.

**WPF**

- `Main method > App > MainWindow`

> [!NOTE]
> `Main` Метод является, по умолчанию, автоматически созданный и не видны в коде.

**Xamarin.Forms**

- **iOS** &ndash; `Main method > AppDelegate > App > ContentPage`
- **Android** &ndash; `MainActivity > App > ContentPage`
- **UWP** &ndash; `Main method > App(UWP) > MainPage(UWP) > App > ContentPage`

### <a name="application-class"></a>Класс приложения

WPF и Xamarin.Forms `Application` класс, который создается как единственный экземпляр. В большинстве случаев приложения будет наследовать от этого класса для предоставления пользовательского приложения, несмотря на то, что это не является обязательным требованием в WPF. Оба предоставляют `Application.Current` свойство, чтобы найти созданный единственный экземпляр.

### <a name="global-properties--persistence"></a>Глобальные свойства + сохраняемости

WPF и Xamarin.Forms имеют `Application.Properties` словарь доступных хранения глобальных объектов уровня приложения, которые доступны в любом месте приложения. Основное отличие заключается в который будет Xamarin.Forms _сохранения_ любые типы-примитивы, хранящихся в коллекции, когда приложение приостановлено и загружает их повторно, когда он будет запущен повторно. WPF автоматически не поддерживает такое поведение — вместо этого, большинство разработчиков полагались на изолированное хранилище или используется встроенная `Settings` поддержки.

## <a name="defining-pages-and-the-visual-tree"></a>Определение страниц и визуального дерева

WPF использует `Window` как корневой элемент для любого элемента верхнего уровня visual. Это определяет HWND в мире Windows для отображения информации. Можно создать и отобразить столько окна одновременно, как вам нравится в WPF.

В Xamarin.Forms, визуальный элемент верхнего уровня всегда определяется платформой — например на iOS, это `UIWindow`. Xamarin.Forms отрисовывает его содержимого в этими двумя представлениями собственной платформы с помощью `Page` класса. Каждый `Page` в Xamarin.Forms представляет уникальный «страница» в приложении, где только один имеет видимой за раз.

Оба WPFs `Window` и Xamarin.Forms `Page` включают `Title` свойства, которые влияют на отображаемый заголовок и оба имеют `Icon` свойство для отображения указанного значка для страницы (**Примечание** , Заголовок и значок не всегда отображаются в Xamarin.Forms). Кроме того можно изменить общие свойства визуальных элементов на обоих, такие как фоновый цвет или рисунок.

Технически возможно, должны быть отображены два представления отдельной платформой (например определите две `UIWindow` объектов и иметь второго отрисовки для внешнего дисплея или AirPlay), он требует от платформы код для этого и не непосредственно поддерживаемой функцией Xamarin.Forms сам.

### <a name="views"></a>Представления

Аналогично визуальной иерархии для обеих платформ. WPF расширенную из-за его поддержка WYSIWYG документов.

**WPF**

```
DependencyObject - base class for all bindable things
   Visual - rendering mechanics
      UIElement - common events + interactions
         FrameworkElement - adds layout
            Shape - 2D graphics
            Control - interactive controls
```

**Xamarin.Forms**

```
BindableObject - base class for all bindable things
   Element - basic parent/child support + resources + effects
      VisualElement - adds visual rendering properties (color, fonts, transforms, etc.)
         View - layout + gesture support
```

### <a name="view-lifecycle"></a>Жизненный цикл представления

Xamarin.Forms в первую очередь ориентирован на сценариев для мобильных устройств. Таким образом, приложения, _активации_, _приостановлено_, и _повторной активации_ как пользователь взаимодействует с ними. Это похоже на щелчок мышью от `Window` в приложении WPF и существует набор методов и соответствующих событий, можно переопределить или отладочному для наблюдения за это поведение.

| Цель | Метод WPF | Метод Xamarin.Forms |
|--- |--- |--- |
|Первоначальная активация|ctor + Window.OnLoaded|ctor + Page.OnStart|
|Показано|Window.IsVisibleChanged|Page.Appearing|
|Hidden|Window.IsVisibleChanged|Page.Disappearing|
|Приостановить поражение фокус|Window.OnDeactivated|Page.OnSleep|
|Активировать фактическое фокус|Window.OnActivated|Page.OnResume|
|Closed|Window.OnClosing + Window.OnClosed|Н/Д|


Поддержки как скрытие/отображение дочерних элементов управления, в WPF это свойство тремя состояниями `IsVisible` (видимым, скрытый и свернутый). В Xamarin.Forms, это просто видимым или скрытым с помощью `IsVisible` свойство.

### <a name="layout"></a>Макет

Макет страницы происходит в том же 2-проходе (мер/расположение) происходящее в WPF. Можно связать с макета страницы путем переопределения следующие методы в Xamarin.Forms `Page` класса:

| Метод | Цель |
|--- |--- |
|OnChildMeasureInvalidated|Предпочтительный размер дочернего элемента изменилось.|
|OnSizeAllocated|Страница, явно назначенной ширины и высоты.|
|События LayoutChanged представления|Макет и размер страницы был изменен.|

Существует событие не глобального макета, который вызывается в настоящее время не существует глобальной `CompositionTarget.Rendering` найти это событие как в WPF.

#### <a name="common-layout-properties"></a>Общие свойства макета

WPF и Xamarin.Forms, поддерживают `Margin` интервала управления вокруг элемента, и `Padding` интервала управления _внутри_ элемент. Кроме того большая часть макета представления Xamarin.Forms имеют свойства для расстояния (например, строки или столбца).

Кроме того большинство элементов имеют свойства, которые влияют на то, как они расположены в родительском контейнере:

| WPF | Xamarin.Forms | Цель |
|--- |--- |--- |
|HorizontalAlignment|HorizontalOptions|Параметры влево/Center/вправо/Stretch|
|VerticalAlignment|VerticalOptions|Параметры TOP/Center/нижней/Stretch|

> [!NOTE]
> Фактический интерпретации этих свойств зависит от родительского контейнера.

#### <a name="layout-views"></a>Представления с макетом

WPF и Xamarin.Forms использовать элементы управления макета для размещения дочерних элементов. В большинстве случаев это очень близко друг к другу с точки зрения функциональности.

| WPF | Xamarin.Forms | Стиль макета |
|--- |--- |--- |
|StackPanel|StackLayout|Слева направо и сверху вниз бесконечный наложение|
|Grid|Grid|Табличном формате (строки и столбцы)|
|DockPanel|Н/Д|Закрепить края окна|
|Canvas|AbsoluteLayout|Позиционирование пикселя с координатой|
|WrapPanel|Н/Д|Упаковки стека|
|Н/Д|RelativeLayout|Относительный основе правил позиционирования|

> [!NOTE]
> Xamarin.Forms поддерживает `GridSplitter`.

Обе эти платформы используют _присоединенных свойств_ для точной настройки дочерних элементов.

### <a name="rendering"></a>Отрисовка

Механизм отрисовки для WPF и Xamarin.Forms радикально отличаются. В WPF элементы управления, созданный непосредственно отображать содержимое пикселей на экране. WPF поддерживает два объектов графики (_деревьев_) этого - _логического дерева_ представляет элементы управления, как определено в коде или XAML и _визуального дерева_ представляет Реальное отображение, происходящее на экране, который является выполнения любого непосредственно с помощью визуального элемента (с помощью метода виртуального draw), или с помощью определяемых XAML `ControlTemplate` которого можно заменить или настроить. Как правило визуальное дерево гораздо сложнее, так как он содержит такие как границы вокруг элементов управления, метки для неявного содержимого и т. д. WPF включает в себя набор интерфейсов API (`LogicalTreeHelper` и `VisualTreeHelper`) для таких ошибок два объекта диаграммы.

В Xamarin.Forms, элементы управления определяются в `Page` — это просто простыми объектами данных. Они похожи на представление логического дерева, но никогда не отображать содержимое сами по себе. Вместо этого они _модель данных_ который влияет на отрисовку элементов. Реальное отображение осуществляется [разделения набор _visual модулей подготовки отчетов_ которой сопоставляются с каждого типа элемента управления](~/xamarin-forms/app-fundamentals/custom-renderer/index.md). Эти модули подготовки отчетов регистрируются в каждом из проектов с платформой Xamarin.Forms сборки для конкретных платформ. Вы увидите список [здесь](~/xamarin-forms/app-fundamentals/custom-renderer/renderers.md). В дополнение к замена или расширение модуль подготовки отчетов, Xamarin.Forms также реализована поддержка [эффекты](~/xamarin-forms/app-fundamentals/effects/index.md) которого может использоваться для изменения собственного отрисовку в каждой платформы.

#### <a name="the-logicalvisual-tree"></a>Дерево логических/Visual

Никакой интерфейс API, предоставляемых для выполнения логического дерева, описанной в Xamarin.Forms — но можно использовать отражение для получения те же сведения. Например [здесь — это метод, который может перечислить логических дочерних элементов](https://github.com/xamarinhq/xamu-infrastructure/blob/master/src/XamU.Infrastructure/Extensions/ElementExtensions.cs#L108) с помощью отражения.

## <a name="graphics"></a>Графика

Xamarin.Forms не включает графической системе примитивов за пределы простого прямоугольника (`BoxView`). Может включать библиотеки сторонних производителей, таких как [SkiaSharp](~/graphics-games/skiasharp/index.md) для получения кросс платформенных двухмерного рисования, или [UrhoSharp](~/graphics-games/urhosharp/index.md) для 3D.

## <a name="resources"></a>Ресурсы

WPF и Xamarin.Forms имеют концепцию ресурсы и словари ресурсов. Вы можете поместить объект любого типа в `ResourceDictionary` с ключом, затем поищите его с `{StaticResource}` для таких задач, которые остаются неизменными, или `{DynamicResource}` для таких задач, которые можно изменить в словаре во время выполнения. Использование и механизмы совпадают с одним отличием: Xamarin.Forms требуется определить `ResourceDictionary` присваиваемое `Resources` свойство, тогда как WPF предварительно создает одну и назначает его для вас.

Например см. в разделе Определение ниже:

**WPF**

```xaml
<Window.Resources>
   <Color x:Key="redColor">#ff0000</Color>
   ...
</Window.Resources>
```

**Xamarin.Forms**

```xaml
<ContentPage.Resources>
   <ResourceDictionary>
      <Color x:Key="redColor">#ff0000</Color>
      ...
   </ResourceDictionary>
</ContentPage.Resources>
```

Если не определить `ResourceDictionary`, возникает ошибка среды выполнения.

## <a name="styles"></a>Стили

Стили также полностью поддерживаются в Xamarin.Forms и можно использовать тему Xamarin.Forms элементов, составляющих пользовательский Интерфейс. Они поддерживают наследование (свойства, события и данные), триггеры, через `BasedOn`и поиск ресурсов для значения. Стили применяются к элементам, либо явным образом с помощью `Style` свойство, или неявно не предоставить ключ ресурса — так же, как WPF.

### <a name="device-styles"></a>Стили устройства

WPF имеется набор предопределенных свойств (хранятся в виде статических значений в наборе статических классов, таких как `SystemColors`) которого определяют системные цвета, шрифты и метрики в виде значения и ключи ресурсов. Xamarin.Forms, похоже, но также определяет набор [стили устройства](~/xamarin-forms/user-interface/styles/device.md) для представления и то же. Эти стили предоставляемого платформой и задайте значения в зависимости от среды выполнения (например, специальные возможности).

**WPF**

```xaml
<Label Text="Title" Foreground="{DynamicResource {x:Static SystemColors.DesktopBrushKey}}" />
```

**Xamarin.Forms**

```xaml
<Label Text="Title" Style="{DynamicResource TitleStyle}" />
```
