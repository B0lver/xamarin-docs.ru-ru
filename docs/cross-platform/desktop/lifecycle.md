---
ms.assetid: 7C132A7C-4973-4B2D-98DC-3661C08EA33F
title: Сравнение WPF и Жизненный цикл приложения Xamarin.Forms
description: В этом документе сравниваются сходства и различия между жизненным циклом приложения для Xamarin. Forms и приложений WPF. Он также рассматривает визуальное дерево, графику, ресурсы и стили.
author: conceptdev
ms.author: crdun
ms.date: 04/26/2017
ms.openlocfilehash: 8c009c079842a6a110212693a56489ca2ad5d263
ms.sourcegitcommit: 933de144d1fbe7d412e49b743839cae4bfcac439
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2019
ms.locfileid: "70290376"
---
# <a name="wpf-vs-xamarinforms-app-lifecycle"></a>Сравнение WPF и Жизненный цикл приложения Xamarin.Forms

Xamarin. Forms принимает множество руководств по проектированию из платформ на основе XAML, которые были выпущены до этого, особенно в WPF. Тем не менее, в других случаях это сильно отличается от того, что может быть закрепления для пользователей, пытающихся выполнить миграцию. В этом документе предпринимается попытка найти некоторые из этих проблем и предоставлены рекомендации по взаимовозможности моста данных WPF в Xamarin. Forms.

## <a name="app-lifecycle"></a>Жизненный цикл приложения

Жизненный цикл приложения между WPF и Xamarin. Forms аналогичен. Оба запускаются во внешнем коде (на платформе) и запускают пользовательский интерфейс с помощью вызова метода. Отличие заключается в том, что Xamarin. Forms всегда начинается в сборке, зависящей от платформы, которая затем инициализирует и создает пользовательский интерфейс для приложения.

**WPF**

- `Main method > App > MainWindow`

> [!NOTE]
> По `Main` умолчанию этот метод создается автоматически и не отображается в коде.

**Xamarin.Forms**

- **iOS** &ndash;`Main method > AppDelegate > App > ContentPage`
- **Android** &ndash;`MainActivity > App > ContentPage`
- **UWP** &ndash;`Main method > App(UWP) > MainPage(UWP) > App > ContentPage`

### <a name="application-class"></a>Класс приложения

Как WPF, так и Xamarin. Forms имеют `Application` класс, который создается как одноэлементный. В большинстве случаев приложения будут производными от этого класса для предоставления пользовательского приложения, хотя это не является обязательным в WPF. Оба предоставляют `Application.Current` свойство для размещения созданного одноэлементного экземпляра.

### <a name="global-properties--persistence"></a>Глобальные свойства и сохраняемость

Как WPF, так и Xamarin. Forms доступны по `Application.Properties` словарю, где можно хранить глобальные объекты уровня приложения, доступные в любом месте приложения. Ключевое различие заключается в том, что Xamarin. Forms _сохранит все типы_ -примитивы, хранящиеся в коллекции, когда приложение будет приостановлено, и перезагрузить их при повторном запуске. WPF не поддерживает такое поведение автоматически. вместо этого большинство разработчиков полагаться на изолированное хранилище или использует встроенную `Settings` поддержку.

## <a name="defining-pages-and-the-visual-tree"></a>Определение страниц и визуального дерева

WPF использует в `Window` качестве корневого элемента для любого визуального элемента верхнего уровня. Это определяет HWND в мире Windows для вывода сведений. В WPF можно создавать и отображать любое количество окон одновременно.

В Xamarin. Forms визуальный элемент верхнего уровня всегда определяется платформой, `UIWindow`например в iOS. Xamarin. Forms преобразует содержимое в эти собственные представления платформы с помощью `Page` класса. Каждый `Page` в Xamarin. Forms представляет собой уникальную "страницу" в приложении, где только одна видима за раз.

Как впфс `Window` , так и Xamarin `Page` . Forms включают `Title` свойство, влияющее на отображаемое название, `Icon` и оба имеют свойство для отображения определенного значка для страницы (**Обратите внимание** , что заголовок и значок не всегда отображается в Xamarin. Forms). Кроме того, можно изменять общие визуальные свойства как для фона, так и для изображения.

Технически возможно выполнить визуализацию в двух отдельных представлениях платформы (например, определить два `UIWindow` объекта и получить вторую визуализацию на внешний экран или AirPlay), для этого требуется код, зависящий от платформы, и не является напрямую поддерживаемой функцией Сама по себе Xamarin. Forms.

### <a name="views"></a>Представления

Визуальная иерархия для обеих платформ аналогична. WPF является несколько более глубоким из-за поддержки документов WYSIWYG.

**WPF**

```
DependencyObject - base class for all bindable things
   Visual - rendering mechanics
      UIElement - common events + interactions
         FrameworkElement - adds layout
            Shape - 2D graphics
            Control - interactive controls
```

**Xamarin.Forms**

```
BindableObject - base class for all bindable things
   Element - basic parent/child support + resources + effects
      VisualElement - adds visual rendering properties (color, fonts, transforms, etc.)
         View - layout + gesture support
```

### <a name="view-lifecycle"></a>Жизненный цикл представления

Xamarin. Forms в основном ориентированы на мобильные сценарии. Таким образом, приложения _активируются_, _приостанавливаются_и _повторно активируются_ по мере взаимодействия пользователя с ними. Это похоже на щелчок `Window` в приложении WPF, и существует набор методов и соответствующих событий, которые можно переопределить или подключить для отслеживания этого поведения.

| Цель | Метод WPF | Метод Xamarin. Forms |
|--- |--- |--- |
|Начальная активация|ctor + окно. onloadо|ctor + Page. OnStart|
|Указанного|Window. Исвисиблечанжед|Страница. появляется|
|Hidden|Window. Исвисиблечанжед|Страница. отображается|
|Фокус приостановки или потери|Окно. OnDeactivate|Страница. Переход в спящий режим|
|Активированный/полученный фокус|Окно. onactivateось|Страница. onresume|
|Closed|Window. OnClosing + Window. onclosingось|Н/Д|


Обе поддерживают скрытие и отображение дочерних элементов управления. в WPF это свойство `IsVisible` с тремя состояниями (видимое, скрытое и свернутое). В Xamarin. Forms он просто видим или скрыт с помощью `IsVisible` свойства.

### <a name="layout"></a>Макет

Макет страницы выполняется в одном 2-проходном (измерении или упорядочении) в WPF. Можно присоединиться к макету страницы, переопределив следующие методы в классе Xamarin. Forms `Page` :

| Метод | Цель |
|--- |--- |
|ончилдмеасуреинвалидатед|Предпочтительный размер дочернего элемента изменился.|
|онсизеаллокатед|Странице была назначена ширина и высота.|
|Событие Лайаутчанжед|Изменился макет или размер страницы.|

Не существует события глобального макета, которое вызывается сегодня, и в WPF не существует `CompositionTarget.Rendering` глобального события, такого как Found.

#### <a name="common-layout-properties"></a>Общие свойства макета

WPF и Xamarin. Forms поддерживают `Margin` управление пространством вокруг элемента и `Padding` управляют пространством _внутри_ элемента. Кроме того, большинство представлений макета Xamarin. Forms имеют свойства для управления пространством (например, строка или столбец).

Кроме того, большинство элементов имеют свойства, которые влияют на то, как они расположены в родительском контейнере:

| WPF | Xamarin.Forms | Цель |
|--- |--- |--- |
|HorizontalAlignment|хоризонталоптионс|Параметры Left, Center, Right/Stretch|
|VerticalAlignment|вертикалоптионс|Параметры Top, Center, Bottom/Stretch|

> [!NOTE]
> Фактическая интерпретация этих свойств зависит от родительского контейнера.

#### <a name="layout-views"></a>Представления макета

WPF и Xamarin. Forms используют элементы управления макета для размещения дочерних элементов. В большинстве случаев они очень близки друг к другу с точки зрения функциональности.

| WPF | Xamarin.Forms | Стиль макета |
|--- |--- |--- |
|StackPanel|StackLayout|Бесконечные стеки с направлением слева направо или сверху вниз|
|Grid|Grid|Табличный формат (строки и столбцы)|
|DockPanel|Н/Д|Закрепить на краях окна|
|Canvas|AbsoluteLayout|Пиксельное и координатное позиционирование|
|WrapPanel|Н/Д|Стек переноса|
|Н/Д|RelativeLayout|Относительное позиционирование на основе правил|

> [!NOTE]
> Xamarin. Forms не поддерживает `GridSplitter`.

В обеих платформах _присоединенные свойства_ используются для точной настройки дочерних элементов.

### <a name="rendering"></a>Отрисовка

Механизм визуализации для WPF и Xamarin. Forms имеет коренные отличия. В WPF элементы управления, создаваемые непосредственно, отображают содержимое в пикселах на экране. WPF поддерживает два графа объектов (_деревьев_) для представления. _логическое дерево_ представляет элементы управления, как определено в коде или XAML, а _визуальное дерево_ — фактическую отрисовку на экране, которая выполняется либо непосредственно визуальным элементом (через виртуальный метод Draw) или с помощью определенного `ControlTemplate` XAML, который можно заменить или настроить. Как правило, визуальное дерево сложнее, так как оно включает границы вокруг элементов управления, метки для неявного содержимого и т. д. В состав WPF входит набор API-`LogicalTreeHelper` интерфейсов (и `VisualTreeHelper`) для изучения этих двух графов объектов.

В Xamarin. Forms элементы управления, определяемые в `Page` , — это просто простые объекты данных. Они похожи на представление логического дерева, но никогда не отображают содержимое самостоятельно. Вместо этого они являются _моделью данных_ , которая влияет на отрисовку элементов. Фактическая визуализация выполняется [отдельным набором _визуальных модулей подготовки_ отчетов, которые сопоставляются с каждым типом элемента управления](~/xamarin-forms/app-fundamentals/custom-renderer/index.md). Эти модули подготовки регистрируются в каждом из проектов для конкретной платформы с помощью сборок Xamarin. Forms, зависящих от платформы. Список можно просмотреть [здесь](~/xamarin-forms/app-fundamentals/custom-renderer/renderers.md). Помимо замены или расширения модуля подготовки отчетов, Xamarin. Forms также поддерживает [эффекты](~/xamarin-forms/app-fundamentals/effects/index.md) , которые можно использовать для повлиять на отрисовку в собственном режиме на уровне платформы.

#### <a name="the-logicalvisual-tree"></a>Логическое или визуальное дерево

Нет доступного API для прохода по логическому дереву в Xamarin. Forms, но можно использовать отражение для получения той же информации. Например, [ниже приведен метод, который может перечислять логические дочерние элементы](https://github.com/xamarinhq/xamu-infrastructure/blob/master/src/XamU.Infrastructure/Extensions/ElementExtensions.cs#L108) с помощью отражения.

## <a name="graphics"></a>Графика

Xamarin. Forms не включает графическую систему для примитивов за пределами простого прямоугольника (`BoxView`). Вы можете включить сторонние библиотеки, такие как [SkiaSharp](~/graphics-games/skiasharp/index.md) , для получения 2D-рисования на разных платформах или [UrhoSharp](~/graphics-games/urhosharp/index.md) для трехмерного.

## <a name="resources"></a>Ресурсы

WPF и Xamarin. Forms имеют концепцию ресурсов и словарей ресурсов. Любой тип объекта можно поместить в `ResourceDictionary` ключ с ключом, а затем выполнить поиск `{StaticResource}` для тех вещей, которые не изменяются, `{DynamicResource}` а также для объектов, которые могут изменяться в словаре во время выполнения. Использование и механика одинаковы в одном из следующих различий: Для Xamarin. Forms необходимо определить `ResourceDictionary` назначение `Resources` для свойства, в то время как WPF предварительно создает и назначает его.

Например, см. определение ниже:

**WPF**

```xaml
<Window.Resources>
   <Color x:Key="redColor">#ff0000</Color>
   ...
</Window.Resources>
```

**Xamarin.Forms**

```xaml
<ContentPage.Resources>
   <ResourceDictionary>
      <Color x:Key="redColor">#ff0000</Color>
      ...
   </ResourceDictionary>
</ContentPage.Resources>
```

Если не определить `ResourceDictionary`, возникает ошибка времени выполнения.

## <a name="styles"></a>Стили

Стили также полностью поддерживаются в Xamarin. Forms и могут использоваться для создания темы для элементов Xamarin. Forms, составляющих пользовательский интерфейс. Они поддерживают триггеры (свойство, событие и данные), наследование `BasedOn`и поиск ресурсов для значений. Стили применяются к элементам явным образом через `Style` свойство или неявно, не указывая ключ ресурса — так же, как WPF.

### <a name="device-styles"></a>Стили устройства

WPF имеет набор предопределенных свойств (хранимых как статические значения для набора статических классов, таких как `SystemColors`), которые определяют системные цвета, шрифты и метрики в форме значений и ключей ресурсов. Xamarin. Forms аналогичен, но определяет набор [стилей устройств](~/xamarin-forms/user-interface/styles/device.md) для представления тех же вещей. Эти стили предоставляются платформой и устанавливаются в значения, основанные на среде выполнения (например, Специальные возможности).

**WPF**

```xaml
<Label Text="Title" Foreground="{DynamicResource {x:Static SystemColors.DesktopBrushKey}}" />
```

**Xamarin.Forms**

```xaml
<Label Text="Title" Style="{DynamicResource TitleStyle}" />
```
