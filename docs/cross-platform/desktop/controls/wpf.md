---
ms.assetid: 1BB412D1-FC3D-4E69-8B01-B976A3DB6328
title: 'Сравнение WPF и Xamarin. Forms: Сходство & различия'
description: В этом документе сравнивается и противопоставляется WPF и Xamarin. Forms. В нем обсуждаются шаблоны элементов управления, XAML, инфраструктура привязки, шаблоны данных, ItemsControl, UserControl, Навигация и Навигация по URL-адресам.
author: conceptdev
ms.author: crdun
ms.date: 04/26/2017
ms.openlocfilehash: d23b449382183b0385eac38c0b9205e48dbe0a34
ms.sourcegitcommit: 933de144d1fbe7d412e49b743839cae4bfcac439
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2019
ms.locfileid: "70290408"
---
# <a name="wpf-vs-xamarinforms-similarities--differences"></a>Сравнение WPF и Xamarin. Forms: Сходство & различия

## <a name="control-templates"></a>Шаблоны элементов управления

WPF поддерживает концепцию *шаблонов элементов управления* , предоставляющих инструкции по визуализации для элемента управления`Button`( `ListBox`, и т. д.). Как упоминалось выше, Xamarin. Forms использует конкретные классы _отрисовки_ , которые взаимодействуют с собственной платформой (iOS, Android и т. д.) для визуализации элемента управления.

Однако Xamarin _. Forms имеет_ `ControlTemplate` тип — он `Page` используется для объектов. Он предоставляет определение для `Page` , которое обеспечивает единообразное содержимое, но позволяет пользователю страницы изменять цвета, шрифты и т. д. и даже добавлять элементы, чтобы сделать его уникальным для приложения.

В частности, это такие вещи, как диалоговые окна проверки подлинности, запросы и предоставление стандартизованных возможностей, но их внешний вид и поведение страницы могут быть настроены в приложении. В рамках этой поддержки используются многие знакомые элементы управления WPF с именами:

1. `ContentPage`
2. `ContentView`
3. `ContentPresenter`
4. `TemplateBinding`

Но важно помнить, что в Xamarin. Forms _не_ используются одинаковые цели. Дополнительные сведения об этой функции см. на [странице документации](~/xamarin-forms/app-fundamentals/templates/control-templates/index.md).

## <a name="xaml"></a>XAML

XAML используется в качестве языка декларативной разметки для WPF и Xamarin. Forms. В большинстве случаев синтаксис идентичен, а основное различие — это объекты, определенные или созданные графами XAML.

- Xamarin. Forms поддерживает [спецификацию XAML 2009](/dotnet/framework/xaml-services/xaml-2009-language-features/); Это упрощает определение таких данных, как `string`s, `int`s и т. д., а также определение универсальных типов и передачу аргументов в конструкторы.

- В настоящее время невозможно динамически загрузить XAML, например WPF, с помощью `XamlReader`. Тем не менее, можно получить те же базовые функции с [пакетом NuGet](https://www.nuget.org/packages/Xamarin.Forms.Dynamic/) .

### <a name="markup-extensions"></a>Расширения разметки

Xamarin. Forms поддерживает расширение XAML с помощью расширений разметки, подобно WPF. В этом окне есть те же основные стандартные блоки:

1. `{x:Array}`
2. `{Binding}`
3. `{DynamicResource}`
4. `{x:Null}`
5. `{x:Static}`
6. `{StaticResource}`
7. `{x:Type}`

Кроме того, он включает `{x:Reference}` спецификацию XAML 2009 `{TemplateBinding}` и расширение разметки, которое используется `ControlTemplate` для специализированной версии, поддерживаемой Xamarin. Forms.

> [!WARNING]
> `ControlTemplate` Поддержка не одинакова, даже если она имеет то же имя.

Xamarin. Forms поддерживает пользовательские расширения разметки, но реализация немного отличается. В WPF необходимо создавать производный от `MarkupExtension` — абстрактный базовый класс. В Xamarin. Forms, который заменяется `IMarkupExtension` интерфейсом `IMarkupExtension<T>` или более гибким.

Как и WPF, единственным необходимым методом является `ProvideValue` метод, возвращающий значение из расширения разметки.

## <a name="binding-infrastructure"></a>Инфраструктура привязки

Одним из основных концепций, которые переносятся, является инфраструктура привязки данных для подключения визуальных свойств к свойствам данных .NET. Это позволяет создавать архитектурные шаблоны, такие как MVVM. Базовая схема идентична — у вас есть связываемый базовый класс [bindableobject](xref:Xamarin.Forms.BindableObject), в WPF это класс [DependencyObject](xref:System.Windows.DependencyObject) . Этот базовый класс используется в качестве корневого предка для всех объектов, которые будут участвовать в качестве целевых объектов в привязке данных. Затем производные классы предоставляют объекты [биндаблепроперти](xref:Xamarin.Forms.BindableProperty) , которые действуют как резервное хранилище для значений свойств (они определены как объекты [DependencyProperty](xref:System.Windows.DependencyProperty) в WPF).

### <a name="defining-bindable-properties"></a>Определение привязываемые свойства

Определение свойства, которое может быть привязано в Xamarin. Forms, аналогично WPF:
1. Объект должен быть производным от `BindableObject`.
2. Для определения резервного ключа хранилища для свойства должно `BindableProperty` быть открыто статическое поле типа, объявленного как.
3. Должна быть общедоступная оболочка свойств экземпляра, `GetValue` которая `SetValue` использует и для извлечения и изменения значения свойств.

Полный пример см. в разделе [свойства, допускающие привязку в Xamarin. Forms](~/xamarin-forms/xaml/bindable-properties.md).

### <a name="attached-properties"></a>Вложенные свойства

Вложенные свойства являются подмножеством привязываемого свойства, и они работают так же, как и в WPF. Основное отличие состоит в том, что в этом случае оболочка свойств пропущен и заменяется набором статических методов Get/Set для класса-владельца. Дополнительные сведения см. [в разделе вложенные свойства в Xamarin. Forms](~/xamarin-forms/xaml/attached-properties.md) .

### <a name="using-the-binding-engine"></a>Использование механизма привязки

Процесс использования механизма привязки такой же, как и в WPF. Его можно использовать в коде программной части путем создания `Binding` объекта, привязанного к исходному объекту (любой тип .NET), и необязательного значения свойства (если пропущен, он рассматривает исходный объект как само свойство — как WPF). Затем можно использовать `SetBinding` для Any `BindableObject` , чтобы `BindableProperty`связать привязку с.

Также можно определить связь привязки в XAML с помощью `BindingExtension`. Он имеет те же базовые значения, что и расширение в WPF.

Поддержка и механизм привязки более похожи на реализацию Silverlight, чем WPF. Существует несколько отсутствующих функций, которые не были реализованы в Xamarin. Forms:

- В привязках отсутствует поддержка следующих функций:
  - биндингграупнаме
  - биндсдиректлитосаурце
  - IsAsync
  - MultiBinding
  - нотифйонсаурцеупдатед
  - нотифйонтаржетупдатед
  - нотифйонвалидатионеррор
  - UpdateSourceTrigger
  - упдатесаурцеексцептионфилтер
  - ValidatesOnDataErrors
  - ValidatesOnExceptions
  - Коллекция ValidationRules
  - XPath
  - XmlNamespaceManager

#### <a name="relativesource"></a>RelativeSource

`RelativeSource` Привязки не поддерживаются. В WPF они позволяют выполнять привязку к другим визуальным элементам, определенным в XAML. В Xamarin. Forms такая же возможность может быть достигнута с `{x:Reference}` помощью расширения разметки. Например, если у нас есть элемент управления с именем «Осерконтрол», имеющий свойство Text, можно выполнить привязку к нему следующим образом:

**WPF**

```xaml
Text={Binding RelativeSource={RelativeSource otherControl}, Path=Text}
```

**Xamarin.Forms**

```xaml
Text={Binding Source={x:Reference otherControl}, Path=Text}
```

Ту же возможность можно использовать для `{RelativeSource Self}` функции. Однако Поиск предков по типу (`{RelativeSource FindAncestor}`) не поддерживается.

#### <a name="binding-context"></a>Контекст привязки

В WPF можно определить `DataContext` значение свойства, репрентс источник привязки по умолчанию. Если источник привязки не определен, используется значение этого свойства. Значение наследуется вниз по визуальному дереву, что позволяет определить его на более высоком уровне, а затем использовать в дочерних элементах.

В Xamarin. Forms Эта функция доступных, но имя свойства — `BindingContext`.

#### <a name="value-converters"></a>преобразователи значений;

Преобразователи значений полностью поддерживаются в Xamarin. Forms, как и WPF. Используется та же форма интерфейса, но Xamarin. Forms имеет интерфейс, определенный в `Xamarin.Forms` пространстве имен.

### <a name="model-view-viewmodel"></a>Модель-представление-ViewModel

MVVM полностью поддерживается как WPF, так и Xamarin. Forms.

WPF включает встроенный `RoutedCommand` элемент, который иногда используется; В Xamarin. Forms отсутствует встроенная поддержка команд за пределами `ICommand` определения интерфейса. Можно включить разнообразные платформы MVVM, чтобы добавить необходимые базовые классы для реализации MVVM.

#### <a name="inotifypropertychanged-and-inotifycollectionchanged"></a>INotifyPropertyChanged и INotifyCollectionChanged

Оба интерфейса поддерживаются в привязках Xamarin. Forms полностью. В отличие от многих платформ на основе XAML, уведомления об изменении свойств могут создаваться в фоновых потоках в Xamarin. Forms (так же, как WPF), а механизм привязки будет правильно переходить в поток пользовательского интерфейса.

Кроме того, обе среды поддерживают `SynchronziationContext` и `async` / `await` для правильного маршалинга потоков. WPF включает `Dispatcher` класс для всех визуальных элементов, а Xamarin. Forms — статический `Device.BeginInvokeOnMainThread` метод, который также можно использовать ( `SynchronizationContext` хотя является предпочтительным для кросс-платформенного программирования).

- Xamarin. Forms включает `ObservableCollection<T>` в себя, поддерживающую уведомления об изменениях коллекции.
- Можно использовать `BindingBase.EnableCollectionSynchronization` для включения межпотоковых обновлений для коллекции. API немного отличается от вариации WPF, [Проверьте документацию на наличие сведений об использовании](xref:Xamarin.Forms.BindingBase.EnableCollectionSynchronization*).

## <a name="data-templates"></a>Шаблоны данных

Шаблоны данных поддерживаются в Xamarin. Forms для настройки отрисовки `ListView` строки (ячейки). В отличие от WPF, который `DataTemplate`может использовать s для любого элемента управления, ориентированного на содержимое, Xamarin. Forms в настоящее время использует их только для. `ListView` Определение шаблона может быть определено встроенным (назначенным `ItemTemplate` свойством) или ресурсом `ResourceDictionary`в.

Кроме того, они не так гибкие, как аналоги WPF.

1. Корневой элемент объекта `DataTemplate` `ViewCell` _всегда_ должен быть объектом.
2. Триггеры данных полностью поддерживаются в шаблоне данных, но должны включать `DataType` свойство, указывающее тип свойства, с которым связан триггер.
3. `DataTemplateSelector`также поддерживается, но является производным от `DataTemplate` и, таким образом, просто назначается `ItemTemplate` непосредственно свойству ( `ItemTemplateSelector` и в WPF).

## <a name="itemscontrol"></a>ItemsControl

`ItemsControl` В Xamarin. Forms нет встроенного эквивалента, но [для Xamarin. Forms существует пользовательская часть](https://github.com/xamarinhq/xamu-infrastructure/blob/master/src/XamU.Infrastructure/Controls/ItemsControl.cs).

## <a name="user-controls"></a>Пользовательские элементы управления

В WPF `UserControl`используются для предоставления раздела пользовательского интерфейса с соответствующим поведением. В Xamarin. Forms мы используем `ContentView` для того же назначения. Поддерживаются привязка и включение в XAML.

## <a name="navigation"></a>Навигация

WPF включает в себя редко `NavigationService` используемые, которые можно использовать для предоставления функции навигации, похожей на браузер. В большинстве приложений это не потребовалось, но вместо `Window` этого использовались разные элементы или разные разделы окна для вывода данных.

На телефонных устройствах часто используется несколько _экранов_ , поэтому в Xamarin. Forms предусмотрена поддержка нескольких форм навигации:

| Стиль навигации | Тип страницы |
|--- |--- |
|На основе стека (принудительная или POP)|NavigationPage|
|Основной/подробности|MasterDetailPage|
|Вкладки|TabbedPage|
|Прокрутка влево/вправо|карауселвиев|

Является наиболее распространенным подходом, и каждая страница `Navigation` имеет свойство, которое можно использовать для отправки или POP-страниц в стек навигации. `NavigationPage` Это ближайший эквивалент, `NavigationService` найденный в WPF.

### <a name="url-navigation"></a>Навигация по URL-адресу

WPF — это технология, ориентированная на настольную систему, и может принимать параметры командной строки для направления поведения при запуске. Xamarin. Forms может использовать [углубленную компоновку URL-адресов](https://blog.xamarin.com/deep-link-content-with-xamarin-forms-url-navigation/) для перехода на страницу при запуске.
