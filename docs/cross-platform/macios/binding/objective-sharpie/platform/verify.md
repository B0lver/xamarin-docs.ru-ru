---
title: "Проверьте атрибуты"
ms.topic: article
ms.prod: xamarin
ms.assetid: 107FBCEA-266B-4295-B7AA-40A881B82B7B
ms.technology: xamarin-cross-platform
author: asb3993
ms.author: amburns
ms.date: 01/15/2016
ms.openlocfilehash: cda523cd9d762c3a3c1570e2abd0acb8a264d5dd
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="verify-attributes"></a>Проверьте атрибуты


Вы обнаружите, что созданные Sharpie цели привязки будет сопровождаться `[Verify]` атрибута. Эти атрибуты указывают, что следует _проверить_ , Sharpie цель выполнялось правильнее сравнение привязка, с помощью исходного объявления C, Objective-C (который будет предоставляться в комментарии перед объявлением связанных).

Рекомендуется использовать для проверки _все_ привязан объявления, но скорее всего, _необходимые_ для объявления, сопровождаемых `[Verify]` атрибута. Это так, как во многих ситуациях, не хватает метаданных в исходного машинного кода, чтобы определить, как лучше всего создать привязку. Необходимо ссылаться документации или комментарии к коду в файлах заголовка для принятия наиболее привязки.

После проверки того, что привязка используется исправить или имеют фиксированное оно было правильным, _удалить_ `[Verify]` атрибут для привязки.

> [!IMPORTANT]
> `[Verify]` атрибуты намеренно приведет к ошибкам компиляции C#, чтобы вам придется проверить привязку. Следует удалить `[Verify]` атрибут после проверки (и возможно исправлено) код.

## <a name="verify-hints-reference"></a>Проверить ссылку подсказки

Указание аргумента, предоставленные для атрибута может быть перекрестные ссылки на перечисленные ниже. Документация для любых полученных `[Verify]` атрибутов будет помещена на консоль, а также после завершения привязки.

<table>
  <thead>
  <tr>
    <th>Убедитесь, указание</th>
    <th>Описание:</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>InferredFromPreceedingTypedef</td>
    <td>Имя этого объявления было выведено из распространенных соглашением сразу же предшествующих <code>typedef</code> в собственного исходного кода. Проверьте правильность выводимого имени как этому соглашению, является неоднозначным.</td>
  </tr>
  <tr>
    <td>ConstantsInterfaceAssociation</td>
    <td>Нет не может определить, с какой интерфейс Objective-C может быть связан объявление переменной внешнего выглядел таким эксперимент. Эти экземпляры привязаны как <code>[Field]</code> свойства в частичной интерфейса в рядом с конкретный интерфейс для создания более понятный API, возможно, что исключает константы интерфейс вообще.</td>
  </tr>
  <tr>
    <td>MethodToProperty</td>
    <td>Метод Objective-C были привязаны как свойство C# из-за соглашением, например получающие без параметров и возвращающие значение (результат с отличным от void). Часто такие методы, как они должны быть привязаны как свойства для отображения лучше API, но иногда может возникнуть ложных срабатываний и привязка должна быть фактически метод.</td>
  </tr>
  <tr>
    <td>StronglyTypedNSArray</td>
    <td>Собственный <code>NSArray*</code> были привязаны как <code>NSObject[]</code>. Можно более строгой типизации массива в привязке, основаны на оценках задать с помощью документации по API (например комментарии в файле заголовка) или с помощью проверки путем тестирования содержимое массива. Например, NSArray * содержащий только NSNumber * instancescan привязываться в виде <code>NSNumber[]</code> вместо <code>NSObject[]</code>.</td>
  </tr>
  </tbody>
</table>

Можно также быстро получить документацию по использованию указание `sharpie verify-docs` средство, например:

```csharp
sharpie verify-docs InferredFromPreceedingTypedef
```

