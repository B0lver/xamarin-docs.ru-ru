---
title: Часть 2. Архитектура
description: В этом документе описываются шаблоны архитектуры полезно для создания кроссплатформенных приложений. В нем описывается слои типового приложения (уровень данных, уровень доступа к данным и др.) и Общие шаблоны мобильного программного обеспечения (MVVM, MVC, и т.д.)
ms.prod: xamarin
ms.assetid: 2176DB2D-E84A-3757-CFAB-04A586068D50
author: asb3993
ms.author: amburns
ms.date: 03/27/2017
ms.openlocfilehash: cfb2bddceea7717ac87bd7a78fd9cd45e8b93144
ms.sourcegitcommit: 57e8a0a10246ff9a4bd37f01d67ddc635f81e723
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/08/2019
ms.locfileid: "57670445"
---
# <a name="part-2---architecture"></a>Часть 2. Архитектура

Ключевой принцип создания кроссплатформенных приложений — создание архитектуры, которая предоставляет возможности для максимизации общего кода, используемого несколькими платформами. Соблюдение следующих принципов объектно-ориентированного программирования помогает создавать приложение с хорошо продуманной архитектурой:

-   **Инкапсуляция** — гарантирует, что классы и даже архитектурные уровни предоставляют только минимум API-интерфейса, который выполняет свои требуемые функции и скрывает подробности реализации. На уровне класса это означает, что объекты ведут себя как "черные ящики" и что коду-потребителю не требуется знать, как они выполняют свои задачи. На уровне архитектуры это означает реализацию шаблонов, таких как фасад, которые поощряют упрощение API, координирующих более сложные взаимодействия от имени кода в более абстрактных слоях. Это означает, что код UI (например) должен отвечать только за отображение экранов и принятие входных данных пользователя, никогда не взаимодействуя с базой данных напрямую. Аналогичным образом код обращения к данным должен выполнять только чтение и запись в базу данных, но никогда не должен взаимодействовать напрямую с кнопками или надписями.
-   **Разделение обязанностей** — гарантирует, что каждый компонент (уровня и архитектуры, и класса) имеет понятную и четко определенную цель. Каждый компонент должен выполнять только свои определенные задачи и предоставлять функциональные возможности через интерфейс API, доступный для других классов.
-   **Полиморфизм** — программирования на интерфейс (или абстрактного класса), которая поддерживает несколько реализаций означает, что основной код могут быть записаны и совместного использования на платформах, обеспечивая по-прежнему взаимодействует с функциями платформы.


Естественным результатом будет приложение, смоделированое на основе реальных или абстрактных сущностей с использованием отдельных логических уровней. Разделение кода на уровни упрощает понимание, тестирование и поддержку приложений. Рекомендуется, чтобы код в каждом уровне был отделен физически (либо в каталоги, либо даже в отдельные проекты для очень больших приложений), а также логически (с использованием пространства имен).

 <a name="Typical_Application_Layers" />


## <a name="typical-application-layers"></a>Слои типового приложения

В этом документе и примеры внедрения мы см. следующие уровни шесть приложений:

-   **Уровень данных** — энергонезависимое сохранение данных, вероятно это будет база данных SQLite, но может быть реализовано и с помощью XML-файлов или любого другого подходящего механизма.
-   **Уровень доступа к данным** — оболочка над уровнем данных, которая обеспечивает доступ к данным для создания, чтения, обновления, удаления (CRUD), не раскрывая особенностей реализации вызывающему объекту. Например, DAL может содержать инструкции SQL для запроса или обновления данных, но вызывающий код не должен знать об этом.
-   **Бизнес-слой** (иногда называется уровнем бизнес-логики или BLL) — содержит определения бизнес-сущностей (модель) и бизнес-логику. Кандидат для шаблона Business Façade.
-   **Уровень доступа к службе** — используется для доступа к службам в облаке: от сложных веб-служб (REST, JSON, WCF) до простого извлечения данных и изображений с удаленных серверов. Инкапсулирует поведение по сети и предоставляет простой API для использования на уровнях приложений и пользовательского интерфейса.
-   **Уровень приложений** — код, который обычно является конкретной платформе (обычно не общей для платформ) или код, зависящие от приложения (не обычно повторного использования). — Это позволяет проверить необходимость поместить код на уровне приложения и уровень пользовательского интерфейса (a) для определения, имеет ли класс любые элементы управления фактическому отображению, или (b) есть ли он может совместно использоваться несколько экранов и устройств (например) iPhone и iPad).
-   **Уровень пользовательского интерфейса (UI)** — уровень взаимодействия с пользователем, содержит экраны, виджеты и контроллеры для управления ими.


Приложения не обязательно содержит все уровни — например, уровень доступа к службам не будет существовать в приложении, которое не осуществляет доступ к сетевым ресурсам. Очень простое приложение может объединить уровень данных и уровень доступа к данным, так как в них очень простые операции.

 <a name="Common_Mobile_Software_Patterns" />


## <a name="common-mobile-software-patterns"></a>Общие шаблоны мобильного программного обеспечения

Шаблоны — устоявшиеся способы решения распространенных проблем. Существует несколько основных шаблонов, которые рекомендуется знать для создания понятных и простых в обслуживании мобильных приложений.

-   **Модель-представление-ViewModel (MVVM)** — шаблон Model-View-ViewModel популярных платформ, поддерживающих привязку данных, например Xamarin.Forms. Он был популяризированный Майклом XAML с поддержкой пакеты SDK, например Windows Presentation Foundation (WPF) и Silverlight. где ViewModel выступает в роли посредника между данными (модели) и пользовательского интерфейса (представления) через привязку данных и команд.
-   **Модель-представление-контроллер (MVC)** — шаблон общих и которую часто недооценивают, MVC, чаще всего используется при создании пользовательских интерфейсов и обеспечивает разделение между фактическое определение экран пользовательского интерфейса (представления), за ней механизма, управляющего взаимодействие (контроллер) и данные, заполняет его (модель). Модель — фактически это совершенно необязательно, и таким образом, понимание этого шаблона ядром заключается в представления и контроллера. MVC — это популярный подход для приложений iOS.
-   **Business Фасадной** — так НАЗЫВАЕМЫЙ шаблон Manager предоставляет упрощенный точку входа для выполнения сложных действий. Например, в приложении отслеживания задач, возможно, `TaskManager` класс с методами, например `GetAllTasks()` , `GetTask(taskID)` , `SaveTask (task)` и т. д. `TaskManager` Класс предоставляет интерфейс для внутренней работы фактически сохранение и извлечение объектов задачи.
-   **Singleton** — шаблон Singleton обеспечивает существование только одного экземпляра определенного объекта. Например, при использовании SQLite в мобильных приложениях вам будет нужно, чтобы был только один экземпляр базы данных. Singleton позволяет легко это гарантировать.
-   **Provider** — шаблон, предложенный корпорацией Майкрософт (возможно, он похож на Strategy или базовое внедрение зависимостей) для поддержки многократного использования кода в приложениях Silverlight, WPF и WinForms. Общий код можно писать для интерфейса или абстрактного класса, а конкретные реализации платформы записываются и передаются при использовании кода.
-   **Async** (не путать с ключевым словом Async) — используется в том случае, когда нужно выполнить длительную работу без задержки пользовательского интерфейса или текущих процессов. В простейшей форме шаблон Async описывает, что в случае выполнения длительных задач они должны быть вынесены в другой поток (или в аналогичные абстракции потока, например задачу), а текущий поток продолжает выполняться и ожидать ответа от фонового процесса, после чего обновляет интерфейс при возврате данных и состояния.


Каждый из шаблонов будет проверяться более подробно, как их практического использования проиллюстрирован на примеры внедрения. Википедии с более подробными описаниями [MVVM](https://en.wikipedia.org/wiki/Model–view–viewmodel), [MVC](https://en.wikipedia.org/wiki/Model–view–controller), [Facade](https://en.wikipedia.org/wiki/Facade_pattern), [одноэлементный](https://en.wikipedia.org/wiki/Singleton_pattern), [стратегии](https://en.wikipedia.org/wiki/Strategy_pattern)и [поставщика](https://en.wikipedia.org/wiki/Provider_model) шаблоны (и [шаблоны проектирования](https://en.wikipedia.org/wiki/Design_Patterns) обычно).
