---
title: Часть 2. Архитектура
description: В этом документе описываются шаблоны архитектуры, полезные для создания кросс-платформенных приложений. В нем обсуждаются типичные уровни приложений (уровень данных, уровень доступа к данным и т. д.) и распространенные шаблоны мобильных приложений (MVVM, MVC и т. д.).
ms.prod: xamarin
ms.assetid: 2176DB2D-E84A-3757-CFAB-04A586068D50
author: davidortinau
ms.author: daortin
ms.date: 03/27/2017
ms.openlocfilehash: 84a06e23ec7125892701762ab5bad7b86a8faf90
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73030263"
---
# <a name="part-2---architecture"></a>Часть 2. Архитектура

Ключевым принципом создания кросс-платформенных приложений является создание архитектуры, которая предоставляет максимизации для совместного использования кода на разных платформах. Следование приведенным ниже принципам объектно-ориентированного программирования помогает создать хорошо спроектированное приложение:

- **Инкапсуляция** — обеспечение того, что классы и даже уровни архитектуры предоставляют только минимальный API, который выполняет необходимые функции, и скрывает детали реализации. На уровне класса это означает, что объекты ведут себя как «Черные квадратики», и для использования кода не нужно знать, как они выполняют свои задачи. На уровне архитектуры это означает реализацию таких шаблонов, как фасадной, которые реализуют упрощенный API, координирующий более сложные взаимодействия от имени кода в более абстрактных слоях. Это означает, что код пользовательского интерфейса (например,) должен отвечать только за отображение экранов и принимать входные данные пользователя; и никогда не взаимодействуют с базой данных напрямую. Аналогичным образом, код доступа к данным должен читать и записывать данные только в базу данных, но никогда не взаимодействует напрямую с кнопками или метками.
- **Разделение обязанностей** . Убедитесь, что каждый компонент (на уровне архитектуры и уровня класса) имеет четко определенную цель. Каждый компонент должен выполнять только определенные задачи и предоставлять эти функции через API, доступный другим классам, которым требуется использовать его.
- **Полиморфизм** — программирование на интерфейс (или абстрактный класс), поддерживающее несколько реализаций, означает, что основной код может быть написан и совместно использоваться на разных платформах, в то же время взаимодействуя с функциями, зависящими от платформы.

Естественным результатом является приложение, смоделированное после реальных реальных или абстрактных сущностей с отдельными логическими слоями. Разделение кода на слои облегчает понимание, тестирование и обслуживание приложений. Рекомендуется физически разделить код на каждом слое (в каталогах или даже отдельные проекты для очень больших приложений), а также логически разделить (с использованием пространств имен).

 <a name="Typical_Application_Layers" />

## <a name="typical-application-layers"></a>Стандартные уровни приложений

В этом документе и примерах внедрения мы будем называть следующие шесть уровней приложений:

- **Уровень данных** — долговременное хранение данных, вероятно, является базой данных SQLite, но может быть реализовано с помощью XML-файлов или любого другого подходящего механизма.
- **Уровень доступа к данным** — оболочка для уровня данных, обеспечивающая доступ к данным для создания, чтения, обновления и удаления (CRUD) без предоставления сведений о реализации вызывающему объекту. Например, DAL может содержать инструкции SQL для запроса или обновления данных, но ссылающийся код не должен знать это.
- **Бизнес-слой** (иногда называемый уровнем бизнес-логики или BLL) содержит определения бизнес-объектов (модель) и бизнес-логику. Шаблон кандидата для бизнеса фасадной.
- **Уровень доступа** к службам — используется для доступа к службам в облаке: от сложных веб-служб (RESTFUL, JSON, WCF) до простого извлечения данных и изображений с удаленных серверов. Инкапсулирует поведение сети и предоставляет простой API для использования уровнями приложения и пользовательского интерфейса.
- **Уровень приложения** — код, который обычно зависит от платформы (обычно не используется совместно разными платформами) или код, характерный для приложения (обычно не используется повторно). Хороший тест того, следует ли размещать код на уровне приложения относительно уровня пользовательского интерфейса, — (a), чтобы определить, есть ли у класса фактические элементы управления отображением или (б) может ли он быть общим для нескольких экранов или устройств (например, iPhone и iPad).
- Уровень пользовательского **интерфейса** — слой, на котором пользователь имеет доступ, содержит экраны, мини-приложения и контроллеры, управляющие ими.

Приложение может не содержать все слои. Например, уровень доступа к службе не будет существовать в приложении, которое не обращается к сетевым ресурсам. Очень простое приложение может объединять уровень данных и уровень доступа к данным, так как операции являются чрезвычайно базовыми.

 <a name="Common_Mobile_Software_Patterns" />

## <a name="common-mobile-software-patterns"></a>Распространенные шаблоны мобильных приложений

Шаблоны — это установленный способ сбора повторяющихся решений для распространенных проблем. Существует несколько ключевых шаблонов, которые полезны для понимания создания обслуживаемых и понятных мобильных приложений.

- **Модель, представление, ViewModel (MVVM)** — шаблон Model-View-ViewModel популярен с платформами, поддерживающими привязку данных, например Xamarin. Forms. Он был популярным пакетами SDK с поддержкой XAML, такими как Windows Presentation Foundation (WPF) и Silverlight; где ViewModel выступает в качестве пути взаимодействия между данными (моделью) и пользовательским интерфейсом (представлением) с помощью привязки данных и команд.
- **Модель, представление, контроллер (MVC)** — распространенный и часто непонятный шаблон. MVC чаще всего используется при создании пользовательских интерфейсов и обеспечивает разделение фактического определения экрана пользовательского интерфейса (представления), подлежащий обработке взаимодействия ( Controller) и данные, заполняющие их (модель). Эта модель на самом деле является полностью необязательной частью, поэтому основная часть понимания этого шаблона заключается в представлении и контроллере. MVC — это популярный подход к приложениям iOS.
- Шаблон **Business фасадной** – Manager предоставляет упрощенную точку входа для сложной работы. Например, в приложении для отслеживания задач может существовать `TaskManager` класс с такими методами, как `GetAllTasks()`, `GetTask(taskID)`, `SaveTask (task)` и т. д. Класс `TaskManager` предоставляет фасадной для внутренних операций сохранения и получения объектов Tasks.
- **Singleton** — Одноэлементный шаблон предоставляет способ, в котором может существовать только один экземпляр определенного объекта. Например, при использовании SQLite в мобильных приложениях требуется только один экземпляр базы данных. Использование одноэлементного шаблона — это простой способ обеспечить это.
- **Поставщик** — шаблон, который Майкрософт (вероятно, похоже на стратегию или внедрение зависимости) позволяет повторно использовать код в приложениях Silverlight, WPF и WinForms. Общий код может быть написан для интерфейса или абстрактного класса, а конкретные реализации конкретной платформы записываются и передаются при использовании кода.
- **Асинхронный** — не путать с ключевым словом async, асинхронный шаблон используется, когда долго выполняемая работа должна выполняться без удержания пользовательского интерфейса или текущей обработки. В простейшей форме асинхронная модель просто описывает, что длительные задачи должны запускаться в другом потоке (или подобной абстракции потока, например в задаче), в то время как текущий поток продолжит обрабатывать и ожидать ответа от фонового процесса. , а затем обновляет пользовательский интерфейс при возвращении данных или состояния.

Каждый шаблон будет рассматриваться более подробно, так как их практичное использование проиллюстрировано в примерах внедрения. В Википедии более подробно описаны шаблоны [MVVM](https://en.wikipedia.org/wiki/Model–view–viewmodel), [MVC](https://en.wikipedia.org/wiki/Model–view–controller), [фасад](https://en.wikipedia.org/wiki/Facade_pattern), [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern), [стратегии](https://en.wikipedia.org/wiki/Strategy_pattern) и [поставщиков](https://en.wikipedia.org/wiki/Provider_model) (и [шаблоны разработки](https://en.wikipedia.org/wiki/Design_Patterns) , как правило,).
