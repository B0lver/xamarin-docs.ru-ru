---
title: Часть 2. Архитектура
description: В этом документе описываются шаблоны архитектуры которые полезны для создания кроссплатформенных приложений. В нем описывается слои типового приложения (уровень данных, уровень доступа к данным и др.) и Общие шаблоны мобильного программного обеспечения (MVVM, MVC, и т.д.)
ms.prod: xamarin
ms.assetid: 2176DB2D-E84A-3757-CFAB-04A586068D50
author: asb3993
ms.author: amburns
ms.date: 03/27/2017
ms.openlocfilehash: cfb2bddceea7717ac87bd7a78fd9cd45e8b93144
ms.sourcegitcommit: 57e8a0a10246ff9a4bd37f01d67ddc635f81e723
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/08/2019
ms.locfileid: "57670445"
---
# <a name="part-2---architecture"></a>Часть 2. Архитектура

Ключевой принцип создания кросс платформенных приложений — создание архитектуры, которая предоставляет возможности для максимизации общего кода для использование несколькими платформами. Соблюдение следующих принципов объектно-ориентированного программирования помогает создавать приложение с хорошо продуманной архитектурой:

-   **Инкапсуляция** — гарантирует что классы и даже архитектурные слои предоставляют только минимальный API, который выполняет свои требуемые функции и скрывает подробности реализации. На уровне класса это означает, что объекты ведут себя как «черные ящики» и что коду-потребителю не требуется знать, как они выполняют свои задачи. На уровне архитектуры это означает реализацию шаблонов, таких как фасад, которые поощряют упрощение API, которые координирует более сложные взаимодействия от имени кода в более абстрактных слоях. Это означает, что код UI (например) должен отвечать только за отображение экранов и принятия входных данных пользователя; и никогда не взаимодействовать с базой данных напрямую. Аналогичным образом код обращения к данным должен выполнять только чтение и запись в базу данных, но никогда не должен взаимодействовать напрямую с кнопками или надписями.
-   **Разделение обязанностей** — гарантирует, что каждый компонент (уровня и архитектуры, и класса) имеет понятную и четко определенную цель. Каждый компонент должен выполнять только его определенные задачи и предоставлять функциональные возможности через интерфейс API, доступным для других классов.
-   **Полиморфизм** — программирование интерфейса (или абстрактного класса), которые поддерживает несколько реализаций. Это означает, что основной код может быть использован на различных на платформах, но по-прежнему обеспечивает взаимодействие с функциями платформы.


Естественным результатом будет приложение, смоделированое на основе реальных или абстрактных сущностей с использованием отдельных логических слоев. Разделение кода на слои позволяет приложения проще воспринимать, тестировать и поддерживать. Рекомендуется, чтобы код в каждом слое был отделен физический (как в каталоги, так и даже отдельные проекты для очень больших приложений), а также логически (с использованием пространства имен).

 <a name="Typical_Application_Layers" />


## <a name="typical-application-layers"></a>Слои типового приложения

В этом документе и в конкретных примеры мы ссылаемся на следующие шесть уровней приложения:

-   **Уровень данных** — энергонезависимое сохранение данных, вероятно будет база данных SQLite, но могут быть реализованы с помощью XML-файлов или любого другого подходящего механизма.
-   **Уровень доступа к данным** — оболочка над уровне данных, которая обеспечивает доступ к данным для создание, чтение, обновление, удаление (CRUD) не раскрывая особенностей реализации для вызывающего объекта. Например DAL может содержать инструкции SQL для запроса или обновления данных, но вызывающий код не должен знать об этом.
-   **Бизнес-слой** — (иногда называется уровень бизнес-логики или BLL) содержит определения бизнес-сущностей (модель) и бизнес-логику. Кандидат для шаблона Бизнес Фасад.
-   **Уровень доступа к службе** — используется для доступа к службам в облаке: от сложных веб-служб (REST, JSON, WCF) до простого извлечения данных и изображений с удаленных серверов. Инкапсулирует поведение по сети и предоставляет простой API для использования приложением и UI.
-   **Уровень приложений** — код, который обычно принадлежит конкретной платформе (обычно не для общей платформы) или код, зависящий от приложения (обычно не для повторного использования). — Это позволяет проверить необходимость поместить код на уровне приложения и уровень UI (a) для определения, имеет ли класс любые элементы управления фактическому отображению, или (b) есть ли он может совместно использоваться несколько экранов и устройств (например) iPhone и iPad).
-   **Слой пользовательского интерфейса (UI)** — уровень UI, содержит экраны, виджеты и контроллеры для управления ими.


Приложения не обязательно содержит все слои — например уровень доступа к службе не будет существовать в приложении, которое не осуществляет доступ к сетевым ресурсам. Очень простое приложение может объединить уровень данных и уровень доступа к данным, так как операции являются очень базовыми.

 <a name="Common_Mobile_Software_Patterns" />


## <a name="common-mobile-software-patterns"></a>Общие шаблоны мобильного программного обеспечения

Шаблоны — установленные способы решения распространенных проблем. Существует несколько основных шаблонов, которые удобны для понимания при создании простых в обслуживании/понятных мобильных приложений.

-   **Model, View, ViewModel (MVVM)** — шаблон Model-View-ViewModel популярных платформ, поддерживающих привязку данных, например Xamarin.Forms. Он был популяризированн при помощи XAML содержащих SDK, например Windows Presentation Foundation (WPF) и Silverlight. Где ViewModel выступает в роли посредника между данными (модели) и UI (представления) при помощи привязки данных и команд.
-   **Model, View, Controller  (MVC)** — общий и часто недооцененный шаблон, MVC чаще всего используется при создании UI. Он обеспечивает разделение между фактическим определением UI экрана (представления), управляющего взаимодействием механизма (контроллер) и заполняющих его данных (модель). Модель — фактически совершенно необязательная часть, и таким образом, ядро для понимания этого шаблона являются представления и контроллеры. MVC — это популярный подход для приложений iOS.
-   **Business Facade** — так называемый шаблон Manager, предоставляет упрощенную точку входа для выполнения сложных действий. Например, в приложении отслеживания задач, возможно, `TaskManager` класс с методами, например `GetAllTasks()` , `GetTask(taskID)` , `SaveTask (task)` и т. д. `TaskManager` Класс предоставляет интерфейс для внутренней работы сохранения и извлечения объектов задачи.
-   **Singleton** — Singleton шаблон, который обеспечивает способ, при котором может существовать только один экземпляр определенного объекта. Например при использовании SQLite в мобильных приложениях, тебе требуется только один экземпляр базы данных. С помощью Singleton — это простой способ сделать это.
-   **Provider** — шаблон изобретен корпорацией Майкрософт (возможно похож на Strategy или основные внедрения зависимостей), чтобы стимулировать повторного использования кода в приложениях Silverlight, WPF и WinForms. Общий код могут записываться в интерфейс или абстрактный класс а конкретные реализации платформы записываются и переданнются при использовании кода.
-   **Async** — не следует путать с ключевым словом Async, Async используется в том случае, когда нужно выполнить длительную работу без задержки UI или текущего процесса. В простейшей форме асинхронный шаблон описывает просто то, что в случае выполнения длительных задач они должны быть вынесены в другой поток (или аналогичные абстракции потока, например задачу) а во время текущего потока продолжают выполняться и ожидать ответа от фонового процесса и затем обновляет UI при возврате данных и состояния.


Каждый из шаблонов изучили более подробно в этих обучающих примерах. Также там приведены примеры их практического использования. Википедия имеет более подробное описание [MVVM](https://en.wikipedia.org/wiki/Model–view–viewmodel), [MVC](https://en.wikipedia.org/wiki/Model–view–controller), [Facade](https://en.wikipedia.org/wiki/Facade_pattern), [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern), [Strategy](https://en.wikipedia.org/wiki/Strategy_pattern)и [Provider](https://en.wikipedia.org/wiki/Provider_model) шаблонов (и [шаблоны проектирования](https://en.wikipedia.org/wiki/Design_Patterns) обычно).
