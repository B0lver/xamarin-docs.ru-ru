---
title: Часть 4. Работа с несколькими платформами
description: В этом документе описываются способы расхождения приложения на основе платформы или возможностей. В нем описывается, что размер экрана, метафоры навигации, касания и жесты, Push-уведомлений и парадигм интерфейса, такие как списки и вкладки.
ms.prod: xamarin
ms.assetid: BBE47BA8-78BC-6A2B-63BA-D1A45CB1D3A5
author: asb3993
ms.author: amburns
ms.date: 03/23/2017
ms.openlocfilehash: f4558d5172d7dcbd2e14e6b74a347dd2f1e3a234
ms.sourcegitcommit: 817d26585093cd180a36b28179eb354b0eb900b3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2019
ms.locfileid: "55292133"
---
# <a name="part-4---dealing-with-multiple-platforms"></a>Часть 4. Работа с несколькими платформами

## <a name="handling-platform-divergence-amp-features"></a>Обработка расхождения платформы &amp; функции

Расхождение не просто проблема «кросс платформенные»; устройства на платформе «же» имеют разные возможности (особенно самых разнообразных устройствах Android, которые доступны). Наиболее очевидный и основные является размер экрана, но другие атрибуты устройства можно изменить и требуется приложение для проверки определенных возможностей и ведут себя по-разному в зависимости от наличия (или отсутствия).

Это означает, что все приложения должны иметь дело с Постепенное снижение функциональности, в противном случае представлять наборы функция непривлекательной, наименьшего общего знаменателя. Глубокая интеграция с собственными пакетами SDK для каждой платформы Xamarin позволяют приложениям пользоваться преимуществами функций конкретных платформ, поэтому имеет смысл для разработки приложений для использования этих функций.

См. в документации возможности платформы Обзор из отличий функциональных возможностей платформы.

## <a name="examples-of-platform-divergence"></a>Примеры расхождения платформы

### <a name="fundamental-elements-that-exist-across-platforms"></a>Основные элементы, которые существуют в разных платформах

Существуют некоторые характеристики приложений для мобильных устройств, которые являются универсальными.
Ниже приведены концепции более высокого уровня, которые обычно верно для всех устройств и таким образом можно лежат в основе архитектуру приложения.

-  Выбор компонентов с помощью вкладки или меню
-  Списки данных и прокрутка
-  Единого представления данных
-  Редактирование единого представления данных
-  Переход назад

При проектировании общую работу пользователя может быть основан на эти концепции высокого уровня экрана последовательности.

### <a name="platform-specific-attributes"></a>Атрибуты платформы

Помимо основных элементов, которые существуют на всех платформах необходимо будет решать задачи различия ключа платформы при проектировании. Может потребоваться учитывать (и написание кода специально для обработки) эти различия:

-   **Экранах** — некоторых платформ (таких как iOS и более ранних версий Windows Phone) быть принят размеры экрана для относительно простых целевых. Устройства Android иметь большое разнообразие экрана измерений, которые требуют больше усилий для поддержки в вашем приложении.
-   **Метафоры навигации** — различия между платформами (например) кнопку оборудования «назад», элемент управления пользовательского интерфейса Панорама) и в рамках платформ (Android 2 и 4, iPhone и iPad).
-   **Клавиатуры** — устройства Android некоторые имеют физической клавиатуры, а другим пользователям только сочетания программного обеспечения. Код, который определяет, когда soft клавиатура скрывает части экрана должен быть чувствительно к эти различия.
-   **Касания и жесты** — зависит от поддержки операционной системы для распознавания жестов, особенно в более старых версиях каждой операционной системы. Более ранних версиях Android имеют очень ограниченная поддержка операции сенсорного ввода, это означает, что поддержка старых устройств может потребоваться отдельный код
-   **Push-уведомления** — существуют различные возможности/реализации на каждой платформе (например) Динамические плитки на Windows).

### <a name="device-specific-features"></a>Возможности для конкретных устройств

Определить, какие именно минимум компонентов, необходимых для приложения должны быть; или когда решить, какие дополнительные возможности, чтобы воспользоваться преимуществами на каждой платформе. Код должен будет обнаруживать компоненты и функциональные возможности подключения или отключения предлагают альтернативные варианты (например) альтернативой географическое расположение может быть позволяют введите расположение или выберите из карты):

-   **Камера** — функциональные возможности различаются на разных устройствах: некоторые устройства нет веб-камеры, другие имеют оба переднюю и задней камеры. Некоторые камеры способны видеозапись.
-   **Карты & географическое расположение** — поддержка местоположения GPS или Wi-Fi не присутствует на всех устройствах. Приложениям также требуется ориентироваться на различные уровни точности, которая поддерживается каждым методом.
-   **Акселерометр "," гироскоп "и" компас** — эти функции часто встречается только для выбранных устройств на каждой платформе, поэтому приложения почти всегда требуется для обеспечения наличия резерва, когда оборудование не поддерживается.
-   **Twitter и Facebook** — только «встроенные» iOS5 и iOS6 соответственно. На других платформах и более ранних версий необходимо будет предоставить свои собственные функции проверки подлинности и взаимодействовать непосредственно с каждый API службы.
-   **Рядом с полем Communications (NFC)** — только на (некоторые) телефонов Android (на момент написания статьи).

## <a name="dealing-with-platform-divergence"></a>Работа с платформы расхождения

Существует два различных подхода для поддержки нескольких платформ из одной базы кода, каждый из которых свой собственный набор преимущества и недостатки.

-   **Абстракция платформы** — шаблон Фасадной бизнеса, предоставляет универсальный доступ на платформах и абстрагирует реализации конкретной платформы в единую API.
-   **Разные реализации** — вызов определенной платформы компонентов через разные реализации с помощью архитектуры инструментов, например интерфейсов и наследование или условной компиляции.

## <a name="platform-abstraction"></a>Абстракция платформы

### <a name="class-abstraction"></a>Абстрактного класса

С помощью интерфейсов и базовых классов определен в общем коде и реализовать или расширяется в проекты под конкретные платформы. Написание и расширение общего кода с помощью класса абстракции особенно подходит для переносимых библиотек классов, так как они имеют ограниченный набор framework, доступные на них и не могут содержать директивы компилятора для поддержки ветвей кода для конкретных платформ.

#### <a name="interfaces"></a>Интерфейсы

С помощью интерфейсов позволяет реализовать классы, зависящие от платформы, которые по-прежнему могут быть переданы в ваши общие библиотеки, чтобы воспользоваться преимуществами общего кода.

Интерфейс определен в общем коде и передается в общую библиотеку как параметр или свойства.

Приложениями для конкретных платформ можно затем реализовать интерфейс и дальше пользоваться преимуществами общего кода для «обработки».

 **Преимущества**

Реализация может содержать код платформы и даже ссылаться на внешние библиотеки для конкретных платформ.

 **Недостатки**

Создавая и передать реализаций в общий код. Если этот интерфейс используется в общий код затем в конечном итоге передать несколько параметров метода или в противном случае переданы через цепочку вызовов. Если общий код использует множество различных интерфейсов затем они должны все быть создан и настройте в общем коде, где-нибудь.

#### <a name="inheritance"></a>Наследование

Общий код может реализовать абстрактный или виртуальный классы, которые могут быть расширены в один или несколько проектов для конкретных платформ. Это аналогично с помощью интерфейсов, но с некоторое поведение уже реализована. Существуют различные точки зрения на ли интерфейсы или наследования являются лучшим выбором разработки: в частности потому, что C# разрешает только одиночное наследование можно диктовать способом, API-интерфейсы можно реализовать в будущем. Используйте наследование с осторожностью.

Преимущества и недостатки интерфейсов в равной мере применимы к наследования, с использованием дополнительное преимущество. базовый класс может содержать реализации кода (возможно всей платформы зависит от реализация, которая может расширяться при необходимости).

## <a name="xamarinforms"></a>Xamarin.Forms

См. в разделе [Xamarin.Forms](~/get-started/index.md) документации.

### <a name="other-cross-platform-libraries"></a>Другие кросс платформенные библиотеки

Эти библиотеки также предлагают кросс платформенной функциональности для C# разработчиков:

- [**Xamarin.Essentials** ](~/essentials/index.md) — кроссплатформенные API-интерфейсы для общих компонентов.
- [**SkiaSharp** ](~/xamarin-forms/user-interface/graphics/skiasharp/index.md) — кроссплатформенная Двухмерная графика.

## <a name="conditional-compilation"></a>Условная компиляция

Существуют ситуации, где общему коду будет по-прежнему нужно работать по-разному на каждой платформе, возможно обращение к классов или функций, которые ведут себя по-разному. Условная компиляция лучше всего работает с проектами ОС Shared, где указан тот же исходный файл в нескольких проектах, которые имеют разные символы, определенные.

Проекты Xamarin всегда можно определить `__MOBILE__` которого имеет значение true, если для iOS и проектах приложений Android (Обратите внимание, двойным подчеркиванием до и после исправления на эти символы).

```csharp
#if __MOBILE__
// Xamarin iOS or Android-specific code
#endif
```
#### <a name="ios"></a>iOS

Определяет Xamarin.iOS `__IOS__` который можно использовать для обнаружения устройств iOS.

```csharp
#if __IOS__
// iOS-specific code
#endif
```

Также существуют Контрольные значения и ТВ-символы для:

```csharp
#if __TVOS__
// tv-specific stuff
#endif

#if __WATCHOS__
// watch-specific stuff
#endif
```

#### <a name="android"></a>Android

Код, который должен быть скомпилирован только в приложениях Xamarin.Android можно использовать следующие команды

```csharp
#if __ANDROID__
// Android-specific code
#endif
```

Каждая версия API также определяет новая директива компилятора, поэтому следующий код позволит добавить компоненты Если заданы новые интерфейсы API. Каждый уровень API включает все символы «нижний» уровня. Эта функция не очень полезна для поддержки нескольких платформ; Обычно `__ANDROID__` символов будет достаточно.

```csharp
#if __ANDROID_11__
// code that should only run on Android 3.0 Honeycomb or newer
#endif
```

#### <a name="mac"></a>Mac

Не существует встроенный символ для Xamarin.Mac, но можно добавить проект приложения в Mac **параметры > Создать > компилятора** в **определить символы** , или измените **.csproj**  файл и добавьте существует (например `__MAC__`)

```xml
<PropertyGroup><DefineConstants>__MAC__;$(DefineConstants)</DefineConstants></PropertyGroup>
```

#### <a name="universal-windows-platform-uwp"></a>Универсальная платформа Windows (UWP)

Используйте ключевое слово `WINDOWS_UWP`. Существуют без символов подчеркивания, окружающие строку как символы платформы Xamarin.

```csharp
#if WINDOWS_UWP
// UWP-specific code
#endif
```

#### <a name="using-conditional-compilation"></a>С помощью условной компиляции

Простой пример пример использования условной компиляции является установка расположение файла для файла базы данных SQLite. Три платформы имеют требования слегка различаются для указания местоположения файла:

-   **iOS** — Apple предпочитает не написанный пользователем данных помещается в определенном месте (каталог библиотеки), но есть константа не системы для этого каталога. Правильный путь требуется код для определенной платформы.
-   **Android** — в системный путь, возвращаемый `Environment.SpecialFolder.Personal` — это допустимый расположение для хранения файла базы данных.
-   **Windows Phone** – механизм изолированного хранилища не поддерживает полный путь указать, только относительный путь и имя файла.
-   **Платформа универсальных Windows** — использует `Windows.Storage` API-интерфейсы.

В следующем коде используется условной компиляции, чтобы обеспечить `DatabaseFilePath` является правильным для каждой платформы:

```csharp
public static string DatabaseFilePath {
        get {
    var filename = "TodoDatabase.db3";
#if SILVERLIGHT
    // Windows Phone 8
    var path = filename;
#else

#if __ANDROID__
    string libraryPath = Environment.GetFolderPath(Environment.SpecialFolder.Personal); ;
#else
#if __IOS__
        // we need to put in /Library/ on iOS5.1 to meet Apple's iCloud terms
        // (they don't want non-user-generated data in Documents)
        string documentsPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal); // Documents folder
        string libraryPath = Path.Combine (documentsPath, "..", "Library");
#else
        // UWP
        string libraryPath = Windows.Storage.ApplicationData.Current.LocalFolder.Path;
#endif
#endif
        var path = Path.Combine (libraryPath, filename);
#endif
        return path;
}
```

Результат является классом, можно создать и использовать на всех платформах, поместив файл базы данных SQLite в другом месте на каждой платформе.
