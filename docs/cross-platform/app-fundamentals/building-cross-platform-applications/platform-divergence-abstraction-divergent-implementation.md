---
title: "Часть 4. Работа с несколькими платформами"
ms.topic: article
ms.prod: xamarin
ms.assetid: BBE47BA8-78BC-6A2B-63BA-D1A45CB1D3A5
ms.technology: xamarin-cross-platform
author: asb3993
ms.author: amburns
ms.date: 03/23/2017
ms.openlocfilehash: 21cd08ad2eb9c78ba1bcd6b31400a38266c65e51
ms.sourcegitcommit: 8e722d72c5d1384889f70adb26c5675544897b1f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2018
---
# <a name="part-4---dealing-with-multiple-platforms"></a>Часть 4. Работа с несколькими платформами

## <a name="handling-platform-divergence-amp-features"></a>Обработка расхождение платформы &amp; функции

Расхождение не просто проблема 'кросс платформенных'; устройства на платформе «же» имеют разные возможности (особенно самых разнообразных устройствах Android, которые доступны). Наиболее очевидным и основные размера экрана, а другие атрибуты устройства можно изменить и требуется приложению проверять наличие определенных возможностей и ведут себя по-разному в зависимости от наличия (или отсутствия).

Это означает, что все приложения должны предусматривать Постепенное снижение функциональности, либо представлять наборы компонентов все, наименьшее общий знаменатель. Тесная интеграция с SDK собственного каждой из платформ Xamarin позволяют приложениям использовать функции платформой, поэтому имеет смысл для разработки приложений для использования этих возможностей.

См. в документации функциональные возможности платформы Общие сведения для отличия платформ функциональные возможности.

 <a name="Examples_of_Platform_Divergence" />


### <a name="examples-of-platform-divergence"></a>Примеры расхождения платформы

 <a name="Fundamental_elements_that_exist_across_platforms" />


#### <a name="fundamental-elements-that-exist-across-platforms"></a>Основные элементы, которые существуют на платформах

Существуют некоторые характеристики, универсальных приложений для мобильных устройств.
Это более высокого уровня основные понятия, которые выполняются для всех устройств и можно таким образом, формируют основу архитектуру приложения:

-  Выбор компонентов посредством вкладки или меню
-  Списки данных и прокрутка
-  Единого представления данных
-  Редактирование единого представления данных
-  Переход назад


При разработке вашего потока высокоуровневые экрана можно создать общие взаимодействие с пользователем на этих основных понятий.

 <a name="platform-specific_attributes" />


#### <a name="platform-specific-attributes"></a>атрибуты, предназначенные для платформы

Помимо основных элементов, которые существуют на всех платформах необходимо будет решать задачи различия ключа платформы в проекте. Может потребоваться учитывать (и напишите код для обработки, в частности) эти различия:

-   **Размеры экрана** — некоторые платформы (например, iOS и более ранних версиях Windows Phone) быть принят для относительно простых целевых размеров. Устройства Android не предусматривают множества различных измерений экрана, которые требуют больше усилий для поддержки в вашем приложении.
-   **Метафоры навигации** — различия между платформами (например) кнопки «Назад» оборудования элемент управления "Панорама" пользовательского интерфейса) и в пределах платформ (Android 2 и 4, iPhone и iPad).
-   **Клавиатура** — устройства Android некоторые иметь физической клавиатуры тогда как другие только сочетания программного обеспечения. Код, который определяет, когда клавиатуре soft скрывая части экрана должен зависит от этих различий.
-   **Сенсорный ввод и жестов** — поддержка операционной системы для распознавания жестов зависит, особенно в более ранних версиях для каждой операционной системы. Android более ранних версиях, имеют очень ограниченная поддержка для операций сенсорного ввода, это означает, что поддержки старых устройств может потребоваться отдельный код
-   **Push-уведомления** — существуют различные возможности и реализации для каждой платформы (например) Динамических плиток в Windows).


 <a name="Device-specific_features" />


#### <a name="device-specific-features"></a>Возможности для конкретных устройств

Определить, какие минимальные функции, необходимые для приложения должен быть; или, если решите, какие дополнительные возможности, чтобы воспользоваться преимуществами на каждой платформе. Код должен будет обнаруживать компоненты и функциональные возможности подключения или отключения предоставляют альтернативные варианты (например) альтернативой географическое расположение может быть пользователь мог ввести расположение или выберите из карты):

-   **Камера** — функциональные возможности различаются на разных устройствах: некоторые устройства нет веб-камеры, остальные пользователи имеют оба передней и задней камеры. Некоторые камеры способны видеозапись.
-   **Географическое расположение & maps** — поддержка GPS или Wi-Fi в папке не существует на всех устройствах. Приложения должны обслуживающие с различными уровнями точности, который поддерживается для каждого метода.
-   **Акселерометр, гироскопа и компас** — эти функции часто встречается в только выбранные устройства для каждой платформы, поэтому приложения почти всегда необходимо предоставить переход на резервный ресурс, если оборудование не поддерживается.
-   **Twitter и Facebook** — только «встроенные» iOS5 и iOS6 соответственно. В более ранних версиях и других платформ необходимо будет предоставить свои собственные функции проверки подлинности и взаимодействовать непосредственно с каждой API служб.
-   **Вблизи поля связи (NFC)** — только на (некоторые) телефонов Android (на момент написания статьи).


 <a name="Dealing_with_Platform_Divergence" />


### <a name="dealing-with-platform-divergence"></a>Работа с расхождение платформы

Существует два различных подхода для поддержки нескольких платформ из одной базы кода, каждый из которых свой собственный набор преимущества и недостатки.

-   **Платформа абстракции** — шаблон Business Фасадной предоставляет унифицированный доступ между платформами и абстрагирует реализации конкретной платформы в единую API.
-   **Разные реализации** — вызов конкретную платформу функции через разные реализации через архитектуры средства, такие как интерфейсы и наследование или условной компиляции.


 <a name="Platform_Abstraction" />


## <a name="platform-abstraction"></a>Абстракция платформы

 <a name="Class_Abstraction" />


### <a name="class-abstraction"></a>Класс абстракции

Используя интерфейсы или базовые классы определены в коде общих и реализована или расширенных в проекты под конкретные платформы. Написание и расширение общего кода с помощью класса абстракции, особенно подходящую переносимой библиотеки классов, так как они имеют ограниченное подмножество framework, доступные на них и не могут содержать директивы компилятора для поддержки ветвей кода под конкретную платформу.

 <a name="Interfaces" />


#### <a name="interfaces"></a>интерфейсов,

Использование интерфейсов позволяет реализовать такие классы специфический для платформы, которые по-прежнему могут быть переданы в вашей общей библиотеки, чтобы воспользоваться преимуществами общий код.

Интерфейс определяется в общий код и передается в общей библиотеки, в качестве параметра или свойства.

Специфический для платформы приложений можно затем реализуйте интерфейс и воспользоваться преимуществами общего кода для «обработки».

 **Преимущества**

Реализация может содержать код платформы и даже ссылаться на внешние библиотеки для конкретных платформ.

 **Недостатки**

Нужно создавать и передавать в общий код реализации. Если этот интерфейс используется в общий код затем концов, передаваемые через несколько параметров метода или в противном случае сместить вниз по цепочке вызова. Если общий код использует большое количество различных интерфейсов затем они должны все быть создана и в где-либо общий код.

 <a name="Inheritance" />


#### <a name="inheritance"></a>Наследование

Общий код может реализовать абстрактный или виртуальный классы, которые могут быть расширены в один или несколько проектов конкретную платформу. Это аналогично с помощью интерфейсов, но с некоторое поведение уже реализован. Существуют различных точек зрения ли интерфейсы или наследования отдается проектирования: в частности, так как C# позволяет только одиночное наследование его определяют способ собственные интерфейсы API могут быть спроектированы таким образом Забегая вперед. Используйте наследование с осторожностью.

Преимущества и недостатки интерфейсов также применяются для наследования с дополнительное преимущество. базовый класс может содержать некоторые кода реализации (возможно всей платформы зависит от реализации, могут быть расширены при необходимости).

<a name="Xamarin.Forms" />

### <a name="xamarinforms"></a>Xamarin.Forms

В разделе [Xamarin.Forms](~/xamarin-forms/get-started/index.md) документации.


### <a name="plug-in-cross-platform-functionality"></a>Подключаемый модуль межплатформенное взаимодействие

Также можно расширить кросс платформенных приложений согласованным образом с помощью подключаемых модулей.

Связаны с нашей [github подключаемых модулей](https://github.com/xamarin/plugins), большинство подключаемых модулей открытым исходным кодом (обычно доступных проектов для установки через Nuget), помогающие реализовать различные функциональные возможности конкретной платформы из состояние батареи параметры с Общие API, который удобно использовать в приложениях платформы Xamarin и Xamarin.Forms.


<a name="Other_Cross-Platform_Libraries" />

### <a name="other-cross-platform-libraries"></a>Другие библиотеки кросс платформенных

Существует ряд библиотеки сторонних производителей доступны, обеспечивающие возможности кросс платформенных:

-   **MvvmCross** -  [https://github.com/slodge/MvvmCross/](https://github.com/slodge/MvvmCross/)
-   **Vernacular** (в целях локализации) -  [https://github.com/rdio/vernacular/](https://github.com/rdio/vernacular/)
-   **MonoGame** (для игр XNA -)  [http://monogame.codeplex.com/](http://monogame.codeplex.com/)
-   **NGraphics** - [NGraphics](https://github.com/praeclarum/NGraphics) и его перед обменом [https://github.com/praeclarum/CrossGraphics](https://github.com/praeclarum/CrossGraphics)


 <a name="Divergent_Implementation" />


### <a name="divergent-implementation"></a>Разные реализации

 <a name="Conditional_Compilation" />


#### <a name="conditional-compilation"></a>Условная компиляция

Существуют ситуации, когда общий код все равно придется работают по-разному на каждой платформе, возможно обращение к любому классы или функции, которые ведут себя по-разному. Рекомендуется общих активов проектов, где находятся ссылки на том же исходном файле в нескольких проектах, которые определены разные символы условной компиляции.

Проекты Xamarin всегда можно определить `__MOBILE__` которого имеет значение true, если для iOS и Android приложения проектов (Обратите внимание двойным подчеркиванием до и после исправления на эти символы).

```csharp
#if __MOBILE__
// Xamarin iOS or Android-specific code
#endif
```

<a name="iOS" />

##### <a name="ios"></a>iOS

Определяет Xamarin.iOS `__IOS__` которого можно использовать для обнаружения устройств iOS.

```csharp
#if __IOS__
// iOS-specific code
#endif
```

Существуют также контрольных значений и ТВ-символы для:

```csharp
#if __TVOS__
// tv-specific stuff
#endif

#if __WATCHOS__
// watch-specific stuff
#endif
```

<a name="Android" />

##### <a name="android"></a>Android

Код, который следует компилировать в Xamarin.Android приложения можно использовать следующие средства

```csharp
#if __ANDROID__
// Android-specific code
#endif
```

Каждая версия API также определяет новая директива компилятора, поэтому следующего кода позволит добавить компоненты Если нацелены новые интерфейсы API. Каждый уровень API включает все символы «ниже» уровня. Эта функция не очень полезна для поддержки нескольких платформ; Обычно `__ANDROID__` символ будет достаточно.

```csharp
#if __ANDROID_11__
// code that should only run on Android 3.0 Honeycomb or newer
#endif
```

##### <a name="mac"></a>Mac

Не существует встроенный символ для Xamarin.Mac, но можно добавить свой собственный в Mac проект приложения **параметры > сборки > компилятора** в **определить символы** , или измените **CSPROJ-файл**  и добавьте существует файла (например `__MAC__`)

```xml
<PropertyGroup><DefineConstants>__MAC__;$(DefineConstants)</DefineConstants></PropertyGroup>
```

<a name="Windows_Phone" />

##### <a name="windows-phone"></a>Windows Phone

Приложения Windows Phone определяет два символы — `WINDOWS_PHONE` и `SILVERLIGHT` — который может использоваться для кода на платформу. Эти нет знаки подчеркивания вокруг их как символы платформа Xamarin сделать.


<a name="Using_Conditional_Compilation" />

##### <a name="using-conditional-compilation"></a>С помощью условной компиляции

Простой пример практический пример условной компиляции выполняется задание расположение файла для файла базы данных SQLite. Три платформы имеют требования слегка различаются для указания расположения файлов:

-   **iOS** — Apple, является предпочтительным для встроенных данных помещается в указанное местоположение (каталог библиотеки), но нет не константа системы для этого каталога. Код платформы требуется правильный путь.
-   **Android** — в системный путь, возвращаемый `Environment.SpecialFolder.Personal` — допустимое расположение для хранения файла базы данных.
-   **Windows Phone** – механизм изолированное хранилище не допускает полный путь должен задаваться, только относительный путь и имя файла.
-   **Универсальная платформа Windows** — использует `Windows.Storage` API-интерфейсы.

В следующем коде используется условной компиляции, чтобы обеспечить `DatabaseFilePath` является правильным для каждой платформы:

```csharp
public static string DatabaseFilePath {
        get {
    var filename = "TodoDatabase.db3";
#if SILVERLIGHT
    // Windows Phone 8
    var path = filename;
#else

#if __ANDROID__
    string libraryPath = Environment.GetFolderPath(Environment.SpecialFolder.Personal); ;
#else
#if __IOS__
        // we need to put in /Library/ on iOS5.1 to meet Apple's iCloud terms
        // (they don't want non-user-generated data in Documents)
        string documentsPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal); // Documents folder
        string libraryPath = Path.Combine (documentsPath, "..", "Library");
#else
        // UWP
        string libraryPath = Windows.Storage.ApplicationData.Current.LocalFolder.Path;
#endif
#endif
        var path = Path.Combine (libraryPath, filename);
#endif
        return path;
}
```

Результат является классом, который построен и использовать на всех платформах, поместив файл базы данных SQLite в другое место на каждой платформе.

