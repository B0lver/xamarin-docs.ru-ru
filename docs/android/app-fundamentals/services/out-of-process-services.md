---
title: Запуск служб Android в удаленных процессах
description: Как правило, все компоненты приложения Android будут выполняться в одном процессе. Службы Android являются заметным исключением в том, что их можно настроить для работы в собственных процессах и совместно использовать с другими приложениями, в том числе с другими разработчиками Android. В этом руководство рассказывается, как создать и использовать удаленную службу Android с помощью Xamarin.
ms.prod: xamarin
ms.assetid: 27A2E972-A690-480B-B31D-5EF1F74F673C
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 02/16/2018
ms.openlocfilehash: f546a1403aa0af07fc69187c4cfbec8982ed7a2a
ms.sourcegitcommit: 5821c9709bf5e06e6126233932f94f9cf3524577
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/31/2019
ms.locfileid: "75556513"
---
# <a name="running-android-services-in-remote-processes"></a>Запуск служб Android в удаленных процессах

_Как правило, все компоненты приложения Android будут выполняться в одном процессе. Службы Android являются заметным исключением в том, что их можно настроить для работы в собственных процессах и совместно использовать с другими приложениями, в том числе с другими разработчиками Android. В этом руководство рассказывается, как создать и использовать удаленную службу Android с помощью Xamarin._

## <a name="out-of-process-services-overview"></a>Общие сведения о службах вне процесса

При запуске приложения Android создает процесс, в котором будет выполняться приложение. Как правило, все компоненты, которые приложение будет выполнять в этом одном процессе. Службы Android являются заметным исключением в том, что их можно настроить для работы в собственных процессах и совместно использовать с другими приложениями, в том числе с другими разработчиками Android. Эти типы служб называются _удаленными службами_ или _необработанными службами_. Код для этих служб будет содержаться в том же APK, что и основное приложение. Однако при запуске службы Android создаст новый процесс для только этой службы. В отличие от этого, служба, которая работает в том же процессе, что и остальная часть приложения, иногда называется _локальной службой_.

В общем случае не требуется, чтобы приложение реализовало удаленную службу. Локальная служба достаточна (и желательно) для требований приложения во многих случаях. Вне процесса у него есть собственный объем памяти, который должен управляться Android. Хотя это приводит к дополнительным издержкам для всего приложения, существуют некоторые сценарии, в которых может оказаться целесообразным запускать службу в собственном процессе:

1. **Функции совместного использования** &ndash; некоторые разработчики приложений могут иметь несколько приложений и функций, которые являются общими для всех приложений. Упаковка этих функций в службу Android, которая выполняется в собственном процессе, может упростить обслуживание приложений. Также можно упаковать службу в собственную изолированную APK и развернуть ее отдельно от остальной части приложения.
2. **Улучшение взаимодействия с пользователем** &ndash; существует два возможных способа, с помощью которых служба вне процесса может улучшить взаимодействие с пользователем приложения. Первый способ заключается в использовании управления памятью. Когда происходит цикл сборки мусора (GC), Android приостанавливает все действия в процессе до завершения сборки мусора. Пользователь может воспринимать эту паузу как "перебои" или "жанк". Когда служба выполняется в собственном процессе, это приостановленный процесс службы, а не процесс приложения. Эта пауза будет гораздо менее заметной для пользователя, так как процесс приложения (и, следовательно, Пользовательский интерфейс) не приостановлен.

    Во-вторых, если требования к памяти процесса становятся слишком большими, Android может уничтожить этот процесс, чтобы освободить ресурсы для устройства. Если служба имеет большой объем памяти и выполняется в том же процессе, что и пользовательский интерфейс, то когда Android принудительно освобождает эти ресурсы, Пользовательский интерфейс будет закрыт, что позволит пользователю запустить приложение. Однако если служба, работающая в собственном процессе, завершает работу с Android, процесс пользовательского интерфейса остается неизменным. Пользовательский интерфейс может привязывать (и перезапускать) службу, прозрачно для пользователя и возобновлять нормальную работу.

3. **Повышение производительности приложений** &ndash; процесс пользовательского интерфейса может завершиться или завершить работу независимо от процесса службы. Перемещение длительных задач запуска в службу вне процесса может привести к увеличению времени запуска пользовательского интерфейса (при условии, что процесс службы находится в активном состоянии между временем запуска пользовательского интерфейса).

Во многих случаях привязка к службе, работающей в другом процессе, аналогична [привязке к локальной службе](~/android/app-fundamentals/services/creating-a-service/bound-services.md). Клиент вызывает `BindService` для привязки (и запуска при необходимости) службы. Для управления подключением между клиентом и службой будет создан объект `Android.OS.IServiceConnection`. Если клиент успешно привязывается к службе, то Android возвратит объект через `IServiceConnection`, который можно использовать для вызова методов в службе. Затем клиент взаимодействует со службой, используя этот объект. Для просмотра ниже приведены действия по привязке к службе.

- **Создайте намерение** , &ndash; для привязки к службе необходимо использовать явную намерение.
- **Реализуйте и создайте экземпляр объекта `IServiceConnection`** &ndash; объект `IServiceConnection` выступает в качестве посредника между клиентом и службой.  Он отвечает за наблюдение за подключением между клиентом и сервером.
- **Вызов метода `BindService`** &ndash; вызов `BindService` будет отправлять намерение и подключение службы, созданное на предыдущих шагах, к Android, что потребует запуска службы и установления связи между клиентом и службой.

Необходимость в межпроцессных границах приводит к дополнительной сложности: связь является односторонней (клиент-сервер), и клиент не может напрямую вызывать методы класса службы. Помните, что когда служба выполняет тот же процесс, что и клиент, Android предоставляет объект `IBinder`, который может допускать двустороннюю связь. Это не так, когда служба работает в собственном процессе. Клиент взаимодействует с удаленной службой с помощью класса `Android.OS.Messenger`.

Когда клиент запрашивает привязку к удаленной службе, Android вызывает метод жизненного цикла `Service.OnBind`, который возвращает внутренний `IBinder` объект, инкапсулированный `Messenger`. `Messenger` является тонкой оболочкой для специальной реализации `IBinder`, предоставляемой пакет SDK для Android. `Messenger` проходит обмен данными между двумя разными процессами. Разработчик не связан с деталями сериализации сообщения, маршалингом сообщения через границу процесса, а затем десериализацией его на клиенте. Эта работа обрабатывается объектом `Messenger`. На этой диаграмме показаны компоненты Android на стороне клиента, которые используются, когда клиент инициирует привязку к внешней службе:

![Схема, на которой показаны этапы и компоненты для привязки клиента к службе](out-of-process-services-images/ipc-01.png "Схема, на которой показаны шаги и компоненты для привязки клиента к службе.")

Класс `Service` в удаленном процессе будет проходить через те же обратные вызовы жизненного цикла, что и связанная служба в локальном процессе, и многие из задействованных API будут одинаковыми. `Service.OnCreate` используется для инициализации `Handler` и вставки его в объект `Messenger`. Аналогичным образом `OnBind` переопределяется, но вместо того, чтобы возвращать объект `IBinder`, служба возвратит `Messenger`.  На этой схеме показано, что происходит в службе при привязке клиента к ней:

![Схема, на которой показаны шаги и компоненты, с которыми проходит служба при выполнении привязки удаленным клиентом](out-of-process-services-images/ipc-02.png "Схема, на которой показаны шаги и компоненты, с которыми проходит служба при выполнении привязки удаленным клиентом.")

Когда служба получает `Message`, она обрабатывается в экземпляре `Android.OS.Handler`. Служба будет реализовывать собственный подкласс `Handler`, который должен переопределять метод `HandleMessage`. Этот метод вызывается `Messenger` и получает `Message` в качестве параметра. `Handler` будет проверять метаданные `Message` и использовать эти сведения для вызова методов в службе.

Односторонняя связь возникает, когда клиент создает объект `Message` и отправляет его в службу с помощью метода `Messenger.Send`. `Messenger.Send` будет выполнять сериализацию `Message` и вручную, которые сериализованные данные находятся в Android, что приведет к маршрутизации сообщения между границей процесса и службой.  `Messenger`, размещенный в службе, создаст `Message` объект из входящих данных. Эта `Message` помещается в очередь, где сообщения отправляются по одной на `Handler`. `Handler` будет проверять метаданные, содержащиеся в `Message`, и вызывать соответствующие методы в `Service`. На следующей схеме показаны эти различные понятия в действии.

![Диаграмма, показывающая, как сообщения передаются между процессами](out-of-process-services-images/ipc-03.png "Диаграмма, показывающая, как сообщения передаются между процессами.")

В этом разделе обсуждаются сведения о реализации службы вне процесса. В нем обсуждается реализация службы, которая должна выполняться в собственном процессе и как клиент может взаимодействовать с этой службой, используя `Messenger` Framework. Также будет кратко обсуждать двустороннее взаимодействие: клиент отправляет сообщение службе, а служба отправляет сообщение обратно клиенту. Поскольку службы могут совместно использоваться разными приложениями, в этом руководством также рассматривается один из способов ограничения клиентского доступа к службе с помощью разрешений Android.

> [!IMPORTANT]
> [Бугзилла 51940/GitHub 1950. службы с изолированными процессами и классом пользовательского приложения не могут правильно разрешать перегрузки, чтобы](https://github.com/xamarin/xamarin-android/issues/1950) служба Xamarin. Android не запускалась должным образом, если для `IsolatedProcess` установлено значение `true`. Это руководство предназначено для справки. Приложение Xamarin. Android по-прежнему должно иметь возможность взаимодействовать со службой вне процесса, написанной на Java.

## <a name="requirements"></a>Требования

В этом учебнике предполагается знание создания служб.

Хотя можно использовать неявные цели с приложениями, предназначенными для более старых интерфейсов API Android, в этом руководством основное внимание уделяется исключительно использованию явных целей. Приложения, предназначенные для Android 5,0 (уровень API 21) или более поздней версии, должны использовать явную намерение для привязки к службе; Это метод, который будет продемонстрирован в этом руководством.

## <a name="create-a-service-that-runs-in-a-separate-process"></a>Создание службы, работающей в отдельном процессе

Как было сказано выше, тот факт, что служба выполняется в собственном процессе, означает, что некоторые другие API-интерфейсы задействованы. В качестве краткого обзора ниже приведены шаги для привязки и использования удаленной службы.  

- **Создайте подкласс `Service`** &ndash; подклассировать тип `Service` и реализуйте методы жизненного цикла для привязанной службы. Также необходимо задать метаданные, которые будут сообщать Android о том, что служба должна выполняться в собственном процессе.
- **Реализуйте `Handler`** &ndash; `Handler` отвечает за анализ запросов клиентов, извлечение всех параметров, которые были переданы из клиента, и вызов соответствующих методов службы.
- **Создание экземпляра `Messenger`** &ndash; как описано выше, каждый `Service` должен поддерживать экземпляр класса `Messenger`, который будет маршрутизировать клиентские запросы к `Handler`, созданному на предыдущем шаге.

Служба, предназначенная для выполнения в собственном процессе, по-прежнему является привязанной службой. Класс службы расширяет базовый класс `Service` и дополняется `ServiceAttribute`, содержащим метаданные, которые требуются для пакета Android в манифесте Android. Чтобы начать с, следующие свойства `ServiceAttribute`, которые важны для службы вне процесса:

1. `Exported` &ndash; это свойство должно иметь значение `true`, чтобы другие приложения могли взаимодействовать со службой. По умолчанию этому свойству присваивается значение `false`.
2. `Process` &ndash; это свойство должно быть задано. Он используется для указания имени процесса, в котором будет выполняться служба.
3. `IsolatedProcess` &ndash; это свойство обеспечивает дополнительный уровень безопасности, предуказывая Android запустить службу в изолированной песочнице с минимальными разрешениями на взаимодействие с остальными компонентами системы. См. раздел [бугзилла 51940-Services with изолированные процессы и класс пользовательского приложения не удается правильно разрешить перегрузки](https://bugzilla.xamarin.com/show_bug.cgi?id=51940).
4. `Permission` &ndash; можно управлять доступом клиентов к службе, указав разрешение, которое клиенты должны запрашивать (и предоставлять).

Чтобы запустить службу в собственном процессе, свойству `Process` в `ServiceAttribute` должно быть присвоено имя службы. Чтобы взаимодействовать с внешними приложениями, свойству `Exported` должно быть присвоено значение `true`. Если `Exported` `false`, то только клиенты в одном APK (т. е. одно приложение) и выполняются в одном процессе, смогут взаимодействовать со службой.

Тип процесса, в котором будет выполняться служба, зависит от значения свойства `Process`. Android определяет три различных типа процессов:

- **Частный процесс** &ndash; частный процесс — это тот, который доступен только для приложения, запустившего его. Чтобы идентификатор процесса был закрыт, его имя должно начинаться с символа **(точка с запятой** ). Служба, представленная в предыдущем фрагменте кода и снимке экрана, является частным процессом. Следующий фрагмент кода является примером `ServiceAttribute`:

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process=":timestampservice_process",
             Exported=true)]
    ```

- **Глобальный процесс** &ndash; служба, которая выполняется в глобальном процессе, доступна для всех приложений, выполняющихся на устройстве. Глобальный процесс должен быть полным именем класса, который начинается с символа нижнего регистра.
    (Если не предпринимаются действия для защиты службы, другие приложения могут привязываться к ней и взаимодействовать с ней. Защита службы от несанкционированного использования будет рассмотрена далее в этом пошаговом окне.)

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process="com.xamarin.xample.messengerservice.timestampservice_process",
             Exported=true)]
    ```

- **Изолированный процесс** &ndash; изолированный процесс — это процесс, выполняемый в собственной песочнице, изолированный от остальной части системы и не имеющий специальных разрешений. Чтобы запустить службу в изолированном процессе, свойству `IsolatedProcess` `ServiceAttribute` присваивается значение `true`, как показано в следующем фрагменте кода:
    
    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             IsolatedProcess= true,
             Process="com.xamarin.xample.messengerservice.timestampservice_process",
             Exported=true)]
    ```

> [!IMPORTANT]
> См. раздел [бугзилла 51940-Services with изолированные процессы и класс пользовательского приложения не удается правильно разрешить перегрузки](https://bugzilla.xamarin.com/show_bug.cgi?id=51940)

Изолированная служба — это простой способ защитить приложение и устройство от ненадежного кода. Например, приложение может загрузить и выполнить сценарий с веб-сайта. В этом случае выполнение этого действия в изолированном процессе обеспечивает дополнительный уровень безопасности на основе ненадежного кода, поставя под угрозу устройство Android.

> [!IMPORTANT]
> После экспорта службы имя службы не должно изменяться. Изменение имени службы может привести к нарушению работы других приложений, использующих эту службу.

Чтобы увидеть, как действует свойство `Process`, на следующем снимке экрана показана служба, работающая в собственном частном процессе:

![Снимок экрана, на котором показана служба, работающая в частном процессе](out-of-process-services-images/ipc-04.png "Снимок экрана, на котором показана служба, работающая в частном процессе.")

На следующем снимке экрана показан `Process="com.xamarin.xample.messengerservice.timestampservice_process"` и служба, выполняющаяся в глобальном процессе:

![Снимок экрана службы, выполняющейся в глобальном процессе](out-of-process-services-images/ipc-05.png "Снимок экрана службы, выполняющейся в глобальном процессе.")

После установки `ServiceAttribute` службе необходимо реализовать `Handler`.

### <a name="implementing-a-handler"></a>Реализация обработчика

Для обработки клиентских запросов служба должна реализовать `Handler` и переопределить метод `HandleMessage`. Этот метод принимает экземпляр `Message`, который инкапсулирует вызов метода от клиента и преобразует этот вызов в какое-либо действие или задачу, которую будет выполнять служба. Объект `Message` предоставляет свойство с именем `What`, которое является целочисленным значением, значение которого является общим для клиента и службы и относится к некоторой задаче, которую служба должна выполнить для клиента.

В следующем фрагменте кода из примера приложения показан один из примеров `HandleMessage`. В этом примере клиент может запросить службу с помощью двух действий:

- Первое действие — это сообщение _Hello, World_ , клиент отправил в службу простое сообщение.
- Второе действие вызывает метод службы и извлекает строку, в данном случае строка представляет собой сообщение, которое возвращает время запуска службы и время ее выполнения:

```csharp
public class TimestampRequestHandler : Android.OS.Handler
{
    // other code omitted for clarity

    public override void HandleMessage(Message msg)
    {
        int messageType = msg.What;
        Log.Debug(TAG, $"Message type: {messageType}.");

        switch (messageType)
        {
            case Constants.SAY_HELLO_TO_TIMESTAMP_SERVICE:
                // The client has sent a simple Hello, say in the Android Log.
                break;

            case Constants.GET_UTC_TIMESTAMP:
                // Call methods on the service to retrieve a timestamp message.
                break;
            default:
                Log.Warn(TAG, $"Unknown messageType, ignoring the value {messageType}.");
                base.HandleMessage(msg);
                break;
        }
    }
}
```

Также можно упаковать параметры для службы в `Message`. Это будет рассмотрено далее в этом пошаговом окне. В следующем разделе рассматривается создание объекта `Messenger` для обработки входящих `Message`s.

### <a name="instantiating-the-messenger"></a>Создание экземпляра программы Messenger

Как уже говорилось, десериализация объекта `Message` и вызов `Handler.HandleMessage` является обязанностью объекта `Messenger`. Класс `Messenger` также предоставляет объект `IBinder`, который клиент будет использовать для отправки сообщений в службу.  

При запуске службы создается экземпляр `Messenger` и вставляется `Handler`. Хорошим местом для выполнения этой инициализации является метод `OnCreate` службы. Этот фрагмент кода является одним из примеров службы, которая инициализирует собственную `Handler` и `Messenger`:

```csharp
private Messenger messenger; // Instance variable for the Messenger

public override void OnCreate()
{
    base.OnCreate();
    messenger = new Messenger(new TimestampRequestHandler(this));
    Log.Info(TAG, $"TimestampService is running in process id {Android.OS.Process.MyPid()}.");
}
```

На этом этапе последний шаг предназначен для того, чтобы `Service` переопределять `OnBind`.

### <a name="implementing-serviceonbind"></a>Реализация Service. onbind

Все привязанные службы, независимо от того, выполняются они в собственном процессе или нет, должны реализовывать метод `OnBind`. Возвращаемое значение этого метода — это некоторый объект, который клиент может использовать для взаимодействия со службой. Именно то, что этот объект зависит от того, является ли служба локальной или удаленной службой. Хотя локальная служба возвращает пользовательскую реализацию `IBinder`, удаленная служба возвращает `IBinder`, который инкапсулирован, но `Messenger`, созданный в предыдущем разделе:

```csharp
public override IBinder OnBind(Intent intent)
{
    Log.Debug(TAG, "OnBind");
    return messenger.Binder;
}
```

После выполнения этих трех шагов удаленную службу можно считать завершенной.

## <a name="consuming-the-service"></a>Использование службы

Все клиенты должны реализовать некоторый код, чтобы иметь возможность привязать и использовать удаленную службу. По сути, с точки зрения клиента существует очень мало различий между привязками к локальной службе или удаленной службе. Клиент вызывает метод `BindService`, передавая явную цель для указания службы и `IServiceConnection`, которая помогает управлять соединением между клиентом и службой.

Этот фрагмент кода является примером того, как создать **явную цель** для привязки к удаленной службе. Цель должна обозначать пакет, содержащий службу, и имя службы. Один из способов задать эту информацию — использовать объект `Android.Content.ComponentName` и предоставить его намерению. Этот фрагмент кода является одним из примеров:  

```csharp
// This is the package name of the APK, set in the Android manifest
const string REMOTE_SERVICE_COMPONENT_NAME = "com.xamarin.TimestampService";
// This is the name of the service, according the value of ServiceAttribute.Name
const string REMOTE_SERVICE_PACKAGE_NAME   = "com.xamarin.xample.messengerservice";

// Provide the package name and the name of the service with a ComponentName object.
ComponentName cn = new ComponentName(REMOTE_SERVICE_PACKAGE_NAME, REMOTE_SERVICE_COMPONENT_NAME);
Intent serviceToStart = new Intent();
serviceToStart.SetComponent(cn);
```

При привязке службы вызывается метод `IServiceConnection.OnServiceConnected` и обеспечивается `IBinder` клиенту. Однако клиент не будет напрямую использовать `IBinder`. Вместо этого будет создан экземпляр объекта `Messenger` из этого `IBinder`. Это `Messenger`, который клиент будет использовать для взаимодействия с удаленной службой.

Ниже приведен пример очень простой `IServiceConnection`ной реализации, которая демонстрирует, как клиент будет управлять подключением к службе и отключаться от нее. Обратите внимание, что метод `OnServiceConnected` получает и `IBinder`, а клиент создает `Messenger` из этого `IBinder`:

```csharp
public class TimestampServiceConnection : Java.Lang.Object, IServiceConnection
{
    static readonly string TAG = typeof(TimestampServiceConnection).FullName;

    MainActivity mainActivity;
    Messenger messenger;

    public TimestampServiceConnection(MainActivity activity)
    {
        IsConnected = false;
        mainActivity = activity;
    }

    public bool IsConnected { get; private set; }
    public Messenger Messenger { get; private set; }

    public void OnServiceConnected(ComponentName name, IBinder service)
    {
        Log.Debug(TAG, $"OnServiceConnected {name.ClassName}");

        IsConnected = service != null;
        Messenger = new Messenger(service);

        if (IsConnected)
        {
            // things to do when the connection is successful. perhaps notify the client? enable UI features?
        }
        else
        {
            // things to do when the connection isn't successful.
        }
    }

    public void OnServiceDisconnected(ComponentName name)
    {
        Log.Debug(TAG, $"OnServiceDisconnected {name.ClassName}");
        IsConnected = false;
        Messenger = null;

        // Things to do when the service disconnects. perhaps notify the client? disable UI features?

    }
}
```

После создания подключения службы и намерений клиент может вызвать `BindService` и инициировать процесс привязки:

```csharp
var serviceConnection = new TimestampServiceConnection(this);
BindService(serviceToStart, serviceConnection, Bind.AutoCreate);
```

После того как клиент успешно привязан к службе и `Messenger` доступен, клиент может отправить `Messages` в службу.

## <a name="sending-messages-to-the-service"></a>Отправка сообщений в службу

После подключения клиента и получения объекта `Messenger` можно взаимодействовать со службой путем диспетчеризации `Message` объектов через `Messenger`. Такое взаимодействие является односторонним, клиент отправляет сообщение, но ответ от службы не возвращается клиенту. В этом отношении `Message` является механизмом пожара и забыть.

Предпочтительным способом создания объекта `Message` является использование метода фабрики [`Message.Obtain`](xref:Android.OS.Message) . Этот метод выберет объект `Message` из глобального пула, поддерживаемого Android. `Message.Obtain` также содержит некоторые перегруженные методы, позволяющие инициализировать объект `Message` с использованием значений и параметров, необходимых службе.  После создания экземпляра `Message` он отправляется в службу путем вызова `Messenger.Send`. Этот фрагмент кода является одним из примеров создания и диспетчеризации `Message` для процесса службы:

```csharp
Message msg = Message.Obtain(null, Constants.SAY_HELLO_TO_TIMESTAMP_SERVICE);
try
{
    serviceConnection.Messenger.Send(msg);
}
catch (RemoteException ex)
{
    Log.Error(TAG, ex, "There was a error trying to send the message.");
}
```

Существует несколько различных форм метода `Message.Obtain`. В предыдущем примере используется [`Message.Obtain(Handler h, Int32 what)`](xref:Android.OS.Message.Obtain). Так как это асинхронный запрос к службе вне процесса; Служба не будет отвечать на запрос, поэтому для `Handler` установлено значение `null`. Второй параметр, `Int32 what`, будет храниться в свойстве `.What` объекта `Message`. Свойство `.What` используется кодом в процессе службы для вызова методов службы.

Класс `Message` также предоставляет два дополнительных свойства, которые могут использоваться для получателя: `Arg1` и `Arg2`. Эти два свойства представляют собой целочисленные значения, которые могут иметь некоторые специальные согласованные значения, имеющие смысл между клиентом и службой. Например, `Arg1` может содержать идентификатор клиента и `Arg2` может содержать номер заказа на покупку для этого клиента. [`Method.Obtain(Handler h, Int32 what, Int32 arg1, Int32 arg2)`](xref:Android.OS.Message.Obtain) можно использовать для задания двух свойств при создании `Message`. Другим способом заполнения этих двух значений является установка `.Arg` и `.Arg2` свойств непосредственно в объекте `Message` после его создания.

### <a name="passing-additional-values-to-the-service"></a>Передача дополнительных значений в службу

В службу можно передать более сложные данные с помощью `Bundle`. В этом случае дополнительные значения можно поместить в `Bundle` и отправить вместе с `Message`, установив свойство [свойства`.Data`](xref:Android.OS.Message.Data) перед отправкой.

```csharp
Bundle serviceParameters = new Bundle();
serviceParameters.

var msg = Message.Obtain(null, Constants.SERVICE_TASK_TO_PERFORM);
msg.Data = serviceParameters;

messenger.Send(msg);
```

> [!NOTE]
> Как правило, `Message` не должны иметь полезных данных, превышающих 1 МБ. Ограничение размера может отличаться в зависимости от версии Android и любых изменений, которые поставщик мог внести в свою реализацию проекта Android Open Source (АОСП), который входит в состав устройства.

## <a name="returning-values-from-the-service"></a>Возвращение значений из службы

Архитектура обмена сообщениями, обсуждаемая в этой точке, является односторонней, клиент отправляет сообщение службе. Если необходимо, чтобы служба возвращала значение клиенту, то все, что обсуждалось до этого момента, будет обращено к этому моменту. Служба должна создать `Message`, упаковать все возвращаемые значения и подготовить `Message` через `Messenger` клиенту. Однако служба не создает собственный `Messenger`; Вместо этого он основывается на создании экземпляра клиента и упаковке `Messenger` в качестве части начального запроса. Служба будет `Send` сообщение с помощью предоставленного клиентом `Messenger`.  

Ниже приведена последовательность событий для двустороннего обмена данными.

1. Клиент привязывается к службе. Когда служба и клиент подключаются, `IServiceConnection`, обслуживаемый клиентом, будет иметь ссылку на объект `Messenger`, который используется для передачи `Message`s в службу. Чтобы избежать путаницы, это будет называться _Service Messenger_.
2. Клиент создает `Handler` (называемый _обработчиком клиента_) и использует его для инициализации собственного `Messenger` ( _клиента Messenger_). Обратите внимание, что служба Messenger и клиентская программа Messenger — это два разных объекта, которые обрабатывают трафик в двух разных направлениях. Служба Messenger обрабатывает сообщения от клиента службе, тогда как клиентская программа Messenger будет обрабатывать сообщения от службы клиенту.
3. Клиент создает объект `Message` и задает для свойства `ReplyTo` значение Client Messenger. Затем сообщение отправляется в службу с помощью службы Messenger Service.
4. Служба получает сообщение от клиента и выполняет запрошенную работу.
5. Когда служба отправит ответ клиенту, она будет использовать `Message.Obtain` для создания нового объекта `Message`.
6. Чтобы отправить это сообщение клиенту, Служба извлечет клиентскую программу Messenger из свойства `.ReplyTo` клиентского сообщения и будет использовать его для `.Send` `Message` обратно клиенту.
7. Когда клиент получает ответ, он имеет собственный `Handler`, который обработает `Message`, проверив свойство `.What` (и при необходимости извлекая все параметры, содержащиеся в `Message`).

В этом примере кода демонстрируется, как клиент будет создавать экземпляр `Message` и упаковывать `Messenger`, которые служба должна использовать для своего ответа:

```csharp
Handler clientHandler = new ActivityHandler();
Messenger clientMessenger = new Messenger(activityHandler);

Message msg = Message.Obtain(null, Constants.GET_UTC_TIMESTAMP);
msg.ReplyTo = clientMessenger;

try
{
    serviceConnection.Messenger.Send(msg);
}
catch (RemoteException ex)
{
    Log.Error(TAG, ex, "There was a problem sending the message.");
}
```

Служба должна внести некоторые изменения в собственную `Handler`, чтобы извлечь `Messenger` и использовать ее для отправки ответов клиенту. Этот фрагмент кода является примером того, как `Handler` службы создаст `Message` и отправит его обратно клиенту:  

```csharp
// This is the message that the service will send to the client.
Message responseMessage = Message.Obtain(null, Constants.RESPONSE_TO_SERVICE);
Bundle dataToReturn = new Bundle();
dataToReturn.PutString(Constants.RESPONSE_MESSAGE_KEY, "This is the result from the service.");
responseMessage.Data = dataToReturn;

// The msg object here is the message that was received by the service. The service will not instantiate a client,
// It will use the client that is encapsulated by the message from the client.
Messenger clientMessenger = msg.ReplyTo;
if (clientMessenger!= null)
{
    try
    {
        clientMessenger.Send(responseMessage);
    }
    catch (Exception ex)
    {
        Log.Error(TAG, ex, "There was a problem sending the message.");
    }
}
```

Обратите внимание, что в приведенных выше примерах кода `Messenger` экземпляр, созданный клиентом, *не* совпадает с объектом, полученным службой. Это два разных `Messenger` объектов, работающих в двух отдельных процессах, представляющих канал связи.

## <a name="securing-the-service-with-android-permissions"></a>Защита службы с помощью разрешений Android

Служба, которая выполняется в глобальном процессе, доступна для всех приложений, запущенных на этом устройстве Android. В некоторых ситуациях это открытость и доступность нежелательна, поэтому необходимо защитить службу от несанкционированного доступа от неавторизованных клиентов. Одним из способов ограничения доступа к удаленной службе является использование разрешений Android.

Разрешения могут определяться свойством `Permission` `ServiceAttribute`, который добавляет к подклассу `Service`. Это имя будет иметь разрешение, которое должен предоставить клиент при привязке к службе. Если у клиента нет соответствующих разрешений, то Android выдаст `Java.Lang.SecurityException`, когда клиент пытается выполнить привязку к службе.

Android предоставляет четыре различных уровня разрешений:

- **обычная** &ndash; это уровень разрешений по умолчанию. Он используется для обнаружения разрешений низкого риска, которые могут быть автоматически предоставлены Android клиентам, запрашивающим его. Пользователь не должен явно предоставлять эти разрешения, но разрешения можно просмотреть в параметрах приложения.
- **подпись** &ndash; это особая категория разрешений, которая автоматически предоставляется Android для приложений, подписанных одним и тем же сертификатом. Это разрешение предназначено для того, чтобы разработчики приложений могли совместно использовать компоненты или данные в своих приложениях, не требуя от пользователя постоянного утверждения.
- **сигнатуреорсистем** &ndash; это очень похоже на разрешения **подписи** , описанные выше. Кроме автоматического предоставления приложениям, подписанным одним и тем же сертификатом, это разрешение также будет предоставляться для приложений, которые подписаны тем же сертификатом, который использовался для подписания приложений, установленных с помощью образа системы Android. Это разрешение обычно используется разработчиками Android ROM, чтобы позволить приложениям работать с приложениями сторонних производителей. Она обычно не используется приложениями, которые предназначены для общего распространения в целом.
- **опасные** &ndash; опасные разрешения, которые могут вызвать проблемы для пользователя. По этой причине пользователь должен явно утверждать **опасные** разрешения.

Поскольку разрешения `signature` и `normal` автоматически предоставляются Android на момент установки, крайне важно, чтобы APK размещения службы устанавливался **перед** APK, содержащей клиент. Если клиент установлен первым, Android не предоставит разрешения. В этом случае потребуется удалить клиент APK, установить службу APK, а затем повторно установить клиент APK.

Существует два распространенных способа защитить службу с помощью разрешений Android.

1. **Реализация безопасности на уровне подписи** &ndash; безопасность на уровне подписи означает, что этим приложениям автоматически предоставляются разрешения, подписанные с помощью того же ключа, который использовался для ПОДписывания APK, содержащего службу. Это простой способ защитить службу, чтобы обеспечить их доступность из собственных приложений. Разрешения уровня подписи объявляются путем присвоения свойству `Permission` `ServiceAttribute` значения `signature`:

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process="com.xamarin.TimestampService.timestampservice_process",
             Permission="signature")]
    public class TimestampService : Service
    {
    }
    ```

2. **Создайте пользовательское разрешение** &ndash; возможно, разработчик службы может создать пользовательское разрешение для службы. Это лучше, когда разработчик хочет поделиться своей службой с приложениями других разработчиков. Пользовательское разрешение требует немного больше усилий для реализации и будет рассмотрено ниже.

Упрощенный пример создания пользовательского `normal` разрешения будет описан в следующем разделе. Дополнительные сведения о разрешениях Android см. в документации Google, где приведены [рекомендации по обеспечению безопасности &](https://developer.android.com/training/articles/security-tips.html). Дополнительные сведения о разрешениях Android см. в [разделе "разрешения](https://developer.android.com/guide/topics/manifest/manifest-intro.html#perms) " документации Android, посвященной манифесту приложения, для получения дополнительных сведений о разрешениях Android.

> [!NOTE]
> Как правило, [компания Google не рекомендует использовать пользовательские разрешения](https://developer.android.com/training/articles/security-tips.html#RequestingPermissions) , так как они могут сбить с толку пользователей.

### <a name="creating-a-custom-permission"></a>Создание пользовательского разрешения

Чтобы использовать пользовательское разрешение, оно объявляется службой, а клиент явным образом запрашивает это разрешение.

Чтобы создать разрешение в службе APK, элемент `permission` добавляется в элемент `manifest` в **AndroidManifest. XML**. Это разрешение должно иметь набор атрибутов `name`, `protectionLevel`и `label`. Атрибуту `name` должно быть присвоено строковое значение, однозначно идентифицирующее разрешение. Имя будет отображаться в представлении **сведений о приложении** в **параметрах Android** (как показано в следующем разделе).

Атрибуту `protectionLevel` должно быть присвоено одно из четырех строковых значений, описанных выше.  `label` и `description` должны ссылаться на строковые ресурсы и использоваться для предоставления пользователю понятного имени и описания.

Этот фрагмент кода является примером объявления настраиваемого атрибута `permission` в **AndroidManifest. XML** для APK, который содержит службу:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="1"
          android:versionName="1.0"
          package="com.xamarin.xample.messengerservice">

    <uses-sdk android:minSdkVersion="21" />

    <permission android:name="com.xamarin.xample.messengerservice.REQUEST_TIMESTAMP"
                android:protectionLevel="signature"
                android:label="@string/permission_label"
                android:description="@string/permission_description"
                />

    <application android:allowBackup="true"
            android:icon="@mipmap/icon"
            android:label="@string/app_name"
            android:theme="@style/AppTheme">

    </application>
</manifest>
```

Затем **AndroidManifest. XML** клиента apk должен явно запрашивать это новое разрешение. Это можно сделать, добавив атрибут `users-permission` в **AndroidManifest. XML**:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="1"
          android:versionName="1.0"
          package="com.xamarin.xample.messengerclient">

    <uses-sdk android:minSdkVersion="21" />

    <uses-permission android:name="com.xamarin.xample.messengerservice.REQUEST_TIMESTAMP" />

    <application
            android:allowBackup="true"
            android:icon="@mipmap/icon"
            android:label="@string/app_name"
            android:theme="@style/AppTheme">
    </application>
    </manifest>
```

### <a name="view-the-permissions-granted-to-an-app"></a>Просмотр разрешений, предоставленных приложению

Чтобы просмотреть разрешения, предоставленные приложению, откройте приложение параметры Android и выберите **приложения**. Найдите и выберите приложение в списке. На экране **сведения о приложении** выберите **разрешения** , которые будут отображать все разрешения, предоставленные приложению:

[![снимков экрана с устройства Android, показывающее, как найти разрешения, предоставленные приложению](out-of-process-services-images/ipc-06-sml.png)](out-of-process-services-images/ipc-06.png#lightbox)

## <a name="summary"></a>Сводка

Это руководство было расширено обсуждением запуска службы Android в удаленном процессе. Были описаны различия между локальной и удаленной службами, а также некоторые причины, по которым удаленная служба может быть полезной для стабильности и производительности приложения Android. После того как вы узнаете, как реализовать удаленную службу и как клиент может обмениваться данными со службой, руководство помогла предоставить один из способов ограничить доступ к службе только проверенными клиентами.

## <a name="related-links"></a>Связанные ссылки

- [Обработке](xref:Android.OS.Handler)
- [Сообщение](xref:Android.OS.Message)
- [Messenger](xref:Android.OS.Messenger)
- [сервицеаттрибуте](xref:Android.App.ServiceAttribute)
- [Экспортированный атрибут](https://developer.android.com/guide/topics/manifest/service-element.html#exported)
- [Службы с изолированными процессами и классом пользовательского приложения не могут правильно разрешать перегрузки](https://bugzilla.xamarin.com/show_bug.cgi?id=51940)
- [Процессы и потоки](https://developer.android.com/guide/components/processes-and-threads.html)
- [Манифест Android — разрешения](https://developer.android.com/guide/topics/manifest/manifest-intro.html#perms)
- [Советы по безопасности](https://developer.android.com/training/articles/security-tips.html)
- [Мессенжерсервицедемо (пример)](https://docs.microsoft.com/samples/xamarin/monodroid-samples/applicationfundamentals-servicesamples-messengerservicedemo)
