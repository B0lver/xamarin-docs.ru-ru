---
title: Запуск служб Android в удаленных процессах
description: Как правило, все компоненты приложения Android будут выполняться в одном процессе. Службы Android являются заметным исключением в том, что их можно настроить для работы в собственных процессах и совместно использовать с другими приложениями, в том числе с другими разработчиками Android. В этом руководство рассказывается, как создать и использовать удаленную службу Android с помощью Xamarin.
ms.prod: xamarin
ms.assetid: 27A2E972-A690-480B-B31D-5EF1F74F673C
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 02/16/2018
ms.openlocfilehash: 2794a1d23cd7c1eab9cf4e94eaa805ad2b8bca61
ms.sourcegitcommit: 1dd7d09b60fcb1bf15ba54831ed3dd46aa5240cb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/28/2019
ms.locfileid: "70119120"
---
# <a name="running-android-services-in-remote-processes"></a>Запуск служб Android в удаленных процессах

_Как правило, все компоненты приложения Android будут выполняться в одном процессе. Службы Android являются заметным исключением в том, что их можно настроить для работы в собственных процессах и совместно использовать с другими приложениями, в том числе с другими разработчиками Android. В этом руководство рассказывается, как создать и использовать удаленную службу Android с помощью Xamarin._

## <a name="out-of-process-services-overview"></a>Общие сведения о службах вне процесса

При запуске приложения Android создает процесс, в котором будет выполняться приложение. Как правило, все компоненты, которые приложение будет выполнять в этом одном процессе. Службы Android являются заметным исключением в том, что их можно настроить для работы в собственных процессах и совместно использовать с другими приложениями, в том числе с другими разработчиками Android. Эти типы служб называются _удаленными службами_ или необработанными _службами_. Код для этих служб будет содержаться в том же APK, что и основное приложение. Однако при запуске службы Android создаст новый процесс для только этой службы. В отличие от этого, служба, которая работает в том же процессе, что и остальная часть приложения, иногда называется _локальной службой_.

В общем случае не требуется, чтобы приложение реализовало удаленную службу. Локальная служба достаточна (и желательно) для требований приложения во многих случаях. Вне процесса у него есть собственный объем памяти, который должен управляться Android. Хотя это приводит к дополнительным издержкам для всего приложения, существуют некоторые сценарии, в которых может оказаться целесообразным запускать службу в собственном процессе:

1. **Возможности совместного использования** &ndash; Некоторые разработчики приложений могут иметь несколько приложений и функций, которые являются общими для всех приложений. Упаковка этих функций в службу Android, которая выполняется в собственном процессе, может упростить обслуживание приложений. Также можно упаковать службу в собственную изолированную APK и развернуть ее отдельно от остальной части приложения.
2. **Улучшение взаимодействия с пользователем** &ndash; Существует два возможных способа, с помощью которых служба вне процесса может улучшить взаимодействие с пользователем приложения. Первый способ заключается в использовании управления памятью. Когда происходит цикл сборки мусора (GC), Android приостанавливает все действия в процессе до завершения сборки мусора. Пользователь может воспринимать эту паузу как "перебои" или "жанк". Когда служба выполняется в собственном процессе, это приостановленный процесс службы, а не процесс приложения. Эта пауза будет гораздо менее заметной для пользователя, так как процесс приложения (и, следовательно, Пользовательский интерфейс) не приостановлен.

    Во-вторых, если требования к памяти процесса становятся слишком большими, Android может уничтожить этот процесс, чтобы освободить ресурсы для устройства. Если служба имеет большой объем памяти и выполняется в том же процессе, что и пользовательский интерфейс, то когда Android принудительно освобождает эти ресурсы, Пользовательский интерфейс будет закрыт, что позволит пользователю запустить приложение. Однако если служба, работающая в собственном процессе, завершает работу с Android, процесс пользовательского интерфейса остается неизменным. Пользовательский интерфейс может привязывать (и перезапускать) службу, прозрачно для пользователя и возобновлять нормальную работу.

3. **Повышение производительности приложения** &ndash; Процесс пользовательского интерфейса может завершиться или завершить работу независимо от процесса службы. Перемещение длительных задач запуска в службу вне процесса может привести к увеличению времени запуска пользовательского интерфейса (при условии, что процесс службы находится в активном состоянии между временем запуска пользовательского интерфейса).

Во многих случаях привязка к службе, работающей в другом процессе, аналогична [привязке к локальной службе](~/android/app-fundamentals/services/creating-a-service/bound-services.md). Клиент будет вызывать `BindService` , чтобы выполнить привязку (и запуск при необходимости) службы. Для управления подключением между клиентом и службой будет создан объект.`Android.OS.IServiceConnection` Если клиент успешно привязывается к службе, то Android возвратит объект через `IServiceConnection` , который можно использовать для вызова методов в службе. Затем клиент взаимодействует со службой, используя этот объект. Для просмотра ниже приведены действия по привязке к службе.

- **Создание намерения** &ndash; Для привязки к службе необходимо использовать явную намерение.
- **Реализация и создание `IServiceConnection` объекта** &ndash; . объект выступает `IServiceConnection` в качестве посредника между клиентом и службой.  Он отвечает за наблюдение за подключением между клиентом и сервером.
- **Вызов`BindService`**  метода&ndash; приведет к отправке цели и подключения службы, созданного на предыдущих шагах, к Android, что потребует запуска службы и установления связи между `BindService` Клиент и служба.

Необходимость в межпроцессных границах приводит к дополнительной сложности: связь является односторонней (клиент-сервер), и клиент не может напрямую вызывать методы класса службы. Помните, что когда служба выполняет тот же процесс, что и клиент, Android предоставляет `IBinder` объект, который может обеспечить двустороннюю связь. Это не так, когда служба работает в собственном процессе. Клиент взаимодействует с удаленной службой с `Android.OS.Messenger` помощью класса.

Когда клиент запрашивает привязку к удаленной службе, Android выполнит `Service.OnBind` метод жизненного цикла, который вернет внутренний `IBinder` объект, инкапсулированный `Messenger`. Является тонкой оболочкой для специальной `IBinder` реализации, предоставляемой пакет SDK для Android. `Messenger` `Messenger` Выполняет обмен данными между двумя разными процессами. Разработчик не связан с деталями сериализации сообщения, маршалингом сообщения через границу процесса, а затем десериализацией его на клиенте. Эта работа обрабатывается `Messenger` объектом. На этой диаграмме показаны компоненты Android на стороне клиента, которые используются, когда клиент инициирует привязку к внешней службе:

![Схема, на которой показаны этапы и компоненты для привязки клиента к службе](out-of-process-services-images/ipc-01.png "Схема, на которой показаны шаги и компоненты для привязки клиента к службе.")

`Service` Класс в удаленном процессе будет проходить через те же обратные вызовы жизненного цикла, которые связанная служба в локальном процессе будет проходить, и многие из вовлеченных API одинаковы. `Service.OnCreate`используется для инициализации `Handler` и вставки этого объекта в `Messenger` объект. Аналогичным образом переопределяется, но вместо `IBinder` возврата объекта Служба возвращает `Messenger`. `OnBind`  На этой схеме показано, что происходит в службе при привязке клиента к ней:

![Схема, на которой показаны шаги и компоненты, с которыми проходит служба при выполнении привязки удаленным клиентом](out-of-process-services-images/ipc-02.png "Схема, на которой показаны шаги и компоненты, с которыми проходит служба при выполнении привязки удаленным клиентом.")

Когда служба получает сообщение, она обрабатывается в `Android.OS.Handler`экземпляре. `Message` Служба будет реализовывать собственный `Handler` подкласс, который должен `HandleMessage` переопределять метод. Этот метод вызывается `Messenger` методом и получает в `Message` качестве параметра. `Handler` Будет`Message` проверять метаданные и использовать эти сведения для вызова методов в службе.

Односторонняя связь возникает, когда клиент создает `Message` объект и отправляет его в службу `Messenger.Send` с помощью метода. `Messenger.Send`будет выполнять сериализацию `Message` и пересылку сериализованных данных в Android, который направит сообщение между границей процесса и службой.  , Размещенный в службе `Message` , создаст объект из входящих данных. `Messenger` Он помещается в очередь, где сообщения отправляются `Handler`по очереди. `Message` Будет проверять метаданные, содержащиеся в, `Message` и вызывать соответствующие методы в `Service`. `Handler` На следующей схеме показаны эти различные понятия в действии.

![Диаграмма, показывающая, как сообщения передаются между процессами](out-of-process-services-images/ipc-03.png "Диаграмма, показывающая, как сообщения передаются между процессами.")

В этом разделе обсуждаются сведения о реализации службы вне процесса. В нем обсуждается реализация службы, которая должна выполняться в собственном процессе и как клиент может взаимодействовать с этой службой с помощью `Messenger` платформы. Также будет кратко обсуждать двустороннее взаимодействие: клиент отправляет сообщение службе, а служба отправляет сообщение обратно клиенту. Поскольку службы могут совместно использоваться разными приложениями, в этом руководством также рассматривается один из способов ограничения клиентского доступа к службе с помощью разрешений Android.

> [!IMPORTANT]
> [Бугзилла 51940/GitHub 1950. службы с изолированными процессами и пользовательским классом приложения не могут правильно разрешать](https://github.com/xamarin/xamarin-android/issues/1950) перегрузки, чтобы служба Xamarin. Android не запускалась должным `true`образом, если `IsolatedProcess` параметр имеет значение. Это руководство предназначено для справки. Приложение Xamarin. Android по-прежнему должно иметь возможность взаимодействовать со службой вне процесса, написанной на Java.

## <a name="requirements"></a>Требования

В этом учебнике предполагается знание создания служб.

Хотя можно использовать неявные цели с приложениями, предназначенными для более старых интерфейсов API Android, в этом руководством основное внимание уделяется исключительно использованию явных целей. Приложения, предназначенные для Android 5,0 (уровень API 21) или более поздней версии, должны использовать явную намерение для привязки к службе; Это метод, который будет продемонстрирован в этом руководством.

## <a name="create-a-service-that-runs-in-a-separate-process"></a>Создание службы, работающей в отдельном процессе

Как было сказано выше, тот факт, что служба выполняется в собственном процессе, означает, что некоторые другие API-интерфейсы задействованы. В качестве краткого обзора ниже приведены шаги для привязки и использования удаленной службы.  

- **Создание`Service` подкласса** &ndash; подкласс длятипаи`Service` реализация методов жизненного цикла для привязанной службы. Также необходимо задать метаданные, которые будут сообщать Android о том, что служба должна выполняться в собственном процессе.
- **Реализуйте `Handler` объект** &ndash; , отвечающий за анализ клиентских запросов, извлечение всех параметров, переданных из клиента, и вызов соответствующих методов службы. `Handler`
- `Messenger` `Handler` `Service` **Создайте экземпляр класса, как описано выше. каждый из них должен поддерживать экземпляры классов, которые будут маршрутизировать клиентские запросы к, созданному на предыдущем шаге. `Messenger`**  &ndash;

Служба, предназначенная для выполнения в собственном процессе, по-прежнему является привязанной службой. Класс службы расширяет базовый `Service` класс и дополняет его `ServiceAttribute` содержащими метаданными, которые требуются для пакета Android в манифесте Android. Чтобы начать с, следующие свойства `ServiceAttribute` объекта важны для службы вне процесса:

1. `Exported`Для этого свойства необходимо `true` задать значение, чтобы другие приложения могли взаимодействовать со службой. &ndash; По умолчанию этому свойству присваивается значение `false`.
2. `Process`&ndash; Это свойство должно быть задано. Он используется для указания имени процесса, в котором будет выполняться служба.
3. `IsolatedProcess`&ndash; Это свойство обеспечивает дополнительный уровень безопасности, предуказывая Android запустить службу в изолированной песочнице с минимальными разрешениями на взаимодействие с остальными компонентами системы. См. раздел [бугзилла 51940-Services with изолированные процессы и класс пользовательского приложения не удается правильно разрешить](https://bugzilla.xamarin.com/show_bug.cgi?id=51940)перегрузки.
4. `Permission`&ndash; Можно управлять доступом клиентов к службе, указав разрешение, которое клиенты должны запрашивать (и предоставлять).

Для запуска службы собственного процесса `Process` свойство `ServiceAttribute` в должно быть установлено в имя службы. Для взаимодействия с внешними приложениями `Exported` свойство должно иметь `true`значение. Если `Exported` имеет `false`значение, то только клиенты в одном apk (т. е. одно приложение) и выполняются в одном процессе, смогут взаимодействовать со службой.

Тип процесса, в котором будет выполняться служба, зависит от значения `Process` свойства. Android определяет три различных типа процессов:

- **Частный процесс** &ndash; Частный процесс — это тот, который доступен только для приложения, запустившего его. Чтобы идентификатор процесса был закрыт, его имя должно начинаться с символа (точка с запятой). Служба, представленная в предыдущем фрагменте кода и снимке экрана, является частным процессом. Следующий фрагмент кода является примером `ServiceAttribute`:

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process=":timestampservice_process",
             Exported=true)]
    ```

- **Глобальный процесс** &ndash; Служба, которая выполняется в глобальном процессе, доступна для всех приложений, выполняющихся на устройстве. Глобальный процесс должен быть полным именем класса, который начинается с символа нижнего регистра.
    (Если не предпринимаются действия для защиты службы, другие приложения могут привязываться к ней и взаимодействовать с ней. Защита службы от несанкционированного использования будет рассмотрена далее в этом пошаговом окне.)

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process="com.xamarin.xample.messengerservice.timestampservice_process",
             Exported=true)]
    ```

- **Изолированный процесс** &ndash; Изолированный процесс — это процесс, выполняемый в собственной песочнице, изолированный от остальной части системы и не имеющий специальных разрешений. Для запуска службы в изолированном процессе `IsolatedProcess` свойству `ServiceAttribute` присваивается значение `true` , как показано в следующем фрагменте кода:
    
    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             IsolatedProcess= true,
             Process="com.xamarin.xample.messengerservice.timestampservice_process",
             Exported=true)]
    ```

> [!IMPORTANT]
> См. раздел [бугзилла 51940-Services with изолированные процессы и класс пользовательского приложения не удается правильно разрешить](https://bugzilla.xamarin.com/show_bug.cgi?id=51940) перегрузки

Изолированная служба — это простой способ защитить приложение и устройство от ненадежного кода. Например, приложение может загрузить и выполнить сценарий с веб-сайта. В этом случае выполнение этого действия в изолированном процессе обеспечивает дополнительный уровень безопасности на основе ненадежного кода, поставя под угрозу устройство Android.

> [!IMPORTANT]
> После экспорта службы имя службы не должно изменяться. Изменение имени службы может привести к нарушению работы других приложений, использующих эту службу.

Чтобы увидеть результат `Process` этого свойства, на следующем снимке экрана показана служба, работающая в собственном частном процессе:

![Снимок экрана, на котором показана служба, работающая в частном процессе](out-of-process-services-images/ipc-04.png "Снимок экрана, на котором показана служба, работающая в частном процессе.")

На следующем снимке `Process="com.xamarin.xample.messengerservice.timestampservice_process"` экрана показана служба, выполняющаяся в глобальном процессе:

![Снимок экрана службы, выполняющейся в глобальном процессе](out-of-process-services-images/ipc-05.png "Снимок экрана службы, выполняющейся в глобальном процессе.")

После задания службы необходимо `Handler`реализовать. `ServiceAttribute`

### <a name="implementing-a-handler"></a>Реализация обработчика

Для обработки клиентских запросов служба должна реализовать `Handler` и `HandleMessage` переопределить месодсис `Message` — метод принимает экземпляр, инкапсулирующий вызов метода от клиента и преобразующий этот вызов в какое-либо действие или задачу. , который будет выполняться службой. Объект предоставляет свойство с именем `What` , которое является целочисленным значением, значение которого является общим для клиента и службы и относится к некоторой задаче, которую служба должна выполнить для клиента. `Message`

В следующем фрагменте кода из примера приложения показан один пример `HandleMessage`. В этом примере клиент может запросить службу с помощью двух действий:

- Первое действие — это сообщение _Hello, World_ , клиент отправил в службу простое сообщение.
- Второе действие вызывает метод службы и извлекает строку, в данном случае строка представляет собой сообщение, которое возвращает время запуска службы и время ее выполнения:

```csharp
public class TimestampRequestHandler : Android.OS.Handler
{
    // other code omitted for clarity

    public override void HandleMessage(Message msg)
    {
        int messageType = msg.What;
        Log.Debug(TAG, $"Message type: {messageType}.");

        switch (messageType)
        {
            case Constants.SAY_HELLO_TO_TIMESTAMP_SERVICE:
                // The client as sent a simple Hello, say in the Android Log.
                break;

            case Constants.GET_UTC_TIMESTAMP:
                // Call methods on the service to retrieve a timestamp message.
                break;
            default:
                Log.Warn(TAG, $"Unknown messageType, ignoring the value {messageType}.");
                base.HandleMessage(msg);
                break;
        }
    }
}
```

Также можно упаковать параметры для службы в `Message`. Это будет рассмотрено далее в этом пошаговом окне. Следующий раздел, который следует рассмотреть, — `Messenger` создание объекта для обработки входящих `Message`сообщений.

### <a name="instantiating-the-messenger"></a>Создание экземпляра программы Messenger

Как было сказано выше, ответственность за `Message` выполнение этого `Messenger` объекта `Handler.HandleMessage` заключается в десериализации объекта и вызове. `Messenger` Класс также`IBinder` предоставляет объект, который клиент будет использовать для отправки сообщений в службу.  

При запуске службы будет создан экземпляр `Messenger` и внедрен объект. `Handler` Хорошим местом для выполнения этой инициализации является `OnCreate` метод службы. Этот фрагмент кода является одним из примеров службы, которая инициализирует свои собственные `Handler` и `Messenger`:

```csharp
private Messenger messenger; // Instance variable for the Messenger

public override void OnCreate()
{
    base.OnCreate();
    messenger = new Messenger(new TimestampRequestHandler(this));
    Log.Info(TAG, $"TimestampService is running in process id {Android.OS.Process.MyPid()}.");
}
```

На этом этапе последним шагом является `Service` переопределение. `OnBind`

### <a name="implementing-serviceonbind"></a>Реализация Service. onbind

Все привязанные службы, независимо от `OnBind` того, выполняются они в собственном процессе или нет, должны реализовывать метод. Возвращаемое значение этого метода — это некоторый объект, который клиент может использовать для взаимодействия со службой. Именно то, что этот объект зависит от того, является ли служба локальной или удаленной службой. Хотя локальная служба будет возвращать пользовательскую `IBinder` реализацию, удаленная служба `IBinder` вернет инкапсулированный, но `Messenger` созданный в предыдущем разделе.

```csharp
public override IBinder OnBind(Intent intent)
{
    Log.Debug(TAG, "OnBind");
    return messenger.Binder;
}
```

После выполнения этих трех шагов удаленную службу можно считать завершенной.

## <a name="consuming-the-service"></a>Использование службы

Все клиенты должны реализовать некоторый код, чтобы иметь возможность привязать и использовать удаленную службу. По сути, с точки зрения клиента существует очень мало различий между привязками к локальной службе или удаленной службе. Клиент вызывает `BindService` метод, передавая явную цель для указания службы `IServiceConnection` и которая помогает управлять соединением между клиентом и службой.

Этот фрагмент кода является примером того, как создать **явную цель** для привязки к удаленной службе. Цель должна обозначать пакет, содержащий службу, и имя службы. Один из способов задать эту информацию — использовать `Android.Content.ComponentName` объект и предоставить его намерению. Этот фрагмент кода является одним из примеров:  

```csharp
// This is the package name of the APK, set in the Android manifest
const string REMOTE_SERVICE_COMPONENT_NAME = "com.xamarin.TimestampService";
// This is the name of the service, according the value of ServiceAttribute.Name
const string REMOTE_SERVICE_PACKAGE_NAME   = "com.xamarin.xample.messengerservice";

// Provide the package name and the name of the service with a ComponentName object.
ComponentName cn = new ComponentName(REMOTE_SERVICE_PACKAGE_NAME, REMOTE_SERVICE_COMPONENT_NAME);
Intent serviceToStart = new Intent();
serviceToStart.SetComponent(cn);
```

При привязке `IServiceConnection.OnServiceConnected` службы вызывается метод, который `IBinder` предоставляет клиенту. Однако клиент не будет напрямую использовать `IBinder`. Вместо этого будет создан экземпляр `Messenger` объекта. `IBinder` Это то `Messenger` , что клиент будет использовать для взаимодействия с удаленной службой.

Ниже приведен пример очень простой `IServiceConnection` реализации, которая демонстрирует, как клиент может управлять подключением к службе и отключаться от нее. Обратите внимание `OnServiceConnected` , что метод `IBinder`получает и, `Messenger` а клиент создает из этого `IBinder`:

```csharp
public class TimestampServiceConnection : Java.Lang.Object, IServiceConnection
{
    static readonly string TAG = typeof(TimestampServiceConnection).FullName;

    MainActivity mainActivity;
    Messenger messenger;

    public TimestampServiceConnection(MainActivity activity)
    {
        IsConnected = false;
        mainActivity = activity;
    }

    public bool IsConnected { get; private set; }
    public Messenger Messenger { get; private set; }

    public void OnServiceConnected(ComponentName name, IBinder service)
    {
        Log.Debug(TAG, $"OnServiceConnected {name.ClassName}");

        IsConnected = service != null
        Messenger = new Messenger(service);

        if (IsConnected)
        {
            // things to do when the connection is successful. perhaps notify the client? enable UI features?
        }
        else
        {
            // things to do when the connection isn't successful.
        }
    }

    public void OnServiceDisconnected(ComponentName name)
    {
        Log.Debug(TAG, $"OnServiceDisconnected {name.ClassName}");
        IsConnected = false;
        Messenger = null;

        // Things to do when the service disconnects. perhaps notify the client? disable UI features?

    }
}
```

После создания подключения службы и намерений клиент может вызвать `BindService` и инициировать процесс привязки:

```csharp
IServiceConnection serviceConnection = new TimestampServiceConnection(this);
BindActivity(serviceToStart, serviceConnection, Bind.AutoCreate);
```

После того как клиент успешно привязан к службе и `Messenger` доступен, клиент может отправить `Messages` в службу.

## <a name="sending-messages-to-the-service"></a>Отправка сообщений в службу

После подключения клиента и `Messenger` объекта он может взаимодействовать со службой путем `Message` отправки объектов через `Messenger`. Такое взаимодействие является односторонним, клиент отправляет сообщение, но ответ от службы не возвращается клиенту. В этом отношении `Message` — это механизм пожара и-забыть.

Предпочтительным способом создания `Message` объекта является [`Message.Obtain`](xref:Android.OS.Message) использование метода Factory. Этот метод выберет `Message` объект из глобального пула, поддерживаемого Android. `Message.Obtain`также содержит некоторые перегруженные методы, позволяющие `Message` инициализировать объект значениями и параметрами, необходимыми для службы.  После создания экземпляра он отправляется в службу путем вызова `Messenger.Send`. `Message` Этот фрагмент кода является одним из примеров создания и диспетчеризации `Message` процесса службы:

```csharp
Message msg = Message.Obtain(null, Constants.SAY_HELLO_TO_TIMESTAMP_SERVICE);
try
{
    serviceConnection.Messenger.Send(msg);
}
catch (RemoteException ex)
{
    Log.Error(TAG, ex, "There was a error trying to send the message.");
}
```

Существует несколько различных форм `Message.Obtain` метода. В предыдущем примере используется [`Message.Obtain(Handler h, Int32 what)`](xref:Android.OS.Message.Obtain). Так как это асинхронный запрос к службе вне процесса; Служба не будет отвечать на запрос, поэтому для `Handler` `null`параметра задается значение. Второй параметр, `Int32 what`, будет храниться `.What` в свойстве `Message` объекта. `.What` Свойство используется кодом в процессе службы для вызова методов службы.

Класс также предоставляет два дополнительных свойства, которые могут использоваться для получателя: `Arg1` и `Arg2`. `Message` Эти два свойства представляют собой целочисленные значения, которые могут иметь некоторые специальные согласованные значения, имеющие смысл между клиентом и службой. Например, `Arg1` может содержать идентификатор клиента и `Arg2` может содержать номер заказа на покупку для этого клиента. Можно использовать для задания двух свойств `Message` при создании. [`Method.Obtain(Handler h, Int32 what, Int32 arg1, Int32 arg2)`](xref:Android.OS.Message.Obtain) Другим способом заполнения этих двух значений является установка `.Arg` свойств и `.Arg2` непосредственно на `Message` объекте после его создания.

### <a name="passing-additional-values-to-the-service"></a>Передача дополнительных значений в службу

В службу можно передать более сложные данные с помощью `Bundle`. В этом случае дополнительные значения можно поместить в `Bundle` и отправить вместе с, `Message` установив [ `.Data` свойство Property](xref:Android.OS.Message.Data) перед отправкой.

```csharp
Bundle serviceParameters = new Bundle();
serviceParameters.

var msg = Message.Obtain(null, Constants.SERVICE_TASK_TO_PERFORM);
msg.Data = serviceParameters;

messenger.Send(msg);
```


> [!NOTE]
> Как `Message` правило, не должно иметь полезных данных, превышающих 1 МБ. Ограничение размера может отличаться в зависимости от версии Android и любых изменений, которые поставщик мог внести в свою реализацию проекта Android Open Source (АОСП), который входит в состав устройства.

## <a name="returning-values-from-the-service"></a>Возвращение значений из службы

Архитектура обмена сообщениями, обсуждаемая в этой точке, является односторонней, клиент отправляет сообщение службе. Если необходимо, чтобы служба возвращала значение клиенту, то все, что обсуждалось до этого момента, будет обращено к этому моменту. Служба должна создавать `Message`, упаковывать любые возвращаемые значения и отправлять их `Message` через `Messenger` клиент. Однако служба не создает ее самостоятельно `Messenger`; вместо этого она основывается на создании экземпляра клиента и упаковке в `Messenger` качестве части исходного запроса. Служба будет `Send` использовать сообщение, предоставляемое `Messenger`этим клиентом.  

Ниже приведена последовательность событий для двустороннего обмена данными.

1. Клиент привязывается к службе. Когда служба и клиент подключаются, компонент `IServiceConnection` , обслуживаемый клиентом, будет иметь ссылку `Messenger` на объект, который используется для передачи `Message`s в службу. Чтобы избежать путаницы, это будет называться _Service Messenger_.
2. Клиент создает экземпляр `Handler` класса (называемый обработчиком _клиента_) и использует его для инициализации собственного `Messenger` ( _клиента Messenger_). Обратите внимание, что служба Messenger и клиентская программа Messenger — это два разных объекта, которые обрабатывают трафик в двух разных направлениях. Служба Messenger обрабатывает сообщения от клиента службе, тогда как клиентская программа Messenger будет обрабатывать сообщения от службы клиенту.
3. Клиент создает `Message` объект и `ReplyTo` задает свойство для клиента Messenger. Затем сообщение отправляется в службу с помощью службы Messenger Service.
4. Служба получает сообщение от клиента и выполняет запрошенную работу.
5. Когда служба отправит ответ клиенту, она будет использовать `Message.Obtain` для создания нового `Message` объекта.
6. Чтобы отправить это сообщение клиенту, Служба извлечет клиентскую программу Messenger из `.ReplyTo` свойства клиентского сообщения и будет использовать его `Message` для `.Send` возврата клиенту.
7. Когда клиент получает ответ, он имеет свой `Handler` собственный, который обработает объект `Message` , проверив `.What` свойство (и при необходимости извлекая все параметры, содержащиеся в `Message`).

В этом примере кода показано `Message` `Messenger` , как клиент будет создавать экземпляр и пакет а, который служба должна использовать для своего ответа:

```csharp
Handler clientHandler = new ActivityHandler();
Messenger clientMessenger = new Messenger(activityHandler);

Message msg = Message.Obtain(null, Constants.GET_UTC_TIMESTAMP);
msg.ReplyTo = clientMessenger;

try
{
    serviceConnection.Messenger.Send(msg);
}
catch (RemoteException ex)
{
    Log.Error(TAG, ex, "There was a problem sending the message.");
}
```

Служба должна внести некоторые изменения `Handler` , чтобы извлечь объект `Messenger` и использовать его для отправки ответов клиенту. Этот фрагмент кода является примером того, как служба `Handler` `Message` создает и отправляет ее обратно клиенту:  

```csharp
// This is the message that the service will send to the client.
Message responseMessage = Message.Obtain(null, Constants.RESPONSE_TO_SERVICE);
Bundle dataToReturn = new Bundle();
dataToReturn.PutString(Constants.RESPONSE_MESSAGE_KEY, "This is the result from the service.");
responseMessage.Data = dataToReturn;

// The msg object here is the message that was received by the service. The service will not instantiate a client,
// It will use the client that is encapsulated by the message from the client.
Messenger clientMessenger = msg.ReplyTo;
if (clientMessenger!= null)
{
    try
    {
        clientMessenger.Send(responseMessage);
    }
    catch (Exception ex)
    {
        Log.Error(TAG, ex, "There was a problem sending the message.");
    }
}
```

Обратите внимание, что в приведенных выше `Messenger` примерах кода экземпляр, созданный клиентом, *не* совпадает с объектом, полученным службой. Это два разных `Messenger` объекта, работающих в двух отдельных процессах, представляющих канал связи.

## <a name="securing-the-service-with-android-permissions"></a>Защита службы с помощью разрешений Android

Служба, которая выполняется в глобальном процессе, доступна для всех приложений, запущенных на этом устройстве Android. В некоторых ситуациях это открытость и доступность нежелательна, поэтому необходимо защитить службу от несанкционированного доступа от неавторизованных клиентов. Одним из способов ограничения доступа к удаленной службе является использование разрешений Android.

Разрешения могут `Permission` определяться свойством `ServiceAttribute` объекта, который `Service` добавляет подкласс. Это имя будет иметь разрешение, которое должен предоставить клиент при привязке к службе. Если у клиента нет соответствующих разрешений, то Android выдаст исключение, `Java.Lang.SecurityException` когда клиент попытается выполнить привязку к службе.

Android предоставляет четыре различных уровня разрешений:

- **Обычная задача** &ndash; Это уровень разрешений по умолчанию. Он используется для обнаружения разрешений низкого риска, которые могут быть автоматически предоставлены Android клиентам, запрашивающим его. Пользователь не должен явно предоставлять эти разрешения, но разрешения можно просмотреть в параметрах приложения.
- **сигнатура** &ndash; Это особая категория разрешений, которая будет автоматически предоставляться Android для приложений, подписанных одним и тем же сертификатом. Это разрешение предназначено для того, чтобы разработчики приложений могли совместно использовать компоненты или данные в своих приложениях, не требуя от пользователя постоянного утверждения.
- **сигнатуреорсистем** Это очень похоже на разрешения подписи, описанные выше. &ndash; Кроме автоматического предоставления приложениям, подписанным одним и тем же сертификатом, это разрешение также будет предоставляться для приложений, которые подписаны тем же сертификатом, который использовался для подписания приложений, установленных с помощью образа системы Android. Это разрешение обычно используется разработчиками Android ROM, чтобы позволить приложениям работать с приложениями сторонних производителей. Она обычно не используется приложениями, которые предназначены для общего распространения в целом.
- **опасно** &ndash; Небезопасными разрешениями являются те, которые могут вызвать проблемы для пользователя. По этой причине пользователь должен явно утверждать **опасные** разрешения.

Поскольку `signature`при установке Android разрешения автоматически предоставляются в ходе установки, крайне важно, чтобы apk размещения службы устанавливался до APK, содержащего клиент `normal` . Если клиент установлен первым, Android не предоставит разрешения. В этом случае потребуется удалить клиент APK, установить службу APK, а затем повторно установить клиент APK.

Существует два распространенных способа защитить службу с помощью разрешений Android.

1. **Реализация безопасности на уровне подписи** &ndash; Безопасность на уровне подписи означает, что этим приложениям автоматически предоставляются разрешения, подписанные с помощью того же ключа, который использовался для подписывания APK, содержащего службу. Это простой способ защитить службу, чтобы обеспечить их доступность из собственных приложений. Разрешения уровня подписи объявляются путем присвоения `Permission` свойству `signature`значения `ServiceAttribute` :

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process="com.xamarin.TimestampService.timestampservice_process",
             Permission="signature")]
    public class TimestampService : Service
    {
    }
    ```

2. **Создание настраиваемого разрешения** &ndash; Разработчик службы может создать пользовательское разрешение для службы. Это лучше, когда разработчик хочет поделиться своей службой с приложениями других разработчиков. Пользовательское разрешение требует немного больше усилий для реализации и будет рассмотрено ниже.

Упрощенный пример создания пользовательского `normal` разрешения будет описан в следующем разделе. Дополнительные сведения о разрешениях Android см. в документации Google, где приведены [рекомендации по обеспечению безопасности &](https://developer.android.com/training/articles/security-tips.html). Дополнительные сведения о разрешениях Android см. в [разделе "разрешения](https://developer.android.com/guide/topics/manifest/manifest-intro.html#perms) " документации Android, посвященной манифесту приложения, для получения дополнительных сведений о разрешениях Android.

> [!NOTE]
> Как правило, [компания Google не рекомендует использовать пользовательские разрешения](https://developer.android.com/training/articles/security-tips.html#RequestingPermissions) , так как они могут сбить с толку пользователей.

### <a name="creating-a-custom-permission"></a>Создание пользовательского разрешения

Чтобы использовать пользовательское разрешение, оно объявляется службой, а клиент явным образом запрашивает это разрешение.

Чтобы создать разрешение в службе APK, `permission` элемент добавляется `manifest` в элемент в **AndroidManifest. XML**. Для `name`этого разрешения должны быть заданы атрибуты `label` , `protectionLevel`и. `name` Атрибуту должно быть присвоено строковое значение, однозначно идентифицирующее разрешение. Имя будет отображаться в представлении **сведений о приложении** в **параметрах Android** (как показано в следующем разделе).

`protectionLevel` Атрибуту должно быть присвоено одно из четырех строковых значений, описанных выше.  Объект `label` и`description` должен ссылаться на строковые ресурсы и используются для предоставления пользователю понятного имени и описания.

Этот фрагмент кода представляет собой пример объявления настраиваемого `permission` атрибута в **AndroidManifest. XML** для APK, который содержит службу:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="1"
          android:versionName="1.0"
          package="com.xamarin.xample.messengerservice">

    <uses-sdk android:minSdkVersion="21" />

    <permission android:name="com.xamarin.xample.messengerservice.REQUEST_TIMESTAMP"
                android:protectionLevel="signature"
                android:label="@string/permission_label"
                android:description="@string/permission_description"
                />

    <application android:allowBackup="true"
            android:icon="@mipmap/icon"
            android:label="@string/app_name"
            android:theme="@style/AppTheme">

    </application>
</manifest>
```

Затем **AndroidManifest. XML** клиента apk должен явно запрашивать это новое разрешение. Это можно сделать, добавив `users-permission` атрибут в **AndroidManifest. XML**:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="1"
          android:versionName="1.0"
          package="com.xamarin.xample.messengerclient">

    <uses-sdk android:minSdkVersion="21" />

    <uses-permission android:name="com.xamarin.xample.messengerservice.REQUEST_TIMESTAMP" />

    <application
            android:allowBackup="true"
            android:icon="@mipmap/icon"
            android:label="@string/app_name"
            android:theme="@style/AppTheme">
    </application>
    </manifest>
```

### <a name="view-the-permissions-granted-to-an-app"></a>Просмотр разрешений, предоставленных приложению

Чтобы просмотреть разрешения, предоставленные приложению, откройте приложение параметры Android и выберите **приложения**. Найдите и выберите приложение в списке. На экране **сведения о приложении** выберите **разрешения** , которые будут отображать все разрешения, предоставленные приложению:

[![Снимки экрана с устройства Android, показывающие, как найти разрешения, предоставленные приложению](out-of-process-services-images/ipc-06-sml.png)](out-of-process-services-images/ipc-06.png#lightbox)

## <a name="summary"></a>Сводка

Это руководство было расширено обсуждением запуска службы Android в удаленном процессе. Были описаны различия между локальной и удаленной службами, а также некоторые причины, по которым удаленная служба может быть полезной для стабильности и производительности приложения Android. После того как вы узнаете, как реализовать удаленную службу и как клиент может обмениваться данными со службой, руководство помогла предоставить один из способов ограничить доступ к службе только проверенными клиентами.


## <a name="related-links"></a>Связанные ссылки

- [Обработке](xref:Android.OS.Handler)
- [Сообщение](xref:Android.OS.Message)
- [Messenger](xref:Android.OS.Messenger)
- [сервицеаттрибуте](xref:Android.App.ServiceAttribute)
- [Экспортированный атрибут](https://developer.android.com/guide/topics/manifest/service-element.html#exported)
- [Службы с изолированными процессами и классом пользовательского приложения не могут правильно разрешать перегрузки](https://bugzilla.xamarin.com/show_bug.cgi?id=51940)
- [Процессы и потоки](https://developer.android.com/guide/components/processes-and-threads.html)
- [Манифест Android — разрешения](https://developer.android.com/guide/topics/manifest/manifest-intro.html#perms)
- [Советы по безопасности](https://developer.android.com/training/articles/security-tips.html)
- [Мессенжерсервицедемо (пример)](https://docs.microsoft.com/samples/xamarin/monodroid-samples/applicationfundamentals-servicesamples-messengerservicedemo)
