---
title: Жизненный цикл действия
description: Действия — основной строительный блок приложений Android, и они могут присутствовать в нескольких состояниях. Жизненный цикл действия начинается с создания экземпляра и заканчивается уничтожения между включает много состояний. При изменении состояния действия вызывается метод события жизненного цикла соответствующие, уведомив действия внесение изменений состояния и что позволяет выполнять код для адаптации к внесения данного изменения. В этой статье рассматриваются жизненного цикла действия и объясняется ответственность за наличие действия во время каждой из этих изменений в состав обретают, надежные приложения.
ms.prod: xamarin
ms.assetid: 05B34788-F2D2-4347-B66B-40AFD7B1D167
ms.technology: xamarin-android
author: mgmclemore
ms.author: mamcle
ms.date: 02/28/2018
ms.openlocfilehash: f35f3e59d8b669795ade3d370894e45866cea1ff
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/04/2018
---
# <a name="activity-lifecycle"></a>Жизненный цикл действия

_Действия — основной строительный блок приложений Android, и они могут присутствовать в нескольких состояниях. Жизненный цикл действия начинается с создания экземпляра и заканчивается уничтожения между включает много состояний. При изменении состояния действия вызывается метод события жизненного цикла соответствующие, уведомив действия внесение изменений состояния и что позволяет выполнять код для адаптации к внесения данного изменения. В этой статье рассматриваются жизненного цикла действия и объясняется ответственность за наличие действия во время каждой из этих изменений в состав обретают, надежные приложения._

## <a name="activity-lifecycle-overview"></a>Обзор жизненного цикла действия

Действия, необычные концепцию программирования для Android. В традиционных приложений для разработки обычно имеется статический основной метод, который выполняется для запуска приложения. С Android Однако все по-другому; Приложения Android может быть вызвано из любого зарегистрированного действия в приложении. На практике большинство приложений имеют только определенное действие, которое задается как точку входа приложения. Однако, если приложение аварийно завершает работу, или завершается с ОС, ОС может попытаться перезапустить приложение на открытие последнего действия или в любом месте стеке предыдущего действия.
Кроме того ОС может приостановки действий, когда они не active и их восстановления в случае нехватки памяти. Разрешить приложению правильно восстановить свое состояние в случае, если действие перезапуска, особенно в том случае, если, зависит от данных из предыдущего действия должны выполняться тщательного анализа последствий.

Жизненный цикл действия реализуется как коллекция вызовов методов операционной системы на протяжении жизненного цикла действия. Эти методы позволяют разработчикам использовать функциональные возможности, необходимые для удовлетворения требований управления состояния и ресурсов приложений.

Очень важно для разработчиков приложений для анализа требования каждого действия, чтобы определить, какие методы, предоставляемые жизненный цикл действия, необходимо. Если этого не сделать, это может привести к нестабильной работе приложения, сбои, Раздувание ресурсов и нестабильности возможно даже базовой операционной системы.

В этой главе рассматриваются в жизненный цикл действия детализации, включая:

-  Состояния действия
-  Методы жизненного цикла
-  Сохранение состояния приложения


Этот раздел также содержит [Пошаговое руководство](~/android/app-fundamentals/activity-lifecycle/saving-state.md) о том, как эффективно сохранять состояние в течение жизненного цикла действия, обеспечивающие практические примеры. В конце данной главы необходимо понимание жизненного цикла действия и как поддерживать его в приложение.

## <a name="activity-lifecycle"></a>Жизненный цикл действия

Жизненный цикл Android действия охватывает набор методов, предоставляемых в пределах класса действия, которые предоставляют разработчику архитектура управления ресурсами. Эта платформа позволяет разработчикам требованиям управления уникальное состояние каждого действия в приложении и правильно обрабатывать управление ресурсами.

### <a name="activity-states"></a>Состояния действия

Для ОС Android управляет действий в зависимости от их состояния. Это помогает Android выявления действий, которые больше не используются, позволяя операционной системы для освобождения памяти и ресурсов. На следующей схеме показана состояния, которые можно выполнить во время существования действия:

[![Схема состояния активности](images/image1-sml.png)](images/image1.png#lightbox)

Эти состояния можно разбить на 4 группы следующим образом:

1.  *Активный или не запущены* &ndash; действия рассматриваемые активный или выполнения, если они находятся в активном режиме, также известный как верхнюю часть стека действия. Это считается наивысший приоритет действия в Android и таким образом будет только завершен в чрезвычайных ситуациях Операционной системой, такие как если бы действие пытается использовать больше памяти, чем доступно на устройстве как это может привести к пользовательского интерфейса, чтобы перестать отвечать на запросы.

1.  *Приостановлено* &ndash; устройство переходит в спящий режим или его действия по-прежнему отображается, но частично скрыты действием новых, отличных от полноразмерные или прозрачным, считается действие приостановлено. Действия приостановлена, все еще существует, то есть они обеспечивают все состояния и сведения о члене и остается прикрепленным к диспетчера окон. Это рассматривается как второй наивысший приоритет действия в Android и, таким образом, будет завершен Операционной системой, только если завершение этого действия будет удовлетворять требования к ресурсам, необходимую для ведения активный/выполняется действие стабильными и отвечать на запросы.

1.  *Остановить Backgrounded* &ndash; действия, которые полностью скрывается другим действием, считаются остановлена или находится в фоновом режиме.
    Остановлена действий попробовать сохранить их состояние и сведения о члене для при условии, что возможен, но остановленное действий считаются самый низкий приоритет из трех состояний, и, таким образом, операционная система будет завершать действия в этом состоянии, во-первых, для удовлетворения ресурса требования к более высоким приоритетом действий.

1.  *Перезапустить* &ndash; это возможно, для действия, находящегося в любом из приостановлена до остановки в жизненном цикле удаляется из памяти системой Android. Если пользователь переходит к операции, к которой он должен быть перезапущен, восстановлен в ранее сохраненное состояние и затем отображаются для пользователя.


### <a name="activity-re-creation-in-response-to-configuration-changes"></a>Повторное создание действия в ответ на изменения конфигурации

Чтобы сделать более сложный: вопросы и ответы, Android создает один дополнительные гаечного ключа в наборе, вызывается изменения конфигурации. Изменения конфигурации, быстрое действие удаления или повторно-creation циклов, которые возникают при изменении конфигурации действия, например, если устройство [повернутый](~/android/app-fundamentals/handling-rotation.md) (и действие должно быть повторно создан в горизонтальной или вертикальной режим), если отображается клавиатуры (и действия предоставляется возможность изменять размер), или при помещении устройства в закрепления, среди прочего.

Изменения конфигурации по-прежнему вызывать изменений состояния действия, может произойти во время остановки и перезапуска действие. Тем не менее чтобы убедиться в том, что приложение, в том числе отвечать на запросы и выполняет также во время изменения конфигурации, очень важно, они обрабатываться как можно быстрее. По этой причине Android имеет определенный интерфейс API, который может использоваться для сохранения состояния во время изменения конфигурации.
Мы рассмотрим это более поздней версии в [управление состоянием на протяжении жизненного цикла](~/android/app-fundamentals/activity-lifecycle/index.md#Managing_State_Throughout_the_Lifecycle) раздела.

### <a name="activity-lifecycle-methods"></a>Методы жизненного цикла действия

Android SDK и по мере расширения Xamarin.Android framework предоставляют мощные модель управления состоянием действий в приложении. При изменении состояния действия, действие получает уведомление от операционной системы, который вызывает методы, определенные для этого действия. На следующей схеме показана этих методов по отношению к жизненный цикл действия:

[![Блок-схема жизненного цикла действия](images/image2-sml.png)](images/image2.png#lightbox)

Разработчик может обрабатывать изменения состояния путем переопределения этих методов в рамках действия. Важно отметить, что все методы жизненного цикла вызываются в потоке пользовательского интерфейса и заблокирует операционной системы с выполнением следующая часть работы пользовательского интерфейса, например скрытие текущей активности отображение нового действия, и т. д. Таким образом код в этих методах должен быть кратким может затруднить чувствовать себя хорошо работает приложение. Любой длительно выполняемых задач должна выполняться в фоновом потоке.

Давайте рассмотрим каждый из этих методов жизненного цикла и их использование.

#### <a name="oncreate"></a>OnCreate

[OnCreate](https://developer.xamarin.com/api/member/Android.App.Activity.OnCreate/p/Android.OS.Bundle/) первый метод, вызываемый при создании действия.
`OnCreate` всегда переопределяется для инициализаций запуска, таких как необходимые действия:

-  Создание представлений
-  Инициализация переменных
-  Привязка статических данных в списки


`OnCreate` принимает [пакета](https://developer.xamarin.com/api/type/Android.OS.Bundle/) параметр, который представляет собой словарь для хранения и передачи информации о состоянии и объектов между действиями, если пакет не равно null, это указывает перезапуск действия и его следует восстановить свое состояние из предыдущий экземпляр. Ниже показан способ получения значений из пакета.

```csharp
protected override void OnCreate(Bundle bundle)
{
   base.OnCreate(bundle);

   string intentString;
   bool intentBool;

   if (bundle != null)
   {
      intentString = bundle.GetString("myString");
      intentBool = bundle.GetBoolean("myBool");
   }

   // Set our view from the "main" layout resource
   SetContentView(Resource.Layout.Main);
}
```

Один раз `OnCreate` содержит вызов по завершении Android `OnStart`.

#### <a name="onstart"></a>Метод OnStart

[OnStart](https://developer.xamarin.com/api/member/Android.App.Activity.OnStart/) всегда вызывается системой после `OnCreate` завершения работы. Действия могут переопределить этот метод, при необходимости выполнения конкретных задач права, перед действия становится видимой, такие как обновление текущие значения представлений в рамках действия. Android вызовет `OnResume` сразу же после этого метода.

#### <a name="onresume"></a>OnResume

Системные вызовы [OnResume](https://developer.xamarin.com/api/member/Android.App.Activity.OnResume/) при действия готова начать взаимодействие с пользователем.
Действия должны переопределить этот метод для выполнения задач, таких как:

-  Увеличивать частоты кадров (Общие задачи в здании игры)
-  Запуск анимации
-  Ожидание обновления GPS
-  Отображаются соответствующие оповещения и диалоговые окна
-  Связывать обработчики внешних событий


Например в следующем фрагменте кода показано, как инициализировать камеры:

```csharp
public void OnResume()
{
    base.OnResume(); // Always call the superclass first.

    if (_camera==null)
    {
        // Do camera initializations here
    }
}
```

`OnResume` Важно, так как любая операция, которая является в `OnPause` должно быть не завершено в `OnResume`, поскольку он является единственным способом жизненный цикл, который выполняется после `OnPause` при внедрении действия жизни.

#### <a name="onpause"></a>OnPause

[OnPause](https://developer.xamarin.com/api/member/Android.App.Activity.OnPause/) вызывается, когда система пытается поместить действие в фоновом режиме или в случаях, когда действие становится частично закрыт. При необходимости этот метод необходимо переопределить действия:

-   Зафиксировать несохраненные изменения в постоянных данных

-   Удалить или очистить другие объекты, на использование ресурсов

-   Собственный частоты кадров и приостановка анимации

-   Отменить регистрацию обработчиков внешнего события и обработчики для уведомляющих (т. е. те, которые привязаны к службе). Это необходимо сделать для предотвращения утечек памяти действия.

-   Аналогично, если действие отображается, никакие диалоговые окна или предупреждения, они должны удаляться с `.Dismiss()` метод.

Например, в следующем фрагменте кода будет освобождать камеры, как действие не может использовать его во время паузы:

```csharp
public void OnPause()
{
    base.OnPause(); // Always call the superclass first

    // Release the camera as other activities might need it
    if (_camera != null)
    {
        _camera.Release();
        _camera = null;
    }
}
```

Существует два метода возможных жизненного цикла, которые будут вызываться после `OnPause`:

1.  `OnResume` будет вызван, если действие выполняется в ответ на переднем плане.
1.  `OnStop` будет вызываться, если действие помещается в фоновом режиме.


#### <a name="onstop"></a>OnStop

[OnStop](https://developer.xamarin.com/api/member/Android.App.Activity.OnStop/) вызывается, когда действие больше не отображается для пользователя. Это происходит, когда происходит одно из следующих:

-  Новое действие запускается и закрывающий это действие.
-  Существующее действие переводится на переднем плане.
-  Действие уничтожается.


`OnStop` всегда нельзя вызывать в ситуациях нехватки памяти, например при Android является испытывает существенной нехватки ресурсов и правильно фоновые действия. По этой причине не следует полагаться на `OnStop` вызван при подготовке действия для удаления. Далее методов жизненного цикла, которые могут быть вызваны после этого будет `OnDestroy` Если действия выходит из употребления, или `OnRestart` Если действия возвращается для взаимодействия с пользователем.

#### <a name="ondestroy"></a>OnDestroy

[OnDestroy](https://developer.xamarin.com/api/member/Android.App.Activity.OnDestroy/) — окончательный метод, который вызывается для экземпляра действия, прежде чем оно удаляется и полностью удаляется из памяти. В чрезвычайных ситуациях Android может завершить процесс приложения, на котором размещается действия, что приведет к `OnDestroy` не вызывается. Большинство действий не будет реализовывать этот метод, так как большинство Очистка и завершение работы были проведены `OnPause` и `OnStop` методы. `OnDestroy` Метод обычно переопределяется для очистки долго выполнении ресурсы, которые могут допускать утечку ресурсов. Примером этого может быть фоновых потоках, которые были запущены в `OnCreate`.

Будет существовать не вызывается после уничтожения действие методов жизненного цикла.

#### <a name="onrestart"></a>OnRestart

[OnRestart](https://developer.xamarin.com/api/member/Android.App.Activity.OnRestart/) вызывается после действие было остановлено, то перед его снова запустить. Хорошим примером будет при нажатии кнопки Домой на действия в приложении. В этом случае `OnPause` и затем `OnStop` методы вызываются, и действия, перемещаются в фоновом режиме, но не удаляются. Если пользователь были, то для восстановления приложения с помощью диспетчера задач или похожее приложение, вызовет Android `OnRestart` метод действия.

Существует общих принципов вида логики должен быть реализован в `OnRestart`. Это вызвано `OnStart` всегда вызывается независимо от того, создается ли действие или перезапустить, чтобы все ресурсы, необходимые для действия, которые должны быть инициализированы в `OnStart`, а не `OnRestart`.

Вызывается после метода next жизненного цикла `OnRestart` будет `OnStart`.

### <a name="back-vs-home"></a>Создайте резервную vs. Главная страница

Многие устройства Android не предусматривают две отдельных кнопки: кнопка «Назад» и кнопка «Главная». Пример этого можно увидеть на следующем снимке экрана Android 4.0.3:

[![Кнопки домашней назад и](images/image4-sml.png)](images/image4.png#lightbox)

Имеется небольшое различие между двумя кнопками, даже если они присутствуют действовала перевода приложения в фоновом режиме. Когда пользователь нажимает кнопку "Назад", они говорят Android, они выполняются с действием. Android приведет к удалению действия. Напротив, при нажатии кнопки «Домой» действия просто помещается в фоновом режиме &ndash; Android будет завершать действия.

<a name="Managing_State_Throughout_the_Lifecycle" />

## <a name="managing-state-throughout-the-lifecycle"></a>Управление состоянием на протяжении жизненного цикла

При остановлена или уничтожения действия система предоставляет возможность сохранения состояния действия, необходимости в более поздней версии.
Это сохраненное состояние называется состояние экземпляра. Android обеспечивает три варианта для хранения состояния экземпляра в течение жизненного цикла действия.

1. Хранение простые значения в `Dictionary` называется [пакета](https://developer.xamarin.com/api/type/Android.OS.Bundle/) , Android будет использоваться для сохранения состояния.

1. Создание пользовательского класса, который будет содержать сложных значений, таких как растровые изображения. Android будет использовать этот настраиваемый класс для сохранения состояния.

1. Обход жизненного цикла изменений конфигурации и при условии, что выполнено ответственность за сохранение состояния в действие.


В настоящем руководстве описывается первые два варианта.



### <a name="bundle-state"></a>Состояние пакета

Основной параметр для сохранения состояния экземпляра — использовать объект словарь ключей и значений, известный как [пакета](https://developer.xamarin.com/api/type/Android.OS.Bundle/).
Помните, что если создать действие, `OnCreate` методу передается как параметр пакета, этот пакет можно использовать для восстановления данных о состоянии экземпляра. Не рекомендуется использовать пакет для более сложных данных, которые не быстро и легко выполнить сериализацию в ключ значение пары (например, к точечным рисункам); Вместо этого он должен использоваться для простого значения, такие как строки.

Действие предоставляет методы для сохранения и получения состояния экземпляра в пакет:

-   [OnSaveInstanceState](https://developer.xamarin.com/api/member/Android.App.Activity.OnSaveInstanceState/p/Android.OS.Bundle/) &ndash; вызывается с Android при уничтожении действия. Действия можно реализовать этот метод при необходимости сохранить любые элементы состояния ключ значение.

-   [OnRestoreInstanceState](https://developer.xamarin.com/api/member/Android.App.Activity.OnRestoreInstanceState/p/Android.OS.Bundle/) &ndash; это вызывается после `OnCreate` метод завершения работы и предоставляет другой возможности для действия восстановить свое состояние после завершения инициализации.

На следующей схеме показана, как используются эти методы:

[![Блок-схема состояния пакета](images/image3-sml.png)](images/image3.png#lightbox)

#### <a name="onsaveinstancestate"></a>OnSaveInstanceState

[OnSaveInstanceState](https://developer.xamarin.com/api/member/Android.App.Activity.OnSaveInstanceState/p/Android.OS.Bundle/) будет вызываться, как действия был остановлен. Он будет получать, действия можно хранить в состояние параметра пакета. При изменении конфигурации устройства, можно использовать действие `Bundle` объект, переданный для сохранения состояния действия, переопределив `OnSaveInstanceState`. Рассмотрим следующий пример кода:

```csharp
int c;

protected override void OnCreate (Bundle bundle)
{
  base.OnCreate (bundle);

  this.SetContentView (Resource.Layout.SimpleStateView);

  var output = this.FindViewById<TextView> (Resource.Id.outputText);

  if (bundle != null) {
    c = bundle.GetInt ("counter", -1);
  } else {
    c = -1;
  }

  output.Text = c.ToString ();

  var incrementCounter = this.FindViewById<Button> (Resource.Id.incrementCounter);

  incrementCounter.Click += (s,e) => {
    output.Text = (++c).ToString();
  };
}
```

Приведенный выше код увеличивает целое значение с именем `c` при кнопку с именем `incrementCounter` нажатии отображение результата в `TextView` с именем `output`. Когда происходит изменение конфигурации — например, при повороте устройства — приведенный выше код теряли значение `c` из-за `bundle` бы `null`, как показано на рисунке ниже:

[![Не отображаются предыдущее значение](images/07-sml.png)](images/07.png#lightbox)

Чтобы сохранить значение `c` в этом примере можно переопределить действия `OnSaveInstanceState`, сохранение значения в пакете, как показано ниже:

```csharp
protected override void OnSaveInstanceState (Bundle outState)
{
  outState.PutInt ("counter", c);
  base.OnSaveInstanceState (outState);
}
```

Теперь при повороте устройства для новой ориентации, целочисленное значение сохраняется в пакете и извлекаются с помощью строки:

```csharp
c = bundle.GetInt ("counter", -1);
```

> [!NOTE]
> Это важно всегда вызов базовую реализацию `OnSaveInstanceState` , чтобы состояние иерархии представление также будет сохранен.



##### <a name="view-state"></a>Состояние представления

Переопределение `OnSaveInstanceState` имеет соответствующий механизм для сохранения временных данных в действие через ориентации изменения, такие как счетчика в приведенном выше примере. Однако реализация по умолчанию `OnSaveInstanceState` берет на себя сохранения временных данных в пользовательском Интерфейсе для каждого представления, при условии, что каждое представление имеет идентификатор, назначенный. Например, что приложение имеет `EditText` элемент, определенный в формате XML следующим образом:

```xml
<EditText android:id="@+id/myText"
  android:layout_width="fill_parent"
  android:layout_height="wrap_content"/>
```

Поскольку `EditText` управления имеет `id` назначения, если пользователь вводит некоторые данные при повороте устройства, данные по-прежнему отображаются, как показано ниже:

[![Данные сохраняются в альбомной ориентации](images/08-sml.png)](images/08.png#lightbox)

#### <a name="onrestoreinstancestate"></a>OnRestoreInstanceState

[OnRestoreInstanceState](https://developer.xamarin.com/api/member/Android.App.Activity.OnRestoreInstanceState/p/Android.OS.Bundle/) будет вызываться после `OnStart`. Он предоставляет возможность восстановления любого состояния, который был ранее сохранен пакет во время предыдущего действия `OnSaveInstanceState`. Это же пакете, переданный `OnCreate`, но при этом.

В следующем коде показано, как можно восстановить состояние `OnRestoreInstanceState`:

```csharp
protected override void OnRestoreInstanceState(Bundle savedState)
{
    base.OnRestoreSaveInstanceState(savedState);
    var myString = savedState.GetString("myString");
    var myBool = savedState.GetBoolean("myBool");
}
```

Этот метод используется для обеспечения дополнительных возможностей вокруг, если нужно восстановить состояние. Иногда бывает удобнее подождать, пока все операции инициализации выполняются перед восстановлением состояние экземпляра. Кроме того является подклассом существующее действие может потребоваться восстановить определенные значения из состояния экземпляра. Во многих случаях не требуется переопределять `OnRestoreInstanceState`, поскольку большинство действий можно восстановить состояние с помощью набор, указанный для `OnCreate`.

Например, сохранение состояния с помощью `Bundle`, см. [Пошаговое руководство. Сохранение действия состояния](saving-state.md).


#### <a name="bundle-limitations"></a>Ограничения пакета

Несмотря на то что `OnSaveInstanceState` делает его легко для сохранения временных данных, она имеет некоторые ограничения:

-   Он не вызывается во всех случаях. Например, нажатие клавиши **Главная** или **обратно** для выхода из действие не приводит к `OnSaveInstanceState` вызова.

-   Переданный пакет `OnSaveInstanceState` не предназначена для больших объектов, таких как рисунки. В случае больших объектов, сохранении объекта из [OnRetainNonConfigurationInstance](https://developer.xamarin.com/api/member/Android.App.Activity.OnRetainNonConfigurationInstance/) является предпочтительным, как описано ниже.

-   Данные, сохраненные с помощью пакета сериализуется, что может привести к задержкам.

Состояние пакета полезно для простых данных, который не использует много памяти, в то время как *данные экземпляра не конфигурации* является полезным для более сложных данные или данные, ресурсоемкость извлечения, например в результате вызов веб-службы или сложная запрос базы данных. Данные экземпляра конфигурации не сохраняются в объекте при необходимости. В следующем разделе описывается `OnRetainNonConfigurationInstance` как способ сохранения более сложных типов данных с помощью изменения конфигурации.


### <a name="persisting-complex-data"></a>Сохранение сложных данных.

Помимо сохранения данных в пакет Android также поддерживает сохранение данных путем переопределения [OnRetainNonConfigurationInstance](https://developer.xamarin.com/api/member/Android.App.Activity.OnRetainNonConfigurationInstance/) и возвращение экземпляра `Java.Lang.Object` , содержащий данные для сохранения. Существует два основных преимущества использования `OnRetainNonConfigurationInstance` для сохранения состояния:

-   Объект, возвращенный из `OnRetainNonConfigurationInstance` выполняет также с типами более крупных и сложных данных, так как этот объект сохраняет памяти.

-   `OnRetainNonConfigurationInstance` Метод, вызываемый по требованию и только в том случае, при необходимости. Это более экономично, чем при использовании вручную кэша.

С помощью `OnRetainNonConfigurationInstance` подходит для сценариев, где ресурсоемкость извлечения данных несколько раз, например вызовы веб-службы. Например рассмотрим следующий код, который выполняет Twitter:

```csharp
public class NonConfigInstanceActivity : ListActivity
{
  protected override void OnCreate (Bundle bundle)
  {
    base.OnCreate (bundle);
    SearchTwitter ("xamarin");
  }

  public void SearchTwitter (string text)
  {
    string searchUrl = String.Format("http://search.twitter.com/search.json?" + "q={0}&rpp=10&include_entities=false&" + "result_type=mixed", text);

    var httpReq = (HttpWebRequest)HttpWebRequest.Create (new Uri (searchUrl));
    httpReq.BeginGetResponse (new AsyncCallback (ResponseCallback), httpReq);
  }

  void ResponseCallback (IAsyncResult ar)
  {
    var httpReq = (HttpWebRequest)ar.AsyncState;

    using (var httpRes = (HttpWebResponse)httpReq.EndGetResponse (ar)) {
      ParseResults (httpRes);
    }
  }

  void ParseResults (HttpWebResponse httpRes)
  {
    var s = httpRes.GetResponseStream ();
    var j = (JsonObject)JsonObject.Load (s);

    var results = (from result in (JsonArray)j ["results"] let jResult = result as JsonObject select jResult ["text"].ToString ()).ToArray ();

    RunOnUiThread (() => {
      PopulateTweetList (results);
    });
  }

  void PopulateTweetList (string[] results)
  {
    ListAdapter = new ArrayAdapter<string> (this, Resource.Layout.ItemView, results);
  }
}
```

Этот код извлекает результаты из Интернета, в формате JSON, анализирует их и возвращает результаты в виде списка, как показано на следующем снимке экрана:

[![Результаты, отображаемые на экране](images/06-sml.png)](images/06.png#lightbox)

Когда происходит изменение конфигурации — например, при повороте устройства - код повторяет этот процесс. Для повторного использования изначально полученные результаты и не вызывают ненужных, избыточных сетевых вызовов, можно использовать `OnRetainNonconfigurationInstance` для сохранения результатов, как показано ниже:

```csharp
public class NonConfigInstanceActivity : ListActivity
{
  TweetListWrapper _savedInstance;

  protected override void OnCreate (Bundle bundle)
  {
    base.OnCreate (bundle);

    var tweetsWrapper = LastNonConfigurationInstance as TweetListWrapper;

    if (tweetsWrapper != null) {
      PopulateTweetList (tweetsWrapper.Tweets);
    } else {
      SearchTwitter ("xamarin");
    }

    public override Java.Lang.Object OnRetainNonConfigurationInstance ()
    {
      base.OnRetainNonConfigurationInstance ();
      return _savedInstance;
    }

    ...

    void PopulateTweetList (string[] results)
    {
      ListAdapter = new ArrayAdapter<string> (this, Resource.Layout.ItemView, results);
      _savedInstance = new TweetListWrapper{Tweets=results};
    }
}
```

Теперь при повороте устройства исходные результаты извлекаются из `LastNonConfiguartionInstance` свойство. В этом примере результаты состоят из `string[]` содержащий твиты. Так как `OnRetainNonConfigurationInstance` требует `Java.Lang.Object` возвращаться `string[]` упаковывается в класс, который наследуется от класса `Java.Lang.Object`, как показано ниже:

```csharp
class TweetListWrapper : Java.Lang.Object
{
  public string[] Tweets { get; set; }
}
```

Например, при попытке использовать `TextView` как объект, возвращенный из `OnRetainNonConfigurationInstance` произойдет утечка действия, как показано в следующем примере кода:

```csharp
TextView _textView;

protected override void OnCreate (Bundle bundle)
{
  base.OnCreate (bundle);

  var tv = LastNonConfigurationInstance as TextViewWrapper;

  if(tv != null) {
    _textView = tv;
    var parent = _textView.Parent as FrameLayout;
    parent.RemoveView(_textView);
  } else {
    _textView = new TextView (this);
    _textView.Text = "This will leak.";
  }

  SetContentView (_textView);
}

public override Java.Lang.Object OnRetainNonConfigurationInstance ()
{
  base.OnRetainNonConfigurationInstance ();
  return _textView;
}
```

В этом разделе мы узнали, как сохранять данные состояния простой с `Bundle`, и сохраняются более сложных типов данных с `OnRetainNonConfigurationInstance`.

## <a name="summary"></a>Сводка

Жизненный цикл Android действия предоставляет мощные платформу для управления состоянием действий в приложении, но она может быть непростой задачей, для понимания и реализации. В этой главе появился различные состояния, которые действия могут проходить через во время существования, а также методов жизненного цикла, связанные с ними. Затем указано рекомендации о том, какого рода логика должна выполняться в каждом из этих методов.


## <a name="related-links"></a>Связанные ссылки

- [Обработка поворота](~/android/app-fundamentals/handling-rotation.md)
- [Действие Android](https://developer.xamarin.com/api/type/Android.App.Activity/)
