---
title: Графика и анимация
description: Android предоставляет обширную и разнообразную платформу для поддержки двухмерной графики и анимации. В этом разделе рассматриваются эти платформы и обсуждаются способы создания пользовательских графиков и анимаций для использования в приложении Xamarin. Android.
ms.prod: xamarin
ms.assetid: 80086318-6FE4-4711-9A71-5C8F8C28C754
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 02/16/2018
ms.openlocfilehash: 1781503d214b959d31223cbe8f55fd6afa0fef44
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73019289"
---
# <a name="android-graphics-and-animation"></a>Графика и анимация Android

_Android предоставляет обширную и разнообразную платформу для поддержки двухмерной графики и анимации. В этом разделе рассматриваются эти платформы и обсуждаются способы создания пользовательских графиков и анимаций для использования в приложении Xamarin. Android._

## <a name="overview"></a>Обзор

Несмотря на то, что работает на устройствах, имеющих ограниченную мощность, самые высокие оценки мобильных приложений часто имеют опыт взаимодействия с пользователем (UX) с высококачественной графикой и анимацией, которые обеспечивают интуитивно понятную и динамическую работу. По мере того, как мобильные приложения получают больше и сложнее, пользователи начали использовать больше и больше приложений.

К счастью, современные мобильные платформы имеют очень мощные платформы для создания сложных анимаций и пользовательских графиков, сохраняя простоту использования. Это позволяет разработчикам добавлять широкие интерактивные возможности с минимальными усилиями.

Платформы API пользовательского интерфейса в Android можно разделить на две категории: графика и анимация.

Графика разбивается на различные подходы для выполнения двухмерной и трехмерной графики. Трехмерная графика доступна через ряд встроенных платформ, таких как OpenGL ES (версия OpenGL для мобильных устройств) и сторонних платформ, таких как «коигру» (кросс-платформенный набор средств, совместимый с XNA Toolkit). Хотя трехмерная графика не выходит за рамки этой статьи, мы рассмотрим встроенные методы двухмерной прорисовки.

Android предоставляет два разных API для создания двухмерной графики. Один из них является декларативным подходом высокого уровня и другим программным ИНТЕРФЕЙСом низкого уровня:

- Графические **ресурсы** &ndash; они используются для создания пользовательских рисунков программным способом или (чаще) путем встраивания инструкций по рисованию в XML-файлы. Графические ресурсы обычно определяются как XML-файлы, которые содержат инструкции или действия для Android, чтобы визуализировать 2D-график. 

- **Canvas** &ndash; это API нижнего уровня, который включает рисование непосредственно на базовом точечном рисунке. Он обеспечивает очень детализированный контроль над отображаемыми сведениями. 

Помимо этих приемов двухмерной графики, Android также предоставляет несколько различных способов создания анимации:

- **Анимационные анимации** &ndash; Android также поддерживают анимацию по кадрам, известную как *нарисованная анимация*. Это самый простой API анимации. Android последовательно загружает и отображает отображаемые ресурсы в последовательности (во многом похоже на мультипликационный рисунок).

- **Просмотр анимации** &ndash; *просмотр анимации* — исходный API анимации в Android и доступны во всех версиях Android. Этот API ограничен тем, что он будет работать только с объектами представления и может выполнять только простые преобразования этих представлений.
    Анимации представления обычно определяются в файлах XML, находящихся в папке `/Resources/anim`.

- **Анимация свойств** &ndash; Android 3,0 представил новый набор API анимации, известный как *анимация свойств*. В этих новых API реализована расширяемая и гибкая система, которая может использоваться для анимации свойств любого объекта, а не только для просмотра объектов. Такая гибкость позволяет инкапсулировать анимацию в отдельные классы, упрощающие совместное использование кода.

Анимации представлений лучше подходят для приложений, которые должны поддерживать старый API-интерфейс до Android 3,0 (API уровня 11). В противном случае приложения должны использовать более новые API анимации свойств по указанным выше причинам.

Все эти платформы являются приемлемыми вариантами, но там, где это возможно, предпочтение следует предоставить анимациям свойств, так как это более гибкий API для работы с. Анимация свойств позволяет инкапсулировать логику анимации в отдельные классы, что упрощает совместное использование кода и упрощает обслуживание кода.

## <a name="accessibility"></a>Accessibility

Графики и анимации помогают сделать приложения Android привлекательными и приятными в использовании; Однако важно помнить, что некоторые взаимодействия выполняются через средств, альтернативные устройства ввода или при помощи масштабирования.
Кроме того, некоторые взаимодействия могут происходить без звуковых возможностей.

Приложения более удобны в таких ситуациях, если они были разработаны с учетом специальных возможностей: предоставление подсказок и помощника по переходу в пользовательском интерфейсе и обеспечение наличия текстового содержимого или описаний для элементов виде рисунков пользовательского интерфейса.

Дополнительные сведения об использовании интерфейсов API специальных возможностей Android см. в [руководстве по специальным возможностям Google](https://developer.android.com/guide/topics/ui/accessibility/) .

## <a name="2d-graphics"></a>2D-графика

Нарисованные ресурсы являются популярным приемом в приложениях Android. Как и в случае с другими ресурсами, рисуемые ресурсы являются декларативными &ndash; они определяются в XML-файлах. Такой подход позволяет четко отделить код от ресурсов. Это может упростить разработку и обслуживание, поскольку нет необходимости изменять код для обновления или изменения графики в приложении Android. Однако в то время как графические ресурсы полезны для многих простых и распространенных графических требований, они не обладают возможностями и контроля над API Canvas.

Другой метод, использующий объект [Canvas](xref:Android.Graphics.Canvas) , очень похож на другие традиционные платформы API, такие как System. Drawing или основной чертеж iOS. Использование объекта Canvas обеспечивает наибольший контроль над созданием двухмерной графики. Он подходит для ситуаций, когда рисуемый ресурс не будет работать или будет трудно работать с. Например, может потребоваться нарисовать настраиваемый элемент управления Slider, внешний вид которого изменится на основе вычислений, связанных со значением ползунка.

Давайте сначала рассмотрим рисуемые ресурсы. Они проще и охватывают самые распространенные пользовательские варианты рисования.

### <a name="drawable-resources"></a>Рисуемые ресурсы

Нарисованные ресурсы определяются в XML-файле в каталоге `/Resources/drawable`. В отличие от внедрения PNG или JPEG, нет необходимости предоставлять зависящие от плотности версии для нарисованных ресурсов.
Во время выполнения приложение Android загрузит эти ресурсы и будет использовать инструкции, содержащиеся в этих XML-файлах, для создания двухмерной графики.
Android определяет несколько различных типов рисуемых ресурсов:

- [Шапедравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#Shape) &ndash; это рисуемый объект, который рисует примитивную геометрическую форму и применяет к этой фигуре ограниченный набор графических эффектов. Они очень полезны для таких задач, как Настройка кнопок или настройка фона Текствиевс. Далее в этой статье мы рассмотрим пример использования `ShapeDrawable`.

- [Стателистдравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#StateList) &ndash; это рисуемый ресурс, который изменит внешний вид в зависимости от состояния мини-приложения или элемента управления. Например, кнопка может изменить внешний вид в зависимости от того, была ли она нажата.

- [Лайердравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#LayerList) &ndash; этот рисуемый ресурс, который будет поверх другого драваблес в стеке. Пример *лайердравабле* показан на следующем снимке экрана:

    ![Пример Лайердравабле](graphics-and-animation-images/image1.png)

- [Транситиондравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#Transition) &ndash; это *лайердравабле* , но с одним отличием. *Транситиондравабле* может анимировать один слой, который отображается поверх другого.

- [Левеллистдравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#LevelList) &ndash; это очень похоже на *стателистдравабле* в том, что он будет отображать изображение на основе определенных условий. Однако, в отличие от *стателистдравабле*, *левеллистдравабле* отображает изображение на основе целочисленного значения. Примером *левеллистдравабле* может быть отображение силы сигнала Wi-Fi. При изменении силы сигнала WiFi отображаемый рисунок изменится соответствующим образом.

- [Скаледравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#Scale)/[клипдравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#Clip) &ndash; как предполагает их названия, эти драваблес предоставляют функции масштабирования и обрезки. *Скаледравабле* будет масштабировать другой рисунок, в то время как *клипдравабле* будет обрезать другой рисунок.

- [Инсетдравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#Inset) &ndash; этот рисунок будет применять инсетс на сторонах другого ресурса, который может быть нарисован. Он используется, если для представления требуется фон, меньший по отношению к фактическим границам представления.

- [БИТМАПДРАВАБЛЕ](https://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap) XML &ndash; этот файл представляет собой набор инструкций в формате XML, которые должны выполняться на фактическом точечном рисунке. Некоторые действия, которые может выполнять Android, — мозаичное смешение, сглаживание и сглаживание. Одно из наиболее распространенных применений заключается в мозаичном заполнении точечного рисунка на фоне макета.

#### <a name="drawable-example"></a>Пример с рисованием

Рассмотрим краткий пример создания 2D-изображения с помощью `ShapeDrawable`. `ShapeDrawable` может определять одну из четырех базовых фигур: прямоугольник, овал, линия и кольцо. Также можно применить основные эффекты, такие как градиент, цвет и размер. Следующий код XML — это `ShapeDrawable`, который можно найти в проекте-компаньоне *аниматионсдемо* (в файле `Resources/drawable/shape_rounded_blue_rect.xml`).
Он определяет прямоугольник с фиолетовым градиентным фоном и скругленными углами:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
<!-- Specify a gradient for the background -->
<gradient android:angle="45"
          android:startColor="#55000066"
          android:centerColor="#00000000"
          android:endColor="#00000000"
          android:centerX="0.75" />

<padding android:left="5dp"
          android:right="5dp"
          android:top="5dp"
          android:bottom="5dp" />

<corners android:topLeftRadius="10dp"
          android:topRightRadius="10dp"
          android:bottomLeftRadius="10dp"
          android:bottomRightRadius="10dp" />
</shape>
```

Мы можем ссылаться на этот рисуемый ресурс декларативно в макете или на другом рисунке, как показано в следующем коде XML:

```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:background="#33000000">
    <TextView android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_centerInParent="true"
              android:background="@drawable/shape_rounded_blue_rect"
              android:text="@string/message_shapedrawable" />
</RelativeLayout>
```

Нарисованные ресурсы можно также применять программно. В следующем фрагменте кода показано, как программным способом задать фон TextView:

```csharp
TextView tv = FindViewById<TextView>(Resource.Id.shapeDrawableTextView);
tv.SetBackgroundResource(Resource.Drawable.shape_rounded_blue_rect);
```

Чтобы увидеть, как это будет выглядеть, запустите проект *аниматионсдемо* и в главном меню выберите фигурный элемент Shape (рисунок). Мы должны увидеть нечто вроде следующего снимка экрана:

![TextView с помощью пользовательского фона, рисуемого с помощью градиента и скругленных углов](graphics-and-animation-images/image1.png)

Дополнительные сведения о XML-элементах и синтаксисе для нарисованных ресурсов см. в [документации Google](https://developer.android.com/guide/topics/resources/drawable-resource.html#Shape).

### <a name="using-the-canvas-drawing-api"></a>Использование API рисования Canvas

Драваблес являются мощными, но имеют свои ограничения. Некоторые вещи невозможны или очень сложны (например, применение фильтра к изображению, которое было получено камерой на устройстве). Было бы очень сложно применить сокращение красных глаз, используя рисуемый ресурс.
Вместо этого API Canvas позволяет приложению иметь очень детализированный контроль для выборочного изменения цветов в определенной части изображения.

Одним из классов, обычно используемых с Canvas, является класс [Paint](xref:Android.Graphics.Paint) . Этот класс содержит сведения о цвете и стиле рисования. Он используется для предоставления таких объектов, как цвет и прозрачность.

API Canvas использует модель по *образцу* для рисования двухмерной графики.
Операции применяются в последовательных слоях поверх других. Каждая операция охватывает некоторую область базового точечного рисунка. Когда область пересекается с ранее закрашенной областью, Новая заливка будет частично или полностью скроет старую. Это аналогично тому, как многие другие API рисования, такие как System. Drawing и основные графические объекты iOS, работают.

Существует два способа получения объекта `Canvas`. Первый способ заключается в определении объекта [Bitmap](xref:Android.Graphics.Bitmap) , а также при создании экземпляра объекта `Canvas` с ним. Например, следующий фрагмент кода создает новый холст с базовым точечным рисунком:

```csharp
Bitmap bitmap = Bitmap.CreateBitmap(100, 100, Bitmap.Config.Argb8888);
Canvas canvas = new Canvas(b);
```

Другим способом получения `Canvas` объекта является метод обратного вызова [OnDraw](xref:Android.Views.View.OnDraw*) , который предоставляет базовый класс [представления](xref:Android.Views.View) . Android вызывает этот метод, когда необходимо, чтобы представление соработало и передавало объект `Canvas` для работы с представлением.

Класс Canvas предоставляет методы для программного предоставления инструкций Draw. Пример:

- [Canvas. дравпаинт](xref:Android.Graphics.Canvas.DrawPaint*) &ndash; заполняет растровое изображение всего холста заданными красками.

- [Canvas. дравпас](xref:Android.Graphics.Canvas.DrawPath*) &ndash; Рисует указанную геометрическую форму с помощью указанной краски.

- [Canvas. DrawText](xref:Android.Graphics.Canvas.DrawText*) &ndash; выводит текст на холсте с заданной цветкой. Текст отображается в расположении `x,y`.

#### <a name="drawing-with-the-canvas-api"></a>Рисование с помощью API Canvas

Рассмотрим пример API Canvas в действии. В следующем фрагменте кода показано, как нарисовать представление:

```csharp
public class MyView : View
{
    protected override void OnDraw(Canvas canvas)
    {
        base.OnDraw(canvas);
        Paint green = new Paint {
            AntiAlias = true,
            Color = Color.Rgb(0x99, 0xcc, 0),
        };
        green.SetStyle(Paint.Style.FillAndStroke);

        Paint red = new Paint {
            AntiAlias = true,
            Color = Color.Rgb(0xff, 0x44, 0x44)
        };
        red.SetStyle(Paint.Style.FillAndStroke);

        float middle = canvas.Width * 0.25f;
        canvas.DrawPaint(red);
        canvas.DrawRect(0, 0, middle, canvas.Height, green);
    }
}
```

В приведенном выше коде сначала создается красная заливка и зеленый объект Paint. Он заполняет содержимое холста красным цветом, а затем указывает холсту нарисовать зеленый прямоугольник размером 25% от ширины холста. Пример можно просмотреть в `AnimationsDemo` проекте, который включен в исходный код для этой статьи. Запустив приложение и выбрав элемент Drawing в главном меню, мы должны выглядеть следующим образом:

![Экран с красной заливкой и зелеными объектами Paint](graphics-and-animation-images/image3.png)

## <a name="animation"></a>Анимация

Пользователи, такие как элементы, которые переходят в свои приложения. Анимация — это отличный способ улучшить взаимодействие с пользователем приложения и помочь ему в его выводе. Лучшими анимациями являются те, которые пользователи не заметят, так как они естественным образом. Android предоставляет следующие три API для анимации:

- **Просмотреть анимацию** &ndash; это исходный API. Эти анимации привязаны к определенному представлению и могут выполнять простые преобразования содержимого представления. В связи с простотой этот API-интерфейс все еще полезен для таких объектов, как анимация альфа, вращение и т. д.

- **Анимация свойств** &ndash; анимации свойств появились в Android 3,0. Они позволяют приложению анимировать практически любую. Анимация свойств может использоваться для изменения любого свойства любого объекта, даже если этот объект не виден на экране.

- При **рисовании анимации** &ndash; этот специальный ресурс, который используется для применения очень простого эффекта анимации к макетам.

Как правило, анимация свойств является предпочтительной системой для использования, так как она является более гибкой и предлагает больше функций.

### <a name="view-animations"></a>Просмотр анимаций

Анимация представлений ограничена представлениями и может выполнять анимацию только по таким значениям, как начальная и конечная точки, размер, поворот и прозрачность.
Эти типы анимации обычно называют *анимациями анимации*. Анимации представлений можно определить двумя способами &ndash; программным способом в коде или с помощью XML-файлов. XML-файлы — это предпочтительный способ объявления анимаций представлений, так как они более удобочитаемы и удобны в обслуживании.

XML-файлы анимации будут храниться в каталоге `/Resources/anim` проекта Xamarin. Android. Этот файл должен иметь один из следующих элементов в качестве корневого элемента:

- `alpha` &ndash; эффект затухания или затухания.

- `rotate` &ndash; анимации вращения.

- `scale` &ndash; анимации изменения размера.

- `translate` &ndash; горизонтальное и (или) вертикальное движение.

- `set` &ndash; контейнер, который может содержать один или несколько других элементов анимации.

По умолчанию все анимации в XML-файле будут применяться одновременно. Чтобы анимация выполнялась последовательно, установите атрибут `android:startOffset` для одного из элементов, определенных выше.

Можно повлиять на скорость изменения анимации с помощью *интерполяции*. Интерполяция делает возможным ускорение, повтор или замедление эффектов анимации. Платформа Android предоставляет несколько предустановленных интерполяций, например (но не ограничиваясь ими):

- `AccelerateInterpolator` / `DecelerateInterpolator` &ndash; эти интерполяции увеличивают или уменьшают скорость изменения в анимации.

- `BounceInterpolator`, &ndash; изменение передается в конце.

- `LinearInterpolator` &ndash; интенсивность изменений является постоянной.

В следующем коде XML показан пример файла анимации, объединяющего некоторые из этих элементов:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android=http://schemas.android.com/apk/res/android
     android:shareInterpolator="false">

    <scale android:interpolator="@android:anim/accelerate_decelerate_interpolator"
           android:fromXScale="1.0"
           android:toXScale="1.4"
           android:fromYScale="1.0"
           android:toYScale="0.6"
           android:pivotX="50%"
           android:pivotY="50%"
           android:fillEnabled="true"
           android:fillAfter="false"
           android:duration="700" />

    <set android:interpolator="@android:anim/accelerate_interpolator">
        <scale android:fromXScale="1.4"
               android:toXScale="0.0"
               android:fromYScale="0.6"
               android:toYScale="0.0"
               android:pivotX="50%"
               android:pivotY="50%"
               android:fillEnabled="true"
               android:fillBefore="false"
               android:fillAfter="true"
               android:startOffset="700"
               android:duration="400" />

        <rotate android:fromDegrees="0"
                android:toDegrees="-45"
                android:toYScale="0.0"
                android:pivotX="50%"
                android:pivotY="50%"
                android:fillEnabled="true"
                android:fillBefore="false"
                android:fillAfter="true"
                android:startOffset="700"
                android:duration="400" />
    </set>
</set>
```

Эта анимация будет выполнять все анимации одновременно. Первая анимация шкалы растягивает изображение по горизонтали и сжимает его вертикально, а затем изображение будет повернуто в 45 градусов по часовой стрелке и уменьшено, после чего на экране появляется экран.

Анимацию можно программно применить к представлению, увеличив анимацию и применив ее к представлению. Android предоставляет вспомогательный класс `Android.Views.Animations.AnimationUtils`, который выполнит неструктурированный ресурс анимации и возвратит экземпляр `Android.Views.Animations.Animation`. Этот объект применяется к представлению путем вызова `StartAnimation` и передачи объекта `Animation`. В следующем фрагменте кода приведен пример.

```csharp
Animation myAnimation = AnimationUtils.LoadAnimation(Resource.Animation.MyAnimation);
ImageView myImage = FindViewById<ImageView>(Resource.Id.imageView1);
myImage.StartAnimation(myAnimation);
```

Теперь, когда у нас есть фундаментальное представление о работе анимации представлений, можно перейти к анимации свойств.

### <a name="property-animations"></a>Анимация свойств

Анимированные свойства — это новый API, который появился в Android 3,0.
Они предоставляют более расширяемый API, который можно использовать для анимации любого свойства любого объекта.

Все анимации свойств создаются экземплярами подкласса [аниматор](xref:Android.Animation.Animator) . Приложения не используют этот класс напрямую, вместо этого они используют один из подклассов:

- [Валуеаниматор](xref:Android.Animation.ValueAnimator) &ndash; этот класс является самым важным классом в API анимации всего свойства. Он вычисляет значения свойств, которые необходимо изменить. `ViewAnimator` не обновляет эти значения напрямую; Вместо этого он создает события, которые могут использоваться для обновления анимированных объектов.

- [Обжектаниматор](xref:Android.Animation.ObjectAnimator) &ndash; этот класс является подклассом `ValueAnimator`. Он предназначен для упрощения процесса анимации объектов путем приема целевого объекта и свойства для обновления.

- Создание [анимации](xref:Android.Animation.AnimatorSet) &ndash; этот класс отвечает за координацию того, как анимация выполняется по отношению друг к другу. Анимации могут выполняться одновременно, последовательно или с заданной задержкой между ними.

*Оценивающие* являются специальными классами, которые используются в анимации для вычисления новых значений во время анимации. Android предоставляет следующие средства оценки:

- [Интевалуатор](xref:Android.Animation.IntEvaluator) &ndash; вычисляет значения для целочисленных свойств.

- [Флоатевалуатор](xref:Android.Animation.FloatEvaluator) &ndash; вычисляет значения для свойств float.

- [Аргбевалуатор](xref:Android.Animation.ArgbEvaluator) &ndash; вычисляет значения для цветовых свойств.

Если анимированное свойство не является `float`, `int` или цветом, приложения могут создать собственный оценщик, реализовав интерфейс `ITypeEvaluator`. (Реализация пользовательских оценивающих выходит за рамки данного раздела.)

#### <a name="using-the-valueanimator"></a>Использование Валуеаниматор

Анимация состоит из двух частей: вычисление анимированных значений и последующее задание этих значений для свойств некоторого объекта. 
[Валуеаниматор](xref:Android.Animation.ValueAnimator) вычисляет только значения, но не будет обрабатывать объекты напрямую. Вместо этого объекты будут обновляться внутри обработчиков событий, которые будут вызываться во время существования анимации. Такая схема позволяет обновлять несколько свойств из одного анимированного значения.

Чтобы получить экземпляр `ValueAnimator`, вызовите один из следующих методов фабрики:

- `ValueAnimator.OfInt`
- `ValueAnimator.OfFloat`
- `ValueAnimator.OfObject`

После этого экземпляр `ValueAnimator` должен иметь установленную длительность, после чего он может быть запущен. В следующем примере показано, как анимировать значение от 0 до 1 в диапазоне 1000 миллисекунд:

```csharp
ValueAnimator animator = ValueAnimator.OfInt(0, 100);
animator.SetDuration(1000);
animator.Start();
```

Но сам фрагмент кода, приведенный выше, не очень полезен &ndash; аниматор будет выполняться, но для обновленного значения нет цели. Класс `Animator` вызовет событие Update, когда оно принимает решение о необходимости информирования прослушивателей нового значения. Приложения могут предоставлять обработчик событий для реагирования на это событие, как показано в следующем фрагменте кода:

```csharp
MyCustomObject myObj = new MyCustomObject();
myObj.SomeIntegerValue = -1;

animator.Update += (object sender, ValueAnimator.AnimatorUpdateEventArgs e) =>
{
    int newValue = (int) e.Animation.AnimatedValue;
    // Apply this new value to the object being animated.
    myObj.SomeIntegerValue = newValue;
};
```

Теперь, когда у нас есть представление о `ValueAnimator`, вы можете узнать больше о `ObjectAnimator`.

#### <a name="using-the-objectanimator"></a>Использование Обжектаниматор

[Обжектаниматор](xref:Android.Animation.ObjectAnimator) является подклассом `ViewAnimator`, объединяющего ядро времени и вычисления значений `ValueAnimator` с логикой, необходимой для подключения обработчиков событий. `ValueAnimator` требует, чтобы приложения явно настроили обработчик событий &ndash; `ObjectAnimator` позаботится об этом шаге.

API для `ObjectAnimator` очень похож на API для `ViewAnimator`, но требует предоставления объекта и имени обновляемого свойства. В следующем примере показан пример использования `ObjectAnimator`.

```csharp
MyCustomObject myObj = new MyCustomObject();
myObj.SomeIntegerValue = -1;

ObjectAnimator animator = ObjectAnimator.OfFloat(myObj, "SomeIntegerValue", 0, 100);
animator.SetDuration(1000);
animator.Start();
```

Как видно из предыдущего фрагмента кода, `ObjectAnimator` может сократить и упростить код, необходимый для анимации объекта.

### <a name="drawable-animations"></a>Рисованные анимации

Окончательный API анимации — это интерфейс API для рисования. При рисовании можно загружать ряд рисуемых ресурсов один за другим и отображать их последовательно, аналогично перевернутому.

Нарисованные ресурсы определяются в XML-файле, который содержит элемент `<animation-list>` в качестве корневого элемента и ряд элементов `<item>`, определяющих каждый кадр анимации. Этот XML-файл хранится в папке `/Resource/drawable` приложения. Следующий код XML является примером создаваемой анимации:

```xml
<animation-list xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:drawable="@drawable/asteroid01" android:duration="100" />
  <item android:drawable="@drawable/asteroid02" android:duration="100" />
  <item android:drawable="@drawable/asteroid03" android:duration="100" />
  <item android:drawable="@drawable/asteroid04" android:duration="100" />
  <item android:drawable="@drawable/asteroid05" android:duration="100" />
  <item android:drawable="@drawable/asteroid06" android:duration="100" />
</animation-list>
```

Эта анимация будет выполняться через шесть кадров. Атрибут `android:duration` объявляет, сколько времени будет отображаться для каждого кадра. В следующем фрагменте кода показан пример создания рисуемой анимации и ее запуска при нажатии пользователем кнопки на экране:

```csharp
AnimationDrawable _asteroidDrawable;

protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);
    SetContentView(Resource.Layout.Main);

    _asteroidDrawable = (Android.Graphics.Drawables.AnimationDrawable)
    Resources.GetDrawable(Resource.Drawable.spinning_asteroid);

    ImageView asteroidImage = FindViewById<ImageView>(Resource.Id.imageView2);
    asteroidImage.SetImageDrawable((Android.Graphics.Drawables.Drawable) _asteroidDrawable);

    Button asteroidButton = FindViewById<Button>(Resource.Id.spinAsteroid);
    asteroidButton.Click += (sender, e) =>
    {
        _asteroidDrawable.Start();
    };
}
```

На этом этапе мы рассмотрели основы интерфейсов API анимации, доступных в приложении Android.

## <a name="summary"></a>Сводка

В этой статье представлено множество новых концепций и API-интерфейсов, помогающих добавить графику в приложение Android. Сначала мы рассмотрели различные API двухмерной графики и продемонстрировали, как Android позволяет приложениям рисовать непосредственно на экране с помощью объекта Canvas. Мы также рассмотрели некоторые альтернативные методы, позволяющие декларативно создавать графики с помощью XML-файлов. Затем мы собрались обсудить старый и новый API для создания анимаций в Android.

## <a name="related-links"></a>Связанные ссылки

- [Демонстрация анимации (пример)](https://docs.microsoft.com/samples/xamarin/monodroid-samples/animationdemo)
- [Анимация и графика](https://developer.android.com/guide/topics/graphics/index.html)
- [Использование анимаций для переноса мобильных приложений в жизнь](https://youtu.be/ikSk_ILg3d0)
- [аниматиондравабле](xref:Android.Graphics.Drawables.AnimationDrawable)
- [Canvas](xref:Android.Graphics.Canvas)
- [Аниматор объекта](xref:Android.Animation.ObjectAnimator)
- [Значение аниматор](xref:Android.Animation.ValueAnimator)
