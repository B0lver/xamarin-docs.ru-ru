---
title: Графика и анимация
description: Android предоставляет обширную и разнообразную платформу для поддержки двухмерной графики и анимации. В этом разделе рассматриваются эти платформы и обсуждаются способы создания пользовательских графиков и анимаций для использования в приложении Xamarin. Android.
ms.prod: xamarin
ms.assetid: 80086318-6FE4-4711-9A71-5C8F8C28C754
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 02/16/2018
ms.openlocfilehash: 7f21964fff0ac37fd87b8dcc6321e47c42c78a49
ms.sourcegitcommit: 3ea9ee034af9790d2b0dc0893435e997bd06e587
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68644324"
---
# <a name="android-graphics-and-animation"></a>Графика и анимация Android

_Android предоставляет обширную и разнообразную платформу для поддержки двухмерной графики и анимации. В этом разделе рассматриваются эти платформы и обсуждаются способы создания пользовательских графиков и анимаций для использования в приложении Xamarin. Android._

## <a name="overview"></a>Обзор

Несмотря на то, что работает на устройствах, имеющих ограниченную мощность, самые высокие оценки мобильных приложений часто имеют опыт взаимодействия с пользователем (UX) с высококачественной графикой и анимацией, которые обеспечивают интуитивно понятную и динамическую работу. По мере того, как мобильные приложения получают больше и сложнее, пользователи начали использовать больше и больше приложений.

К счастью, современные мобильные платформы имеют очень мощные платформы для создания сложных анимаций и пользовательских графиков, сохраняя простоту использования. Это позволяет разработчикам добавлять широкие интерактивные возможности с минимальными усилиями.

Платформы API пользовательского интерфейса в Android можно разделить на две категории: Графика и анимация.

Графика разбивается на различные подходы для выполнения двухмерной и трехмерной графики. Трехмерная графика доступна через ряд встроенных платформ, таких как OpenGL ES (версия OpenGL для мобильных устройств) и сторонних платформ, таких как «коигру» (кросс-платформенный набор средств, совместимый с XNA Toolkit). Хотя трехмерная графика не выходит за рамки этой статьи, мы рассмотрим встроенные методы двухмерной прорисовки.

Android предоставляет два разных API для создания двухмерной графики. Один из них является декларативным подходом высокого уровня и другим программным ИНТЕРФЕЙСом низкого уровня:

-   **Рисуемые ресурсы** &ndash; Они используются для создания пользовательских рисунков программным способом или (чаще) путем встраивания инструкций по рисованию в XML-файлы. Графические ресурсы обычно определяются как XML-файлы, которые содержат инструкции или действия для Android, чтобы визуализировать 2D-график. 

-   **Холст** &ndash; это интерфейс API нижнего уровня, включающий Рисование непосредственно на базовом точечном рисунке. Он обеспечивает очень детализированный контроль над отображаемыми сведениями. 

Помимо этих приемов двухмерной графики, Android также предоставляет несколько различных способов создания анимации:

-   **Рисованные анимации** Android также поддерживает анимацию по кадрам, известную как нарисованная *анимация.* &ndash; Это самый простой API анимации. Android последовательно загружает и отображает отображаемые ресурсы в последовательности (во многом похоже на мультипликационный рисунок).

-   **Просмотр анимаций** Анимация представлений — это исходный API анимации в Android, который доступен во всех версиях Android. &ndash; Этот API ограничен тем, что он будет работать только с объектами представления и может выполнять только простые преобразования этих представлений.
    Анимации представления обычно определяются в XML-файлах, `/Resources/anim` находящихся в папке.

-   **Анимация свойств** В Android 3,0 появился новый набор API анимации, известный как *анимация свойств.* &ndash; В этих новых API реализована расширяемая и гибкая система, которая может использоваться для анимации свойств любого объекта, а не только для просмотра объектов. Такая гибкость позволяет инкапсулировать анимацию в отдельные классы, упрощающие совместное использование кода.


Анимации представлений лучше подходят для приложений, которые должны поддерживать старый API-интерфейс до Android 3,0 (API уровня 11). В противном случае приложения должны использовать более новые API анимации свойств по указанным выше причинам.

Все эти платформы являются приемлемыми вариантами, но там, где это возможно, предпочтение следует предоставить анимациям свойств, так как это более гибкий API для работы с. Анимация свойств позволяет инкапсулировать логику анимации в отдельные классы, что упрощает совместное использование кода и упрощает обслуживание кода.


## <a name="accessibility"></a>Специальные возможности

Графики и анимации помогают сделать приложения Android привлекательными и приятными в использовании; Однако важно помнить, что некоторые взаимодействия выполняются через средств, альтернативные устройства ввода или при помощи масштабирования.
Кроме того, некоторые взаимодействия могут происходить без звуковых возможностей.

Приложения более удобны в таких ситуациях, если они были разработаны с учетом специальных возможностей: предоставление подсказок и помощника по переходу в пользовательском интерфейсе и обеспечение наличия текстового содержимого или описаний для элементов виде рисунков пользовательского интерфейса.

Дополнительные сведения об использовании интерфейсов API специальных возможностей Android см. в [руководстве по специальным возможностям Google](https://developer.android.com/guide/topics/ui/accessibility/) .



## <a name="2d-graphics"></a>2D-графика

Нарисованные ресурсы являются популярным приемом в приложениях Android. Как и в случае с другими ресурсами, нарисованные ресурсы декларативно &ndash; определяются в XML-файлах. Такой подход позволяет четко отделить код от ресурсов. Это может упростить разработку и обслуживание, поскольку нет необходимости изменять код для обновления или изменения графики в приложении Android. Однако в то время как графические ресурсы полезны для многих простых и распространенных графических требований, они не обладают возможностями и контроля над API Canvas.

Другой метод, использующий объект [Canvas](xref:Android.Graphics.Canvas) , очень похож на другие традиционные платформы API, такие как System. Drawing или основной чертеж iOS. Использование объекта Canvas обеспечивает наибольший контроль над созданием двухмерной графики. Он подходит для ситуаций, когда рисуемый ресурс не будет работать или будет трудно работать с. Например, может потребоваться нарисовать настраиваемый элемент управления Slider, внешний вид которого изменится на основе вычислений, связанных со значением ползунка.

Давайте сначала рассмотрим рисуемые ресурсы. Они проще и охватывают самые распространенные пользовательские варианты рисования.


### <a name="drawable-resources"></a>Рисуемые ресурсы

Нарисованные ресурсы определяются в XML-файле в каталоге `/Resources/drawable`. В отличие от внедрения PNG или JPEG, нет необходимости предоставлять зависящие от плотности версии для нарисованных ресурсов.
Во время выполнения приложение Android загрузит эти ресурсы и будет использовать инструкции, содержащиеся в этих XML-файлах, для создания двухмерной графики.
Android определяет несколько различных типов рисуемых ресурсов:

-   [Шапедравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#Shape) &ndash; Это рисуемый объект, который рисует примитивную геометрическую форму и применяет к этой фигуре ограниченный набор графических эффектов. Они очень полезны для таких задач, как Настройка кнопок или настройка фона Текствиевс. Мы рассмотрим пример использования `ShapeDrawable` далее в этой статье.

-   [Стателистдравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#StateList) &ndash; Это рисуемый ресурс, который изменит внешний вид на основе состояния мини-приложения или элемента управления. Например, кнопка может изменить внешний вид в зависимости от того, была ли она нажата.

-   [Лайердравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#LayerList) &ndash; Этот рисуемый ресурс, который поверх другого драваблес помещается друг на друга. Пример *лайердравабле* показан на следующем снимке экрана:

    ![Пример Лайердравабле](graphics-and-animation-images/image1.png)

-   [Транситиондравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#Transition) Это лайердравабле, но с одним отличием. &ndash; *Транситиондравабле* может анимировать один слой, который отображается поверх другого.

-   [Левеллистдравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#LevelList) Это очень похоже на стателистдравабле в том, что он будет отображать изображение на основе определенных условий. &ndash; Однако, в отличие от *стателистдравабле*, *левеллистдравабле* отображает изображение на основе целочисленного значения. Примером *левеллистдравабле* может быть отображение силы сигнала Wi-Fi. При изменении силы сигнала WiFi отображаемый рисунок изменится соответствующим образом.

-   [ScaleDrawable](https://developer.android.com/guide/topics/resources/drawable-resource.html#Scale)/[ClipDrawable](https://developer.android.com/guide/topics/resources/drawable-resource.html#Clip) &ndash; Как предполагает их название, эти Drawables предоставляют функции масштабирования и обрезки. *Скаледравабле* будет масштабировать другой рисунок, в то время как *клипдравабле* будет обрезать другой рисунок.

-   [Инсетдравабле](https://developer.android.com/guide/topics/resources/drawable-resource.html#Inset) &ndash; Этот рисунок будет применять инсетс на сторонах другого рисуемого ресурса. Он используется, если для представления требуется фон, меньший по отношению к фактическим границам представления.

-   [BitmapDrawable](https://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap) &ndash; XML этот файл представляет собой набор инструкций в формате XML, которые должны выполняться на фактическом точечном рисунке. Некоторые действия, которые может выполнять Android, — мозаичное смешение, сглаживание и сглаживание. Одно из наиболее распространенных применений заключается в мозаичном заполнении точечного рисунка на фоне макета.

#### <a name="drawable-example"></a>Пример с рисованием

Рассмотрим краткий пример создания двухмерной графики с помощью `ShapeDrawable`. `ShapeDrawable` Может определять одну из четырех базовых фигур: прямоугольник, овал, линия и кольцо. Также можно применить основные эффекты, такие как градиент, цвет и размер. Следующий код XML можно найти `ShapeDrawable` в проекте-компаньоне *аниматионсдемо* (в файле `Resources/drawable/shape_rounded_blue_rect.xml`).
Он определяет прямоугольник с фиолетовым градиентным фоном и скругленными углами:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
<!-- Specify a gradient for the background -->
<gradient android:angle="45"
          android:startColor="#55000066"
          android:centerColor="#00000000"
          android:endColor="#00000000"
          android:centerX="0.75" />

<padding android:left="5dp"
          android:right="5dp"
          android:top="5dp"
          android:bottom="5dp" />

<corners android:topLeftRadius="10dp"
          android:topRightRadius="10dp"
          android:bottomLeftRadius="10dp"
          android:bottomRightRadius="10dp" />
</shape>
```

Мы можем ссылаться на этот рисуемый ресурс декларативно в макете или на другом рисунке, как показано в следующем коде XML:

```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:background="#33000000">
    <TextView android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_centerInParent="true"
              android:background="@drawable/shape_rounded_blue_rect"
              android:text="@string/message_shapedrawable" />
</RelativeLayout>
```

Нарисованные ресурсы можно также применять программно. В следующем фрагменте кода показано, как программным способом задать фон TextView:

```csharp
TextView tv = FindViewById<TextView>(Resource.Id.shapeDrawableTextView);
tv.SetBackgroundResource(Resource.Drawable.shape_rounded_blue_rect);
```

Чтобы увидеть, как это будет выглядеть, запустите проект *аниматионсдемо* и в главном меню выберите фигурный элемент Shape (рисунок). Мы должны увидеть нечто вроде следующего снимка экрана:

![TextView с помощью пользовательского фона, рисуемого с помощью градиента и скругленных углов](graphics-and-animation-images/image1.png)

Дополнительные сведения о XML-элементах и синтаксисе для нарисованных ресурсов см. в [документации Google](https://developer.android.com/guide/topics/resources/drawable-resource.html#Shape).


### <a name="using-the-canvas-drawing-api"></a>Использование API рисования Canvas

Драваблес являются мощными, но имеют свои ограничения. Некоторые вещи невозможны или очень сложны (например, применение фильтра к изображению, которое было получено камерой на устройстве). Было бы очень сложно применить сокращение красных глаз, используя рисуемый ресурс.
Вместо этого API Canvas позволяет приложению иметь очень детализированный контроль для выборочного изменения цветов в определенной части изображения.

Одним из классов, обычно используемых с Canvas, является класс [Paint](xref:Android.Graphics.Paint) . Этот класс содержит сведения о цвете и стиле рисования. Он используется для предоставления таких объектов, как цвет и прозрачность.

API Canvas использует модель по *образцу* для рисования двухмерной графики.
Операции применяются в последовательных слоях поверх других. Каждая операция охватывает некоторую область базового точечного рисунка. Когда область пересекается с ранее закрашенной областью, Новая заливка будет частично или полностью скроет старую. Это аналогично тому, как многие другие API рисования, такие как System. Drawing и основные графические объекты iOS, работают.

Получить `Canvas` объект можно двумя способами. Первый способ заключается в определении объекта [Bitmap](xref:Android.Graphics.Bitmap) , а также при создании экземпляра `Canvas` объекта с ним. Например, следующий фрагмент кода создает новый холст с базовым точечным рисунком:

```csharp
Bitmap bitmap = Bitmap.CreateBitmap(100, 100, Bitmap.Config.Argb8888);
Canvas canvas = new Canvas(b);
```

Другим способом получения `Canvas` объекта является метод обратного вызова [OnDraw](xref:Android.Views.View.OnDraw*) , который предоставляет базовый класс [представления](xref:Android.Views.View) . Android вызывает этот метод, когда необходимо, чтобы представление соработало и передавало `Canvas` объект для работы с представлением.

Класс Canvas предоставляет методы для программного предоставления инструкций Draw. Например:

- [Canvas. дравпаинт](xref:Android.Graphics.Canvas.DrawPaint*) &ndash; заполняет растровое изображение всего холста заданными красками.

- [Canvas. дравпас](xref:Android.Graphics.Canvas.DrawPath*) &ndash; Рисует указанную геометрическую форму с помощью указанной краски.

- [Canvas. DrawText](xref:Android.Graphics.Canvas.DrawText*) &ndash; рисует текст на холсте с указанным цветом. Текст отображается в месте расположения `x,y` .

#### <a name="drawing-with-the-canvas-api"></a>Рисование с помощью API Canvas

Рассмотрим пример API Canvas в действии. В следующем фрагменте кода показано, как нарисовать представление:

```csharp
public class MyView : View
{
    protected override void OnDraw(Canvas canvas)
    {
        base.OnDraw(canvas);
        Paint green = new Paint {
            AntiAlias = true,
            Color = Color.Rgb(0x99, 0xcc, 0),
        };
        green.SetStyle(Paint.Style.FillAndStroke);

        Paint red = new Paint {
            AntiAlias = true,
            Color = Color.Rgb(0xff, 0x44, 0x44)
        };
        red.SetStyle(Paint.Style.FillAndStroke);

        float middle = canvas.Width * 0.25f;
        canvas.DrawPaint(red);
        canvas.DrawRect(0, 0, middle, canvas.Height, green);
    }
}
```

В приведенном выше коде сначала создается красная заливка и зеленый объект Paint. Он заполняет содержимое холста красным цветом, а затем указывает холсту нарисовать зеленый прямоугольник размером 25% от ширины холста. Пример можно просмотреть в `AnimationsDemo` Project, который включен в исходный код для этой статьи. Запустив приложение и выбрав элемент Drawing в главном меню, мы должны выглядеть следующим образом:

![Экран с красной заливкой и зелеными объектами Paint](graphics-and-animation-images/image3.png)


## <a name="animation"></a>Анимация

Пользователи, такие как элементы, которые переходят в свои приложения. Анимация — это отличный способ улучшить взаимодействие с пользователем приложения и помочь ему в его выводе. Лучшими анимациями являются те, которые пользователи не заметят, так как они естественным образом. Android предоставляет следующие три API для анимации:

-   **Просмотреть анимацию** &ndash; Это исходный API. Эти анимации привязаны к определенному представлению и могут выполнять простые преобразования содержимого представления. В связи с простотой этот API-интерфейс все еще полезен для таких объектов, как анимация альфа, вращение и т. д.

-   **Анимация свойства** &ndash; Анимации свойств появились в Android 3,0. Они позволяют приложению анимировать практически любую. Анимация свойств может использоваться для изменения любого свойства любого объекта, даже если этот объект не виден на экране.

-   **Восрисованная анимация** &ndash; Этот специальный ресурс, который используется для применения очень простого эффекта анимации к макетам.

Как правило, анимация свойств является предпочтительной системой для использования, так как она является более гибкой и предлагает больше функций.


### <a name="view-animations"></a>Просмотр анимаций

Анимация представлений ограничена представлениями и может выполнять анимацию только по таким значениям, как начальная и конечная точки, размер, поворот и прозрачность.
Эти типы анимации обычно называют *анимациями анимации*. Анимации представлений можно определять двумя способами &ndash; программно в коде или с помощью XML-файлов. XML-файлы — это предпочтительный способ объявления анимаций представлений, так как они более удобочитаемы и удобны в обслуживании.

XML-файлы анимации будут храниться в `/Resources/anim` каталоге проекта Xamarin. Android. Этот файл должен иметь один из следующих элементов в качестве корневого элемента:

-   `alpha`&ndash; Эффект затухания или затухания.

-   `rotate`&ndash; Анимация вращения.

-   `scale`&ndash; Анимация изменения размера.

-   `translate`&ndash; Перемещение по горизонтали и (или) по вертикали.

-   `set`&ndash; Контейнер, который может содержать один или несколько других элементов анимации.

По умолчанию все анимации в XML-файле будут применяться одновременно. Чтобы анимация выполнялась последовательно, установите `android:startOffset` атрибут для одного из элементов, определенных выше.

Можно повлиять на скорость изменения анимации с помощью *интерполяции*. Интерполяция делает возможным ускорение, повтор или замедление эффектов анимации. Платформа Android предоставляет несколько предустановленных интерполяций, например (но не ограничиваясь ими):

-   `AccelerateInterpolator`Эти интерполяции увеличивают или уменьшают скорость изменения в анимации. / `DecelerateInterpolator` &ndash;

-   `BounceInterpolator`&ndash; это изменение повлияет на конец.

-   `LinearInterpolator`&ndash; частота изменений является постоянной.


В следующем коде XML показан пример файла анимации, объединяющего некоторые из этих элементов:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android=http://schemas.android.com/apk/res/android
     android:shareInterpolator="false">

    <scale android:interpolator="@android:anim/accelerate_decelerate_interpolator"
           android:fromXScale="1.0"
           android:toXScale="1.4"
           android:fromYScale="1.0"
           android:toYScale="0.6"
           android:pivotX="50%"
           android:pivotY="50%"
           android:fillEnabled="true"
           android:fillAfter="false"
           android:duration="700" />

    <set android:interpolator="@android:anim/accelerate_interpolator">
        <scale android:fromXScale="1.4"
               android:toXScale="0.0"
               android:fromYScale="0.6"
               android:toYScale="0.0"
               android:pivotX="50%"
               android:pivotY="50%"
               android:fillEnabled="true"
               android:fillBefore="false"
               android:fillAfter="true"
               android:startOffset="700"
               android:duration="400" />

        <rotate android:fromDegrees="0"
                android:toDegrees="-45"
                android:toYScale="0.0"
                android:pivotX="50%"
                android:pivotY="50%"
                android:fillEnabled="true"
                android:fillBefore="false"
                android:fillAfter="true"
                android:startOffset="700"
                android:duration="400" />
    </set>
</set>
```

Эта анимация будет выполнять все анимации одновременно. Первая анимация шкалы растягивает изображение по горизонтали и сжимает его вертикально, а затем изображение будет повернуто в 45 градусов по часовой стрелке и уменьшено, после чего на экране появляется экран.

Анимацию можно программно применить к представлению, увеличив анимацию и применив ее к представлению. Android предоставляет вспомогательный класс `Android.Views.Animations.AnimationUtils` , который увеличит ресурс анимации и возвратит `Android.Views.Animations.Animation`экземпляр. Этот объект применяется к представлению путем вызова `StartAnimation` и `Animation` передачи объекта. В следующем фрагменте кода приведен пример.

```csharp
Animation myAnimation = AnimationUtils.LoadAnimation(Resource.Animation.MyAnimation);
ImageView myImage = FindViewById<ImageView>(Resource.Id.imageView1);
myImage.StartAnimation(myAnimation);
```

Теперь, когда у нас есть фундаментальное представление о работе анимации представлений, можно перейти к анимации свойств.


### <a name="property-animations"></a>Анимация свойств

Анимированные свойства — это новый API, который появился в Android 3,0.
Они предоставляют более расширяемый API, который можно использовать для анимации любого свойства любого объекта.

Все анимации свойств создаются экземплярами подкласса [аниматор](xref:Android.Animation.Animator) . Приложения не используют этот класс напрямую, вместо этого они используют один из подклассов:

-   [Валуеаниматор](xref:Android.Animation.ValueAnimator) &ndash; Этот класс является наиболее важным классом в API анимации всего свойства. Он вычисляет значения свойств, которые необходимо изменить. Объект `ViewAnimator` не обновляет эти значения напрямую; вместо этого он создает события, которые могут использоваться для обновления анимированных объектов.

-   [Обжектаниматор](xref:Android.Animation.ObjectAnimator) Этот класс является `ValueAnimator`подклассом. &ndash; Он предназначен для упрощения процесса анимации объектов путем приема целевого объекта и свойства для обновления.

-   [Анимация](xref:Android.Animation.AnimatorSet) &ndash; Этот класс отвечает за координацию выполнения анимации в связи друг с другом. Анимации могут выполняться одновременно, последовательно или с заданной задержкой между ними.


*Оценивающие* являются специальными классами, которые используются в анимации для вычисления новых значений во время анимации. Android предоставляет следующие средства оценки:

-   [Интевалуатор](xref:Android.Animation.IntEvaluator) &ndash; Вычисляет значения для целочисленных свойств.

-   [Флоатевалуатор](xref:Android.Animation.FloatEvaluator) &ndash; Вычисляет значения для свойств float.

-   [Аргбевалуатор](xref:Android.Animation.ArgbEvaluator) &ndash; Вычисляет значения для цветовых свойств.

Если свойство, для которого выполняется анимация `float`, не является, `int` или цветное, приложения могут создать собственный `ITypeEvaluator` оценщик путем реализации интерфейса. (Реализация пользовательских оценивающих выходит за рамки данного раздела.)

#### <a name="using-the-valueanimator"></a>Использование Валуеаниматор

Анимация состоит из двух частей: вычисление анимированных значений и последующее задание этих значений для свойств некоторого объекта. 
[Валуеаниматор](xref:Android.Animation.ValueAnimator) вычисляет только значения, но не будет обрабатывать объекты напрямую. Вместо этого объекты будут обновляться внутри обработчиков событий, которые будут вызываться во время существования анимации. Такая схема позволяет обновлять несколько свойств из одного анимированного значения.

Экземпляр можно получить `ValueAnimator` , вызвав один из следующих методов фабрики:

-  `ValueAnimator.OfInt`
-  `ValueAnimator.OfFloat`
-  `ValueAnimator.OfObject`

После этого `ValueAnimator` экземпляр должен иметь установленную длительность, после чего он может быть запущен. В следующем примере показано, как анимировать значение от 0 до 1 в диапазоне 1000 миллисекунд:

```csharp
ValueAnimator animator = ValueAnimator.OfInt(0, 100);
animator.SetDuration(1000);
animator.Start();
```

Но сам фрагмент кода, приведенный выше, не очень &ndash; полезен, аниматор будет работать, но для обновленного значения нет цели. `Animator` Класс вызовет событие Update, когда принимает решение о необходимости информирования прослушивателей нового значения. Приложения могут предоставлять обработчик событий для реагирования на это событие, как показано в следующем фрагменте кода:

```csharp
MyCustomObject myObj = new MyCustomObject();
myObj.SomeIntegerValue = -1;

animator.Update += (object sender, ValueAnimator.AnimatorUpdateEventArgs e) =>
{
    int newValue = (int) e.Animation.AnimatedValue;
    // Apply this new value to the object being animated.
    myObj.SomeIntegerValue = newValue;
};
```

Теперь, когда у нас есть понимание `ValueAnimator`, вы можете узнать больше `ObjectAnimator`о.

#### <a name="using-the-objectanimator"></a>Использование Обжектаниматор

[Обжектаниматор](xref:Android.Animation.ObjectAnimator) является подклассом `ViewAnimator` , объединяющим ядро времени и вычисление `ValueAnimator` значений с логикой, необходимой для подключения обработчиков событий. Для `ValueAnimator` выполнения этого шага необходимо, чтобы приложения явно подстроили обработчик &ndash; `ObjectAnimator` событий.

API для `ObjectAnimator` очень похож на API для `ViewAnimator`, но требует предоставления объекта и имени обновляемого свойства. В следующем примере показан пример использования `ObjectAnimator`:

```csharp
MyCustomObject myObj = new MyCustomObject();
myObj.SomeIntegerValue = -1;

ObjectAnimator animator = ObjectAnimator.OfFloat(myObj, "SomeIntegerValue", 0, 100);
animator.SetDuration(1000);
animator.Start();
```

Как видно из предыдущего фрагмента кода, `ObjectAnimator` может уменьшить и упростить код, необходимый для анимации объекта.


### <a name="drawable-animations"></a>Рисованные анимации

Окончательный API анимации — это интерфейс API для рисования. При рисовании можно загружать ряд рисуемых ресурсов один за другим и отображать их последовательно, аналогично перевернутому.

Нарисованные ресурсы определяются в XML-файле, который `<animation-list>` содержит элемент в качестве корневого элемента и `<item>` ряд элементов, определяющих каждый кадр в анимации. Этот XML-файл хранится в `/Resource/drawable` папке приложения. Следующий код XML является примером создаваемой анимации:

```xml
<animation-list xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:drawable="@drawable/asteroid01" android:duration="100" />
  <item android:drawable="@drawable/asteroid02" android:duration="100" />
  <item android:drawable="@drawable/asteroid03" android:duration="100" />
  <item android:drawable="@drawable/asteroid04" android:duration="100" />
  <item android:drawable="@drawable/asteroid05" android:duration="100" />
  <item android:drawable="@drawable/asteroid06" android:duration="100" />
</animation-list>
```

Эта анимация будет выполняться через шесть кадров. `android:duration` Атрибут объявляет, сколько времени будет отображаться для каждого кадра. В следующем фрагменте кода показан пример создания рисуемой анимации и ее запуска при нажатии пользователем кнопки на экране:

```csharp
AnimationDrawable _asteroidDrawable;

protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);
    SetContentView(Resource.Layout.Main);

    _asteroidDrawable = (Android.Graphics.Drawables.AnimationDrawable)
    Resources.GetDrawable(Resource.Drawable.spinning_asteroid);

    ImageView asteroidImage = FindViewById<ImageView>(Resource.Id.imageView2);
    asteroidImage.SetImageDrawable((Android.Graphics.Drawables.Drawable) _asteroidDrawable);

    Button asteroidButton = FindViewById<Button>(Resource.Id.spinAsteroid);
    asteroidButton.Click += (sender, e) =>
    {
        _asteroidDrawable.Start();
    };
}
```

На этом этапе мы рассмотрели основы интерфейсов API анимации, доступных в приложении Android.


## <a name="summary"></a>Сводка

В этой статье представлено множество новых концепций и API-интерфейсов, помогающих добавить графику в приложение Android. Сначала мы рассмотрели различные API двухмерной графики и продемонстрировали, как Android позволяет приложениям рисовать непосредственно на экране с помощью объекта Canvas. Мы также рассмотрели некоторые альтернативные методы, позволяющие декларативно создавать графики с помощью XML-файлов. Затем мы собрались обсудить старый и новый API для создания анимаций в Android.



## <a name="related-links"></a>Связанные ссылки

- [Демонстрация анимации (пример)](https://docs.microsoft.com/samples/xamarin/monodroid-samples/animationdemo)
- [Анимация и графика](https://developer.android.com/guide/topics/graphics/index.html)
- [Использование анимаций для переноса мобильных приложений в жизнь](http://youtu.be/ikSk_ILg3d0)
- [аниматиондравабле](xref:Android.Graphics.Drawables.AnimationDrawable)
- [Canvas](xref:Android.Graphics.Canvas)
- [Аниматор объекта](xref:Android.Animation.ObjectAnimator)
- [Значение аниматор](xref:Android.Animation.ValueAnimator)
