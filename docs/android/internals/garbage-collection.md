---
title: "Сборка мусора"
ms.topic: article
ms.prod: xamarin
ms.assetid: 298139E2-194F-4A58-BC2D-1D22231066C4
ms.technology: xamarin-android
author: mgmclemore
ms.author: mamcle
ms.date: 02/15/2018
ms.openlocfilehash: d2298cf3edcadcc8a4d781e3e121852886fbf1d2
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="garbage-collection"></a>Сборка мусора

Xamarin.Android использует Mono [поколениям простой сборщик мусора](http://www.mono-project.com/Compacting_GC). Это сборщику мусора метки и очистка с помощью двух поколений и *пространство больших объектов*, с двумя типами коллекций: 

-   Дополнительный номер коллекций (сбор данных о Gen0 куча) 
-   Основной коллекции (сбор данных о Gen1 и больших объектов пространства кучи). 

> [!NOTE]
> **Примечание:** в случае отсутствия явного коллекции посредством [сборки Мусора. Collect()](https://developer.xamarin.com/api/member/System.GC.Collect/) коллекции являются *по требованию*, основе выделений памяти в куче. *Это не системы подсчета ссылок*; объекты *не будут собраны как можно скорее нет необработанных ссылок*, или когда вышел из области. Сборка Мусора выполняется в том случае, если дополнительный кучи хватает памяти для новых выделений. В случае выделения отсутствуют, он не работает.


Дополнительный номер коллекции часто и требует больших затрат и используются для сбора недавно выделенные и неиспользуемыми объектами. Дополнительный номер коллекции выполняются после каждых несколько МБ, выделенных объектов. Дополнительный номер коллекции может быть выполнена вручную путем вызова [сборки Мусора. Собирать (0)](https://developer.xamarin.com/api/member/System.GC.Collect/p/System.Int32/) 

Основной коллекции дорогостоящий и реже и используется для освобождения всех неиспользуемыми объектами. Основной коллекции выполняются после Исчерпана память для текущего размера кучи (до изменения размера кучи). Основной коллекции может быть выполнена вручную путем вызова [сборки Мусора. Сбор данных ()](https://developer.xamarin.com/api/member/System.GC.Collect/) или вызвав [сборки Мусора. Собирать (int)](https://developer.xamarin.com/api/member/System.GC.Collect/p/System.Int32) с аргументом [сборки Мусора. MaxGeneration](https://developer.xamarin.com/api/property/System.GC.MaxGeneration/). 


<a name="Cross-VM_Object_Collections" />

## <a name="cross-vm-object-collections"></a>Коллекции объектов между ВМ

Существует три категории типов объектов.

-   **Управляемые объекты**: типы, которые выполняют *не* наследовать от [Java.Lang.Object](https://developer.xamarin.com/api/type/Java.Lang.Object/) , например [System.String](https://developer.xamarin.com/api/type/System.String/). 
    Обычно они собираются сборкой Мусора. 

-   **Объекты Java**: типы Java, которые присутствуют в Android выполнения виртуальной Машины, но не предоставляемыми моно виртуальной машины. Это скучно и не дальнейшего обсуждения. Обычно они собираются Android среды выполнения виртуальной Машины. 

-   **Одноранговая объекты**: типы, которые реализуют [IJavaObject](https://developer.xamarin.com/api/type/Android.Runtime.IJavaObject/) , например все [Java.Lang.Object](https://developer.xamarin.com/api/type/Java.Lang.Object/) и [Java.Lang.Throwable](https://developer.xamarin.com/api/type/Java.Lang.Throwable/) подклассов. Экземпляры этих типов имеет два «halfs» *управляемого одноранговых* и *собственного одноранговых*. Управляемый узел является экземпляром класса C#. Собственный однорангового узла является экземпляром класса Android среды выполнения виртуальной Машины Java и C# [IJavaObject.Handle](https://developer.xamarin.com/api/property/Android.Runtime.IJavaObject.Handle/) свойство содержит глобальные JNI ссылку на собственный узел. 


Существует два вида собственного одноранговых узлов.

-   **Одноранговые узлы Framework** : типы Java «Normal», которые ничего не знают о Xamarin.Android, например [android.content.Context](https://developer.xamarin.com/api/type/Android.Content.Context/).

-   **Одноранговые узлы пользователя** : [Android с помощью вызываемых оболочек](~/android/platform/java-integration/working-with-jni.md) которого создаются во время построения для каждого Java.Lang.Object подкласс присутствует в приложении.


Есть две виртуальные машины в рамках процесса Xamarin.Android, существует два типа сборки мусора.

-   Коллекции Android среды выполнения 
-   Моно коллекций 

Android выполнения коллекций работают нормально, но с исключением: глобальные ссылки JNI рассматривается как корневой сборки Мусора. Следовательно, если JNI глобальна ссылка удерживает Android среды выполнения объекта виртуальной Машины, объект *нельзя* сбор, даже если в противном случае станет доступным для коллекции.

Моно коллекции — это когда происходит интересных. Обычно собираются управляемых объектов. Одноранговые объекты собираются, выполнив следующую процедуру:

1.  Все одноранговые объекты, подлежащие моно коллекции имеют их JNI глобальной ссылки заменены JNI глобального слабую ссылку. 

2.  Вызывается Android времени выполнения сборщика Мусора виртуальной Машины. Любой экземпляр собственного одноранговых могут собираться. 

3.  Проверяются JNI слабые глобальной ссылки в (1). Если собрал слабую ссылку, собираются объект однорангового узла. Если есть слабой ссылки *не* собраны, затем слабая ссылка заменяется JNI глобальной ссылки и объект однорангового узла не собираются. Примечание: на API 14+, это означает, что значение, возвращаемое из `IJavaObject.Handle` может изменяться после сборки Мусора. 

В результате все это, что экземпляр объекта узла будет располагаться до тех пор, пока он ссылается либо управляемого кода (например, хранящиеся в `static` переменной) или ссылается на языке Java. Кроме того, время существования собственного одноранговые узлы будут расширены за то, что это было бы в противном случае live, собственный однорангового узла не будет собираемой до собираемой собственного однорангового узла и управляемые однорангового узла.

<a name="Object_Cycles" />

## <a name="object-cycles"></a>Объект циклов

Одноранговые объекты логически присутствуют в Android среды выполнения и Mono виртуальной Машины. Например [Android.App.Activity](https://developer.xamarin.com/api/type/Android.App.Activity/) одноранговых управляемый экземпляр будет иметь соответствующий [android.app.Activity](http://developer.android.com/reference/android/app/Activity.html) framework одноранговый экземпляр Java. Все объекты, которые наследуют от [Java.Lang.Object](https://developer.xamarin.com/api/type/Java.Lang.Object/) можно должен обладать представления в обе виртуальные машины. 

Все объекты, которые имеют представление в обе виртуальные машины будут иметь время существования которых являются расширенными, по сравнению с объектами, которые присутствуют только в пределах одной виртуальной Машины (такие как [ `System.Collections.Generic.List<int>` ](https://developer.xamarin.com/api/type/System.Collections.Generic.List%601/)). Вызов [сборки Мусора. Собирать](https://developer.xamarin.com/api/member/System.GC.Collect/) будет собирать обязательно эти объекты, как сборщик Мусора Xamarin.Android должен убедиться, что объект не ссылается на любой виртуальной Машины перед сбором его. 

Чтобы сократить время существования объекта, [Java.Lang.Object.Dispose()](https://developer.xamarin.com/api/member/Java.Lang.Object.Dispose/) должны вызываться. Это вручную» разорвет» соединение между двумя виртуальными машинами путем освобождения глобальной ссылки объектов, собираемых быстрее, позволяя тем самым объекта. 

<a name="Automatic_Collections" />

## <a name="automatic-collections"></a>Автоматическое коллекций

Начиная с версии [выпуска 4.1.0](https://developer.xamarin.com/releases/android/mono_for_android_4/mono_for_android_4.1.0), Xamarin.Android автоматически выполняет полной сборки Мусора при достижении порогового значения gref. Это пороговое значение составляет 90% известных максимальное grefs для платформы: 1800 grefs в эмуляторе (2000 max) и 46800 grefs на оборудовании (максимальная 52000). *Примечание:* Xamarin.Android включает только grefs, созданные [Android.Runtime.JNIEnv](https://developer.xamarin.com/api/type/Android.Runtime.JNIEnv/)и не будет знать о других grefs, созданный в процессе. Это эвристики *только*. 

При выполнении автоматического сбора в журнал отладки печатается сообщение, аналогичное следующему:

```shell
I/monodroid-gc(PID): 46800 outstanding GREFs. Performing a full GC!
```

Вхождения является недетерминированным, а также может произойти в неподходящие моменты (например, во время отрисовки графики). Если вы видите это сообщение, может потребоваться явное коллекции в другом месте или вы можете попытаться [уменьшить время существования объектов одноранговых](#Helping_the_GC). 

## <a name="gc-bridge-options"></a>Параметры моста GC

Xamarin.Android обеспечивает управление прозрачный памяти с Android и Android среды выполнения. Он реализован как расширение моно сборщик мусора вызывается *GC моста*. 

Мост сборщик Мусора работает во время сбора мусора моно и фигуры, какой из одноранговых узлов объектов требуется их «liveness» проверена с помощью кучи Android среды выполнения. Мост сборщика Мусора определяет это, выполнив следующие действия (по порядку):

1.  Вызывать граф моно ссылок объектов одноранговых узлов недоступен в Java объекты, которые они представляют. 

2.  Выполнение сборки Мусора Java.

3.  Проверьте, какие объекты не существуют действительно. 

Этот сложный процесс является то, что позволяет подклассы `Java.Lang.Object` свободно ссылку на объекты; оно удаляет все ограничения на Java, какие объекты могут быть привязаны к C#. Из-за такой сложности моста процесс может быть очень дорого и может привести к заметной перерывы в приложении. Если приложение часто возникают значительные пауз, стоит один следующие три реализации моста GC: 

-   **Tarjan** -на основе совершенно новую конструктора моста GC [Robert Tarjan алгоритм и обратной ссылки распространения](http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm).
    Имеет лучшую производительность для наших имитацию рабочих нагрузок, но он также имеет большую долю экспериментальный кода. 

-   **Новый** -кардинальных исходного кода, исправления двух экземпляров квадратичной поведение, но сохранении основной алгоритм (на основе [Kosaraju алгоритм](http://en.wikipedia.org/wiki/Kosaraju's_algorithm) для строго поиск связанных компонентов). 

-   **Старый** -исходной реализации (считается наиболее стабильная из трех). Это моста, приложение должно использовать, если `GC_BRIDGE` пауз являются допустимыми. 


Единственный способ выяснить, какие моста сборщик Мусора работает лучше всего — эксперименты в приложении и анализируя выходные данные. Сбор данных для тестирования производительности двумя способами. 

-   **Включить ведение журнала** -включить ведение журнала (как описано в [конфигурации](~/android/internals/garbage-collection.md) разделе) для каждого параметра моста GC захвата и сравните выходные данные журнала каждого параметра. Проверить `GC` сообщений для каждого параметра; в частности, `GC_BRIDGE` сообщения. Приостанавливает работу до 150ms для приемлемый неинтерактивных приложений, а пауз выше 60 мс для очень интерактивных приложений (например, игры) — проблема. 

-   **Включить учет моста** -моста учета отображается Средняя стоимость объекты, на которые указывают каждого объекта, участвующих в процессе моста. Сортировка по размеру эти сведения предоставит указания относительно удерживает наибольший объем дополнительных объектов. 


Чтобы указать, какие `GC_BRIDGE` параметр приложения должна использовать, передавать `bridge-implementation=old`, `bridge-implementation=new` или `bridge-implementation=tarjan` для `MONO_GC_PARAMS` переменной среды, например: 

```shell
MONO_GC_PARAMS=bridge-implementation=tarjan
```

Значение по умолчанию — **Tarjan**. Если вы нашли регрессии, может оказаться необходимых для этого параметра задано значение **старый**. Кроме того, вы можете использовать более стабильным **старый** Если **Tarjan** не создает повышение производительности. 

<a name="Helping_the_GC" />

## <a name="helping-the-gc"></a>Помощь в сервере глобального Каталога

Существует несколько способов для сборки Мусора для сокращения времени сбор и использование памяти.


<a name="Disposing_of_Peer_instances" />

### <a name="disposing-of-peer-instances"></a>Удаление экземпляров однорангового узла

Сборщик Мусора имеет неполные представление процесса и нельзя запустить когда не хватает памяти, так как сборщик Мусора не знает, что памяти недостаточно. 

Например, экземпляр [Java.Lang.Object](https://developer.xamarin.com/api/type/Java.Lang.Object/) типа или производный тип имеет по крайней мере 20 байт (может быть изменено без предварительного уведомления, т. д., и т. д.). 
[Управляемые вызываемых оболочек](~/android/internals/architecture.md) не добавить членов дополнительного экземпляра, поэтому при наличии [Android.Graphics.Bitmap](https://developer.xamarin.com/api/type/Android.Graphics.Bitmap/) экземпляр, который ссылается на большой двоичный объект 10 МБ памяти, Xamarin.Android сборщик Мусора не будет знать, что &ndash; сборка Мусора объект 20 байт и смогут будет невозможно определить, что она связана с Android выделенной среды выполнения объектов, которые поддержания 10 МБ памяти. 

Часто она необходима для сборки Мусора. К сожалению *сборки Мусора. AddMemoryPressure()* и *сборки Мусора. RemoveMemoryPressure()* не поддерживаются, поэтому, если вы *знать* просто освобождения граф больших объектов, выделенных Java, может потребоваться вручную вызовите [сборки Мусора. Collect()](https://developer.xamarin.com/api/member/System.GC.Collect/) запрос сборки Мусора для освобождения Java стороне памяти, или можно явно удалять *Java.Lang.Object* подклассов, критические сопоставление управляемых вызываемой оболочки и экземпляр Java. Например, в разделе [1084 ошибки](http://bugzilla.xamarin.com/show_bug.cgi?id=1084#c6). 


> [!NOTE]
> **Примечание:** должно быть *очень* соблюдать осторожность при утилизации `Java.Lang.Object` подкласс экземпляров.

Чтобы свести к минимуму вероятность повреждения памяти, просмотрите следующие рекомендации при вызове `Dispose()`.


#### <a name="sharing-between-multiple-threads"></a>Совместное использование нескольких потоков

Если *Java или управляемых* экземпляра могут совместно использоваться несколькими потоками *не должно быть `Dispose()`d*, **когда-либо**. Например [ `Typeface.Create()` ](https://developer.xamarin.com/api/member/Android.Graphics.Typeface.Create/(System.String%2cAndroid.Graphics.TypefaceStyle)) может вернуть *кэшированный экземпляр*. Если несколько потоков предоставляет те же аргументы, они получат *же* экземпляра. Следовательно `Dispose()`любого из `Typeface` экземпляр из одного потока, может сделать недействительным другие потоки, которые могут приводить к `ArgumentException`s из `JNIEnv.CallVoidMethod()` (среди прочих), так как экземпляр был удален из другого потока. 


#### <a name="disposing-bound-java-types"></a>Удаление типов связанных Java

Если экземпляр имеет связанный тип Java, экземпляр может быть удален *при условии, что* из управляемого кода не будет повторно использовать экземпляр *и* экземпляр Java не может быть общим для потоков (см. предыдущие `Typeface.Create()` обсуждений). (Это может быть затруднен.) В следующий раз при переходе экземпляра Java управляемый код, *новый* оболочки будут созданы для него. 

Это часто полезно в тех случаях, когда дело доходит до Drawables и других ресурсов доступно экземпляров:

```csharp
using (var d = Drawable.CreateFromPath ("path/to/filename"))
    imageView.SetImageDrawable (d);
```

Выше безопасна поскольку однорангового узла, [Drawable.CreateFromPath()](https://developer.xamarin.com/api/member/Android.Graphics.Drawables.Drawable.CreateFromPath/) возвращает будет ссылаться на объект Framework *не* однорангового узла пользователя. `Dispose()` Вызова в конце `using` блок разорвет связь между управляемой [Drawable](https://developer.xamarin.com/api/type/Android.Graphics.Drawables.Drawable/) и framework [Drawable](http://developer.android.com/reference/android/graphics/drawable/Drawable.html) экземпляров, позволяя к экземпляру Java сбор по мере выполнения Android требуется. Это будет *не* можно с уверенностью в том случае, если экземпляр однорангового узла пользователя; здесь мы используем «external» сведения о *знать* , `Drawable` не может ссылаться на одноранговый узел пользователя и, следовательно, `Dispose()` вызова можно безопасно. 


#### <a name="disposing-other-types"></a>Удаление других типов 

Если экземпляр относится к типу, который не привязку типа Java (например пользовательский `Activity`), **не** вызвать `Dispose()` Если вы *знать* что код Java не будет вызвать переопределенные методы, экземпляр. Невыполнение этого требования приведет к [ `NotSupportedException`s](~/android/internals/architecture.md#Premature_Dispose_Calls). 

Например при наличии пользовательского щелкните прослушиватель:

```csharp
partial class MyClickListener : Java.Lang.Object, View.IOnClickListener {
    // ...
}
```

Вы *не должны* dispose данного экземпляра, как Java будет предпринята попытка вызова методов в его в будущем:

```csharp
// BAD CODE; DO NOT USE
Button b = FindViewById<Button> (Resource.Id.myButton);
using (var listener = new MyClickListener ())
    b.SetOnClickListener (listener);
```


#### <a name="using-explicit-checks-to-avoid-exceptions"></a>С помощью явной проверки, чтобы избежать исключений

При реализации [Java.Lang.Object.Dispose](https://developer.xamarin.com/api/member/Java.Lang.Object.Dispose(System.Boolean)/) перегрузки метода, не прикасайтесь объекты, включающие JNI. Это может привести к *dispose двойной* ситуацию, которая делает возможным для кода (неустранимо) пытаются получить доступ к базовой объект Java, которая уже была собрана сборщиком мусора. Таким образом создается исключение, подобное следующему: 

```shell
System.ArgumentException: 'jobject' must not be IntPtr.Zero.
Parameter name: jobject
at Android.Runtime.JNIEnv.CallVoidMethod
```

Такая ситуация часто возникает при первой dispose объекта вызывает член принимают значение null, а затем попытке последующий доступ к нему по этому элементу значение null приводит к созданию исключения. В частности, объекта `Handle` (который связывает управляемого экземпляра его базовый экземпляр Java) на первом dispose, но и управляемый код по-прежнему пытается получить доступ к этой базовый экземпляр Java, несмотря на то, что он больше не доступен (см. в разделе [ Управляемые вызываемых оболочек](~/android/internals/architecture.md#Managed_Callable_Wrappers) для получения дополнительных сведений о сопоставлении между экземплярами Java и управляемых экземпляров). 

Хороший способ предотвратить это исключение является явным образом проверить в вашей `Dispose` метод, который еще не истек; это сопоставление управляемого экземпляра базового экземпляра Java, проверка на наличие объекта `Handle` имеет значение null (`IntPtr.Zero`) Перед получением доступа к его членам. Например, следующая `Dispose` обращается к метод `childViews` объекта: 

```csharp
class MyClass : Java.Lang.Object, ISomeInterface 
{
    protected override void Dispose (bool disposing)
    {
        base.Dispose (disposing);
        for (int i = 0; i < this.childViews.Count; ++i)
        {
            // ...
        }
    }
}
```

Если начальное dispose передать причины `childViews` иметь недопустимый `Handle`, `for` цикла доступа вызовет `ArgumentException`. Добавив явно `Handle` null проверки перед первым `childViews` доступ следующие `Dispose` метод предотвращает возникнет исключение: 

```csharp
class MyClass : Java.Lang.Object, ISomeInterface 
{
    protected override void Dispose (bool disposing)
    {
        base.Dispose (disposing);

        // Check for a null handle:
        if (this.childViews.Handle == IntPtr.Zero)
            return;

        for (int i = 0; i < this.childViews.Count; ++i)
        {
            // ...
        }
    }
}
```

<a name="Reduce_Referenced_Instances" />

### <a name="reduce-referenced-instances"></a>Уменьшить экземпляров, на который указывает ссылка

Каждый раз, когда экземпляр `Java.Lang.Object` типа или подкласс проверяется во время сборки Мусора, вся *граф объекта* , на который ссылается экземпляр должен просматриваться. Граф объекта — это набор экземпляров объектов, которые называют «корневой экземпляр» *, а также* все ссылается экземпляр корневого ссылается, рекурсивно. 

Рассмотрим следующий класс:

```csharp
class BadActivity : Activity {

    private List<string> strings;

    protected override void OnCreate (Bundle bundle)
    {
        base.OnCreate (bundle);

        strings.Value = new List<string> (
                Enumerable.Range (0, 10000)
                .Select(v => new string ('x', v % 1000)));
    }
}
```

При `BadActivity` — создано, граф объекта будет содержать 10004 экземпляров (1 x `BadActivity`, 1 x `strings`, 1 x `string[]` удерживаемые `strings`, 10000 x экземплярами класса string), *все* из которого должен быть Каждый раз, когда просматриваются `BadActivity` сканируется экземпляра. 

Это может оказать отрицательное влияние на ваш времени сбора в результате чего увеличивается время паузы сборки Мусора. 

Вы можете помочь GC по *уменьшение* размер графов объектов, которые связаны с однорангового пользовательские экземпляры. В приведенном выше примере, это можно сделать путем перемещения `BadActivity.strings` в отдельный класс, который не наследуется от Java.Lang.Object: 

```csharp
class HiddenReference<T> {

    static Dictionary<int, T> table = new Dictionary<int, T> ();
    static int idgen = 0;

    int id;

    public HiddenReference ()
    {
        lock (table) {
            id = idgen ++;
        }
    }

    ~HiddenReference ()
    {
        lock (table) {
            table.Remove (id);
        }
    }

    public T Value {
        get { lock (table) { return table [id]; } }
        set { lock (table) { table [id] = value; } }
    }
}

class BetterActivity : Activity {

    HiddenReference<List<string>> strings = new HiddenReference<List<string>>();

    protected override void OnCreate (Bundle bundle)
    {
        base.OnCreate (bundle);

        strings.Value = new List<string> (
                Enumerable.Range (0, 10000)
                .Select(v => new string ('x', v % 1000)));
    }
}
```

<a name="Minor_Collections" />

## <a name="minor-collections"></a>Дополнительный номер коллекций

Дополнительный номер коллекции может быть выполнена вручную путем вызова [сборки Мусора. Collect(0)](https://developer.xamarin.com/api/member/System.GC.Collect/p/System.Int32). Дополнительный коллекции — это требует больших затрат (по сравнению с основной коллекций), но значительно фиксированных затрат, поэтому не требуется запускать их слишком часто и должен иметь паузы несколько миллисекунд. 

Если приложение имеет «рабочая нагрузка» в котором многократно выполняется то же самое, возможно, рекомендуется выполнить вручную вспомогательные коллекции после завершения рабочая нагрузка. Пример рабочих циклов включают: 

-  Цикл обработки одной игрового кадра.
-  Всего взаимодействия диалоговое окно приложения (Открытие, заполняя закрытие) 
-  Группа сетевых запросов на обновление и синхронизацию данных приложения.


<a name="Major_Collections" />

## <a name="major-collections"></a>Основные коллекций

Основной коллекции может быть выполнена вручную путем вызова [сборки Мусора. Collect()](https://developer.xamarin.com/api/member/System.GC.Collect/) или `GC.Collect(GC.MaxGeneration)`. 

Они должны выполняться редко и, возможно, паузы доли секунды на устройстве Android стиль при сборе данных кучи 512 МБ. 

Основные коллекций вручную вызывается только, если когда-либо: 

-   В конце продолжительной работы циклов и при приостановке long не является проблемой для пользователя. 

-   Переопределенного [Android.App.Activity.OnLowMemory()](https://developer.xamarin.com/api/member/Android.App.Activity.OnLowMemory/) метод. 


<a name="Diagnostics" />

## <a name="diagnostics"></a>Диагностика

Для отслеживания при создании и удалении ссылок на глобальный, можно задать [debug.mono.log](~/android/troubleshooting/index.md) системное свойство, чтобы содержать [ *gref* ](~/android/troubleshooting/index.md) и/или [ *gc*](~/android/troubleshooting/index.md). 


<a name="Configuration" />

## <a name="configuration"></a>Конфигурация

Сборщик мусора Xamarin.Android можно настроить, задав `MONO_GC_PARAMS` переменной среды. Переменные среды можно задать с помощью действия построения [AndroidEnvironment](~/android/deploy-test/environment.md).

`MONO_GC_PARAMS` Переменной среды является списком разделенных запятой со следующими параметрами: 

-   `nursery-size` = *размер* : задает размер nursery. Размер указывается в байтах и должен быть степенью двух. Суффиксы `k` , `m` и `g` может использоваться для указания килограмм-, мегабайт - и гигабайт, соответственно. Nursery — это первый поколение (два). Больше nursery позволяют ускорить обработку программы, но очевидно, что будет использовать больше памяти. По умолчанию nursery размером 512 КБ. 

-   `soft-heap-limit` = *размер* : максимально целевой управляемых потребление памяти для приложения. Если использование памяти ниже указанного значения, сборщик Мусора оптимизирован для времени выполнения (меньшее число коллекций). 
    Выше этот предел сборщик Мусора оптимизирован для использования памяти (несколько коллекций). 

-   `evacuation-threshold` = *Пороговое значение* : задает эвакуации пороговое значение в процентах. Значение должно быть целым числом в диапазоне от 0 до 100. Значение по умолчанию — 66. На этапе очистки коллекции обнаруживает, что заполненность тип блока определенной кучи меньше, чем это процентное значение, будет выполнять копирование коллекцию для этого типа блока в следующей коллекции основных тем самым восстановление (LDM) для близким к 100 процентам. Значение 0 отключает эвакуации. 

-   `bridge-implementation` = *мост реализацию* : будет назначено параметр GC моста для сборки Мусора адрес проблем производительности. Существует три возможных значения: *старый* , *новый* , *tarjan*.

-   `bridge-require-precise-merge`: Tarjan моста содержит оптимизации, что может в редких случаях привести объект был собираются один сборщик Мусора после становится сборки мусора. Включая этот параметр отключает оптимизации, выполняющего более предсказуемым, но потенциально медленнее глобальных каталогов.

Например, чтобы настроить сервер глобального Каталога иметь ограничение на размер кучи 128 МБ, добавьте новый файл в проект с **действие построения** из `AndroidEnvironment` содержимым: 

```shell
MONO_GC_PARAMS=soft-heap-limit=128m
```
