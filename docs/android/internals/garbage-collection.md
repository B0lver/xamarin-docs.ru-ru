---
title: Сборка мусора
ms.prod: xamarin
ms.assetid: 298139E2-194F-4A58-BC2D-1D22231066C4
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 03/15/2018
ms.openlocfilehash: c5a4247b2e10706014c9f92a487803e4a718c1a6
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "60953753"
---
# <a name="garbage-collection"></a>Сборка мусора

Xamarin.Android использует Mono [сборщик мусора разных поколений простой](https://www.mono-project.com/docs/advanced/garbage-collector/sgen/). Это сборщик мусора Марк и очистка с помощью двух поколений и *пространство больших объектов*, с помощью двух видов коллекций: 

-   Дополнительный номер коллекций (сбор данных о количестве Gen0 куча) 
-   Основной коллекции (собирает поколение 1 и больших объектов пространства кучи). 

> [!NOTE]
> При отсутствии явной коллекции с помощью [сборки Мусора. Collect()](xref:System.GC.Collect) коллекции являются *по запросу*, которая представляет выделений памяти из кучи. *Это не является ссылкой, подсчет системы*; объекты *не будут собраны, как только нет ожидающих ссылок*, или когда область был завершен. Сборщик Мусора будет выполняться при незначительных куче хватает памяти для нового выделения. Если нет выделения, он не запустится.


Дополнительный номер коллекции требует больших затрат и частые и используются для сбора недавно выделенный и неработающих объектов. Дополнительный номер коллекции выполняются после каждые несколько МБ, выделенных объектов. Дополнительный номер коллекции могут выполняться вручную путем вызова [сборки Мусора. Collect (0)](/dotnet/api/system.gc.collect#System_GC_Collect_System_Int32_) 

Основной коллекции, которые дороги и реже и используются для освобождения всех неиспользуемыми объектами. Основной коллекции выполняются в том случае, когда исчерпан памяти для текущего размера кучи (для того, перед изменением размера кучи). Основной коллекции могут выполняться вручную путем вызова [сборки Мусора. Собирать ()](xref:System.GC.Collect) или вызвав [сборки Мусора. Собирать (int)](/dotnet/api/system.gc.collect#System_GC_Collect_System_Int32_) с аргументом [сборки Мусора. MaxGeneration](xref:System.GC.MaxGeneration). 



## <a name="cross-vm-object-collections"></a>Коллекции объектов между виртуальными Машинами

Существует три категории типов объектов.

-   **Управляемые объекты**: типы, которые выполняют *не* наследовать от [Java.Lang.Object](https://developer.xamarin.com/api/type/Java.Lang.Object/) , например [System.String](xref:System.String). 
    Они обычно собираются сборщиком Мусора. 

-   **Объекты Java**: Типы Java, которые присутствуют в среде выполнения Android виртуальной Машины, но не представлен на виртуальную машину с Mono. Это скучно и не будут рассматриваться далее. Они обычно собираются службой среды выполнения Android виртуальной Машины. 

-   **Одноранговые объекты**: типы, которые реализуют интерфейс [IJavaObject](https://developer.xamarin.com/api/type/Android.Runtime.IJavaObject/) , например все [Java.Lang.Object](https://developer.xamarin.com/api/type/Java.Lang.Object/) и [Java.Lang.Throwable](https://developer.xamarin.com/api/type/Java.Lang.Throwable/) подклассы. Экземпляры этих типов имеют два «halfs» *управляемых однорангового* и *собственного однорангового*. Управляемые однорангового узла представляет собой экземпляр C# класса. Собственный однорангового узла представляет собой экземпляр класса Java в среде выполнения Android виртуальной Машины и C# [IJavaObject.Handle](https://developer.xamarin.com/api/property/Android.Runtime.IJavaObject.Handle/) свойство содержит глобальные ссылки JNI собственного однорангового узла. 


Существует два типа собственного партнеров:

-   **Одноранговые узлы Framework** : «Normal» типов Java, которые ничего не знают о Xamarin.Android, например [android.content.Context](https://developer.xamarin.com/api/type/Android.Content.Context/).

-   **Одноранговые узлы пользователя** : [Android вызываемых оболочек](~/android/platform/java-integration/working-with-jni.md) которого создаются во время построения для каждый подкласс Java.Lang.Object, присутствует в приложении.


Поскольку существуют две виртуальные машины в рамках процесса Xamarin.Android, существует два типа сборки мусора.

-   Коллекции среды выполнения Android 
-   Mono коллекций 

Коллекции среды выполнения Android работают нормально, но Будьте осторожны: глобальные ссылки JNI рассматривается как корня сборки Мусора. Следовательно, если JNI глобальна ссылка удерживающих объект виртуальной Машины, поскольку объект среды выполнения Android *нельзя* собираться, даже если в противном случае он станет доступным для коллекции.

Mono коллекции являются местом выполнения удовольствие. Обычно собираются управляемые объекты. Одноранговые объекты собираются, выполнив следующую процедуру:

1.  Все объекты однорангового узла, доступным для Mono коллекции имеют свои глобальной ссылки JNI, заменены слабой глобальные ссылки JNI. 

2.  Вызывается Android среды выполнения сборки Мусора виртуальной Машины. Собираемые любой экземпляр собственного однорангового узла. 

3.  Проверяются слабые глобальные ссылки JNI, созданной на (1). Если были собраны слабую ссылку, собираются объект однорангового узла. Если есть слабую ссылку *не* собраны, затем слабая ссылка заменяется глобальной ссылки JNI и объект однорангового узла не собираются. Примечание: на API 14+, это означает, что значение, возвращаемое из `IJavaObject.Handle` может измениться после сборки Мусора. 

В результате все это, что экземпляр объекта однорангового узла будут находиться до тех пор, пока он ссылается либо управляемого кода (например, хранящиеся в `static` переменной) или ссылается на языке Java. Кроме того, время существования собственного одноранговые узлы будут расширены за то, что это было бы в противном случае в реальном времени, собственного одноранговый узел не будет собираемой до собираемой собственного однорангового узла и управляемые однорангового узла.


## <a name="object-cycles"></a>Циклов объекта

Одноранговые объекты логически присутствуют в пределах среды выполнения Android и Mono виртуальной Машины. Например [Android.App.Activity](https://developer.xamarin.com/api/type/Android.App.Activity/) однорангового управляемый экземпляр будет иметь соответствующий [android.app.Activity](https://developer.android.com/reference/android/app/Activity.html) экземпляр Java framework одноранговых узлов. Все объекты, наследующие от [Java.Lang.Object](https://developer.xamarin.com/api/type/Java.Lang.Object/) можно ожидать представлений в обеих виртуальных машин. 

Все объекты, которые имеют представление в обеих виртуальных машин будет иметь время существования которых расширяются по сравнению с объектами, которые присутствуют только в пределах одной виртуальной Машины (такие как [ `System.Collections.Generic.List<int>` ](xref:System.Collections.Generic.List%601)). Вызов [сборки Мусора. Собирать](xref:System.GC.Collect) не собираем обязательно таких объектов, как сборщик Мусора Xamarin.Android должны убедиться, что объект не ссылается на любой виртуальной Машины перед их сбор. 

Для сокращения времени существования объектов, [Java.Lang.Object.Dispose()](https://developer.xamarin.com/api/member/Java.Lang.Object.Dispose/) должны вызываться. Это будет вручную «» приведет к разрыву подключения объекта между двумя виртуальными машинами путем освобождения глобальной ссылки, таким образом, объектов, собираемых быстрее. 


## <a name="automatic-collections"></a>Автоматическое коллекций

Начиная с версии [версии 4.1.0](https://developer.xamarin.com/releases/android/mono_for_android_4/mono_for_android_4.1.0), Xamarin.Android автоматически выполняет полного сбора Мусора при пересечении gref, установленное пороговое значение. Это пороговое значение составляет 90% известных максимальное grefs для платформы: 1800 grefs в эмуляторе (2000 max) и 46800 grefs на оборудовании (максимальное 52000). *Примечание.* Xamarin.Android включает только grefs, созданные [Android.Runtime.JNIEnv](https://developer.xamarin.com/api/type/Android.Runtime.JNIEnv/)и не будет знать о других grefs, созданных в процессе. Это эвристики *только*. 

Когда выполняется автоматический сбор, выводится сообщение, аналогичное приведенному ниже журнал отладки:

```shell
I/monodroid-gc(PID): 46800 outstanding GREFs. Performing a full GC!
```

Вхождение это является недетерминированным, а также может произойти в неподходящие моменты (например, в середине отрисовки графики). Если вы видите это сообщение, вам может потребоваться выполнить явной коллекции в другом месте или вы можете попытаться [сократить время существования объектов одноранговых узлов](#Helping_the_GC). 

## <a name="gc-bridge-options"></a>Параметры моста GC

Xamarin.Android предоставляет управление прозрачного памятью с помощью среды выполнения Android и Android. Он реализуется как расширение Mono мусора вызывается *моста GC*. 

Мост сборщик Мусора работает во время сбора мусора Mono и рисунки, out какие одноранговых объектов требуется их «жизнеспособность», проверенный с помощью кучи среды выполнения Android. Мост GC осуществляет это определение, выполните указанные ниже действия (в порядке):

1.  Вызвать на графе mono ссылок объектов одноранговых узлов недоступен в объекты Java, которые они представляют. 

2.  Выполнение сборки Мусора Java.

3.  Проверьте, какие объекты действительно мертвы. 

Это сложный процесс позволяет подклассы `Java.Lang.Object` свободно ссылку на любые объекты; оно удаляет каких-либо ограничений, на какие Java объекты могут быть привязаны к C#. Из-за такой сложности процесса мост может быть очень дорогим, а также может вызвать заметное пауз в приложении. Если приложение испытывает значительное пауз, стоит одно из следующих трех реализаций моста GC: 

-   **Tarjan** -на основе совершенно новый дизайн моста GC [Роберт Tarjan алгоритм и обратной ссылки распространения](https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm).
    Она обеспечивает наибольшую производительность в наших имитации рабочей нагрузки, но он также имеет большую долю экспериментальный кода. 

-   **Новый** -кардинальных исходного кода, устранение два вхождения второго поведение но с сохранением основной алгоритм (на основе [Kosaraju алгоритм](https://en.wikipedia.org/wiki/Kosaraju's_algorithm) строго поиск связи между компонентами). 

-   **Старый** -исходной реализации (считается наиболее стабильная версия из трех). Это моста, приложения следует использовать, если `GC_BRIDGE` пауз являются допустимыми. 


Единственный способ понять, какие моста сборщик Мусора работает лучше всего — экспериментов в приложении и анализируя выходные данные. Для сбора данных для тестирования производительности двумя способами: 

-   **Включение ведения журнала** -включить ведение журнала (как описано в [конфигурации](~/android/internals/garbage-collection.md) разделе) для каждого параметра моста GC захватить данные и сравнить выходные данные журнала из каждого параметра. Проверьте `GC` сообщений для каждого параметра; в частности, `GC_BRIDGE` сообщения. Приостанавливает работу до 150ms для приемлемой неинтерактивных приложений, но пауз выше 60 мс для очень интерактивных приложений (например, игры) не проблема. 

-   **Включение учета моста** -мост учета отображается Средняя стоимость объектов, указываемых каждому из вовлечь в процесс моста объектов. Сортировка эту информацию по размеру предоставит указания о том, что был блокирован наибольший объем дополнительных объектов. 


Чтобы указать, какие `GC_BRIDGE` параметр приложения должна использовать, передавать `bridge-implementation=old`, `bridge-implementation=new` или `bridge-implementation=tarjan` для `MONO_GC_PARAMS` переменной среды, например: 

```shell
MONO_GC_PARAMS=bridge-implementation=tarjan
```

Значение по умолчанию — **Tarjan**. Если вы нашли Регрессия, вам может оказаться необходимым для этого параметра задано значение **старый**. Кроме того, вы можете использовать более стабильная работа **старый** Если **Tarjan** не создает повышение производительности. 

<a name="Helping_the_GC" />

## <a name="helping-the-gc"></a>Помогая сборщик Мусора

Существует несколько способов, позволяющих сократить время сбор и использование памяти сборщик Мусора.



### <a name="disposing-of-peer-instances"></a>Удаление экземпляров однорангового узла

Сборщик Мусора имеет неполные представление процесса и нельзя запустить памяти при низком уровне, так как сборщик Мусора не знает, что памяти недостаточно. 

Например, экземпляр [Java.Lang.Object](https://developer.xamarin.com/api/type/Java.Lang.Object/) тип или производный тип является размер по крайней мере 20 байт (может быть изменена без предварительного уведомления и др., и т.д.). 
[Управляемые вызываемых оболочек времени](~/android/internals/architecture.md) добавляет дополнительный экземпляр членов, поэтому при наличии [Android.Graphics.Bitmap](https://developer.xamarin.com/api/type/Android.Graphics.Bitmap/) экземпляр, который ссылается на большой двоичный объект 10 МБ памяти, сборщик Мусора Xamarin.Android не будет знать, что &ndash; сборщик Мусора увидите объект 20-байтный и не сможет определить, что она связана с Android размещенных в среде выполнения объектов, поддержания 10 МБ памяти. 

Часто бывает необходимо помочь сборщик Мусора. К сожалению *сборки Мусора. AddMemoryPressure()* и *сборки Мусора. RemoveMemoryPressure()* не поддерживаются, поэтому, если вы *знать* только что освободила граф больших объектов, выделенных в Java, может потребоваться вручную вызвать [сборки Мусора. Collect()](xref:System.GC.Collect) в окно запроса сборки Мусора для освобождения со стороны Java памяти, или можно явно удалять *Java.Lang.Object* подклассов, критические сопоставление управляемых вызываемой оболочки и экземпляр Java. Например, см. в разделе [1084 ошибки](http://bugzilla.xamarin.com/show_bug.cgi?id=1084#c6). 


> [!NOTE]
> Будьте *чрезвычайно* внимательны при утилизации `Java.Lang.Object` подкласс экземпляров.

Чтобы свести к минимуму вероятность повреждения содержимого памяти, просмотрите следующие рекомендации при вызове `Dispose()`.


#### <a name="sharing-between-multiple-threads"></a>Совместное использование нескольких потоков

Если *Java или управляемых* экземпляра могут совместно использоваться несколькими потоками *не должно быть `Dispose()`d*, **когда-нибудь**. Например [`Typeface.Create()`](https://developer.xamarin.com/api/member/Android.Graphics.Typeface.Create/(System.String%2cAndroid.Graphics.TypefaceStyle)) 
может возвращать *кэшированный экземпляр*. Если несколько потоков предоставляют те же аргументы, они будут получать *же* экземпляра. Следовательно `Dispose()`любого из `Typeface` экземпляр из одного потока может сделать недействительными другие потоки, которые могут привести к `ArgumentException`s из `JNIEnv.CallVoidMethod()` (среди прочего), так как экземпляр был удален из другого потока. 


#### <a name="disposing-bound-java-types"></a>Удаление типов связанных Java

Если экземпляр имеет связанный тип Java, экземпляр может быть удален *, пока* из управляемого кода не будет повторно использовать экземпляр *и* экземпляр Java не может быть общим для потоков (см. предыдущий `Typeface.Create()` обсуждение). (Дело обстоит может быть сложным.) В следующий раз Java экземпляр переходит в управляемом коде, *новый* оболочки создается для него. 

Это часто полезно в тех случаях, когда дело доходит до прорисовываемых ресурсов и другие экземпляры с большим количеством ресурсов:

```csharp
using (var d = Drawable.CreateFromPath ("path/to/filename"))
    imageView.SetImageDrawable (d);
```

Выше можно безопасно поскольку однорангового узла, [Drawable.CreateFromPath()](https://developer.xamarin.com/api/member/Android.Graphics.Drawables.Drawable.CreateFromPath/) возвращает будет ссылаться на Framework однорангового узла, *не* однорангового узла пользователя. `Dispose()` Вызывать в конце `using` блок приведет к разрыву связи между управляемой [Drawable](https://developer.xamarin.com/api/type/Android.Graphics.Drawables.Drawable/) и framework [Drawable](https://developer.android.com/reference/android/graphics/drawable/Drawable.html) экземпляров, позволяя к экземпляру Java собранные сразу же после выполнения Android требуется. Это будет *не* гарантируется, если одноранговый экземпляр ссылались на одноранговый узел пользователя; здесь мы используем «external» сведения для *знать* , `Drawable` не может ссылаться на одноранговый узел пользователя и, следовательно, `Dispose()` вызова можно безопасно. 


#### <a name="disposing-other-types"></a>Удаление других типов 

Если экземпляр относится к типу, не привязкой этого типа Java (например настраиваемый `Activity`), **ВООБЩЕ не** вызвать `Dispose()` Если вы *знать* что применительно к, код Java не вызывать переопределенные методы экземпляр. Невыполнение этого требования приводит [ `NotSupportedException`s](~/android/internals/architecture.md#Premature_Dispose_Calls). 

Например если у вас есть пользовательский щелкните прослушиватель:

```csharp
partial class MyClickListener : Java.Lang.Object, View.IOnClickListener {
    // ...
}
```

Вы *не должны* dispose данного экземпляра, как Java будет пытаться вызывать методы на его в будущем:

```csharp
// BAD CODE; DO NOT USE
Button b = FindViewById<Button> (Resource.Id.myButton);
using (var listener = new MyClickListener ())
    b.SetOnClickListener (listener);
```


#### <a name="using-explicit-checks-to-avoid-exceptions"></a>С помощью явных проверок, чтобы избежать исключений

Если вы реализовали [Java.Lang.Object.Dispose](https://developer.xamarin.com/api/member/Java.Lang.Object.Dispose(System.Boolean)/) перегрузки метода, не касаясь объекты, включающие JNI. Это может привести к *dispose двойной* ситуацию, которая делает возможным для кода (пагубно) попытка получить доступ к базовый объект Java, которая уже была собрана сборщиком мусора. Это создает исключение, аналогичную следующей: 

```shell
System.ArgumentException: 'jobject' must not be IntPtr.Zero.
Parameter name: jobject
at Android.Runtime.JNIEnv.CallVoidMethod
```

Эта ситуация часто возникает, когда первый метод dispose объекта вызывает элемент принимают значение null, а затем сообщение об ошибке попытки последующего доступа для этого элемента null приводит к возникновению исключения, исключение. В частности, объекта `Handle` на первый dispose (который связывает управляемого экземпляра его базового экземпляра Java) является недействительным, но управляемый код по-прежнему пытается получить доступ к этой нижележащего экземпляра Java, несмотря на то, что он больше не доступна (см. [ Управляемые вызываемых оболочек](~/android/internals/architecture.md#Managed_Callable_Wrappers) Дополнительные сведения о сопоставлении между экземплярами Java и управляемых экземпляров). 

Хороший способ предотвратить это исключение является явным образом проверить в вашей `Dispose` метод, который все еще действителен; это сопоставление между управляемым экземпляром и нижележащего экземпляра Java, проверьте правильность объекта `Handle` имеет значение null (`IntPtr.Zero`) Перед обращением к их элементам. Например, следующая `Dispose` метод обращается к `childViews` объекта: 

```csharp
class MyClass : Java.Lang.Object, ISomeInterface 
{
    protected override void Dispose (bool disposing)
    {
        base.Dispose (disposing);
        for (int i = 0; i < this.childViews.Count; ++i)
        {
            // ...
        }
    }
}
```

Если начальная dispose передается причины `childViews` требуется при использовании недопустимого `Handle`, `for` доступа цикл создаст исключение `ArgumentException`. Добавив явно `Handle` значение null, проверка перед первым `childViews` доступ к следующих `Dispose` метод предотвращает возникновение исключения: 

```csharp
class MyClass : Java.Lang.Object, ISomeInterface 
{
    protected override void Dispose (bool disposing)
    {
        base.Dispose (disposing);

        // Check for a null handle:
        if (this.childViews.Handle == IntPtr.Zero)
            return;

        for (int i = 0; i < this.childViews.Count; ++i)
        {
            // ...
        }
    }
}
```


### <a name="reduce-referenced-instances"></a>Уменьшить экземпляров, на которую указывает ссылка

Каждый раз, когда экземпляр `Java.Lang.Object` типа или подкласс проверяется во время сборки Мусора, весь *графа объектов* что экземпляр относится к должны просматриваться. Граф объекта — это набор экземпляров объектов, на которые ссылается «корневой экземпляр», *, а также* все ссылается экземпляр корневого ссылается, рекурсивно. 

Рассмотрим следующий класс:

```csharp
class BadActivity : Activity {

    private List<string> strings;

    protected override void OnCreate (Bundle bundle)
    {
        base.OnCreate (bundle);

        strings.Value = new List<string> (
                Enumerable.Range (0, 10000)
                .Select(v => new string ('x', v % 1000)));
    }
}
```

При `BadActivity` будет создано, граф объекта будет содержать 10004 экземпляров (1 x `BadActivity`, 1 x `strings`, 1 x `string[]` удерживаемые `strings`, 10000 x экземплярами класса string), *все* из которой необходимо будет Каждый раз, когда сканирование `BadActivity` сканируется экземпляра. 

Это может оказать неблагоприятное влияние на время вашей коллекции, в результате чего увеличивается время пауз GC. 

Вы можете помочь сборщик Мусора по *уменьшение* размер графов объектов, которые связаны с экземплярами однорангового узла пользователя. В приведенном выше примере, это можно сделать, переместив `BadActivity.strings` в отдельный класс, который не наследуется от Java.Lang.Object: 

```csharp
class HiddenReference<T> {

    static Dictionary<int, T> table = new Dictionary<int, T> ();
    static int idgen = 0;

    int id;

    public HiddenReference ()
    {
        lock (table) {
            id = idgen ++;
        }
    }

    ~HiddenReference ()
    {
        lock (table) {
            table.Remove (id);
        }
    }

    public T Value {
        get { lock (table) { return table [id]; } }
        set { lock (table) { table [id] = value; } }
    }
}

class BetterActivity : Activity {

    HiddenReference<List<string>> strings = new HiddenReference<List<string>>();

    protected override void OnCreate (Bundle bundle)
    {
        base.OnCreate (bundle);

        strings.Value = new List<string> (
                Enumerable.Range (0, 10000)
                .Select(v => new string ('x', v % 1000)));
    }
}
```


## <a name="minor-collections"></a>Дополнительный номер коллекций

Дополнительный номер коллекции могут выполняться вручную путем вызова [сборки Мусора. Collect(0)](xref:System.GC.Collect). Дополнительный номер коллекции — это требует больших затрат, (по сравнению с основной коллекции), имеют значительные фиксированные, поэтому вы не хотите активировать их слишком часто, но должны иметь время приостановки, равное нескольким миллисекундам. 

Если приложение имеет «рабочая нагрузка» в котором то же самое делается снова и снова, возможно, рекомендуется выполнять вручную, дополнительный номер коллекции после завершения рабочий цикл. Пример рабочих циклов включают: 

-  Цикл обработки одного кадра игры.
-  Всего взаимодействие с диалоговое окно приложения (Открытие, заполнения, закрытие) 
-  Группа сетевых запросов для обновления и синхронизации данных приложения.



## <a name="major-collections"></a>Основной коллекции

Основной коллекции могут выполняться вручную путем вызова [сборки Мусора. Collect()](xref:System.GC.Collect) или `GC.Collect(GC.MaxGeneration)`. 

Они должны выполняться редко и может иметь время приостановки доли секунды на устройстве Android стиле при сборе данных кучи 512 МБ. 

Основной коллекции вручную вызывается только, если когда-либо: 

-   В конце длительных пошлины циклов и когда приостановить long не является проблемой для пользователя. 

-   В переопределенный [Android.App.Activity.OnLowMemory()](https://developer.xamarin.com/api/member/Android.App.Activity.OnLowMemory/) метод. 



## <a name="diagnostics"></a>Диагностика

Для отслеживания, когда глобальные ссылки создаются и удаляются, можно задать [debug.mono.log](~/android/troubleshooting/index.md) системное свойство, чтобы содержать [ *gref, установленное* ](~/android/troubleshooting/index.md) и/или [ *gc*](~/android/troubleshooting/index.md). 



## <a name="configuration"></a>Параметр Configuration

Сборщик мусора Xamarin.Android можно настроить, задав `MONO_GC_PARAMS` переменной среды. Могут быть установлены переменные среды с действием сборки [AndroidEnvironment](~/android/deploy-test/environment.md).

`MONO_GC_PARAMS` Переменная среды — это разделенный запятыми список следующих параметров: 

-   `nursery-size` = *размер* : Задает размер инкубатор. Размер указывается в байтах и должен быть степенью двух. Суффиксы `k` , `m` и `g` может использоваться для указания килограмм-, мегабайт - и гигабайта, соответственно. Инкубатор — это первое поколение (два). Больше инкубатор обычно ускорит программы, но очевидно, что будут использовать больше памяти. Инкубатор по умолчанию размер 512 КБ. 

-   `soft-heap-limit` = *размер* : Максимальный целевой управляемых потребление памяти для приложения. Если использование памяти не превышает указанное значение, GC оптимизирован для времени выполнения (меньшее число коллекций). 
    Превышает этот предел GC оптимизирован для использования памяти (больше коллекций). 

-   `evacuation-threshold` = *Пороговое значение* : Задает эвакуации пороговое значение в процентах. Значение должно быть целым числом в диапазоне от 0 до 100. По умолчанию используется 66. Если на этапе очистки коллекции обнаруживает, что степень заполненности типа блока определенной кучи не превышает этот процент, она сделает копирование коллекцию для этого типа блока в следующей основной коллекции, тем самым восстановив степень заполненности для близким к 100 процентам. Значение 0 отключает эвакуации. 

-   `bridge-implementation` = *мост реализации* : Это установит параметр GC моста, чтобы помочь устранить проблемы производительности сборки Мусора. Существует три возможных значения: *старый* , *новый* , *tarjan*.

-   `bridge-require-precise-merge`: Tarjan, мост содержит оптимизации, что может в редких случаях привести объект как собраны один сборщик Мусора после становится сборки мусора. Включая этот параметр отключает что оптимизация, что делает более предсказуемым, но потенциально медленнее глобальных каталогов.

Например, чтобы настроить сборщик Мусора имеет ограничение на размер кучи 128 МБ, добавьте новый файл в проект с **действие при сборке** из `AndroidEnvironment` с содержимым: 

```shell
MONO_GC_PARAMS=soft-heap-limit=128m
```
