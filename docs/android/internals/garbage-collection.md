---
title: Сборка мусора
ms.prod: xamarin
ms.assetid: 298139E2-194F-4A58-BC2D-1D22231066C4
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 03/15/2018
ms.openlocfilehash: 40fb8f81a82aab9e7d9d3ea3bf4084c14cb6d4ff
ms.sourcegitcommit: 57f815bf0024b1afe9754c0e28054fc0a53ce302
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70757922"
---
# <a name="garbage-collection"></a>Сборка мусора

Xamarin. Android использует [простой сборщик мусора](https://www.mono-project.com/docs/advanced/garbage-collector/sgen/)Mono. Это сборщик мусора пометки и очистки с двумя поколениями и *пространством больших объектов*с двумя типами коллекций: 

- Вспомогательные коллекции (сбор данных в куче Gen0) 
- Основные коллекции (собирающие кучи Gen1 и пространства больших объектов). 

> [!NOTE]
> При отсутствии явной коллекции через [GC. Сбор данных ()](xref:System.GC.Collect) выполняется *по требованию на*основе выделения кучи. *Это не является системой подсчета ссылок*; объекты *не будут собираться сразу после отсутствия необработанных ссылок*или при выходе из области. Сборщик мусора будет запущен, когда во вспомогательной куче не хватает памяти для новых выделений. Если распределения отсутствуют, они не будут запущены.

Небольшие коллекции являются недорогими и часто используются для сбора недавно выделенных и неработающих объектов. Дополнительные коллекции выполняются после каждых нескольких МБ выделенных объектов. Вспомогательные коллекции могут выполняться вручную путем вызова [GC. Получение (0)](/dotnet/api/system.gc.collect#System_GC_Collect_System_Int32_) 

Основные коллекции являются дорогостоящими и менее частыми и используются для освобождения всех неработающих объектов. Основные коллекции выполняются после исчерпания памяти для текущего размера кучи (до изменения размера кучи). Основные коллекции можно выполнить вручную, вызвав [GC. Сбор ()](xref:System.GC.Collect) или вызов [GC. Сбор (int)](/dotnet/api/system.gc.collect#System_GC_Collect_System_Int32_) с аргументом [GC. Максженератион](xref:System.GC.MaxGeneration). 

## <a name="cross-vm-object-collections"></a>Коллекции объектов между виртуальными машинами

Существует три категории типов объектов.

- **Управляемые объекты**: типы, которые *не* наследуют от [Java. lang. Object](xref:Java.Lang.Object) , например [System. String](xref:System.String). 
    Они обычно собираются сборщиком мусора. 

- **Объекты Java**: Типы Java, которые находятся на ВИРТУАЛЬНОЙ машине среды выполнения Android, но не предоставляются виртуальной машине Mono. Они скучны и не будут обсуждаться дальше. Они обычно собираются виртуальной машиной среды выполнения Android. 

- **Одноранговые объекты**: типы, которые реализуют [ижаваобжект](xref:Android.Runtime.IJavaObject) , например все [Java. lang. Object](xref:Java.Lang.Object) и [Java. lang. throws](xref:Java.Lang.Throwable) . Экземпляры этих типов имеют две "половины" *управляемого однорангового узла* и *собственного однорангового узла*. Управляемый одноранговый узел является экземпляром C# класса. Собственный одноранговый узел является экземпляром класса Java на виртуальной машине среды выполнения Android, а C# свойство [ижаваобжект. Handle](xref:Android.Runtime.IJavaObject.Handle) содержит глобальную ссылку JNI на собственный одноранговый узел. 

Существует два типа собственных одноранговых узлов:

- **Одноранговые узлы платформы** : «Обычные» типы Java, которые ничего не знает о Xamarin. Android, например   [Android. Content. Context](xref:Android.Content.Context).

- **Одноранговые узлы пользователей** :   [Вызываемые оболочки Android](~/android/platform/java-integration/working-with-jni.md) , создаваемые во время сборки для каждого подкласса Java. lang. Object, присутствующего в приложении.

Так как в процессе Xamarin. Android есть две виртуальные машины, существует два типа сборок мусора:

- Коллекции среды выполнения Android 
- Коллекции Mono 

Коллекции среды выполнения Android работают нормально, но с помощью предупреждения: Глобальная ссылка JNI рассматривается как корень GC. Следовательно, если имеется глобальная ссылка JNI, содержащая объект виртуальной машины среды выполнения Android, объект *не может* быть собран, даже если он подходит для коллекции.

Коллекции Mono — это то, где происходит веселое. Управляемые объекты собираются как обычно. Одноранговые объекты собираются путем выполнения следующего процесса:

1. Все одноранговые объекты, подходящие для коллекции Mono, имеют глобальную ссылку JNI, замененную JNI ненадежной глобальной ссылкой. 

2. Вызывается сборщик мусора виртуальной машины среды выполнения Android. Может быть собран любой собственный одноранговый экземпляр. 

3. Проверяются слабые глобальные ссылки JNI, созданные в (1). Если слабая ссылка была собрана, то собирается одноранговый объект. Если слабая ссылка *не* была собрана, слабая ссылка заменяется глобальной ссылкой на JNI, а одноранговый объект не собирается. Примечание. в API 14 + это означает, что значение, возвращаемое `IJavaObject.Handle` из, может измениться после сборки мусора. 

Конечным результатом всего этого является то, что экземпляр однорангового объекта будет жить до тех пор, пока на него ссылается управляемый код (например, `static` сохраненный в переменной) или на него ссылается код Java. Более того, время существования собственных одноранговых узлов будет больше, чем в противном случае, так как собственный одноранговый узел не будет подключаться до тех пор, пока выполняется сбор как собственного однорангового, так и управляемого.

## <a name="object-cycles"></a>Циклы объектов

Одноранговые объекты логически представлены как в среде выполнения Android, так и в виртуальной машине Mono. Например, экземпляр управляемого однорангового узла [Android. app. Activity](xref:Android.App.Activity) будет иметь соответствующий экземпляр Java для платформы [Android. app. Activity](https://developer.android.com/reference/android/app/Activity.html) . Все объекты, наследующие [Java. lang. Object](xref:Java.Lang.Object) , могут иметь представления в обеих виртуальных машинах. 

Все объекты, имеющие представление на обеих виртуальных машинах, будут иметь время существования, которое расширено по сравнению с объектами, присутствующими только в [`System.Collections.Generic.List<int>`](xref:System.Collections.Generic.List%601)пределах одной виртуальной машины (например,). Вызов [GC. Сбор](xref:System.GC.Collect) данных не обязательно будет собирать эти объекты, так как в Xamarin. Android GC необходимо убедиться, что ни одна виртуальная машина не ссылается на объект, прежде чем собирать его. 

Чтобы сократить время существования объекта, необходимо вызвать [Java. lang. Object. Dispose ()](xref:Java.Lang.Object.Dispose) . Это позволит вручную «серьезное» подключение к объекту между двумя виртуальными машинами, освобождая глобальную ссылку, тем самым позволяя быстрее собирать объекты. 

## <a name="automatic-collections"></a>Автоматические коллекции

Начиная с [выпуска Release 4.1.0](https://github.com/xamarin/release-notes-archive/blob/master/release-notes/android/mono_for_android_4/mono_for_android_4.1.0/index.md), Xamarin. Android автоматически выполняет полную сборку мусора, когда пороговое значение Греф пересекается. Это пороговое значение равно 90% от известного максимального грефс для платформы: 1800 грефс в эмуляторе (2000 max) и 46800 грефс на оборудовании (максимум 52000). *Примечание.* Xamarin. Android подсчитывает только грефс, созданные [Android. Runtime. жниенв](xref:Android.Runtime.JNIEnv), и не узнает о других грефс, созданных в процессе. Это *только*эвристический подход. 

При выполнении автоматической сборки в журнал отладки будет выведено сообщение следующего вида:

```shell
I/monodroid-gc(PID): 46800 outstanding GREFs. Performing a full GC!
```

Вхождение этого параметра является недетерминированным и может происходить в иноппортуне раз (например, в середине отрисовки графики). Если вы видите это сообщение, вам может потребоваться выполнить явную коллекцию в других местах или попытаться [сократить время существования одноранговых объектов](#Helping_the_GC). 

## <a name="gc-bridge-options"></a>Параметры моста GC

Xamarin. Android обеспечивает прозрачное управление памятью с помощью Android и среды выполнения Android. Он реализуется как расширение для сборщика мусора Mono, называемого *мостом GC*. 

Мост GC работает во время сборки мусора Mono и определяет, какие одноранговые объекты требуют своего "реальной" проверки с помощью кучи среды выполнения Android. Мост GC выполняет это определение, выполняя следующие действия (по порядку):

1. Вызов графа справочника Mono недостижимых одноранговых объектов в объекты Java, которые они представляют. 

2. Выполните Java GC.

3. Проверьте, какие объекты на самом деле отсутствуют. 

Этот сложный процесс позволяет подклассам `Java.Lang.Object` свободно ссылаться на любые объекты. он устраняет все ограничения, с C#которыми могут быть связаны объекты Java. Из-за этой сложности процесс моста может быть очень ресурсоемким и может привести к заметным паузам в приложении. Если приложение испытывает значительные паузы, стоит изучить одну из следующих трех реализаций моста GC: 

- **Таржан** — совершенно новая структура моста GC на основе [алгоритма Роберт таржан и обратного распространения ссылок](https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm).
    Она обладает лучшей производительностью в моделируемых рабочих нагрузках, но она также имеет большую общую папку экспериментального кода. 

- **New** — основной ремонт исходного кода с устранением двух экземпляров поведений в виде квадратичного поведения, но с удержанием основного алгоритма (на основе [алгоритма косаражу](https://en.wikipedia.org/wiki/Kosaraju's_algorithm) для поиска строго подключенных компонентов). 

- **Old** — исходная реализация (считается наиболее стабильной из трех). Это мост, который приложение должно использовать, если `GC_BRIDGE` паузы приемлемы. 

Единственный способ выяснить, какой оптимальный мост GC работает, — эксперименты в приложении и анализ выходных данных. Существует два способа получить данные для тестирования производительности: 

- **Включите ведение журнала** . Включите ведение журнала (как описано в разделе [Конфигурация](~/android/internals/garbage-collection.md) ) для каждого параметра моста GC, а затем запишите и сравните выходные данные журнала из каждого параметра. Проверьте сообщения для каждого параметра `GC_BRIDGE` , в частности сообщения. `GC` Приостановка до 150ms для неинтерактивных приложений — приемлемой, но приостановка над 60ms для очень интерактивных приложений (например, игр) является проблемой. 

- **Включить учет моста** . при учете моста будут отображаться средние затраты на объекты, на которые указывает каждый объект, участвующий в процессе моста. При сортировке этих сведений по размеру будут предоставлены указания на то, что удерживает самый крупный объем дополнительных объектов. 

Чтобы указать, `GC_BRIDGE` какой вариант приложения должен иметь значение, `bridge-implementation=old` `bridge-implementation=new` передать или `bridge-implementation=tarjan` в `MONO_GC_PARAMS` переменную среды, например: 

```shell
MONO_GC_PARAMS=bridge-implementation=tarjan
```

Значение по умолчанию — **таржан**. Если вы обнаружите регрессию, может потребоваться установить для этого параметра значение **Old**. Кроме того, вы можете использовать более стабильный **старый** вариант, если **таржан** не приводит к повышению производительности. 

<a name="Helping_the_GC" />

## <a name="helping-the-gc"></a>Помощь в сборке мусора

Существует несколько способов помочь сборщику мусора сократить использование памяти и время сбора.

### <a name="disposing-of-peer-instances"></a>Удаление одноранговых экземпляров

Сборщик мусора имеет неполное представление о процессе и может не запускаться, если память мала, так как сборщик мусора не знает, что память мала. 

Например, экземпляр типа [Java. lang. Object](xref:Java.Lang.Object) или производного типа имеет размер не менее 20 байт (может быть изменен без уведомления и т. д.). 
[Управляемые вызываемые оболочки](~/android/internals/architecture.md) не добавляют дополнительные члены экземпляра, поэтому при наличии экземпляра [Android. Graphics. Bitmap](xref:Android.Graphics.Bitmap) , который ссылается на большой двоичный объект размером 10 МБ памяти, в сборщике мусора Xamarin &ndash; . Android не будет известно, что сборщик мусора увидит 20-байтный объект и не сможет определить, что он связан с объектами, выделенными средой выполнения Android и не может поддерживать 10 МБ памяти. 

Часто возникает необходимость в помощи сборщика мусора. Увы, *GC. Аддмеморипрессуре ()* и *GC. RemoveMemoryPressure ()* не поддерживаются, поэтому, если *известно* , что вы только что освободили большой объем выделенной Java диаграммы объектов, может потребоваться вручную вызвать [GC. Выполните сбор ()](xref:System.GC.Collect) , чтобы предложить сборщику мусора освободить память на стороне Java, или можно явно удалить подклассы *Java. lang. Object* , разбивая сопоставление между управляемой вызываемой оболочкой и экземпляром Java. Например, см. [ошибку 1084](http://bugzilla.xamarin.com/show_bug.cgi?id=1084#c6). 

> [!NOTE]
> При`Java.Lang.Object` удалении экземпляров подклассов необходимо быть *предельно* осторожным.

Для снижения вероятности повреждения памяти при вызове `Dispose()`необходимо учитывать следующие рекомендации.

#### <a name="sharing-between-multiple-threads"></a>Совместное использование нескольких потоков

Если *Java или управляемый* экземпляр может совместно использоваться несколькими потоками, *он никогда не должен `Dispose()`быть d*. Например[`Typeface.Create()`](xref:Android.Graphics.Typeface.Create*) 
может возвращать *кэшированный экземпляр*. Если несколько потоков предоставляют одинаковые аргументы, они получают *один и тот же* экземпляр. Следовательно, `Dispose()` `ArgumentException`при создании `JNIEnv.CallVoidMethod()` экземпляра из одного потока могут оказаться недействительными другие потоки, что может привести к появлению из других потоков, поскольку экземпляр был удален из другого потока. `Typeface` 

#### <a name="disposing-bound-java-types"></a>Удаление привязанных типов Java

Если экземпляр имеет привязанный тип Java, экземпляр может быть удален до тех *пор* , пока экземпляр не будет повторно использован из управляемого кода *и* экземпляр Java не будет совместно использоваться другими потоками (см. предыдущее `Typeface.Create()` обсуждение). (Такое определение может оказаться затруднительным.) В следующий раз, когда экземпляр Java войдет в управляемый код, для него будет создана *Новая* оболочка. 

Это часто полезно, когда речь идет о Драваблес и других ресурсоемких экземплярах:

```csharp
using (var d = Drawable.CreateFromPath ("path/to/filename"))
    imageView.SetImageDrawable (d);
```

Приведенная выше безопасность является надежной, так как одноранговый объект, который можно использовать для [рисования. креатефромпас ()](xref:Android.Graphics.Drawables.Drawable.CreateFromPath*) , ссылается на одноранговый узел платформы, а *не* на одноранговый Вызов в конце `using` блока приведет к нарушению связи между управляемыми [рисуемыми экземплярами и](xref:Android.Graphics.Drawables.Drawable) создаваемыми [платформами](https://developer.android.com/reference/android/graphics/drawable/Drawable.html) , позволяя собирать экземпляр Java сразу после того, как среда выполнения Android потребуется. `Dispose()` Это *не* будет быть надежным, если одноранговый экземпляр ссылается на одноранговый узел пользователя; Здесь мы используем «внешние» сведения, чтобы *убедиться* , что `Drawable` объект не может ссылаться на одноранговый узел пользователя `Dispose()` , поэтому вызов является типобезопасным. 

#### <a name="disposing-other-types"></a>Удаление других типов 

Если экземпляр ссылается на тип, который не является привязкой типа Java ( `Activity`например, пользовательского), не вызывайте **метод** `Dispose()` , если не *известно* , что код Java не будет вызывать переопределенные методы в этом экземпляре. В противном случае результаты в [ `NotSupportedException`s](~/android/internals/architecture.md#Premature_Dispose_Calls). 

Например, если у вас есть пользовательский прослушиватель щелчка:

```csharp
partial class MyClickListener : Java.Lang.Object, View.IOnClickListener {
    // ...
}
```

*Не следует* удалять этот экземпляр, так как Java будет пытаться вызывать в будущем методы.

```csharp
// BAD CODE; DO NOT USE
Button b = FindViewById<Button> (Resource.Id.myButton);
using (var listener = new MyClickListener ())
    b.SetOnClickListener (listener);
```

#### <a name="using-explicit-checks-to-avoid-exceptions"></a>Использование явных проверок для предотвращения исключений

Если вы реализовали метод перегрузки [Java. lang. Object. Dispose](xref:Java.Lang.Object.Dispose*) , старайтесь не касаться объектов, использующих JNI. Это может создать ситуацию *двойного удаления* , которая позволяет коду (неустранимо) попытаться получить доступ к базовому объекту Java, который уже был собран сборщиком мусора. При этом создается исключение, аналогичное следующему: 

```shell
System.ArgumentException: 'jobject' must not be IntPtr.Zero.
Parameter name: jobject
at Android.Runtime.JNIEnv.CallVoidMethod
```

Такая ситуация часто возникает, когда первая ликвидация объекта приводит к тому, что элемент будет иметь значение null, а последующие попытки доступа к этому элементу NULL приводят к возникновению исключения. В частности, объект `Handle` (который связывает управляемый экземпляр с его базовым экземпляром Java) становится недействительным при первом удалении, но управляемый код по-прежнему пытается получить доступ к этому базовому экземпляру Java, даже если он больше не доступен (см. [ Управляемые вызываемые оболочки](~/android/internals/architecture.md#Managed_Callable_Wrappers) для получения дополнительных сведений о сопоставлении между экземплярами Java и управляемыми экземплярами. 

Хорошим способом предотвратить это исключение является явное подтверждение в `Dispose` методе, что сопоставление между управляемым экземпляром и базовым экземпляром Java по-прежнему является допустимым; то есть проверьте, `Handle` имеет ли объект значение null (`IntPtr.Zero`). перед доступом к его членам. Например, следующий `Dispose` метод обращается к `childViews` объекту: 

```csharp
class MyClass : Java.Lang.Object, ISomeInterface 
{
    protected override void Dispose (bool disposing)
    {
        base.Dispose (disposing);
        for (int i = 0; i < this.childViews.Count; ++i)
        {
            // ...
        }
    }
}
```

Если в результате первого прохода Dispose `childViews` происходит недопустимое `Handle`значение, `for` доступ к циклу будет вызывать `ArgumentException`исключение. При добавлении явной `Handle` проверки значения null перед первым `childViews` доступом следующий `Dispose` метод предотвращает возникновение исключения: 

```csharp
class MyClass : Java.Lang.Object, ISomeInterface 
{
    protected override void Dispose (bool disposing)
    {
        base.Dispose (disposing);

        // Check for a null handle:
        if (this.childViews.Handle == IntPtr.Zero)
            return;

        for (int i = 0; i < this.childViews.Count; ++i)
        {
            // ...
        }
    }
}
```

### <a name="reduce-referenced-instances"></a>Уменьшить экземпляры, на которые указывает ссылка

При сканировании экземпляра `Java.Lang.Object` типа или подкласса во время сборки мусора весь *граф объектов* , на который ссылается экземпляр, также должен быть проверен. Граф объектов — это набор экземпляров объектов, на которые ссылается корневой экземпляр, *а также* все, на которое ссылается корневой экземпляр, рекурсивный. 

Рассмотрим следующий класс:

```csharp
class BadActivity : Activity {

    private List<string> strings;

    protected override void OnCreate (Bundle bundle)
    {
        base.OnCreate (bundle);

        strings.Value = new List<string> (
                Enumerable.Range (0, 10000)
                .Select(v => new string ('x', v % 1000)));
    }
}
```

Когда `BadActivity` создается объект, граф объектов будет содержать 10004 экземпляров (1x `BadActivity`, `strings`1x `strings`, 1x `string[]` , удерживаемые экземплярами строк 10000x), *все* из которых необходимо проверять каждый раз, когда `BadActivity` экземпляр сканируется. 

Это может негативно повлиять на время сбора, что приведет к увеличению времени приостановки сборки мусора. 

Вы можете помочь сборщику мусора, *уменьшая* размер графов объектов, которые находятся в корне с помощью одноранговых экземпляров пользователей. В приведенном выше примере это можно сделать, переместив `BadActivity.strings` в отдельный класс, который не наследует от Java. lang. Object: 

```csharp
class HiddenReference<T> {

    static Dictionary<int, T> table = new Dictionary<int, T> ();
    static int idgen = 0;

    int id;

    public HiddenReference ()
    {
        lock (table) {
            id = idgen ++;
        }
    }

    ~HiddenReference ()
    {
        lock (table) {
            table.Remove (id);
        }
    }

    public T Value {
        get { lock (table) { return table [id]; } }
        set { lock (table) { table [id] = value; } }
    }
}

class BetterActivity : Activity {

    HiddenReference<List<string>> strings = new HiddenReference<List<string>>();

    protected override void OnCreate (Bundle bundle)
    {
        base.OnCreate (bundle);

        strings.Value = new List<string> (
                Enumerable.Range (0, 10000)
                .Select(v => new string ('x', v % 1000)));
    }
}
```

## <a name="minor-collections"></a>Вспомогательные коллекции

Вспомогательные коллекции могут выполняться вручную путем вызова [GC. Собирайте (0)](xref:System.GC.Collect). Небольшие коллекции являются недорогими (по сравнению с основными коллекциями), но имеют значительные фиксированные затраты, поэтому вы не хотите вызывать их слишком часто и иметь время паузы в течение нескольких миллисекунд. 

Если в приложении есть "цикл работы", в ходе которого одно и то же действие выполняется повторно, может быть целесообразно вручную выполнить дополнительный сбор после завершения цикла пошлины. Ниже приведены примеры рабочих циклов. 

- Цикл отрисовки отдельного кадра игры.
- Все взаимодействие с заданным диалоговым окном приложения (открытие, заполнение, закрытие) 
- Группа сетевых запросов на обновление и синхронизацию данных приложения.

## <a name="major-collections"></a>Основные коллекции

Основные коллекции можно выполнить вручную, вызвав [GC. Собирайте ()](xref:System.GC.Collect) или `GC.Collect(GC.MaxGeneration)`. 

Они должны выполняться редко и могут иметь время паузы в секунду на устройстве в стиле Android при сборе кучи 512 МБ. 

Основные коллекции следует вызывать только вручную, если когда-либо: 

- По завершении длительных циклов пошлины, и когда долгая пауза не будет представлять проблему пользователю. 

- В переопределенном методе [Android. app. Activity. онловмемори ()](xref:Android.App.Activity.OnLowMemory) . 

## <a name="diagnostics"></a>Диагностика

Чтобы определить, когда глобальные ссылки создаются и уничтожаются, можно установить системное свойство [Debug. моно. log](~/android/troubleshooting/index.md) , чтобы оно содержало [*Греф*](~/android/troubleshooting/index.md) и (или) [*GC*](~/android/troubleshooting/index.md). 

## <a name="configuration"></a>Конфигурация

Сборщик мусора Xamarin. Android можно настроить, задав `MONO_GC_PARAMS` переменную среды. Переменные среды можно задать с помощью действия сборки [андроиденвиронмент](~/android/deploy-test/environment.md).

Переменная `MONO_GC_PARAMS` среды представляет собой разделенный запятыми список следующих параметров: 

- `nursery-size` = *Размер* : Задает размер инкубатор. Размер указывается в байтах и должен быть степенью числа 2. Суффиксы `k` `m` и`g` могут использоваться для указания килобайтах-, мегасимволов и гигабайтов соответственно. Инкубатор является первым поколением (из двух). Большая инкубатор обычно ускоряет программу, но, очевидно, использует больше памяти. Размер инкубатор по умолчанию 512 КБ. 

- `soft-heap-limit` = *Размер* : Целевое значение максимального потребления управляемой памяти для приложения. Если использование памяти ниже указанного значения, то сборщик мусора оптимизирован для времени выполнения (меньше коллекций). 
    Выше этого ограничения GC оптимизирован для использования памяти (больше коллекций). 

- `evacuation-threshold` = *пороговое значение* : Устанавливает пороговое значение эвакуации в процентах. Значение должно быть целым числом в диапазоне от 0 до 100. Значение по умолчанию — 66. Если фаза очистки в коллекции обнаруживает, что заполнение определенного типа блока кучи меньше этого процентного значения, он выполняет копирование коллекции для этого типа блока в следующей крупной коллекции, тем самым восстанавливая заполнение до 100 процентов. Значение 0 выключает эвакуации. 

- `bridge-implementation` = *Реализация моста* : Это позволит настроить мост GC для устранения проблем с производительностью GC. Существует три возможных значения: *Old* , *New* , *таржан*.

- `bridge-require-precise-merge`: Мост Таржан содержит оптимизацию, которая может, в редких случаях, привести к тому, что объект будет собираться по одной сборке мусора после того, как она сначала станет мусором. Включение этого параметра отключает оптимизацию, что делает GC более предсказуемым, но потенциально медленным.

Например, чтобы настроить GC на ограничение размера кучи 128 МБ, добавьте новый файл в проект с `AndroidEnvironment` **действием сборки** с содержимым: 

```shell
MONO_GC_PARAMS=soft-heap-limit=128m
```
