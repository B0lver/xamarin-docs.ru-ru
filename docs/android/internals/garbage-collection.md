---
title: Сборка мусора
ms.prod: xamarin
ms.assetid: 298139E2-194F-4A58-BC2D-1D22231066C4
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 03/15/2018
ms.openlocfilehash: 62560d97a2e85a6045e419f0c0602a375f5a2a75
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73027885"
---
# <a name="garbage-collection"></a>Сборка мусора

Xamarin. Android использует [простой сборщик мусора](https://www.mono-project.com/docs/advanced/garbage-collector/sgen/)Mono. Это сборщик мусора пометки и очистки с двумя поколениями и *пространством больших объектов*с двумя типами коллекций: 

- Вспомогательные коллекции (сбор данных в куче Gen0) 
- Основные коллекции (собирающие кучи Gen1 и пространства больших объектов). 

> [!NOTE]
> При отсутствии явной коллекции через [GC. Сбор данных ()](xref:System.GC.Collect) выполняется *по требованию на*основе выделения кучи. *Это не является системой подсчета ссылок*; объекты *не будут собираться сразу после отсутствия необработанных ссылок*или при выходе из области. Сборщик мусора будет запущен, когда во вспомогательной куче не хватает памяти для новых выделений. Если распределения отсутствуют, они не будут запущены.

Небольшие коллекции являются недорогими и часто используются для сбора недавно выделенных и неработающих объектов. Дополнительные коллекции выполняются после каждых нескольких МБ выделенных объектов. Вспомогательные коллекции могут выполняться вручную путем вызова [GC. Получение (0)](/dotnet/api/system.gc.collect#System_GC_Collect_System_Int32_) 

Основные коллекции являются дорогостоящими и менее частыми и используются для освобождения всех неработающих объектов. Основные коллекции выполняются после исчерпания памяти для текущего размера кучи (до изменения размера кучи). Основные коллекции можно выполнить вручную, вызвав [GC. Сбор ()](xref:System.GC.Collect) или вызов [GC. Сбор (int)](/dotnet/api/system.gc.collect#System_GC_Collect_System_Int32_) с аргументом [GC. Максженератион](xref:System.GC.MaxGeneration). 

## <a name="cross-vm-object-collections"></a>Коллекции объектов между виртуальными машинами

Существует три категории типов объектов.

- **Управляемые объекты**: типы, которые *не* наследуют от [Java. lang. Object](xref:Java.Lang.Object) , например [System. String](xref:System.String). 
    Они обычно собираются сборщиком мусора. 

- **Объекты Java**: типы Java, которые находятся на виртуальной машине среды выполнения Android, но не доступны для виртуальной машины Mono. Они скучны и не будут обсуждаться дальше. Они обычно собираются виртуальной машиной среды выполнения Android. 

- **Одноранговые объекты**: типы, которые реализуют [ижаваобжект](xref:Android.Runtime.IJavaObject) , например все [Java. lang. Object](xref:Java.Lang.Object) и [Java. lang. throws](xref:Java.Lang.Throwable) . Экземпляры этих типов имеют две "половины" *управляемого однорангового узла* и *собственного однорангового узла*. Управляемый одноранговый узел является экземпляром C# класса. Собственный одноранговый узел является экземпляром класса Java на виртуальной машине среды выполнения Android, а C# свойство [ижаваобжект. Handle](xref:Android.Runtime.IJavaObject.Handle) содержит глобальную ссылку JNI на собственный одноранговый узел. 

Существует два типа собственных одноранговых узлов:

- **Одноранговые узлы платформы** : "обычные" типы Java, которые ничего не знает о Xamarin. Android, например   [Android. Content. Context](xref:Android.Content.Context).

- **Одноранговые узлы пользователей** : [вызываемые оболочки Android](~/android/platform/java-integration/working-with-jni.md) , созданные во время сборки для каждого подкласса Java. lang. Object, присутствующего в приложении.

Так как в процессе Xamarin. Android есть две виртуальные машины, существует два типа сборок мусора:

- Коллекции среды выполнения Android 
- Коллекции Mono 

Коллекции среды выполнения Android работают нормально, но с помощью предупреждения: Глобальная ссылка JNI рассматривается как корень GC. Следовательно, если имеется глобальная ссылка JNI, содержащая объект виртуальной машины среды выполнения Android, объект *не может* быть собран, даже если он подходит для коллекции.

Коллекции Mono — это то, где происходит веселое. Управляемые объекты собираются как обычно. Одноранговые объекты собираются путем выполнения следующего процесса:

1. Все одноранговые объекты, подходящие для коллекции Mono, имеют глобальную ссылку JNI, замененную JNI ненадежной глобальной ссылкой. 

2. Вызывается сборщик мусора виртуальной машины среды выполнения Android. Может быть собран любой собственный одноранговый экземпляр. 

3. Проверяются слабые глобальные ссылки JNI, созданные в (1). Если слабая ссылка была собрана, то собирается одноранговый объект. Если слабая ссылка *не* была собрана, слабая ссылка заменяется глобальной ссылкой на JNI, а одноранговый объект не собирается. Примечание. в API 14 + это означает, что значение, возвращаемое из `IJavaObject.Handle` может измениться после сборки мусора. 

Конечным результатом всего этого является то, что экземпляр однорангового объекта будет жить до тех пор, пока на него ссылается управляемый код (например, хранится в `static` переменной) или на него ссылается код Java. Более того, время существования собственных одноранговых узлов будет больше, чем в противном случае, так как собственный одноранговый узел не будет подключаться до тех пор, пока выполняется сбор как собственного однорангового, так и управляемого.

## <a name="object-cycles"></a>Циклы объектов

Одноранговые объекты логически представлены как в среде выполнения Android, так и в виртуальной машине Mono. Например, экземпляр управляемого однорангового узла [Android. app. Activity](xref:Android.App.Activity) будет иметь соответствующий экземпляр Java для платформы [Android. app. Activity](https://developer.android.com/reference/android/app/Activity.html) . Все объекты, наследующие [Java. lang. Object](xref:Java.Lang.Object) , могут иметь представления в обеих виртуальных машинах. 

Все объекты, имеющие представление на обеих виртуальных машинах, будут иметь время существования, расширенное по сравнению с объектами, присутствующими только в пределах одной виртуальной машины (например, [`System.Collections.Generic.List<int>`](xref:System.Collections.Generic.List%601)). Вызов [GC. Сбор](xref:System.GC.Collect) данных не обязательно будет собирать эти объекты, так как в Xamarin. Android GC необходимо убедиться, что ни одна виртуальная машина не ссылается на объект, прежде чем собирать его. 

Чтобы сократить время существования объекта, необходимо вызвать [Java. lang. Object. Dispose ()](xref:Java.Lang.Object.Dispose) . Это позволит вручную «серьезное» подключение к объекту между двумя виртуальными машинами, освобождая глобальную ссылку, тем самым позволяя быстрее собирать объекты. 

## <a name="automatic-collections"></a>Автоматические коллекции

Начиная с [выпуска Release 4.1.0](https://github.com/xamarin/release-notes-archive/blob/master/release-notes/android/mono_for_android_4/mono_for_android_4.1.0/index.md), Xamarin. Android автоматически выполняет полную сборку мусора, когда пороговое значение Греф пересекается. Это пороговое значение составляет 90% от известного максимального грефс для платформы: 1800 грефс на эмуляторе (2000 max) и 46800 грефс на оборудовании (максимум 52000). *Примечание.* Xamarin. Android подсчитывает только грефс, созданные [Android. Runtime. жниенв](xref:Android.Runtime.JNIEnv), и не узнает о других грефс, созданных в процессе. Это *только*эвристический подход. 

При выполнении автоматической сборки в журнал отладки будет выведено сообщение следующего вида:

```shell
I/monodroid-gc(PID): 46800 outstanding GREFs. Performing a full GC!
```

Вхождение этого параметра является недетерминированным и может происходить в иноппортуне раз (например, в середине отрисовки графики). Если вы видите это сообщение, вам может потребоваться выполнить явную коллекцию в других местах или попытаться [сократить время существования одноранговых объектов](#Helping_the_GC). 

## <a name="gc-bridge-options"></a>Параметры моста GC

Xamarin. Android обеспечивает прозрачное управление памятью с помощью Android и среды выполнения Android. Он реализуется как расширение для сборщика мусора Mono, называемого *мостом GC*. 

Мост GC работает во время сборки мусора Mono и определяет, какие одноранговые объекты требуют своего "реальной" проверки с помощью кучи среды выполнения Android. Мост GC выполняет это определение, выполняя следующие действия (по порядку):

1. Вызов графа справочника Mono недостижимых одноранговых объектов в объекты Java, которые они представляют. 

2. Выполните Java GC.

3. Проверьте, какие объекты на самом деле отсутствуют. 

Этот сложный процесс позволяет подклассам `Java.Lang.Object` свободно ссылаться на любые объекты. Он удаляет все ограничения, к C#которым можно привязать объекты Java. Из-за этой сложности процесс моста может быть очень ресурсоемким и может привести к заметным паузам в приложении. Если приложение испытывает значительные паузы, стоит изучить одну из следующих трех реализаций моста GC: 

- **Таржан** — совершенно новая структура моста GC на основе [алгоритма Роберт таржан и обратного распространения ссылок](https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm).
    Она обладает лучшей производительностью в моделируемых рабочих нагрузках, но она также имеет большую общую папку экспериментального кода. 

- **New** — основной ремонт исходного кода с устранением двух экземпляров поведений в виде квадратичного поведения, но с удержанием основного алгоритма (на основе [алгоритма косаражу](https://en.wikipedia.org/wiki/Kosaraju's_algorithm) для поиска строго подключенных компонентов). 

- **Old** — исходная реализация (считается наиболее стабильной из трех). Это мост, который приложение должно использовать, если приостановки `GC_BRIDGE` приемлемы. 

Единственный способ выяснить, какой оптимальный мост GC работает, — эксперименты в приложении и анализ выходных данных. Существует два способа получить данные для тестирования производительности: 

- **Включите ведение журнала** . Включите ведение журнала (как описано в разделе [Конфигурация](~/android/internals/garbage-collection.md) ) для каждого параметра моста GC, а затем запишите и сравните выходные данные журнала из каждого параметра. Проверьте `GC` сообщения для каждого параметра. в частности, `GC_BRIDGE` сообщения. Приостановка до 150ms для неинтерактивных приложений — приемлемой, но приостановка над 60ms для очень интерактивных приложений (например, игр) является проблемой. 

- **Включить учет моста** . при учете моста будут отображаться средние затраты на объекты, на которые указывает каждый объект, участвующий в процессе моста. При сортировке этих сведений по размеру будут предоставлены указания на то, что удерживает самый крупный объем дополнительных объектов. 

Чтобы указать, какой `GC_BRIDGE` параметр приложения должен иметь значение, передайте `bridge-implementation=old`, `bridge-implementation=new` или `bridge-implementation=tarjan` в переменную среды `MONO_GC_PARAMS`, например: 

```shell
MONO_GC_PARAMS=bridge-implementation=tarjan
```

Значение по умолчанию — **таржан**. Если вы обнаружите регрессию, может потребоваться установить для этого параметра значение **Old**. Кроме того, вы можете использовать более стабильный **старый** вариант, если **таржан** не приводит к повышению производительности. 

<a name="Helping_the_GC" />

## <a name="helping-the-gc"></a>Помощь в сборке мусора

Существует несколько способов помочь сборщику мусора сократить использование памяти и время сбора.

### <a name="disposing-of-peer-instances"></a>Удаление одноранговых экземпляров

Сборщик мусора имеет неполное представление о процессе и может не запускаться, если память мала, так как сборщик мусора не знает, что память мала. 

Например, экземпляр типа [Java. lang. Object](xref:Java.Lang.Object) или производного типа имеет размер не менее 20 байт (может быть изменен без уведомления и т. д.). 
[Управляемые вызываемые оболочки](~/android/internals/architecture.md) не добавляют дополнительные члены экземпляра, поэтому при наличии экземпляра [Android. Graphics. Bitmap](xref:Android.Graphics.Bitmap) , который ссылается на большой двоичный объект памяти размером 10 МБ, сборщик мусора Xamarin. Android не знает, что &ndash; сборщик мусора будет видеть 20-байтовый объект и не удается определить, что он связан с объектами, выделенными средой выполнения Android и не может поддерживать 10 МБ памяти. 

Часто возникает необходимость в помощи сборщика мусора. Увы, *GC. Аддмеморипрессуре ()* и *GC. RemoveMemoryPressure ()* не поддерживаются, поэтому, если *известно* , что вы только что освободили большой объем выделенной Java диаграммы объектов, может потребоваться вручную вызвать [GC. Выполните сбор ()](xref:System.GC.Collect) , чтобы предложить сборщику мусора освободить память на стороне Java, или можно явно удалить подклассы *Java. lang. Object* , разбивая сопоставление между управляемой вызываемой оболочкой и экземпляром Java. Например, см. [ошибку 1084](https://bugzilla.xamarin.com/show_bug.cgi?id=1084#c6). 

> [!NOTE]
> При удалении экземпляров подклассов `Java.Lang.Object` необходимо соблюдать *крайне* внимательное внимание.

Чтобы максимально ограничить вероятность повреждения памяти, при вызове `Dispose()`Обратите внимание на следующие рекомендации.

#### <a name="sharing-between-multiple-threads"></a>Совместное использование нескольких потоков

Если экземпляр *Java или управляемого* экземпляра может совместно использоваться несколькими потоками, он **никогда** *не должен быть `Dispose()`d*. Например, [`Typeface.Create()`](xref:Android.Graphics.Typeface.Create*) 
может возвращать *кэшированный экземпляр*. Если несколько потоков предоставляют одинаковые аргументы, они получают *один и тот же* экземпляр. Следовательно, `Dispose()`ность экземпляра `Typeface` из одного потока может сделать недействительными другие потоки, что может привести к `ArgumentException`из `JNIEnv.CallVoidMethod()` (в других случаях), так как экземпляр был удален из другого потока. 

#### <a name="disposing-bound-java-types"></a>Удаление привязанных типов Java

Если экземпляр имеет привязанный тип Java, экземпляр может быть удален до тех *пор* , пока экземпляр не будет повторно использован из управляемого кода *и* экземпляр Java не будет совместно использоваться другими потоками (см. предыдущее `Typeface.Create()` обсуждение). (Такое определение может оказаться затруднительным.) В следующий раз, когда экземпляр Java войдет в управляемый код, для него будет создана *Новая* оболочка. 

Это часто полезно, когда речь идет о Драваблес и других ресурсоемких экземплярах:

```csharp
using (var d = Drawable.CreateFromPath ("path/to/filename"))
    imageView.SetImageDrawable (d);
```

Приведенная выше безопасность является надежной, так как одноранговый объект, который можно использовать для [рисования. креатефромпас ()](xref:Android.Graphics.Drawables.Drawable.CreateFromPath*) , ссылается на одноранговый узел платформы, а *не* на одноранговый Вызов `Dispose()` в конце блока `using` приведет к нарушению связи [между управляемыми рисуемыми](xref:Android.Graphics.Drawables.Drawable) экземплярами и вызываемыми [платформами](https://developer.android.com/reference/android/graphics/drawable/Drawable.html) , позволяя собирать экземпляр Java сразу после того, как среда выполнения Android потребуется. Это *не* будет быть надежным, если одноранговый экземпляр ссылается на одноранговый узел пользователя; Здесь мы используем "внешние" сведения, чтобы *узнать* , что `Drawable` не может ссылаться на одноранговый узел пользователя, поэтому `Dispose()` вызов является надежным. 

#### <a name="disposing-other-types"></a>Удаление других типов 

Если экземпляр ссылается на тип, который не является привязкой типа Java (например, пользовательского `Activity`), не вызывайте **`Dispose()`, если** не *известно* , что код Java не будет вызывать переопределенные методы в этом экземпляре. В противном случае результат [`NotSupportedException`s](~/android/internals/architecture.md#Premature_Dispose_Calls). 

Например, если у вас есть пользовательский прослушиватель щелчка:

```csharp
partial class MyClickListener : Java.Lang.Object, View.IOnClickListener {
    // ...
}
```

*Не следует* удалять этот экземпляр, так как Java будет пытаться вызывать в будущем методы.

```csharp
// BAD CODE; DO NOT USE
Button b = FindViewById<Button> (Resource.Id.myButton);
using (var listener = new MyClickListener ())
    b.SetOnClickListener (listener);
```

#### <a name="using-explicit-checks-to-avoid-exceptions"></a>Использование явных проверок для предотвращения исключений

Если вы реализовали метод перегрузки [Java. lang. Object. Dispose](xref:Java.Lang.Object.Dispose*) , старайтесь не касаться объектов, использующих JNI. Это может создать ситуацию *двойного удаления* , которая позволяет коду (неустранимо) попытаться получить доступ к базовому объекту Java, который уже был собран сборщиком мусора. При этом создается исключение, аналогичное следующему: 

```shell
System.ArgumentException: 'jobject' must not be IntPtr.Zero.
Parameter name: jobject
at Android.Runtime.JNIEnv.CallVoidMethod
```

Такая ситуация часто возникает, когда первая ликвидация объекта приводит к тому, что элемент будет иметь значение null, а последующие попытки доступа к этому элементу NULL приводят к возникновению исключения. В частности, `Handle` объекта (который связывает управляемый экземпляр с его базовым экземпляром Java) становится недействительным при первом удалении, но управляемый код по-прежнему пытается получить доступ к этому базовому экземпляру Java, даже если он больше не доступен (см [. Управляемые вызываемые оболочки](~/android/internals/architecture.md#Managed_Callable_Wrappers) для получения дополнительных сведений о сопоставлении между экземплярами Java и управляемыми экземплярами. 

Хорошим способом предотвратить это исключение является явная проверка в методе `Dispose`, что сопоставление между управляемым экземпляром и базовым экземпляром Java по-прежнему допустимо. то есть убедитесь, что `Handle` объекта имеет значение null (`IntPtr.Zero`), прежде чем получить доступ к его членам. Например, следующий метод `Dispose` обращается к объекту `childViews`: 

```csharp
class MyClass : Java.Lang.Object, ISomeInterface 
{
    protected override void Dispose (bool disposing)
    {
        base.Dispose (disposing);
        for (int i = 0; i < this.childViews.Count; ++i)
        {
            // ...
        }
    }
}
```

Если начальный проход Dispose приводит к тому, что `childViews` имеет недопустимое `Handle`, доступ к циклу `for` вызовет `ArgumentException`. При добавлении явной `Handle` проверки null перед первым `childViews`ным доступом следующий метод `Dispose` предотвращает возникновение исключения: 

```csharp
class MyClass : Java.Lang.Object, ISomeInterface 
{
    protected override void Dispose (bool disposing)
    {
        base.Dispose (disposing);

        // Check for a null handle:
        if (this.childViews.Handle == IntPtr.Zero)
            return;

        for (int i = 0; i < this.childViews.Count; ++i)
        {
            // ...
        }
    }
}
```

### <a name="reduce-referenced-instances"></a>Уменьшить экземпляры, на которые указывает ссылка

Каждый раз при сканировании экземпляра типа `Java.Lang.Object` или подкласса во время сборки мусора все *графы объектов* , на которые ссылается экземпляр, также должны быть проверены. Граф объектов — это набор экземпляров объектов, на которые ссылается корневой экземпляр, *а также* все, на которое ссылается корневой экземпляр, рекурсивный. 

Рассмотрим следующий класс:

```csharp
class BadActivity : Activity {

    private List<string> strings;

    protected override void OnCreate (Bundle bundle)
    {
        base.OnCreate (bundle);

        strings.Value = new List<string> (
                Enumerable.Range (0, 10000)
                .Select(v => new string ('x', v % 1000)));
    }
}
```

При создании `BadActivity` граф объектов будет содержать 10004 экземпляров (1x `BadActivity`, 1x `strings`, 1x `string[]`, удерживаемые `strings`, 10000x строковые экземпляры), *все* из которых необходимо проверять при сканировании экземпляра `BadActivity`. 

Это может негативно повлиять на время сбора, что приведет к увеличению времени приостановки сборки мусора. 

Вы можете помочь сборщику мусора, *уменьшая* размер графов объектов, которые находятся в корне с помощью одноранговых экземпляров пользователей. В приведенном выше примере это можно сделать, переместив `BadActivity.strings` в отдельный класс, который не наследует от Java. lang. Object: 

```csharp
class HiddenReference<T> {

    static Dictionary<int, T> table = new Dictionary<int, T> ();
    static int idgen = 0;

    int id;

    public HiddenReference ()
    {
        lock (table) {
            id = idgen ++;
        }
    }

    ~HiddenReference ()
    {
        lock (table) {
            table.Remove (id);
        }
    }

    public T Value {
        get { lock (table) { return table [id]; } }
        set { lock (table) { table [id] = value; } }
    }
}

class BetterActivity : Activity {

    HiddenReference<List<string>> strings = new HiddenReference<List<string>>();

    protected override void OnCreate (Bundle bundle)
    {
        base.OnCreate (bundle);

        strings.Value = new List<string> (
                Enumerable.Range (0, 10000)
                .Select(v => new string ('x', v % 1000)));
    }
}
```

## <a name="minor-collections"></a>Вспомогательные коллекции

Вспомогательные коллекции могут выполняться вручную путем вызова [GC. Собирайте (0)](xref:System.GC.Collect). Небольшие коллекции являются недорогими (по сравнению с основными коллекциями), но имеют значительные фиксированные затраты, поэтому вы не хотите вызывать их слишком часто и иметь время паузы в течение нескольких миллисекунд. 

Если в приложении есть "цикл работы", в ходе которого одно и то же действие выполняется повторно, может быть целесообразно вручную выполнить дополнительный сбор после завершения цикла пошлины. Ниже приведены примеры рабочих циклов. 

- Цикл отрисовки отдельного кадра игры.
- Все взаимодействие с заданным диалоговым окном приложения (открытие, заполнение, закрытие) 
- Группа сетевых запросов на обновление и синхронизацию данных приложения.

## <a name="major-collections"></a>Основные коллекции

Основные коллекции можно выполнить вручную, вызвав [GC. Собирайте ()](xref:System.GC.Collect) или `GC.Collect(GC.MaxGeneration)`. 

Они должны выполняться редко и могут иметь время паузы в секунду на устройстве в стиле Android при сборе кучи 512 МБ. 

Основные коллекции следует вызывать только вручную, если когда-либо: 

- По завершении длительных циклов пошлины, и когда долгая пауза не будет представлять проблему пользователю. 

- В переопределенном методе [Android. app. Activity. онловмемори ()](xref:Android.App.Activity.OnLowMemory) . 

## <a name="diagnostics"></a>Диагностика

Чтобы определить, когда глобальные ссылки создаются и уничтожаются, можно установить системное свойство [Debug. моно. log](~/android/troubleshooting/index.md) , чтобы оно содержало [*Греф*](~/android/troubleshooting/index.md) и (или) [*GC*](~/android/troubleshooting/index.md). 

## <a name="configuration"></a>Параметр Configuration

Сборщик мусора Xamarin. Android можно настроить, задав переменную среды `MONO_GC_PARAMS`. Переменные среды можно задать с помощью действия сборки [андроиденвиронмент](~/android/deploy-test/environment.md).

Переменная среды `MONO_GC_PARAMS` представляет собой разделенный запятыми список следующих параметров: 

- `nursery-size`*размер* = : задает размер инкубатор. Размер указывается в байтах и должен быть степенью числа 2. Суффиксы `k`, `m` и `g` можно использовать для указания килобайтах-, мегасимволов и гигабайтов соответственно. Инкубатор является первым поколением (из двух). Большая инкубатор обычно ускоряет программу, но, очевидно, использует больше памяти. Размер инкубатор по умолчанию 512 КБ. 

- `soft-heap-limit`*размер* = : целевое значение Максимальное потребление управляемой памяти для приложения. Если использование памяти ниже указанного значения, то сборщик мусора оптимизирован для времени выполнения (меньше коллекций). 
    Выше этого ограничения GC оптимизирован для использования памяти (больше коллекций). 

- `evacuation-threshold` = *пороговое значение* : устанавливает пороговое значение эвакуации в процентах. Значение должно быть целым числом в диапазоне от 0 до 100. Значение по умолчанию — 66. Если фаза очистки в коллекции обнаруживает, что заполнение определенного типа блока кучи меньше этого процентного значения, он выполняет копирование коллекции для этого типа блока в следующей крупной коллекции, тем самым восстанавливая заполнение до 100 процентов. Значение 0 выключает эвакуации. 

- `bridge-implementation` = *реализации моста* . Этот параметр ЗАДАЕТ мост GC для устранения проблем с производительностью GC. Существует три возможных значения: *Old* , *New* , *таржан*.

- `bridge-require-precise-merge`. мост Таржан содержит оптимизацию, которая может, в редких случаях, привести к тому, что объект будет собран по одной сборке мусора после того, как он сначала станет мусором. Включение этого параметра отключает оптимизацию, что делает GC более предсказуемым, но потенциально медленным.

Например, чтобы настроить GC на ограничение размера кучи 128 МБ, добавьте новый файл в проект с **действием сборки** `AndroidEnvironment` с содержимым: 

```shell
MONO_GC_PARAMS=soft-heap-limit=128m
```
