---
title: Jelly Bean функции
description: 'Этот документ послужит общий обзор новых возможностей для разработчиков, которые были введены в Android 4.1. Эти функции включают: расширенный уведомлений, обновления для Android луч обмениваться большими файлами, обновлений к мультимедиа, peer-to-peer сетевого обнаружения, анимацию, новые разрешения.'
ms.prod: xamarin
ms.assetid: 23F57634-2EF9-5C15-C710-B3E19A5AF7E1
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 03/01/2018
ms.openlocfilehash: 9e83c9a8c1e2740596a981598cafbbfb65e2caf2
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50119245"
---
# <a name="jelly-bean-features"></a>Jelly Bean функции

_Этот документ послужит общий обзор новых возможностей для разработчиков, которые были введены в Android 4.1. Эти функции включают: расширенный уведомлений, обновления для Android луч обмениваться большими файлами, обновлений к мультимедиа, peer-to-peer сетевого обнаружения, анимацию, новые разрешения._



## <a name="overview"></a>Обзор

Android 4.1 (уровень API 16), также известный как «Jelly Bean», был выпуска 9 июля 2012 г. Этой статье содержатся вводные сведения верхнего уровня на некоторые из новых функций в Android 4.1 для разработчиков, использующих Xamarin.Android. Некоторые из этих новых возможностей, представленных улучшениями для анимации для запуска действия, новые звуки для камеры и улучшенная поддержка стека навигации приложения. Теперь возможна для вырезания и вставки с намерениями.

Возможность изолировать зависимость от нестабильной поставщики содержимого повышение стабильности приложений Android. Службы также могут изолированной, чтобы они были доступны только с помощью действия, их запуска.

Добавлена поддержка для обнаружения службы сети с помощью Bonjour, UPnP или многоадресной рассылки DNS на основе служб. Теперь можно более широкие уведомлений, формат которых задан текст, кнопки действий и больших изображений.

Наконец в Android 4.1 были добавлены несколько новых разрешений.



## <a name="requirements"></a>Требования

Для разработки приложений Xamarin.Android с помощью Jelly Bean требуется Xamarin.Android 4.2.6 или более поздней версии и Android 4.1 (уровень API 16) установить через диспетчер пакетов SDK для Android как показано на следующем снимке экрана:

[![Выбор Android 4.1 в диспетчере пакетов SDK для Android](jelly-bean-images/image1.png)](jelly-bean-images/image1.png#lightbox)



## <a name="whats-new"></a>Новые возможности



### <a name="animations"></a>Анимации

Действия можно запустить с помощью пользовательской анимации или анимации масштабирования с помощью `ActivityOptions` класса. Следующие новые методы предоставляются для поддержки этих анимаций:

-   `MakeScaleUpAnimation` — Это создаст анимацию, которая масштабируется окно действий из начальное положение и размер на экране.
-   `MakeThumbnailScaleUpAnimation` — Это создает анимацию, которая масштабируется эскиз изображения из указанной позиции на экране.
-   `MakeCustomAnimation` — Это создает анимацию из ресурсов приложения. Имеется одна анимация для открытия действия, а другой — для остановки действия.


Новый `TimeAnimator` класс предоставляет интерфейс `TimeAnimator.ITimeListener` , уведомлять приложение, каждый раз при изменении кадра анимации. Например, рассмотрим следующую реализацию `TimeAnimator.ITimeListener`:

```csharp
class MyTimeListener : Java.Lang.Object,  TimeAnimator.ITimeListener
{
    public void OnTimeUpdate(TimeAnimator animation, long totalTime, long deltaTime)
    {
        Log.Debug("Activity1", "totalTime={0}, deltaTime={1}", totalTime, deltaTime);
    }
}
```

А теперь использовать класс, экземпляр `TimeAnimator` создается, и задайте прослушиватель:

```csharp
var animator = new TimeAnimator();
animator.SetTimeListener(new MyTimeListener());
animator.Start();
```

Как `TimeAnimator` экземпляр запущен, он будет вызывать `ITimeAnimator.ITimeListener`, который будет затем войдите как долго animator была запущена и как долго он как были со времени последнего метод был вызван.



### <a name="application-stack-navigation"></a>Стек навигации приложений

Android 4.1 улучшает навигации стека приложений, которая была введена в Android 3.0. Путем указания `ParentName` свойство `ActivityAttribute`, Android можно открыть правильного родительского действия, когда пользователь нажимает [кнопка](http://developer.android.com/design/patterns/navigation.html#up-vs-back) на панели действий - Android будет создавать действие, заданное `ParentName`свойство. Это позволяет приложениям сохранять иерархию действий, которые делают данной задачи.

Для установки большинства приложений `ParentName` в действии — достаточно сведений для Android для обеспечения правильного поведения для навигации в стек приложений; Android будет синтезировать необходимые стек переходов назад, создав ряд способов для каждого родительского действия. Тем не менее так как это стека искусственный приложений, каждое искусственных действие не будет сохраненное состояние, которое окажет действием естественным. Чтобы предоставить сохраненное состояние искусственных родительским действием, может переопределить действия `OnPrepareNavigationUpTaskStack` метод. Этот метод получает `TaskStackBuilder` экземпляр, который будет иметь коллекцию намерение объектов, что Android будет использовать для создания стек переходов назад. Действие может изменять эти Intents так, что при создании искусственной действия он будет получать сведения правильное состояние.

Для более сложных сценариев существует новые методы в классе действия, который может использоваться для обработки поведение навигации и создания стек переходов назад.

-   `OnNavigateUp` — Путем переопределения этого метода существует возможность выполнения настраиваемого действия при <span class="ui">вверх</span> нажатии кнопки.
-   `NavigateUpTo` — Вызов этого метода приложение для перехода от текущего действия действие, заданное данной цели.
-   `ParentActivityIntent` — Это используется для получения объекта Intent, который запустит родительское действие текущего действия.
-   `ShouldUpRecreateTask` — Этот метод используется для запроса, если перейти к родительскому действию должны создаваться искусственных стек переходов назад. Возвращает `true` Если синтетические стек должен быть создан. 
-   `FinishAffinity` — Вызов этого метода будет завершить текущее действие и все действия под ним в текущей задаче, имеют одну и ту же территориальную задачи.
-   `OnCreateNavigateUpTaskStack` — Этот метод переопределяется, при необходимости иметь полный контроль над Создание искусственных стека.




### <a name="camera"></a>Камера

Имеется новый интерфейс, `Camera.IAutoFocusMoveCallback`, который позволяют обнаружить, когда началась или остановить перемещение фокуса автоматически. Пример этого нового интерфейса можно увидеть в следующем фрагменте:

```csharp
public class AutoFocusCallbackActivity : Activity, Camera.IAutoFocusCallback
{
    public void OnAutoFocus(bool success, Camera camera)
    {
        // camera is an instance of the camera service object.

        if (success)
        {
            // Auto focus was successful - do something here.
        }
        else
        {
            // Auto focus didn't happen for some reason - react to that here.
        }
    }
}
```

Новый класс `MediaActionSound` предоставляет набор API для создания звуки для различных действий мультимедиа. Несколько действий, которые могут возникнуть с камерой, они определяются перечислением `Android.Media.MediaActionSoundType`:

-   `MediaActionSoundType.FocusComplete` — Этот звук, который воспроизводится После завершения установки фокуса.
-   `MediaActionSoundType.ShutterClick` — Этот звук будет воспроизводиться при переводе снимка изображения.
-   `MediaActionSoundType.StartVideoRecording` — Этот звук используется указывают на начало записи видео.
-   `MediaActionSoundType.StopVideoRecording` — Этот звук будет воспроизводиться для указания на конец записи видео.


Пример использования `MediaActionSound` класс может отображаться в следующем фрагменте кода:

```csharp
var mediaActionPlayer = new MediaActionSound();

// Preload the sound for a shutter click.
mediaActionPlayer.Load(MediaActionSoundType.ShutterClick);
var button = FindViewById<Button>(Resource.Id.MyButton);

// Play the sound on a button click.
button.Click += (sender, args) => mediaActionPlayer.Play(MediaActionSoundType.ShutterClick);

// This releases the preloaded resources. Don’t make any calls on
// mediaActionPlayer after this.
mediaActionPlayer.Release();
```



### <a name="connectivity"></a>подключение



#### <a name="android-beam"></a>Android луч

Android луч — это технология на основе NFC, позволяющий два устройствам Android обмениваться данными друг с другом. Android 4.1 реализована Улучшенная поддержка для передачи больших файлов. При использовании нового метода `NfcAdapter.SetBeamPushUris()` Android будет переключаться между транспорта альтернативные механизмы (например, Bluetooth) для достижения скорости быстрой передачи.



#### <a name="network-services-discovery"></a>Обнаружение сетевых служб

Android 4.1 содержит новый API для обнаружения службы на основе DNS многоадресной рассылки.
Это позволяет приложению для обнаружения и подключения по Wi-Fi для других устройств, таких как принтеры, камеры и мультимедийных устройств. Эти новые API находятся в `Android.Net.Nsd` пакета.

Для создания службы, которые могут быть использованы другими службами, `NsdServiceInfo` класс используется для создания объекта, который будет определять свойства службы. Этот объект затем передается `NsdManager.RegisterService()` вместе с реализацией `NsdManager.ResolveListener`. Реализации `NsdManager.ResolveListener` используются для сообщать об успешной регистрации и отмены регистрации службы.

Для обнаружения служб в сети, и реализация `Nsd.DiscoveryListener` передается `NsdManager.discoverServices()`.



#### <a name="network-usage"></a>Использование сети

Новый метод `ConnectivityManager.IsActiveNetworkMetered` позволяет устройству для проверки, если он подключен к сети с оплатой за трафик. Этот метод может использоваться для управления использование данных, точно информируя пользователей, что может быть дорогостоящим взимает плату за операции с данными.



#### <a name="wifi-direct-service-discovery"></a>Обнаружение службы Wi-Fi Direct

`WifiP2pManager` Класс впервые появился в Android 4.0 для поддержки *zeroconf*. Zeroconf (сеть ноль конфигурации) — это набор методов, позволяющий устройствам (компьютеры, принтеры, телефоны) для подключения к сетям, автоматически, с участием человека сети операторы или специальной настройки серверов.

В Jelly Bean `WifiP2pManager` может обнаруживать находящихся поблизости устройств с помощью *Bonjour* или *Upnp*. Bonjour — реализация Apple zeroconf. UPnP представляет собой набор сетевых протоколов, которые также поддерживает zeroconf. Следующие методы, добавленные `WiFiP2pManager` для поддержки обнаружения службы Wi-Fi:

-   `AddLocalService()` — Этот метод используется объявили о выходе приложения как услуга через Wi-Fi для обнаружения одноранговыми узлами.
-   `AddServiceRequest(` ) — Этот метод может отправить запрос на обнаружение службы платформы. Он используется для инициализации обнаружения службы Wi-Fi.
-   `SetDnsSdResponseListeners()` — Этот метод используется для регистрации обратных вызовов, вызываемый при получении ответа на запросы обнаружения от Bonjour.
-   `SetUpnpServiceResponseListener()` — Этот метод используется для регистрации обратных вызовов, вызываемый при получении ответа на запросы обнаружения Upnp.




### <a name="content-providers"></a>Поставщики содержимого

`ContentResolver` Класс получил новый метод `AcquireUnstableContentProvider`. Этот метод позволяет приложению получить поставщик содержимого «нестабильной». Как правило когда приложение получает поставщика содержимого, а данный поставщик содержимого аварийно завершает работу, поэтому будет приложение. Вызов этого метода приложения не произойдет сбой в случае сбоя поставщика содержимого. Вместо этого `Android.OS.DeadObjectionException` возникает из вызовов для поставщика содержимого для оповещения приложения, исчезла поставщика содержимого. Поставщик содержимого «нестабильной» полезен при взаимодействии с поставщиками содержимого из других приложений — это менее вероятно, что основывались на коде из другого приложения будет влиять на другое приложение.



### <a name="copy-and-paste-with-intents"></a>Копирование и вставку намерений

`Intent` Класс теперь может иметь `ClipData` объект, связанный с ним через `Intent.ClipData` свойство. Этот метод позволяет дополнительные данные из буфера обмена для передачи с целью. Экземпляр `ClipData` может содержать один или несколько `ClipData.Item`. `ClipData.Item`в элементы следующих типов:

-   **Текст** — это любая строка текста, либо HTML или распространяется на любую строку, формат которого поддерживается Android встроенный стиль.
-  **Намерение** — любое `Intent` объекта.
-   **URI** – это может быть любой URI, например HTTP закладку или URI для поставщика содержимого.




### <a name="isolated-services"></a>Изолированной службы

Изолированной службы — это служба, который работает в свой собственный специальный и не имеет разрешений свои собственные. — Это единственное сообщение со службой при запуске службы и привязка к нему через API службы. Можно объявить службу как изолированное, задав свойство `IsolatedProcess="true"` в `ServiceAttribute` , украшает классом службы.


### <a name="media"></a>Мультимедиа

Новый `Android.Media.MediaCodec` класс предоставляет API для кодеки media низкого уровня. Приложения могут запросить системы, чтобы узнать о кодеках низкого уровня на устройстве.

Новый `Android.Media.Audiofx.AudioEffect` подклассы были добавлены для поддержки дополнительных аудио предварительной обработки на отслеживаемых аудио:

-   `Android.Media.Audiofx.AcousticEchoCanceler` — Этот класс используется для предварительной обработки аудио для удаления сигнала от удаленной стороны из записанного звуковых сигналов. Например удаление echo из приложения голосовой связи.
-   `Android.Media.Audiofx.AutomaticGainControl` — Этот класс используется для нормализации записанного сигнала, повышение или понижение входного сигнала, чтобы выходном сигнале является константой.
-   `Android.Media.Audiofx.NoiseSuppressor` – Этот класс удалит фоновый шум от записанного сигнала.


Не все устройства будут поддерживать эти эффекты. Метод `AudioEffect.IsAvailable` должен вызываться приложением для того, поддерживается ли рассматриваемый аудио эффект на устройстве под управлением приложения.

`MediaPlayer` Класс теперь поддерживает неперекрывающееся воспроизведение с помощью `SetNextMediaPlayer()` метод. Этот новый метод указывает Далее MediaPlayer, чтобы запустить его воспроизведением по завершении текущего мультимедийного проигрывателя.

Следующие новые классы предоставляют стандартные механизмы и пользовательский Интерфейс для выбора, где будет воспроизводиться мультимедиа:

-   `MediaRouter` – Этот класс позволяет приложениям управлять маршрутизацией каналы из устройства внешние динамики или других устройств.
-   `MediaRouterActionProvider` и `MediaRouteButton` — эти классы помогают обеспечить согласованность их пользовательского интерфейса для выбора и воспроизведение мультимедиа.




### <a name="notifications"></a>Уведомления

Android 4.1 позволяет приложениям, дополнительную гибкость и контроль с отображения уведомлений. Приложения может отображать масштабнее, еще лучше уведомления для пользователей. Новый метод `NotificationBuilder.SetStyle()` позволяет для одного из новых три новый стиль на уведомления:

-   `Notification.BigPictureStyle` — Это вспомогательный класс, который будет создавать уведомления, которые будут иметь изображения в них. Ниже показан пример уведомления с помощью больших образа:


 [![Снимок экрана с примером уведомления BigPictureStyle](jelly-bean-images/image2.png)](jelly-bean-images/image2.png#lightbox)

-   `Notification.BigTextStyle` — Это вспомогательный класс, который будет создавать уведомления, которые будут иметь несколько строк текста, такие как электронная почта. Примером стиля новый уведомлений можно увидеть на следующем снимке экрана:


 [![Снимок экрана с примером уведомления BigTextStyle](jelly-bean-images/image3.png)](jelly-bean-images/image3.png#lightbox)

-   `Notification.InboxStyle` — Это вспомогательный класс, который будет создавать уведомления, которые содержат список строк, таких как фрагменты кода из сообщения электронной почты, как показано на следующем снимке экрана:


 [![Снимок экрана с примером уведомления Notification.InboxStyle](jelly-bean-images/image4.png)](jelly-bean-images/image4.png#lightbox)

Это можно добавить до двух кнопок в нижней части сообщение уведомления, когда уведомление с использованием стиля, normal или больше.
Пример этого можно увидеть на следующем снимке экрана, где отображаются кнопки действий в нижней части уведомления:

 [![Снимок экрана с примером действия кнопок, отображаемых ниже сообщение уведомления](jelly-bean-images/image5.png)](jelly-bean-images/image5.png#lightbox)

`Notification` Класс получил новые константы, которые позволяют разработчику указывать один из пяти уровней приоритета для уведомления. Они могут устанавливаться уведомлений с помощью `Priority` свойство.



### <a name="permissions"></a>Разрешения

Добавлены следующие новые разрешения.

-   `READ_EXTERNAL_STORAGE` -Приложению требуется доступом только для чтения во внешнее хранилище. В настоящее время все приложения имеют доступ на чтение по умолчанию, но в будущих версиях Android будет требовать приложения явным образом запросить доступ для чтения.
-   `READ_USER_DICTIONARY` -Разрешает читать словарь word пользователя.
-   `READ_CALL_LOG` -Позволяет приложению получить сведения о входящих и исходящих вызовов путем чтения журнала звонков.
-   `WRITE_CALL_LOG` -Позволяет приложению записывать в журнал вызовов на телефоне.
-   `WRITE_USER_DICTIONARY` -Позволяет приложению для записи словарь пользователя.


Произошло важное изменение, следует отметить `READ_EXTERNAL_STORAGE` — в настоящее время это разрешение предоставляется автоматически системой Android. Будущие версии Android потребуется приложение, чтобы запросить это разрешение, прежде чем предоставлено разрешение.



## <a name="summary"></a>Сводка

В этой статье представлен ряд новых API, которые доступны в Android 4.1 (уровень API 16). Выделены некоторые изменения для анимации и анимации запуска действия и представлен для обнаружения сетевых ресурсов других устройств, с помощью протоколов, таких как Bonjour или UPnP новый API. Другие изменения в API были выделены цветом, такие как возможность вырезания и вставки данных через объекты Intent, возможность использования изолированной службы или «нестабильной» поставщиков содержимого.

В этой статье затем объяснили, внести обновления на уведомления, а также обсуждаются некоторые из новых разрешений, которые были введены с Android версии 4.1


## <a name="related-links"></a>Связанные ссылки

- [Пример анимации времени (пример)](https://developer.xamarin.com/samples/monodroid/PlatformFeatures/TimeAnimatorExample/)
- [Android 4.1 API-интерфейсов](http://developer.android.com/about/versions/android-4.1.html)
- [Задачи и стеки назад](http://developer.android.com/guide/components/tasks-and-back-stack.html)
- [Переход с помощью назад» и «вверх](http://developer.android.com/design/patterns/navigation.html)
