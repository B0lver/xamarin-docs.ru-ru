---
title: Функции Jelly Bean
description: В этом документе представлен общий обзор новых функций для разработчиков, появившихся в Android 4,1. К этим функциям относятся расширенные уведомления, обновления для устройств Android для совместного использования больших файлов, обновления для мультимедиа, обнаружение одноранговых сетей, анимации, новые разрешения.
ms.prod: xamarin
ms.assetid: 23F57634-2EF9-5C15-C710-B3E19A5AF7E1
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 03/01/2018
ms.openlocfilehash: 614a0e3952db42d2587930b66bf71ce4c703d035
ms.sourcegitcommit: 6264fb540ca1f131328707e295e7259cb10f95fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/16/2019
ms.locfileid: "69524073"
---
# <a name="jelly-bean-features"></a>Функции Jelly Bean

_В этом документе представлен общий обзор новых функций для разработчиков, появившихся в Android 4,1. К этим функциям относятся расширенные уведомления, обновления для устройств Android для совместного использования больших файлов, обновления для мультимедиа, обнаружение одноранговых сетей, анимации, новые разрешения._



## <a name="overview"></a>Обзор

Android 4,1 (API уровня 16), также известный как "Jelly Bean", был выпущен 9 июля 2012. В этой статье приводятся общие сведения о некоторых новых возможностях Android 4,1 для разработчиков, использующих Xamarin. Android. Некоторые из этих новых функций являются усовершенствованиями анимации для запуска действий, новых звуков для камеры и улучшенной поддержкой навигации по стеку приложений. Теперь его можно вырезать и вставить с помощью целей.

Стабильность приложений Android улучшена с возможностью изолировать зависимость от нестабильных поставщиков содержимого. Службы также могут быть изолированы, чтобы они были доступны только в действии, которое их запустило.

Добавлена поддержка обнаружения сетевых служб с помощью Bonjour, UPnP или многоадресных служб на основе DNS. Теперь можно использовать более широкие уведомления с форматированным текстом, кнопками действий и большими изображениями.

Наконец, в Android 4,1 добавлено несколько новых разрешений.



## <a name="requirements"></a>Требования

Для разработки приложений Xamarin. Android с помощью Jelly Bean требуется Xamarin. Android 4.2.6 или более поздней версии, а Android 4,1 (уровень API 16) можно установить с помощью диспетчера пакет SDK для Android, как показано на следующем снимке экрана:

[![Выбор Android 4,1 в диспетчере пакет SDK для Android](jelly-bean-images/image1.png)](jelly-bean-images/image1.png#lightbox)



## <a name="whats-new"></a>Новые возможности



### <a name="animations"></a>Анимации

Действия могут быть запущены с помощью анимации масштаба или пользовательской анимации с помощью `ActivityOptions` класса. Для поддержки этих анимаций предоставляются следующие новые методы:

- `MakeScaleUpAnimation`— Будет создана анимация, которая масштабирует окно действия по начальному положению и размеру на экране.
- `MakeThumbnailScaleUpAnimation`— Создает анимацию, которая масштабируется от эскиза к заданному положению на экране.
- `MakeCustomAnimation`— Создает анимацию на основе ресурсов в приложении. Существует одна анимация для времени открытия действия, а другая — для остановки действия.


Новый `TimeAnimator` класс предоставляет интерфейс `TimeAnimator.ITimeListener` , который может уведомлять приложение каждый раз, когда кадр изменяется в анимации. Например, рассмотрим следующую реализацию `TimeAnimator.ITimeListener`:

```csharp
class MyTimeListener : Java.Lang.Object,  TimeAnimator.ITimeListener
{
    public void OnTimeUpdate(TimeAnimator animation, long totalTime, long deltaTime)
    {
        Log.Debug("Activity1", "totalTime={0}, deltaTime={1}", totalTime, deltaTime);
    }
}
```

Теперь, чтобы использовать класс, создается экземпляр `TimeAnimator` и прослушиватель задается следующим образом:

```csharp
var animator = new TimeAnimator();
animator.SetTimeListener(new MyTimeListener());
animator.Start();
```

Как только `ITimeAnimator.ITimeListener`экземпляр запущен, он вызывает, который затем зарегистрирует время выполнения аниматор и время, которое прошло с момента последнего вызова метода. `TimeAnimator`



### <a name="application-stack-navigation"></a>Навигация по стеку приложений

Android 4,1 улучшает навигацию по стеку приложений, появившуюся в Android 3,0. Задавая `ParentName` свойство `ActivityAttribute`объекта, Android может открыть соответствующее родительское действие, когда пользователь нажмет [кнопку вверх](https://developer.android.com/design/patterns/navigation.html#up-vs-back) на панели действий. Android создаст `ParentName` экземпляр действия, указанного свойством. Это позволяет приложениям сохранять иерархию действий, которые выполняют данную задачу.

Для большинства приложений, для `ParentName` которых задано действие, достаточно информации для Android, чтобы обеспечить правильное поведение при навигации по стеку приложений. Android создаст необходимый обратный стек, создав последовательность целей для каждого родительского действия. Однако, поскольку это искусственный стек приложений, у каждого искусственного действия не будет сохраненного состояния, которое будет иметь естественное действие. Чтобы предоставить сохраненное состояние искусственному родительскому действию, действие может переопределить `OnPrepareNavigationUpTaskStack` метод. Этот метод получает `TaskStackBuilder` экземпляр, который будет иметь коллекцию объектов намерения, которые Android будет использовать для создания стека "назад". Действие может изменить эти намерения таким образом, чтобы при создании искусственного действия он получал соответствующие сведения о состоянии.

Для более сложных сценариев существуют новые методы класса Activity, которые могут использоваться для управления поведением навигации и создания стека назад.

- `OnNavigateUp`— Путем переопределения этого метода можно выполнить пользовательское действие при нажатии кнопки Up ( **вверх** ).
- `NavigateUpTo`— Вызов этого метода приведет к тому, что приложение будет переходить от текущего действия к действию, заданному намерением.
- `ParentActivityIntent`— Используется для получения цели, которая запустит родительское действие текущего действия.
- `ShouldUpRecreateTask`— Этот метод используется для запроса, если необходимо создать искусственный задний стек для перехода к родительскому действию. Возвращает `true` значение, если необходимо создать искусственный стек. 
- `FinishAffinity`— Вызов этого метода приведет к завершению текущего действия и всех действий, расположенных под ним в текущей задаче с одинаковым сходством задач.
- `OnCreateNavigateUpTaskStack`— Этот метод переопределяется, когда необходим полный контроль над созданием искусственного стека.




### <a name="camera"></a>Камера

Существует новый интерфейс `Camera.IAutoFocusMoveCallback`, который можно использовать для обнаружения начала или прекращения перемещения автоматических фокуса. Пример этого нового интерфейса можно увидеть в следующем фрагменте кода:

```csharp
public class AutoFocusCallbackActivity : Activity, Camera.IAutoFocusCallback
{
    public void OnAutoFocus(bool success, Camera camera)
    {
        // camera is an instance of the camera service object.

        if (success)
        {
            // Auto focus was successful - do something here.
        }
        else
        {
            // Auto focus didn't happen for some reason - react to that here.
        }
    }
}
```

Новый класс `MediaActionSound` предоставляет набор API для создания звуков для различных действий мультимедиа. Существует несколько действий, которые могут возникать на камере. они определяются перечислением `Android.Media.MediaActionSoundType`:

- `MediaActionSoundType.FocusComplete`— Этот звук воспроизводится при завершении фокусировки.
- `MediaActionSoundType.ShutterClick`— Этот звук будет воспроизводиться при проходе изображения по-прежнему.
- `MediaActionSoundType.StartVideoRecording`— Этот звук используется для обозначения начала записи видео.
- `MediaActionSoundType.StopVideoRecording`— Этот звук будет воспроизводиться, чтобы показать окончание записи видео.


Пример использования `MediaActionSound` класса можно увидеть в следующем фрагменте кода:

```csharp
var mediaActionPlayer = new MediaActionSound();

// Preload the sound for a shutter click.
mediaActionPlayer.Load(MediaActionSoundType.ShutterClick);
var button = FindViewById<Button>(Resource.Id.MyButton);

// Play the sound on a button click.
button.Click += (sender, args) => mediaActionPlayer.Play(MediaActionSoundType.ShutterClick);

// This releases the preloaded resources. Don’t make any calls on
// mediaActionPlayer after this.
mediaActionPlayer.Release();
```



### <a name="connectivity"></a>Подключение



#### <a name="android-beam"></a>Android Beam

Технология Android поддерживает технологию на основе технологии NFC, которая позволяет двум устройствам Android взаимодействовать друг с другом. Android 4,1 обеспечивает лучшую поддержку при переносе больших файлов. При использовании нового метода `NfcAdapter.SetBeamPushUris()` Android переключается между альтернативными механизмами транспортировки (например, Bluetooth) для достижения максимальной скорости передачи.



#### <a name="network-services-discovery"></a>Обнаружение сетевых служб

Android 4,1 содержит новые API для многоадресного обнаружения служб на основе DNS.
Это позволяет приложению обнаруживать и подключаться по Wi-Fi к другим устройствам, таким как принтеры, камеры и устройства мультимедиа. Эти новые API-интерфейсы находятся в `Android.Net.Nsd` пакете.

Чтобы создать службу, которая может использоваться другими службами, `NsdServiceInfo` класс используется для создания объекта, который будет определять свойства службы. Затем этот объект предоставляется `NsdManager.RegisterService()` вместе с `NsdManager.ResolveListener`реализацией. `NsdManager.ResolveListener` Реализации используются для уведомления об успешной регистрации и отмены регистрации службы.

Для обнаружения служб в сети и реализации `Nsd.DiscoveryListener` , передаваемой в. `NsdManager.discoverServices()`



#### <a name="network-usage"></a>Использование сети

Новый метод позволяет устройству `ConnectivityManager.IsActiveNetworkMetered` проверить, подключено ли оно к сети с лимитным тарифным планом. Этот метод можно использовать для управления использованием данных путем точного формирования пользователей, которые могут взимать дорогостоящие расходы на операции с данными.



#### <a name="wifi-direct-service-discovery"></a>Прямое обнаружение службы WiFi

Класс был представлен в Android 4,0 для поддержки *зероконф.* `WifiP2pManager` Зероконф (сеть без настройки) — это набор приемов, которые позволяют устройствам (компьютерам, принтерам, телефонам) автоматически подключаться к сетям с помощью операторов работы с сетью или специальных серверов конфигурации.

В Jelly Bean `WifiP2pManager` может обнаруживать ближайшие устройства с помощью *Bonjour* или *UPnP*. Bonjour является реализацией зероконф Apple. UPnP — это набор сетевых протоколов, которые также поддерживают зероконф. Следующие методы добавляются `WiFiP2pManager` в для поддержки обнаружения службы Wi-Fi:

- `AddLocalService()`— Этот метод используется для объявления приложения в качестве службы по Wi-Fi для обнаружения одноранговыми узлами.
- `AddServiceRequest(`) — Этот метод предназначен для отправки запроса на обнаружение службы в платформу. Он используется для инициализации обнаружения службы Wi-Fi.
- `SetDnsSdResponseListeners()`— Этот метод используется для регистрации обратных вызовов для вызова при получении ответа на запросы обнаружения от Bonjour.
- `SetUpnpServiceResponseListener()`— Этот метод используется для регистрации обратных вызовов, которые вызываются при получении ответа на запросы обнаружения UPnP.




### <a name="content-providers"></a>Поставщики содержимого

Класс получил новый метод, `AcquireUnstableContentProvider`. `ContentResolver` Этот метод позволяет приложению получить нестабильный поставщик содержимого. Обычно, когда приложение получает поставщик содержимого и этот поставщик содержимого аварийно завершает работу, приложение будет работать. При вызове этого метода приложение не будет завершаться сбоем, если происходит сбой поставщика содержимого. Вместо этого `Android.OS.DeadObjectionException` будет вызываться из вызовов поставщика содержимого для информирования приложения о том, что поставщик содержимого пропала. Нестабильный поставщик содержимого полезен при взаимодействии с поставщиками содержимого из других приложений — менее вероятно, что ошибками код из другого приложения повлияет на другое приложение.



### <a name="copy-and-paste-with-intents"></a>Копирование и вставка с использованием целей

Теперь класс может иметь связанный с `ClipData` ним объект через свойство.`Intent.ClipData` `Intent` Этот метод позволяет передавать дополнительные данные из буфера обмена с намерением. Экземпляр `ClipData` может содержать один или несколько `ClipData.Item`. `ClipData.Item`являются элементами следующих типов:

- **Текст** — это любая текстовая строка, HTML или любая строка, формат которой поддерживается встроенными в стиле Android диапазонами.
- **Намерение** — `Intent` любой объект.
- **URI** — это может быть любой универсальный код ресурса (URI), например HTTP-закладка или универсальный код ресурса (URI) поставщика содержимого.




### <a name="isolated-services"></a>Изолированные службы

Изолированная служба — это служба, которая работает в собственном специальном процессе и не имеет собственных разрешений. Единственное взаимодействие со службой — при запуске службы и привязке к ней через API службы. Можно объявить службу как изолированную, задав свойство `IsolatedProcess="true"` `ServiceAttribute` в классе, который является классом службы.


### <a name="media"></a>Мультимедиа

Новый `Android.Media.MediaCodec` класс предоставляет API для низкоуровневых кодеков мультимедиа. Приложения могут запрашивать систему, чтобы узнать, какие кодеки низкого уровня доступны на устройстве.

Добавлены новые `Android.Media.Audiofx.AudioEffect` подклассы для поддержки дополнительной предварительной обработки аудио на записанном аудио:

- `Android.Media.Audiofx.AcousticEchoCanceler`— Этот класс используется для предварительной обработки аудио, чтобы удалить сигнал от удаленной стороны из захваченного звукового сигнала. Например, вы удаляете эхо из приложения для обмена голосовыми сообщениями.
- `Android.Media.Audiofx.AutomaticGainControl`— Этот класс используется для нормализации захваченного сигнала путем увеличения или уменьшения входного сигнала, чтобы выходной сигнал был постоянным.
- `Android.Media.Audiofx.NoiseSuppressor`— Этот класс будет удалять фоновые шумы из захваченного сигнала.


Не все устройства будут поддерживать эти эффекты. Метод `AudioEffect.IsAvailable` должен вызываться приложением, чтобы узнать, поддерживается ли на устройстве, где выполняется приложение, поддерживаемый звуковой результат.

Теперь класс поддерживает воспроизведение неперекрывающееся `SetNextMediaPlayer()` с помощью метода. `MediaPlayer` Этот новый метод указывает следующее значение MediaPlayer, которое будет запускаться при завершении воспроизведения текущего проигрывателя мультимедиа.

Следующие новые классы предоставляют стандартные механизмы и пользовательский интерфейс для выбора места воспроизведения мультимедиа:

- `MediaRouter`— Этот класс позволяет приложениям управлять маршрутизацией каналов медиа с устройства на внешние динамики или другие устройства.
- `MediaRouterActionProvider`и `MediaRouteButton` — эти классы помогают обеспечить единообразный пользовательский интерфейс для выбора и воспроизведения мультимедиа.




### <a name="notifications"></a>Уведомления

Android 4,1 позволяет приложениям повысить гибкость и контролировать отображение уведомлений. Теперь приложения могут отображать более крупные и более качественные уведомления для пользователей. Новый метод `NotificationBuilder.SetStyle()` позволяет задать один из новых трех новых стилей для уведомлений:

- `Notification.BigPictureStyle`— Это вспомогательный класс, который будет создавать уведомления, в которых будет сосуществовать изображение. На следующем рисунке показан пример уведомления с большим изображением:


 [![Пример снимка экрана уведомления Бигпиктурестиле](jelly-bean-images/image2.png)](jelly-bean-images/image2.png#lightbox)

- `Notification.BigTextStyle`— Это вспомогательный класс, который будет создавать уведомления, которые будут содержать несколько строк текста, таких как электронная почта. Пример этого нового стиля уведомления можно увидеть на следующем снимке экрана:


 [![Пример снимка экрана уведомления Бигтекстстиле](jelly-bean-images/image3.png)](jelly-bean-images/image3.png#lightbox)

- `Notification.InboxStyle`— Это вспомогательный класс, который будет создавать уведомления, содержащие список строк, например фрагментов сообщения электронной почты, как показано на следующем снимке экрана:


 [![Пример снимка экрана уведомления. Инбоксстиле](jelly-bean-images/image4.png)](jelly-bean-images/image4.png#lightbox)

В нижней части сообщения уведомления можно добавить до двух кнопок действий, когда в уведомлении используется стандартный или более крупный стиль.
Пример можно увидеть на следующем снимке экрана, где кнопки действий отображаются в нижней части уведомления:

 [![Пример снимка экрана кнопок действий, отображаемых под сообщением уведомления](jelly-bean-images/image5.png)](jelly-bean-images/image5.png#lightbox)

`Notification` Класс получил новые константы, позволяющие разработчику указать один из пяти уровней приоритета для уведомления. Их можно задать для уведомления с помощью `Priority` свойства.



### <a name="permissions"></a>Разрешения

Добавлены следующие новые разрешения:

- `READ_EXTERNAL_STORAGE`— Приложению требуется доступ только для чтения к внешнему хранилищу. В настоящее время все приложения имеют доступ на чтение по умолчанию, но в будущих выпусках Android приложения должны явным образом запрашивать доступ на чтение.
- `READ_USER_DICTIONARY`— Разрешает доступ для чтения к словарю пользователя.
- `READ_CALL_LOG`— Позволяет приложению получать сведения о входящих и исходящих вызовах, считывая журнал вызовов.
- `WRITE_CALL_LOG`— Позволяет приложению выполнять запись в журнал вызовов на телефоне.
- `WRITE_USER_DICTIONARY`— Позволяет приложению выполнять запись в словарь слов пользователя.


Важное изменение в заметке `READ_EXTERNAL_STORAGE` — в настоящее время это разрешение автоматически предоставляется Android. В будущих версиях Android потребуется приложение, запрашивающее это разрешение, прежде чем ему будет предоставлено разрешение.



## <a name="summary"></a>Сводка

В этой статье появились некоторые новые API, доступные в Android 4,1 (API уровня 16). В нем выделены некоторые изменения анимации и анимации запуска действия, а также появились новые API для обнаружения сетевых устройств с помощью таких протоколов, как Bonjour или UPnP. Другие изменения, внесенные в API, также были выделены, например возможность вырезания и вставки данных посредством целей, возможность использования изолированных служб или нестабильных поставщиков содержимого.

Затем эта статья посвящена внесению обновлений в уведомления и обсуждению некоторых новых разрешений, появившихся в Android 4,1.


## <a name="related-links"></a>Связанные ссылки

- [Пример анимации времени (пример)](https://docs.microsoft.com/samples/xamarin/monodroid-samples/platformfeatures-timeanimatorexample)
- [API-интерфейсы Android 4,1](https://developer.android.com/about/versions/android-4.1.html)
- [Задачи и резервные стеки](https://developer.android.com/guide/components/tasks-and-back-stack.html)
- [Навигация с помощью кнопок "назад" и "вверх"](https://developer.android.com/design/patterns/navigation.html)
