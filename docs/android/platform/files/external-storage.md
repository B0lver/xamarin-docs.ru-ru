---
title: Доступ к файлам во внешнем хранилище с помощью Xamarin. Android
description: В этом руководством рассматривается доступ к файлам во внешнем хранилище в Xamarin. Android.
ms.prod: xamarin
ms.assetid: 40da10b2-a207-4f9c-a2dd-165d9b662f33
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 07/23/2018
ms.openlocfilehash: 96b0d6a00c7825939b1f89ed63e3e5559ca4ef59
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73020484"
---
# <a name="external-storage"></a>Внешнее хранилище

Внешнее хранилище относится к хранилищу файлов, которое не находится во внутреннем хранилище и недоступно для приложения, ответственного за файл. Основной целью внешнего хранилища является предоставление места для размещения файлов, которые должны совместно использоваться приложениями или которые слишком велики для размещения во внутреннем хранилище.

Исторически говоря, внешнее хранилище, на которое ссылается раздел диска на съемном носителе, такое как SD-карта (также называемое _портативным хранилищем_). Это различие больше не так важно, как устройства Android были изменены, а многие устройства Android больше не поддерживают съемные носители. Вместо этого некоторые устройства выделяют часть внутренней энергонезависимой памяти, которую Android будет использовать для выполнения одной и той же функции съемного носителя. Это называется _эмуляцией_ хранилища и по-прежнему считается внешним хранилищем. Кроме того, некоторые устройства Android могут иметь несколько внешних разделов хранилища. Например, планшет Android (помимо внутреннего хранилища) может иметь эмуляцию хранения и один или несколько слотов для SD-карты. Все эти секции обрабатываются Android как внешнее хранилище.

На устройствах с несколькими пользователями каждый пользователь будет иметь выделенный каталог в основном внешнем разделе хранилища для своего внешнего хранилища. Приложения, работающие от имени одного пользователя, не будут иметь доступа к файлам другого пользователя на устройстве. Файлы для всех пользователей по-прежнему доступны для чтения и записи в мир; Тем не менее Android будет изолировать каждый профиль пользователя от других.

Чтение и запись в файлы практически идентичны в Xamarin. Android, как и в любом другом приложении .NET. Приложение Xamarin. Android определяет путь к файлу, который будет обрабатываться, а затем использует стандартные идиомы .NET для доступа к файлам. Так как фактические пути к внутреннему и внешнему хранилищу могут отличаться от устройства к устройству или от версии Android до версии Android, не рекомендуется жестко кодировать путь к файлам. Вместо этого Xamarin. Android предоставляет собственные API-интерфейсы Android, которые помогут определить путь к файлам во внутреннем и внешнем хранилище.

В этом руководством обсуждаются основные понятия и интерфейсы API в Android, относящиеся к внешнему хранилищу.

## <a name="public-and-private-files-on-external-storage"></a>Открытые и закрытые файлы во внешнем хранилище

Существует два разных типа файлов, которые приложение может хранить во внешнем хранилище:

* **Закрытые** файлы &ndash; закрытые файлы — это файлы, характерные для вашего приложения (но которые по-прежнему доступны для чтения и записи в мире). Android ждет, что частные файлы хранятся в определенном каталоге во внешнем хранилище. Несмотря на то, что файлы называются "частными", они по-прежнему видимы и доступны другим приложениям на устройстве, но не имеют специальной защиты Android.

* **Общедоступные** файлы &ndash; это файлы, которые не считаются специфическими для приложения и предназначены для свободного доступа.

Различия между этими файлами в основном концептуальны. Закрытые файлы являются частными в том смысле, что они считаются частью приложения, а общедоступные файлы — это любые другие файлы, существующие во внешнем хранилище. Android предоставляет два разных интерфейса API для разрешения путей к частным и общедоступным файлам, но в противном случае для чтения и записи этих файлов используются одни и те же API-интерфейсы .NET. Это те же интерфейсы API, которые обсуждаются в разделе [чтение и запись](~/android/platform/files/index.md#reading-or-writing-to-files-on-internal-storage).

### <a name="private-external-files"></a>Закрытые внешние файлы

Частные внешние файлы считаются специфичными для приложения (как и внутренние файлы), но хранятся во внешнем хранилище по любому ряду причин (например, слишком велико для внутреннего хранилища). Как и внутренние файлы, эти файлы будут удалены при удалении приложения пользователем.

Основное расположение для закрытых внешних файлов можно найти, вызвав метод `Android.Content.Context.GetExternalFilesDir(string type)`. Этот метод возвращает объект `Java.IO.File`, представляющий закрытый каталог внешнего хранилища для приложения. При передаче `null` в этот метод будет возвращен путь к каталогу хранилища пользователя для приложения. Например, для приложения с именем пакета `com.companyname.app`корневым каталогом закрытых внешних файлов будет:

```bash
/storage/emulated/0/Android/data/com.companyname.app/files/
```

Этот документ будет ссылаться на каталог хранилища для частных файлов во внешнем хранилище как _частный\_внешнее хранилище\__ .

Параметр для `GetExternalFilesDir()` — это строка, указывающая _каталог приложения_. Это каталог, предназначенный для обеспечения стандартного расположения для логической организации файлов. Строковые значения доступны через константы в классе `Android.OS.Environment`:

| `Android.OS.Environment` | Каталог |
|-|-|
| директорялармс | **_Частный\_внешнее хранилище\__ /Алармс** |
| директоридЦим | **_Частный\_внешнее хранилище\__ /дЦим** |
| директоридовнлоадс | **_Частный\_внешнее хранилище\__ /download** |
| директоридокументс | **_Частный\_внешнее хранилище\__ /документс** |
| директоримовиес | **_Частный\_внешнее хранилище\__ /Movies** |
| директоримусик | **_Частный\_внешнее хранилище\__ /Мусик** |
| директоринотификатионс | **_Частный\_внешнее хранилище\__ /нотификатионс** |
| директориподкастс | **_Частный\_внешнее хранилище\__ /подкастс** |
| директорирингтонес | **_Частный\_внешнее хранилище\__ /рингтонес** |
| директорипиктурес | **_Частный\_внешнее хранилище\__ /пиктурес** |

Для устройств с несколькими внешними секциями хранилища каждая секция будет иметь каталог, предназначенный для частных файлов. Метод `Android.Content.Context.GetExternalFilesDirs(string type)` вернет массив `Java.IO.Files`. Каждый объект будет представлять частный каталог конкретного приложения на всех общих или внешних устройствах хранения, где приложение может разместить файлы, которыми он владеет.

> [!IMPORTANT]
> Точный путь к частному внешнему каталогу хранилища может отличаться от устройства к устройству и между версиями Android. По этой причине приложения не должны жестко кодировать путь к этому каталогу, а вместо этого использовать интерфейсы API Xamarin. Android, например `Android.Content.Context.GetExternalFilesDir()`.

### <a name="public-external-files"></a>Открытые внешние файлы

Общедоступные файлы — это файлы, которые существуют во внешнем хранилище, которые не хранятся в каталоге, который Android выделяет для частных файлов. Открытые файлы не будут удалены при удалении приложения. Приложениям Android должно быть предоставлено разрешение для чтения или записи общедоступных файлов. Общедоступные файлы могут существовать где угодно во внешнем хранилище, но в соответствии с соглашением Android ожидает, что общедоступные файлы существуют в каталоге, определенном свойством `Android.OS.Environment.ExternalStorageDirectory`. Это свойство вернет объект `Java.IO.File`, представляющий основной каталог внешнего хранилища. Например, `Android.OS.Environment.ExternalStorageDirectory` может ссылаться на следующий каталог:

```bash
/storage/emulated/0/
```

Этот документ будет ссылаться на каталог хранилища для общедоступных файлов во внешнем хранилище как _Общедоступный\_внешнее хранилище\__ .

Android также поддерживает концепцию каталогов приложений на _Общедоступных\_внешних\_хранилище_. Эти каталоги точно такие же, как и каталоги приложений для `PRIVATE_EXTERNAL_STORAGE` и описаны в таблице в предыдущем разделе. Метод `Android.OS.Environment.GetExternalStoragePublicDirectory(string directoryType)` вернет объект `Java.IO.File`, соответствующий общедоступному каталогу приложения. Параметр `directoryType` является обязательным и не может быть `null`.

Например, вызов `Environment.GetExternalStoragePublicDirectory(Environment.DirectoryDocuments).AbsolutePath` вернет строку, которая будет выглядеть примерно так:

```bash
/storage/emulated/0/Documents
```

> [!IMPORTANT]
> Точный путь к общедоступному внешнему каталогу хранилища может отличаться от устройства к устройству и между версиями Android. По этой причине приложения не должны жестко кодировать путь к этому каталогу, а вместо этого использовать интерфейсы API Xamarin. Android, например `Android.OS.Environment.ExternalStorageDirectory`.

## <a name="working-with-external-storage"></a>Работа с внешним хранилищем

Когда приложение Xamarin. Android получает полный путь к файлу, для создания, чтения, записи и удаления файлов в нем должны использоваться стандартные API-интерфейсы .NET. Это увеличивает объем кода, совместимого с разными платформами, для приложения. Однако перед попыткой доступа к файлу приложение Xamarin. Android должно обеспечить доступ к этому файлу.

1. **Проверка внешнего хранилища** &ndash; в зависимости от природы внешнего хранилища, возможно, оно не может быть подключено и использовано приложением. Все приложения должны проверить состояние внешнего хранилища, прежде чем пытаться использовать его.
2. **Выполните проверку разрешений среды выполнения** &ndash; приложение Android должно запрашивать разрешение у пользователя для доступа к внешнему хранилищу. Это означает, что перед доступом к файлу необходимо выполнить запрос разрешения времени выполнения. Разрешения для руководств [в Xamarin. Android](~/android/app-fundamentals/permissions.md) содержат дополнительные сведения о разрешениях Android.

Каждая из этих двух задач будет рассмотрена ниже.

### <a name="verifying-that-external-storage-is-available"></a>Проверка доступности внешнего хранилища

Первый шаг перед записью во внешнее хранилище — проверка того, что она доступна для чтения или записи. Свойство `Android.OS.Environment.ExternalStorageState` содержит строку, которая определяет состояние внешнего хранилища. Это свойство вернет строку, представляющую состояние. Эта таблица представляет собой список значений `ExternalStorageState`, которые могут быть возвращены `Environment.ExternalStorageState`.

| екстерналсторажестате | Описание  |
|----------------------|---|
| медиабадремовал      | Носитель был внезапно удален без правильного отключения. |
| медиачеккинг        | Носитель находится в процессе проверки диска.  |
| медиаежектинг        | Носитель находится в процессе отключения и извлечения.  |
| медиамаунтед         | Носитель подключен и может быть прочитан или записан в.  |
| медиамаунтедреадонли | Носитель подключен, но может быть прочитан только из. |
| медианофс            | Носитель отсутствует, но не содержит файловую систему, подходящую для Android. |
| медиаремовед         | Отсутствует носитель. |
| медиашаред          | Носитель отсутствует, но не подключен. Общий доступ осуществляется через USB с другого устройства.|
| медиаункновн         | Android не распознает состояние носителя. |
| медиаунмаунтабле     | Носитель отсутствует, но не может быть подключен к Android. |
| медиаунмаунтед       | Носитель отсутствует, но не подключен. |

Большинству приложений Android необходимо только проверить, подключено ли внешнее хранилище. В следующем фрагменте кода показано, как убедиться, что внешнее хранилище подключено для доступа только для чтения или для чтения и записи.

```csharp
bool isReadonly = Environment.MediaMountedReadOnly.Equals(Environment.ExternalStorageState);
bool isWriteable = Environment.MediaMounted.Equals(Environment.ExternalStorageState);
```

## <a name="external-storage-permissions"></a>Разрешения внешнего хранилища

Android считает доступ к внешнему хранилищу _неопасным_, что обычно требует, чтобы пользователь предоставил разрешение на доступ к ресурсу. Пользователь может в любое время отозвать это разрешение.  Это означает, что перед доступом к файлу необходимо выполнить запрос разрешения времени выполнения. Приложениям автоматически предоставляются разрешения на чтение и запись собственных закрытых файлов. Приложения могут считывать и записывать закрытые файлы, принадлежащие другим приложениям, после [предоставления пользователю разрешения](~/android/app-fundamentals/permissions.md) .

Все приложения Android должны объявлять одно из двух разрешений для внешнего хранилища в **AndroidManifest. XML** . Для обнаружения разрешений необходимо добавить один из следующих двух `uses-permission` элементов в **AndroidManifest. XML**:

```xml
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
```

> [!NOTE]
> Если пользователь предоставляет `WRITE_EXTERNAL_STORAGE`, то `READ_EXTERNAL_STORAGE` также неявно предоставляется. Нет необходимости запрашивать оба разрешения в **AndroidManifest. XML**.

# <a name="visual-studiotabwindows"></a>[Visual Studio](#tab/windows)

Разрешения также можно добавить на вкладке **Манифест Android** в **свойствах решения**:

![Обозреватель решений — необходимые разрешения для Visual Studio](./images/required-permissions.w157.png)

# <a name="visual-studio-for-mactabmacos"></a>[Visual Studio для Mac](#tab/macos)

Разрешения также можно добавить с помощью вкладки **Манифест Android** на панели **свойств решения**.

[![Панель решения необходимые разрешения для Visual Studio для Mac](./images/required-permissions.m752-sml.png)](./images/required-permissions.m752.png#lightbox)

-----

В общем случае все опасные разрешения должны быть утверждены пользователем. Разрешения для внешнего хранилища являются аномалией в том, что в этом правиле есть исключения, в зависимости от версии Android, в которой выполняется приложение:

![Блок-схема проверок разрешений внешнего хранилища](./images/external-permission-check-flowchart.png)

Дополнительные сведения о выполнении запросов разрешений во время выполнения см. в [разделе разрешения программы в Xamarin. Android](~/android/app-fundamentals/permissions.md). **Monodroid-Sample** [локалфилес](https://github.com/xamarin/monodroid-samples/tree/master/LocalFiles) также демонстрирует один из способов выполнения проверок разрешений среды выполнения.

#### <a name="granting-and-revoking-permissions-with-adb"></a>Предоставление и Отмена разрешений с помощью ADB

В процессе разработки приложения Android может потребоваться предоставить и отозвать разрешения для тестирования различных рабочих процессов, участвующих в проверках разрешений среды выполнения. Это можно сделать в командной строке с помощью ADB. В следующих фрагментах кода командной строки показано, как предоставить или отозвать разрешения с помощью ADB для приложения Android, имя пакета которого — **com. CompanyName. app**:

```bash
$ adb shell pm grant com.companyname.app android.permission.WRITE_EXTERNAL_STORAGE

$ adb shell pm revoke com.companyname.app android.permission.WRITE_EXTERNAL_STORAGE
```

## <a name="deleting-files"></a>Удаление файлов

Любой из стандартных C# интерфейсов API можно использовать для удаления файла из внешнего хранилища, например [`System.IO.File.Delete`](xref:System.IO.File.Delete*). Также можно использовать API-интерфейсы Java за счет переноса кода. Пример:

```csharp
System.IO.File.Delete("/storage/emulated/0/Android/data/com.companyname.app/files/count.txt");
```

## <a name="related-links"></a>Связанные ссылки

* [Пример использования локальных файлов Xamarin. Android на **monodroid-Samples**](https://github.com/xamarin/monodroid-samples/tree/master/LocalFiles)
* [Разрешения в Xamarin. Android](~/android/app-fundamentals/permissions.md)
