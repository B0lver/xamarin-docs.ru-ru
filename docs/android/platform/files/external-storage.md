---
title: Доступ к файлам на внешних носителях, с помощью Xamarin.Android
description: В этом руководстве будут рассмотрены доступ к файлам на внешних носителях, в Xamarin.Android
ms.prod: xamarin
ms.assetid: 40da10b2-a207-4f9c-a2dd-165d9b662f33
ms.technology: xamarin-android
author: topgenorth
ms.author: toopge
ms.date: 07/23/2018
ms.openlocfilehash: 380100d38febf567fde94096455fd846d9d3d2d3
ms.sourcegitcommit: 9bb9e8297d3edd9a50585f4ba53c1b4f0bcd1d3e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2018
ms.locfileid: "39212210"
---
# <a name="external-storage"></a>Внешнее хранилище

Внешнее хранилище ссылается на файл и хранилище, не на внутреннее хранилище исключительно нет доступа к приложению, которое отвечает за файл. Основная цель внешнего хранилища является предоставление места для размещения файлов, предназначены для совместно использоваться приложениями или таблицы, слишком велик для внутреннего хранилища.

Исторически произношения, внешние хранилища, называется раздела диска на съемных носителях, например SD-карты (также известной как _переносное_). Это различие становится недоступным как связанные, так как развились устройств Android и многих устройств Android больше не поддерживает съемных носителей. Вместо этого некоторые устройства будет выделять некоторые из своих внутренних энергонезависимой памяти какие Android для выполнения одной функции съемный носитель. Этот процесс называется _эмулированного_ хранения и по-прежнему считается внешнего хранилища. Кроме того на некоторых устройствах Android может быть несколько секций внешнего хранилища. Например, Android планшета (в дополнение к его внутренней памяти) может эмулировать хранилища и один или несколько слотов для SD-карты. Все эти разделы обрабатываются системой Android как внешнее хранилище.

На устройствах, несколько пользователей каждый пользователь будет иметь отдельный каталог в разделе основного внешнего хранилища для их внешнего хранилища. Приложения, выполняющийся как один пользователь не будет доступа к файлам из другого пользователя на устройстве. Файлы для всех пользователей, по-прежнему мире для чтения и всему миру для записи; Тем не менее Android будет "песочницы" каждого профиля пользователя, от других.

Чтение и запись в файлы практически идентичны в Xamarin.Android, как любое другое приложение .NET. Приложение Xamarin.Android определяет путь к файлу, который будет производиться работа, затем использует стандартный .NET идиомы для доступа к файлам. Так как фактические пути, для внутреннего и внешнего хранения зависит от устройства к устройству с Android версии до версии Android, не рекомендуется явно указывать путь к файлам. Вместо этого Xamarin.Android предоставляет собственный API Android, призванная помочь определить путь к файлам на внутренние и внешние хранилища.

В этом руководстве будут рассмотрены основные понятия и API-интерфейсы в Android, заданной во внешнее хранилище.

## <a name="public-and-private-files-on-external-storage"></a>Файлы открытого и закрытого на внешних носителях

Существует два типа файлов, которые приложение может хранить на внешних носителях.

* **Закрытый** файлы &ndash; закрытый файлы — это файлы, относящиеся к приложения (но по-прежнему мире для чтения и записи по всему миру). Android ожидает, что личные файлы хранятся в заданном каталоге на внешних носителях. Несмотря на то, что эти файлы называются «private», они по-прежнему видимым и доступным для нескольких приложений на устройстве, системой Android не они получают специальные защиту.

* **Открытый** файлы &ndash; это файлы, которые не считаются зависящие от приложения и предназначены для совместного использования свободно.

Различия между этими файлами являются главным образом концептуальной. Личные файлы являются закрытыми, в том смысле, что они считаются частью приложения, хотя общедоступные файлы являются другие файлы, которые существуют на внешних носителях. Android предоставляет два разных API для разрешения путей к файлам, частных и общедоступных. Однако в противном случае используются те же интерфейсы API .NET для чтения и записи к этим файлам. Это те же интерфейсы API, описанные в разделе на [чтения и записи](~/android/platform/files/index.md#reading-or-writing-to-files-on-internal-storage).

### <a name="private-external-files"></a>Частных внешних файлов

Закрытый внешние файлы считаются зависят от конкретного приложения (как внутренних файлов), но сохраняются на внешних носителях, по ряду причин (например, слишком велик для внутреннего хранения). Как и для внутренних файлов, эти файлы будут удалены при удалении приложения пользователем.

Основное расположение для частных внешних файлов находится путем вызова метода `Android.Content.Context.GetExternalFilesDir(string type)`. Этот метод будет возвращать `Java.IO.File` объект, представляющий каталог частного внешнего хранилища для приложения. Передача `null` в этот метод возвращает путь для каталога хранилища пользователя для приложения. Например, для приложения с именем пакета `com.companyname.app`, это будет папка «root» частных внешних файлов:

```bash
/storage/emulated/0/Android/data/com.companyname.app/files/
```

В этом документе будет ссылаться в каталог хранения для файлов, закрытых на внешних носителях, как _ЧАСТНОГО\_ВНЕШНИХ\_ХРАНЕНИЯ_.


Параметр для `GetExternalFilesDir()` является строка, указывающая _каталога приложения_. Это каталог, должны давать стандартное место для логической организации файлов. Строковые значения доступны через константы на `Android.OS.Environment` класса:

| `Android.OS.Environment` | Каталог |
|-|-|
| DirectoryAlarms | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_  /тревоги** |
| DirectoryDcim | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_/DCIM** |
| DirectoryDownloads | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_  /загрузки** |
| DirectoryDocuments | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_  /документы** |
| DirectoryMovies | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_/Movies** |
| DirectoryMusic | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_/Music** |
| DirectoryNotifications | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_/Notifications** |
| DirectoryPodcasts | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_/Podcasts** |
| DirectoryRingtones | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_/Ringtones** |
| DirectoryPictures | **_ЗАКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_  /Pictures** |

Для устройств, которые имеют несколько секций внешнего хранилища каждая секция будет иметь каталога, который предназначен для личные файлы. Метод `Android.Content.Context.GetExternalFilesDirs(string type)` вернет массив `Java.IO.Files`. Каждый объект будет представлять закрытый каталог приложения на все общие и внешних запоминающих устройствах, где приложение может поместить файлы ему принадлежат.

> [!IMPORTANT]
> Точный путь к каталогу закрытый внешнее хранилище может варьироваться от устройства к устройству, а также между версиях Android. По этой причине приложения должен не жестко кода путь к этому каталогу и вместо этого используйте API Xamarin.Android, например `Android.Content.Context.GetExternalFilesDir()`.

### <a name="public-external-files"></a>Общедоступные внешние файлы

Общедоступные файлы, файлы, которые существуют на внешних носителях, которые не хранятся в каталоге, который выделяет Android для личные файлы. Общедоступные файлы не удаляются при удалении приложения. Приложения Android должно быть предоставлено разрешение, прежде чем их можно считывать или записывать все общедоступные файлы. Возможна для общих файлов должно существовать в любом месте на внешних носителях, но по соглашению Android ожидает, что общедоступные файлы в каталоге, указанное в свойстве `Android.OS.Environment.ExternalStorageDirectory`. Это свойство будет возвращать `Java.IO.File` объект, представляющий каталог основного внешнего хранилища. Например `Android.OS.Environment.ExternalStorageDirectory` может ссылаться на следующий каталог:

```bash
/storage/emulated/0/
```

В этом документе будет ссылаться в каталог хранилища для общих файлов на внешних носителях, как _ОТКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_.


Android также поддерживает концепцию каталогов приложения на _ОТКРЫТЫЙ\_ВНЕШНИХ\_ХРАНЕНИЯ_. Эти каталоги являются точно так же, как diretories приложения для `_PRIVATE\_EXTERNAL\_STORAGE_` и описаны в таблице в предыдущем разделе. Метод `Android.OS.Environment.GetExternalStoragePublicDirectory(string directoryType)` вернет `Java.IO.File` объект, который соответствуют directory общедоступных приложений. `directoryType` Параметр является обязательным параметром и не может быть `null`.

Например, вызов `Environment.GetExternalStoragePublicDirectory(Environment.DirectoryDocuments).AbsolutePath` вернет строку, которая будет выглядеть так:

```bash
/storage/emulated/0/Documents
```

> [!IMPORTANT]
> Точный путь к каталогу общедоступного внешнего хранилища может варьироваться от устройства к устройству, а также между версиях Android. По этой причине приложения должен не жестко кода путь к этому каталогу и вместо этого используйте API Xamarin.Android, например `Android.OS.Environment.ExternalStorageDirectory`.

## <a name="working-with-external-storage"></a>Работа с внешнего хранилища

После получения полный путь к файлу приложения Xamarin.Android его следует использовать все стандартные интерфейсы API .NET для создания, чтения, записи или удаления файлов. Это увеличивает объем кросс-совместимый код платформы для приложения. Тем не менее прежде чем пытаться получить доступ к файлу приложения Xamarin.Android необходимо убедиться, что это так, можно осуществлять доступ к этому файлу.

1. **Проверка внешнего хранилища** &ndash; зависимости от природы внешнего хранилища, это возможно, что он может не быть подключены и может использоваться приложением. Все приложения следует проверить состояние внешнего хранилища перед попыткой его использования.
2. **Выполните проверку времени выполнения разрешение** &ndash; приложение Android необходимо запрашивать разрешение пользователя для доступа к внешней службе хранилища. Это означает, что до любой доступ к файлам необходимо провести запрос разрешения времени выполнения. Руководство по [разрешения в Xamarin.Android](~/android/app-fundamentals/permissions.md) содержит дополнительные сведения о разрешениях для Android.

Каждый из этих двух задач будут рассмотрены ниже.

### <a name="verifying-that-external-storage-is-available"></a>Проверка доступности внешнего хранилища

Первым шагом перед записью во внешнее хранилище — убедиться, что он не доступны для чтения или записи. `Android.OS.Environment.ExternalStorageState` Свойство содержит строку, которая определяет состояние внешнего хранилища. Это свойство будет возвращать строку, представляющую состояние. В этой таблице приведен список `ExternalStorageState` значения, возвращаемые `Environment.ExternalStorageState`:

| ExternalStorageState | Описание:  |
|----------------------|---|
| MediaBadRemoval      | Мультимедиа необходимо сразу же был удален без отключением должным образом. |
| MediaChecking        | Присутствует носитель, но диск в режиме проверки.  |
| MediaEjecting        | Мультимедиа находится в процессе отключении и извлечения.  |
| MediaMounted         | Носитель подключается и может быть считываются или записываются на.  |
| MediaMountedReadOnly | Мультимедиа подключены, но может выполняться только чтение. |
| MediaNofs            | Мультимедиа присутствует, но не содержит файловую систему, подходящий для Android. |
| MediaRemoved         | Нет носителя присутствует. |
| MediaShared          | Мультимедиа присутствует, но не подключен. Он находится в совместном через USB с другим устройством.|
| MediaUnknown         | Состояние мультимедиа не распознается Android. |
| MediaUnmountable     | Носитель присутствует, но не может быть подключен по Android. |
| MediaUnmounted       | Носитель присутствует, но не подключен. |


Большинство приложений для Android будет достаточно для проверки, если подключено внешнее хранилище. В следующем фрагменте кода показано, как проверить, что для доступа только для чтения или чтения и записи подключено внешнее хранилище:

```csharp
bool isReadonly = Environment.MediaMountedReadOnly.Equals(Environment.ExternalStorageState);
bool isWriteable = Environment.MediaMounted.Equals(Environment.ExternalStorageState);
```

## <a name="external-storage-permissions"></a>Разрешения внешнего хранилища

Android считает, что доступ к внешнего хранилища, чтобы быть _опасные разрешения_, которой обычно требуется предоставить разрешения на доступ к ресурсу. Пользователь может отменить это разрешение в любое время.  Это означает, что до любой доступ к файлам необходимо провести запрос разрешения времени выполнения. Приложения автоматически предоставляются разрешения на чтение и запись свои личные файлы. Это возможно для приложений для чтения и записи личные файлы, принадлежащие другим приложениям, проработав [разрешение](~/android/app-fundamentals/permissions.md) пользователем.

Все приложения Android необходимо объявить два разрешения для внешнего хранилища в **AndroidManifest.xml** . Для идентификации разрешения, один из следующих двух `uses-permission` элементы, которые необходимо добавить к **AndroidManifest.xml**:

```xml
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
```

> [!NOTE]
> Если пользователь разрешает `WRITE_EXTERNAL_STORAGE`, затем `READ_EXTERNAL_STORAGE` предоставляется также неявно. Нет необходимости запрашивать оба разрешения в **AndroidManifest.xml**.

# <a name="visual-studiotabvswin"></a>[Visual Studio](#tab/vswin)

Разрешения также могут быть добавлены с помощью **манифест Android** вкладке **свойства решения**:

![Обозреватель решений — необходимые разрешения для Visual Studio 2017](./images/required-permissions.w157.png)

# <a name="visual-studio-for-mactabvsmac"></a>[Visual Studio для Mac](#tab/vsmac)

Разрешения также могут быть добавлены с помощью **манифест Android** вкладке **панели свойств решения**:

[![Панель решения — необходимые разрешения для Visual Studio для Mac](./images/required-permissions.m752-sml.png)](./images/required-permissions.m752.png#lightbox)

-----

Вообще говоря все небезопасные разрешения должны утверждаться пользователем. Аномальное требуются разрешения для внешнего хранилища, в том, что существуют исключения из этого правила, в зависимости от версии Android, на котором выполняется приложение.

![Блок-схема этапа проверки разрешений внешнего хранилища](./images/external-permission-check-flowchart.png)

Дополнительные сведения о выполнении запросов разрешений среды выполнения см. в руководстве по [разрешения в Xamarin.Android](~/android/app-fundamentals/permissions.md). **Monodroid-sample** [LocalFiles](https://github.com/xamarin/monodroid-samples/tree/master/LocalFiles) также демонстрирует один из способов выполнения проверки разрешений среды выполнения.

#### <a name="granting-and-revoking-permissions-with-adb"></a>Предоставление и Отмена разрешений с ADB

Во время разработки приложения для Android, может потребоваться предоставить и отменить разрешения для тестирования различных рабочие процессы, связанные с проверки разрешений среды выполнения. Это можно сделать в командной строке с помощью ADB. В следующих фрагментах командной строки показано, как предоставить или отменить разрешения с помощью ADB для приложения Android с именем пакета **com.companyname.app**:

```bash
$ adb shell pm grant com.companyname.app android.permission.WRITE_EXTERNAL_STORAGE

$ adb shell pm revoke com.companyname.app android.permission.WRITE_EXTERNAL_STORAGE
```

## <a name="deleting-files"></a>Удаление файлов

Все стандартные интерфейсы API C# можно использовать для удаления файла из внешнего хранилища, такие как [ `System.IO.File.Delete` ](xref:System.IO.File.Delete*). Можно также использовать API-интерфейсы Java, за счет переноса кода. Пример:

```csharp
System.IO.File.Delete("/storage/emulated/0/Android/data/com.companyname.app/files/count.txt");
```

## <a name="related-links"></a>Связанные ссылки

* [Xamarin.Android локальные файлы образца на **monodroid-samples**](https://github.com/xamarin/monodroid-samples/tree/master/LocalFiles)
* [Разрешения в Xamarin.Android](~/android/app-fundamentals/permissions.md)
