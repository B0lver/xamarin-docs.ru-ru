---
title: Доступ к файлам во внешнем хранилище с помощью Xamarin. Android
description: В этом руководством рассматривается доступ к файлам во внешнем хранилище в Xamarin. Android.
ms.prod: xamarin
ms.assetid: 40da10b2-a207-4f9c-a2dd-165d9b662f33
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 07/23/2018
ms.openlocfilehash: c67f58a4b1886d3f89f7bd1639e1cd687d329869
ms.sourcegitcommit: 4ff181101d76f048b949c9613b2c72cf02618f8b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "71994814"
---
# <a name="external-storage"></a>Внешнее хранилище

Внешнее хранилище относится к хранилищу файлов, которое не находится во внутреннем хранилище и недоступно для приложения, ответственного за файл. Основной целью внешнего хранилища является предоставление места для размещения файлов, которые должны совместно использоваться приложениями или которые слишком велики для размещения во внутреннем хранилище.

Исторически говоря, внешнее хранилище, на которое ссылается раздел диска на съемном носителе, такое как SD-карта (также называемое _портативным хранилищем_). Это различие больше не так важно, как устройства Android были изменены, а многие устройства Android больше не поддерживают съемные носители. Вместо этого некоторые устройства выделяют часть внутренней энергонезависимой памяти, которую Android будет использовать для выполнения одной и той же функции съемного носителя. Это называется _эмуляцией_ хранилища и по-прежнему считается внешним хранилищем. Кроме того, некоторые устройства Android могут иметь несколько внешних разделов хранилища. Например, планшет Android (помимо внутреннего хранилища) может иметь эмуляцию хранения и один или несколько слотов для SD-карты. Все эти секции обрабатываются Android как внешнее хранилище.

На устройствах с несколькими пользователями каждый пользователь будет иметь выделенный каталог в основном внешнем разделе хранилища для своего внешнего хранилища. Приложения, работающие от имени одного пользователя, не будут иметь доступа к файлам другого пользователя на устройстве. Файлы для всех пользователей по-прежнему доступны для чтения и записи в мир; Тем не менее Android будет изолировать каждый профиль пользователя от других.

Чтение и запись в файлы практически идентичны в Xamarin. Android, как и в любом другом приложении .NET. Приложение Xamarin. Android определяет путь к файлу, который будет обрабатываться, а затем использует стандартные идиомы .NET для доступа к файлам. Так как фактические пути к внутреннему и внешнему хранилищу могут отличаться от устройства к устройству или от версии Android до версии Android, не рекомендуется жестко кодировать путь к файлам. Вместо этого Xamarin. Android предоставляет собственные API-интерфейсы Android, которые помогут определить путь к файлам во внутреннем и внешнем хранилище.

В этом руководством обсуждаются основные понятия и интерфейсы API в Android, относящиеся к внешнему хранилищу.

## <a name="public-and-private-files-on-external-storage"></a>Открытые и закрытые файлы во внешнем хранилище

Существует два разных типа файлов, которые приложение может хранить во внешнем хранилище:

* **Закрытые** файлы &ndash; — это файлы, характерные для вашего приложения (но которые по-прежнему доступны для чтения и записи в мире). Android ждет, что частные файлы хранятся в определенном каталоге во внешнем хранилище. Несмотря на то, что файлы называются "частными", они по-прежнему видимы и доступны другим приложениям на устройстве, но не имеют специальной защиты Android.

* **Общие** файлы &ndash; — это файлы, которые не считаются специфическими для приложения и предназначены для свободного доступа.

Различия между этими файлами в основном концептуальны. Закрытые файлы являются частными в том смысле, что они считаются частью приложения, а общедоступные файлы — это любые другие файлы, существующие во внешнем хранилище. Android предоставляет два разных интерфейса API для разрешения путей к частным и общедоступным файлам, но в противном случае для чтения и записи этих файлов используются одни и те же API-интерфейсы .NET. Это те же интерфейсы API, которые обсуждаются в разделе [чтение и запись](~/android/platform/files/index.md#reading-or-writing-to-files-on-internal-storage).

### <a name="private-external-files"></a>Закрытые внешние файлы

Частные внешние файлы считаются специфичными для приложения (как и внутренние файлы), но хранятся во внешнем хранилище по любому ряду причин (например, слишком велико для внутреннего хранилища). Как и внутренние файлы, эти файлы будут удалены при удалении приложения пользователем.

Основное расположение для закрытых внешних файлов можно найти, вызвав метод `Android.Content.Context.GetExternalFilesDir(string type)`. Этот метод возвращает объект `Java.IO.File`, представляющий закрытый каталог внешнего хранилища для приложения. При передаче `null` в этот метод будет возвращен путь к каталогу хранилища пользователя для приложения. Например, для приложения с именем пакета `com.companyname.app` корневым каталогом закрытых внешних файлов будет:

```bash
/storage/emulated/0/Android/data/com.companyname.app/files/
```

Этот документ будет ссылаться на каталог хранилища для закрытых файлов во внешнем хранилище как _Private @ no__t-1EXTERNAL @ no__t-2STORAGE_.

Параметр для `GetExternalFilesDir()` — это строка, указывающая _каталог приложения_. Это каталог, предназначенный для обеспечения стандартного расположения для логической организации файлов. Строковые значения доступны через константы в классе `Android.OS.Environment`:

| `Android.OS.Environment` | Каталог |
|-|-|
| директорялармс | **_Private @ no__t-2EXTERNAL @ no__t-3STORAGE_/Алармс** |
| директоридЦим | **_PRIVATE @ NO__T-2EXTERNAL @ NO__T-3STORAGE_/ДЦИМ** |
| директоридовнлоадс | **_Private @ no__t-2EXTERNAL @ no__t-3STORAGE_/download** |
| директоридокументс | **_Private @ no__t-2EXTERNAL @ no__t-3STORAGE_/документс** |
| директоримовиес | **_Private @ no__t-2EXTERNAL @ no__t-3STORAGE_/Movies** |
| директоримусик | **_Private @ no__t-2EXTERNAL @ no__t-3STORAGE_/Мусик** |
| директоринотификатионс | **_Private @ no__t-2EXTERNAL @ no__t-3STORAGE_/нотификатионс** |
| директориподкастс | **_Private @ no__t-2EXTERNAL @ no__t-3STORAGE_/подкастс** |
| директорирингтонес | **_Private @ no__t-2EXTERNAL @ no__t-3STORAGE_/рингтонес** |
| директорипиктурес | **_Private @ no__t-2EXTERNAL @ no__t-3STORAGE_/пиктурес** |

Для устройств с несколькими внешними секциями хранилища каждая секция будет иметь каталог, предназначенный для частных файлов. Метод `Android.Content.Context.GetExternalFilesDirs(string type)` вернет массив `Java.IO.Files`. Каждый объект будет представлять частный каталог конкретного приложения на всех общих или внешних устройствах хранения, где приложение может разместить файлы, которыми он владеет.

> [!IMPORTANT]
> Точный путь к частному внешнему каталогу хранилища может отличаться от устройства к устройству и между версиями Android. По этой причине приложения не должны жестко кодировать путь к этому каталогу, а вместо этого использовать интерфейсы API Xamarin. Android, такие как `Android.Content.Context.GetExternalFilesDir()`.

### <a name="public-external-files"></a>Открытые внешние файлы

Общедоступные файлы — это файлы, которые существуют во внешнем хранилище, которые не хранятся в каталоге, который Android выделяет для частных файлов. Открытые файлы не будут удалены при удалении приложения. Приложениям Android должно быть предоставлено разрешение для чтения или записи общедоступных файлов. Общедоступные файлы могут существовать где угодно во внешнем хранилище, но в соответствии с соглашением Android ожидает существования общедоступных файлов в каталоге, определяемом свойством `Android.OS.Environment.ExternalStorageDirectory`. Это свойство вернет объект `Java.IO.File`, представляющий основной каталог внешнего хранилища. Например, `Android.OS.Environment.ExternalStorageDirectory` может ссылаться на следующий каталог:

```bash
/storage/emulated/0/
```

Этот документ будет ссылаться на каталог хранилища для общедоступных файлов во внешнем хранилище как _Public @ no__t-1EXTERNAL @ no__t-2STORAGE_.

Android также поддерживает концепцию каталогов приложений на _Public @ no__t-1EXTERNAL @ no__t-2STORAGE_. Эти каталоги точно совпадают с каталогами приложений для `PRIVATE_EXTERNAL_STORAGE` и описаны в таблице в предыдущем разделе. Метод `Android.OS.Environment.GetExternalStoragePublicDirectory(string directoryType)` вернет объект `Java.IO.File`, соответствующий каталогу общедоступного приложения. Параметр `directoryType` является обязательным и не может быть `null`.

Например, при вызове `Environment.GetExternalStoragePublicDirectory(Environment.DirectoryDocuments).AbsolutePath` будет возвращена строка, которая будет выглядеть примерно так:

```bash
/storage/emulated/0/Documents
```

> [!IMPORTANT]
> Точный путь к общедоступному внешнему каталогу хранилища может отличаться от устройства к устройству и между версиями Android. По этой причине приложения не должны жестко кодировать путь к этому каталогу, а вместо этого использовать интерфейсы API Xamarin. Android, такие как `Android.OS.Environment.ExternalStorageDirectory`.

## <a name="working-with-external-storage"></a>Работа с внешним хранилищем

Когда приложение Xamarin. Android получает полный путь к файлу, для создания, чтения, записи и удаления файлов в нем должны использоваться стандартные API-интерфейсы .NET. Это увеличивает объем кода, совместимого с разными платформами, для приложения. Однако перед попыткой доступа к файлу приложение Xamarin. Android должно обеспечить доступ к этому файлу.

1. **Проверка внешнего хранилища** &ndash; в зависимости от характера внешнего хранилища, возможно, он не удастся подключить и использовать в приложении. Все приложения должны проверить состояние внешнего хранилища, прежде чем пытаться использовать его.
2. **Выполнение проверки разрешений среды выполнения** &ndash; приложение Android должно запрашивать разрешение у пользователя для доступа к внешнему хранилищу. Это означает, что перед доступом к файлу необходимо выполнить запрос разрешения времени выполнения. Разрешения для руководств [в Xamarin. Android](~/android/app-fundamentals/permissions.md) содержат дополнительные сведения о разрешениях Android.

Каждая из этих двух задач будет рассмотрена ниже.

### <a name="verifying-that-external-storage-is-available"></a>Проверка доступности внешнего хранилища

Первый шаг перед записью во внешнее хранилище — проверка того, что она доступна для чтения или записи. Свойство `Android.OS.Environment.ExternalStorageState` содержит строку, которая определяет состояние внешнего хранилища. Это свойство вернет строку, представляющую состояние. Эта таблица представляет собой список значений `ExternalStorageState`, которые могут возвращаться `Environment.ExternalStorageState`.

| екстерналсторажестате | Описание  |
|----------------------|---|
| медиабадремовал      | Носитель был внезапно удален без правильного отключения. |
| медиачеккинг        | Носитель находится в процессе проверки диска.  |
| медиаежектинг        | Носитель находится в процессе отключения и извлечения.  |
| медиамаунтед         | Носитель подключен и может быть прочитан или записан в.  |
| медиамаунтедреадонли | Носитель подключен, но может быть прочитан только из. |
| медианофс            | Носитель отсутствует, но не содержит файловую систему, подходящую для Android. |
| медиаремовед         | Отсутствует носитель. |
| медиашаред          | Носитель отсутствует, но не подключен. Общий доступ осуществляется через USB с другого устройства.|
| медиаункновн         | Android не распознает состояние носителя. |
| медиаунмаунтабле     | Носитель отсутствует, но не может быть подключен к Android. |
| медиаунмаунтед       | Носитель отсутствует, но не подключен. |

Большинству приложений Android необходимо только проверить, подключено ли внешнее хранилище. В следующем фрагменте кода показано, как убедиться, что внешнее хранилище подключено для доступа только для чтения или для чтения и записи.

```csharp
bool isReadonly = Environment.MediaMountedReadOnly.Equals(Environment.ExternalStorageState);
bool isWriteable = Environment.MediaMounted.Equals(Environment.ExternalStorageState);
```

## <a name="external-storage-permissions"></a>Разрешения внешнего хранилища

Android считает доступ к внешнему хранилищу _неопасным_, что обычно требует, чтобы пользователь предоставил разрешение на доступ к ресурсу. Пользователь может в любое время отозвать это разрешение.  Это означает, что перед доступом к файлу необходимо выполнить запрос разрешения времени выполнения. Приложениям автоматически предоставляются разрешения на чтение и запись собственных закрытых файлов. Приложения могут считывать и записывать закрытые файлы, принадлежащие другим приложениям, после [предоставления пользователю разрешения](~/android/app-fundamentals/permissions.md) .

Все приложения Android должны объявлять одно из двух разрешений для внешнего хранилища в **AndroidManifest. XML** . Для распознавания разрешений один из следующих двух элементов `uses-permission` должен быть добавлен в **AndroidManifest. XML**:

```xml
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
```

> [!NOTE]
> Если пользователь предоставляет `WRITE_EXTERNAL_STORAGE`, то `READ_EXTERNAL_STORAGE` также неявно предоставляется. Нет необходимости запрашивать оба разрешения в **AndroidManifest. XML**.

# <a name="visual-studiotabwindows"></a>[Visual Studio](#tab/windows)

Разрешения также можно добавить на вкладке **Манифест Android** в **свойствах решения**:

![Обозреватель решений — необходимые разрешения для Visual Studio](./images/required-permissions.w157.png)

# <a name="visual-studio-for-mactabmacos"></a>[Visual Studio для Mac](#tab/macos)

Разрешения также можно добавить с помощью вкладки **Манифест Android** на панели **свойств решения**.

[![Solution Pad — необходимые разрешения для Visual Studio для Mac](./images/required-permissions.m752-sml.png)](./images/required-permissions.m752.png#lightbox)

-----

В общем случае все опасные разрешения должны быть утверждены пользователем. Разрешения для внешнего хранилища являются аномалией в том, что в этом правиле есть исключения, в зависимости от версии Android, в которой выполняется приложение:

![Блок-схема проверок разрешений внешнего хранилища](./images/external-permission-check-flowchart.png)

Дополнительные сведения о выполнении запросов разрешений во время выполнения см. в [разделе разрешения программы в Xamarin. Android](~/android/app-fundamentals/permissions.md). **Monodroid-Sample** [локалфилес](https://github.com/xamarin/monodroid-samples/tree/master/LocalFiles) также демонстрирует один из способов выполнения проверок разрешений среды выполнения.

#### <a name="granting-and-revoking-permissions-with-adb"></a>Предоставление и Отмена разрешений с помощью ADB

В процессе разработки приложения Android может потребоваться предоставить и отозвать разрешения для тестирования различных рабочих процессов, участвующих в проверках разрешений среды выполнения. Это можно сделать в командной строке с помощью ADB. В следующих фрагментах кода командной строки показано, как предоставить или отозвать разрешения с помощью ADB для приложения Android, имя пакета которого — **com. CompanyName. app**:

```bash
$ adb shell pm grant com.companyname.app android.permission.WRITE_EXTERNAL_STORAGE

$ adb shell pm revoke com.companyname.app android.permission.WRITE_EXTERNAL_STORAGE
```

## <a name="deleting-files"></a>Удаление файлов

Любой из стандартных C# интерфейсов API можно использовать для удаления файла из внешнего хранилища, например [`System.IO.File.Delete`](xref:System.IO.File.Delete*). Также можно использовать API-интерфейсы Java за счет переноса кода. Пример:

```csharp
System.IO.File.Delete("/storage/emulated/0/Android/data/com.companyname.app/files/count.txt");
```

## <a name="related-links"></a>Связанные ссылки

* [Пример использования локальных файлов Xamarin. Android на **monodroid-Samples**](https://github.com/xamarin/monodroid-samples/tree/master/LocalFiles)
* [Разрешения в Xamarin. Android](~/android/app-fundamentals/permissions.md)
