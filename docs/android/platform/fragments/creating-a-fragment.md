---
title: Создание фрагмента
ms.prod: xamarin
ms.assetid: F2997242-BC29-1440-7F1A-CFC447CD73FA
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 02/07/2018
ms.openlocfilehash: 0e8d3748c7ddd337cf2f27f5b272b208e79d503a
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73027502"
---
# <a name="creating-a-fragment"></a>Создание фрагмента

Чтобы создать фрагмент, класс должен наследовать от `Android.App.Fragment`, а затем переопределить метод `OnCreateView`. `OnCreateView` будет вызываться действием размещения, когда найдет время на размещение фрагмента на экране и вернет `View`. Типичный `OnCreateView` создаст эту `View` путем расширения файла макета и присоединения его к родительскому контейнеру. Характеристики контейнера важны, так как Android будет применять параметры макета родительского элемента к пользовательскому интерфейсу фрагмента. Это показано в приведенном ниже примере.

```csharp
public override View OnCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
{
    return inflater.Inflate(Resource.Layout.Example_Fragment, container, false);
}
```

Приведенный выше код выполнит расширение представления `Resource.Layout.Example_Fragment`и добавит его как дочернее представление в контейнер `ViewGroup`.

> [!NOTE]
> Подклассы фрагментов должны иметь открытый конструктор аргумента по умолчанию без аргументов.

## <a name="adding-a-fragment-to-an-activity"></a>Добавление фрагмента к действию

Существует два способа размещения фрагмента внутри действия.

- **Декларативно** &ndash; фрагменты можно использовать декларативно в файлах макета `.axml` с помощью тега `<Fragment>`.

- **Программные** &ndash; фрагменты также можно динамически создать с помощью API класса `FragmentManager`.

Программное использование с помощью класса `FragmentManager` будет обсуждаться далее в этом разделе.

### <a name="using-a-fragment-declaratively"></a>Декларативное использование фрагмента

Добавление фрагмента внутри макета требует использования тега `<fragment>` и последующего определения фрагмента путем предоставления атрибута `class` или атрибута `android:name`. В следующем фрагменте кода показано, как использовать атрибут `class` для объявления `fragment`.

```xml
<?xml version="1.0" encoding="utf-8"?>
<fragment class="com.xamarin.sample.fragments.TitlesFragment"
            android:id="@+id/titles_fragment"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent" />
```

В следующем фрагменте кода показано, как объявить `fragment` с помощью атрибута `android:name` для определения класса фрагмента:

```xml
<?xml version="1.0" encoding="utf-8"?>
<fragment android:name="com.xamarin.sample.fragments.TitlesFragment"
            android:id="@+id/titles_fragment"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent" />
```

При создании действия Android создает экземпляр каждого фрагмента, указанного в файле макета, и вставляет представление, созданное из `OnCreateView`, вместо элемента `Fragment`.
Фрагменты, декларативно добавленные в действие, являются статическими и остаются в действии до тех пор, пока они не будут уничтожены. Невозможно динамически заменить или удалить такой фрагмент в течение времени существования действия, к которому оно присоединено.

Каждому фрагменту должен быть назначен уникальный идентификатор:

- **Android: id** &ndash; как и другие элементы пользовательского интерфейса в файле макета, это уникальный идентификатор.

- **Android: tag** &ndash; этот атрибут является уникальной строкой.

Если ни один из двух предыдущих методов не используется, фрагмент будет считать идентификатор представления контейнера. В следующем примере, в котором не указаны ни `android:id`, ни `android:tag`, Android присвоит ИДЕНТИФИКАТОРу `fragment_container` фрагменту:

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:id="+@id/fragment_container"
                android:orientation="horizontal"
                android:layout_width="match_parent"
                android:layout_height="match_parent">

        <fragment class="com.example.android.apis.app.TitlesFragment"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />
</LinearLayout>
```

### <a name="package-name-case"></a>Регистр имени пакета

В Android не допускается использовать символы верхнего регистра в именах пакетов. При попытке выполнить расширение представления, если имя пакета содержит символ верхнего регистра, будет выдано исключение. Тем не менее Xamarin. Android более терпим отношению и будет допускать символы верхнего регистра в пространстве имен.

Например, оба приведенных ниже фрагмента будут работать с Xamarin. Android. Однако второй фрагмент кода вызовет исключение `android.view.InflateException` в чистом приложении Android на основе Java.

```xml
<fragment class="com.example.DetailsFragment" android:id="@+id/fragment_content" android:layout_width="match_parent" android:layout_height="match_parent" />
```

OR

```xml
<fragment class="Com.Example.DetailsFragment" android:id="@+id/fragment_content" android:layout_width="match_parent" android:layout_height="match_parent" />
```

## <a name="fragment-lifecycle"></a>Жизненный цикл фрагмента

Фрагменты имеют собственный жизненный цикл, который несколько не зависит от, но по-прежнему зависят от [жизненного цикла действия размещения](~/android/app-fundamentals/activity-lifecycle/index.md).
Например, при приостановке действия все связанные с ним фрагменты приостанавливаются. На следующей схеме показан жизненный цикл фрагмента.

[Схема потока![, иллюстрирующих жизненный цикл фрагментов](creating-a-fragment-images/fragment-lifecycle.png)](creating-a-fragment-images/fragment-lifecycle.png#lightbox)

### <a name="fragment-creation-lifecycle-methods"></a>Методы жизненного цикла создания фрагментов

В следующем списке показан поток различных обратных вызовов в жизненном цикле фрагмента во время его создания:

- **`OnInflate()`** &ndash; вызывается при создании фрагмента в виде части макета представления. Его можно вызвать сразу после создания фрагмента декларативно из XML-файла макета. Фрагмент еще не связан с его действием, но **действие**, пакет и **набор** **атрибутов** из иерархии представлений передаются в качестве параметров. Этот метод лучше использовать для синтаксического **анализа этого типа и для** сохранения атрибутов, которые могут использоваться в дальнейшем фрагменте.

- **`OnAttach()`** &ndash; вызывается после того, как фрагмент связан с действием. Это первый метод, который должен быть выполнен, когда фрагмент готов к использованию. В целом, фрагменты не должны реализовывать конструктор или переопределять конструктор по умолчанию. Все компоненты, необходимые для фрагмента, должны быть инициализированы в этом методе.

- **`OnCreate()`** &ndash;, вызванный действием для создания фрагмента. При вызове этого метода иерархия представлений ведущего действия может не полностью создаваться, поэтому фрагмент не должен полагаться на какие-либо части иерархии представлений действия до тех пор, пока в жизненном цикле фрагмента не будет более поздней. Например, не используйте этот метод для выполнения каких либо изменений или корректировок пользовательского интерфейса приложения. Это самое раннее время, когда фрагмент может начать сбор необходимых данных. Этот фрагмент выполняется в потоке пользовательского интерфейса на этом этапе, поэтому следует избегать длительной обработки или выполнять эту обработку в фоновом потоке. Этот метод можно пропустить, если вызывается **сетретаининстанце (true)** .
    Эта альтернатива будет рассмотрена более подробно ниже.

- **`OnCreateView()`** &ndash; создает представление для фрагмента.
    Этот метод вызывается после завершения метода **OnCreate ()** действия. На этом этапе можно спокойно взаимодействовать с иерархией представлений действия. Этот метод должен возвращать представление, которое будет использоваться фрагментом.

- **`OnActivityCreated()`** &ndash; вызывается действием размещения после **действия. OnCreate** .
    В настоящее время необходимо выполнить окончательные настройки пользовательского интерфейса.

- **`OnStart()`** &ndash; вызывается после возобновления содержащего его действия. Это делает фрагмент видимым для пользователя. Во многих случаях фрагмент будет содержать код, который в противном случае был бы в методе **OnStart ()** действия.

- **`OnResume()`** &ndash; это последний метод, вызываемый перед тем, как пользователь сможет взаимодействовать с фрагментом. Примером типа кода, который должен быть выполнен в этом методе, будет включение функций устройства, с которыми может взаимодействовать пользователь, например камеры, в которой находятся службы обнаружения расположения. Такие службы, например, могут вызвать чрезмерную батарею аккумулятора, и приложение должно максимально увеличить их использование, чтобы сохранить время работы от аккумулятора.

### <a name="fragment-destruction-lifecycle-methods"></a>Методы жизненного цикла уничтожения фрагментов

В следующем списке объясняются методы жизненного цикла, которые вызываются при уничтожении фрагмента:

- **`OnPause()`** &ndash; пользователь больше не может взаимодействовать с фрагментом. Такая ситуация возникает, поскольку другой операцией фрагмента является изменение этого фрагмента или операция размещения приостановлена. Возможно, действие, в котором размещен этот фрагмент, по-прежнему может быть видимым, то есть действие в фокусе частично прозрачно или не занимает весь экран. Когда этот метод становится активным, это первый индикатор того, что пользователь выходит из фрагмента. Фрагмент должен сохранить изменения.

- **`OnStop()`** &ndash; фрагмент больше не отображается. Действие узла может быть остановлено, или операция фрагмента изменяет ее в действии. Этот обратный вызов выполняет ту же цель, что и **Activity. OnStop**.

- **`OnDestroyView()`** &ndash; этот метод вызывается для очистки ресурсов, связанных с представлением. Вызывается, когда представление, связанное с фрагментом, было уничтожено.

- **`OnDestroy()`** &ndash; этот метод вызывается, когда фрагмент больше не используется. Он по-прежнему связан с действием, но фрагмент больше не работает. Этот метод должен освободить все ресурсы, которые используются в фрагменте, например [**сурфацевиев**](xref:Android.Views.SurfaceView) , который может использоваться для камеры. Этот метод можно пропустить, если вызывается **сетретаининстанце (true)** . Эта альтернатива будет рассмотрена более подробно ниже.

- **`OnDetach()`** &ndash; этот метод вызывается непосредственно перед тем, как фрагмент больше не связан с действием. Иерархия представлений фрагмента больше не существует, и все ресурсы, используемые этим фрагментом, должны быть освобождены в этот момент.

### <a name="using-setretaininstance"></a>Использование Сетретаининстанце

Для фрагмента можно указать, что его не следует полностью уничтожить при повторном создании действия. Класс `Fragment` предоставляет `SetRetainInstance` метода для этой цели. Если в этот метод передается `true`, то при перезапуске действия будет использоваться тот же экземпляр фрагмента. В этом случае все методы обратного вызова будут вызываться, за исключением обратных вызовов `OnCreate` и `OnDestroy` жизненного цикла. Этот процесс показан на приведенной выше схеме жизненного цикла (зелеными пунктирными линиями).

## <a name="fragment-state-management"></a>Управление состоянием фрагмента

Фрагменты могут сохранять и восстанавливать свое состояние во время жизненного цикла фрагмента, используя экземпляр `Bundle`. Пакет позволяет сохранять данные в виде пар "ключ — значение" и полезен для простых данных, не требующих большого объема памяти. Фрагмент может сохранить свое состояние с помощью вызова `OnSaveInstanceState`:

```csharp
public override void OnSaveInstanceState(Bundle outState)
{
    base.OnSaveInstanceState(outState);
    outState.PutInt("current_choice", _currentCheckPosition);
}
```

При создании нового экземпляра фрагмента состояние, сохраненное в `Bundle`, станет доступным для нового экземпляра с помощью `OnCreate`, `OnCreateView`и `OnActivityCreated` методов нового экземпляра.
В следующем примере показано, как получить значение `current_choice` из `Bundle`.

```csharp
public override void OnActivityCreated(Bundle savedInstanceState)
{
    base.OnActivityCreated(savedInstanceState);
    if (savedInstanceState != null)
    {
        _currentCheckPosition = savedInstanceState.GetInt("current_choice", 0);
    }
}
```

Переопределение `OnSaveInstanceState` является подходящим механизмом для сохранения временных данных во фрагменте при изменении ориентации, например `current_choice` значение в приведенном выше примере. Однако реализация `OnSaveInstanceState` по умолчанию следит за сохранением временных данных в пользовательском интерфейсе для каждого представления, которому назначен идентификатор. Например, рассмотрим приложение с элементом `EditText`, определенным в XML следующим образом:

```xml
<EditText android:id="@+id/myText"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"/>
```

Поскольку элементу управления `EditText` назначено `id`, фрагмент автоматически сохраняет данные в мини-приложении при вызове `OnSaveInstanceState`.

### <a name="bundle-limitations"></a>Ограничения пакета

Хотя использование `OnSaveInstanceState` упрощает сохранение временных данных, использование этого метода имеет некоторые ограничения.

- Если фрагмент не добавляется в стек назад, то его состояние не будет восстановлено при нажатии пользователем кнопки **назад** .

- Если пакет используется для сохранения данных, эти данные сериализуются. Это может привести к задержкам обработки.

## <a name="contributing-to-the-menu"></a>Вклад в меню

Фрагменты могут добавлять элементы в меню их действия размещения.
Действие сначала обрабатывает пункты меню. Если действие не имеет обработчика, событие будет передано в фрагмент, который затем будет обрабатывать его.

Чтобы добавить элементы в меню действия, фрагмент должен выполнить два действия.
Во первых, фрагмент должен реализовать метод `OnCreateOptionsMenu` и поместить его элементы в меню, как показано в следующем коде:

```csharp
public override void OnCreateOptionsMenu(IMenu menu, MenuInflater menuInflater)
{
    menuInflater.Inflate(Resource.Menu.menu_fragment_vehicle_list, menu);
    base.OnCreateOptionsMenu(menu, menuInflater);
}
```

Меню в предыдущем фрагменте кода было сведено из следующего XML-файла, расположенного в `menu_fragment_vehicle_list.xml`файлов:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:id="@+id/add_vehicle"
        android:icon="@drawable/ic_menu_add_data"
        android:title="@string/add_vehicle" />
</menu>
```

Затем фрагмент должен вызвать `SetHasOptionsMenu(true)`. Вызов этого метода объявляет о Android, что фрагмент имеет пункты меню для участия в меню параметров. Если не выполнить вызов этого метода, пункты меню для фрагмента не будут добавлены в меню параметров действия. Обычно это делается в методе жизненного цикла `OnCreate()`, как показано в следующем фрагменте кода:

```csharp
public override void OnCreate(Bundle savedState)
{
    base.OnCreate(savedState);
    SetHasOptionsMenu(true);
}
```

На следующем экране показано, как будет выглядеть это меню:

[снимок экрана![пример приложения "Мои поездки", отображающий пункты меню](creating-a-fragment-images/fragment-menu-example.png)](creating-a-fragment-images/fragment-menu-example.png#lightbox)
