---
title: Создание фрагмента
ms.prod: xamarin
ms.assetid: F2997242-BC29-1440-7F1A-CFC447CD73FA
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 02/07/2018
ms.openlocfilehash: 339de4930242e35c40b034af2ce6ba47fe1543af
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50122469"
---
# <a name="creating-a-fragment"></a>Создание фрагмента

Чтобы создать фрагмент, класс должен наследовать от `Android.App.Fragment` и затем Переопределите `OnCreateView` метод. `OnCreateView` будет вызываться с помощью размещения действия при его время разместить в фрагменте на экране и будут возвращать `View`. Типичный `OnCreateView` создаст ее `View` , подобных файл макета, а затем подключив его родительский контейнер. Характеристики контейнера важны, так как Android будет применять параметры макета родительского элемента к пользовательскому Интерфейсу фрагмента. Это показано в приведенном ниже примере.

```csharp
public override View OnCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
{
    return inflater.Inflate(Resource.Layout.Example_Fragment, container, false);
}
```

В приведенном выше коде значительно увеличивают представление `Resource.Layout.Example_Fragment`и добавить его в качестве дочернего представления, чтобы `ViewGroup` контейнера.


> [!NOTE]
> Вложенные классы фрагмент необходимо иметь открытый заданный по умолчанию конструктор без аргументов.

## <a name="adding-a-fragment-to-an-activity"></a>Добавление фрагмента в действие

Существует два способа, что фрагмент может размещаться внутри действия:

-   **Декларативно** &ndash; фрагменты можно использовать декларативно в `.axml` файлы макета с помощью `<Fragment>` тега.

-   **Программно** &ndash; фрагменты могут также создаваться динамически с помощью `FragmentManager` API класса.

Программное использование через `FragmentManager` класс будет рассказано далее в этом руководстве.

### <a name="using-a-fragment-declaratively"></a>Декларативно с помощью фрагмента

Добавление фрагментов внутри макета требуется использование `<fragment>` тег и затем определения фрагмента, предоставляя либо `class` атрибут или `android:name` атрибута. В следующем фрагменте показано, как использовать `class` атрибута для объявления `fragment`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<fragment class="com.xamarin.sample.fragments.TitlesFragment"
            android:id="@+id/titles_fragment"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent" />
```

Этот следующий фрагмент кода показан способ объявления `fragment` с помощью `android:name` атрибут для идентификации класса фрагмент:

```xml
<?xml version="1.0" encoding="utf-8"?>
<fragment android:name="com.xamarin.sample.fragments.TitlesFragment"
            android:id="@+id/titles_fragment"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent" />
```

При создании действия Android создания экземпляра каждого фрагмента, указанный в файле макета и вставить представление, которое создается на основе `OnCreateView` вместо `Fragment` элемент.
Фрагменты, которые декларативно добавляются действия являются статичными и останется в действии до уничтожения; не поддерживается динамически заменить или удалить таким образом фрагменты в течение времени существования действия, к которому он присоединен.

Каждый фрагмент должны быть назначены уникальный идентификатор.

-  **Android: id** &ndash; как с помощью других элементов пользовательского интерфейса в файле макета, это уникальный идентификатор.

-  **Android: тег** &ndash; этот атрибут является уникальной строкой.

Если ни один из двух предыдущих методов используется фрагмента предполагает идентификатор представления контейнера. В следующем примере там, где ни один `android:id` , ни `android:tag` не указан, Android назначит идентификатор `fragment_container` в тот фрагмент:

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:id="+@id/fragment_container"
                android:orientation="horizontal"
                android:layout_width="match_parent"
                android:layout_height="match_parent">

        <fragment class="com.example.android.apis.app.TitlesFragment"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />
</LinearLayout>
```

### <a name="package-name-case"></a>Регистр имен пакета

Android не учитывает символы верхнего регистра в именах пакетов; он вызовет исключение при попытке расширения представления, если имя пакета содержит символ верхнего регистра. Тем не менее Xamarin.Android более терпим к и допускают символов верхнего регистра в пространстве имен.

Например оба из следующих фрагментов будет работать с Xamarin.Android. Тем не менее, приведет к второй фрагмент `android.view.InflateException` исключение чисто Android приложением на платформе Java.

```xml
<fragment class="com.example.DetailsFragment" android:id="@+id/fragment_content" android:layout_width="match_parent" android:layout_height="match_parent" />
```

OR

```xml
<fragment class="Com.Example.DetailsFragment" android:id="@+id/fragment_content" android:layout_width="match_parent" android:layout_height="match_parent" />
```


## <a name="fragment-lifecycle"></a>Жизненный цикл фрагмента

Фрагменты имеют свои собственные жизненный цикл, это отчасти зависит от, но по-прежнему зависит от, [жизненного цикла действия размещения](~/android/app-fundamentals/activity-lifecycle/index.md).
Например при приостановке действия, все его связанные фрагменты будут приостановлены. На следующей схеме показаны жизненный цикл фрагмента.

[![Схема, иллюстрирующая жизненный цикл фрагмента](creating-a-fragment-images/fragment-lifecycle.png)](creating-a-fragment-images/fragment-lifecycle.png#lightbox)


### <a name="fragment-creation-lifecycle-methods"></a>Методы жизненного цикла создания фрагмента

В списке ниже показан поток различных обратных вызовов в жизненном цикле фрагмента, когда она будет создана:

-   **`OnInflate()`** &ndash; Вызывается, когда фрагмент создается как часть макета представления. Это может вызываться сразу же после фрагмента декларативно из XML-файл макета. Фрагмента еще не связана ни с его действием, но **действия**, **пакета**, и **AttributeSet** из представления иерархии передаются в качестве параметров. Этот метод лучше всего подходит для синтаксического анализа **AttributeSet** и для сохранения атрибутов, который может использоваться позже фрагмента.

-   **`OnAttach()`** &ndash; Вызывается после фрагмента, связанных с действием. Это первый метод для запуска в том случае, когда фрагмент готов для использования. В общем случае фрагментов не следует реализовывать конструктор, или переопределить конструктор по умолчанию. Все компоненты, которые требуются для фрагмента должен быть инициализирован в этом методе.

-   **`OnCreate()`** &ndash; Вызывается с помощью действия для создания фрагмента. При вызове этого метода, иерархии представлений размещения действия может не быть создан полностью, поэтому фрагмента не следует полагаться на все части иерархии действия представления, пока не позднее в жизненном цикле фрагмента. Например не используйте этот метод для выполнения любой модификации или изменения в пользовательском Интерфейсе приложения. Это самое раннее время, по которому фрагмент может начать сбор данных, ей. Фрагмент на этом этапе выполняется в потоке пользовательского интерфейса, таким образом избежать любой продолжительной обработки или выполнения этой обработки в фоновом потоке. Этот метод может быть пропущена, если **SetRetainInstance(true)** вызывается.
    Этот вариант рассматривается более подробно ниже.

-   **`OnCreateView()`** &ndash; Создает представление для фрагмента.
    Этот метод вызывается один раз действия **OnCreate()** завершении метода. На этом этапе можно безопасно взаимодействовать с иерархией представления действия. Этот метод должен возвращать представление, которое будет использоваться фрагмента.

-   **`OnActivityCreated()`** &ndash; Вызывается после **Activity.OnCreate** завершения путем размещения действия.
    Окончательные настройки в пользовательском интерфейсе должны выполняться в данный момент.

-   **`OnStart()`** &ndash; Вызывается после возобновил содержащего их действия. При этом фрагмента отображаются для пользователя. Во многих случаях фрагмента будет содержать код, который в противном случае было бы в **OnStart()** метод действия.

-   **`OnResume()`** &ndash; Это последний метод, вызываемый, прежде чем пользователь может взаимодействовать с фрагментом. Пример типа кода, которая должна выполняться в этом методе будет включение возможности устройства, пользователь может взаимодействовать с, таких как камера, службы определения местоположения. Службы, такие как это может привести к разряду батареи чрезмерное, и приложение необходимо свести к минимуму их использование для сохранения батареи.


### <a name="fragment-destruction-lifecycle-methods"></a>Методы жизненного цикла уничтожения фрагмента

Следующий список поясняет методы жизненного цикла, которые вызываются при уничтожении фрагмент:

-   **`OnPause()`** &ndash; Пользователь больше не может взаимодействовать с фрагмента. Это потому, что некоторые другие операции фрагмент изменяет этот фрагмент или приостановки действия размещения. Вполне возможно, что действие, размещение этого фрагмента может по-прежнему отображаться, то есть действия в фокусе — частично прозрачный или не занимает весь экран. Когда этот метод становится активным, это первое Указание, что пользователь оставляет фрагмента. Этот фрагмент должен сохранить внесенные изменения.

-   **`OnStop()`** &ndash; Фрагмент больше не отображается. Узел действия может быть остановлена или операцию фрагмент изменяет его в действии. Этот обратный вызов выполняет те же функции, как **Activity.OnStop**.

-   **`OnDestroyView()`** &ndash; Этот метод вызывается для очистки ресурсов, связанные с представлением. Вызывается, когда уничтожается представления, связанной с данным фрагментом.

-   **`OnDestroy()`** &ndash; Этот метод вызывается, когда фрагмент больше не используется. По-прежнему связан с действием, но фрагмента больше не работает. Этот метод должен освободить все ресурсы, используемые фрагментом, такие как [ **SurfaceView** ](https://developer.xamarin.com/api/type/Android.Views.SurfaceView/) , могут использоваться для веб-камеры. Этот метод может быть пропущена, если **SetRetainInstance(true)** вызывается. Этот вариант рассматривается более подробно ниже.

-   **`OnDetach()`** &ndash; Этот метод вызывается непосредственно перед фрагмента больше не связан с действием. Просмотр иерархии фрагмента больше не существует, и на этом этапе необходимо освободить все ресурсы, используемые фрагментом.


### <a name="using-setretaininstance"></a>С помощью SetRetainInstance

Это возможно для фрагмента указать, что оно не должно быть уничтожено полностью, если действие повторно создается. `Fragment` Класс предоставляет метод `SetRetainInstance` для этой цели. Если `true` передается этому методу, то при перезапуске действие будет использоваться тот же экземпляр фрагмента. Если это происходит, то все методы обратного вызова будет вызываться за исключением `OnCreate` и `OnDestroy` обратные вызовы жизненного цикла. Этот процесс показан на схеме жизненный цикл, показанный выше (зеленый пунктирными линиями).


## <a name="fragment-state-management"></a>Управление состоянием фрагмента

Фрагменты мая сохранять и восстанавливать их состояние во время жизненного цикла фрагмента с помощью экземпляра `Bundle`. Пакет позволяет фрагмент для сохранения данных в виде пар "ключ значение" и полезен для простых данных, которые не требуют много памяти. Фрагмент может сохранить свое состояние с помощью вызова `OnSaveInstanceState`:

```csharp
public override void OnSaveInstanceState(Bundle outState)
{
    base.OnSaveInstanceState(outState);
    outState.PutInt("current_choice", _currentCheckPosition);
}
```

При создании нового экземпляра фрагмента состояние, сохраненное в `Bundle` будут доступны в новый экземпляр класса с помощью `OnCreate`, `OnCreateView`, и `OnActivityCreated` методы нового экземпляра.
В следующем образце показано, как получить значение `current_choice` из `Bundle`:

```csharp
public override void OnActivityCreated(Bundle savedInstanceState)
{
    base.OnActivityCreated(savedInstanceState);
    if (savedInstanceState != null)
    {
        _currentCheckPosition = savedInstanceState.GetInt("current_choice", 0);
    }
}
```

Переопределение `OnSaveInstanceState` представляет собой соответствующий механизм для сохранения временных данных в фрагменте через изменения ориентации, например `current_choice` значение в приведенном выше примере. Однако реализация по умолчанию `OnSaveInstanceState` берет на себя сохранения временных данных в пользовательском Интерфейсе для каждого представления, который присвоен идентификатор. Например, рассмотрим приложение, имеющее `EditText` элемент, определенный в формате XML следующим образом:

```xml
<EditText android:id="@+id/myText"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"/>
```

Так как `EditText` элемент управления имеет `id` назначена, фрагмента автоматически сохраняет данные в мини-приложения при `OnSaveInstanceState` вызывается.


### <a name="bundle-limitations"></a>Ограничения пакета

Несмотря на то, что с помощью `OnSaveInstanceState` делает ее легко сохранять временных данных, использование этого метода имеет некоторые ограничения:

-  Если фрагмент не добавляется в стек переходов назад, то его состояние не будут восстановлены, когда пользователь нажимает **обратно** кнопки.

-  Если пакет используется для сохранения данных, эти данные сериализации. Это может привести к задержки обработки.


## <a name="contributing-to-the-menu"></a>Дополнение к меню

Фрагменты могут влиять на элементы в меню их размещения действия.
Действие сначала обрабатывает пунктов меню. Если действие не содержит обработчик, затем события передаются фрагмент, который затем будет обрабатывать его.

Чтобы добавить элементы меню действия, фрагмент необходимо выполнить два действия.
Во-первых, этот фрагмент должен реализовывать метод `OnCreateOptionsMenu` и поместите его элементы в меню, как показано в следующем коде:

```csharp
public override void OnCreateOptionsMenu(IMenu menu, MenuInflater menuInflater)
{
    menuInflater.Inflate(Resource.Menu.menu_fragment_vehicle_list, menu);
    base.OnCreateOptionsMenu(menu, menuInflater);
}
```

В меню в предыдущем фрагменте кода увеличивается из следующий код XML, расположенным в файле `menu_fragment_vehicle_list.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:id="@+id/add_vehicle"
        android:icon="@drawable/ic_menu_add_data"
        android:title="@string/add_vehicle" />
</menu>
```

Затем необходимо вызвать фрагмент `SetHasOptionsMenu(true)`. Вызов этого метода сообщает Android, что фрагмент содержит пункты меню для участия в меню "параметр". Том случае, если вызов этого метода, пункты меню для фрагмента не будут добавляться в меню параметр действия. Обычно это делается в метод жизненного цикла `OnCreate()`, как показано в следующем фрагменте кода:

```csharp
public override void OnCreate(Bundle savedState)
{
    base.OnCreate(savedState);
    SetHasOptionsMenu(true);
}
```

На следующем рисунке показано, как будет выглядеть это меню:

[![Снимок экрана с примером приложения My поездок, отображение пунктов меню](creating-a-fragment-images/fragment-menu-example.png)](creating-a-fragment-images/fragment-menu-example.png#lightbox)
