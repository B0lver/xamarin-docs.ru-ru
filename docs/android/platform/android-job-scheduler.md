---
title: "Планировщик заданий Android"
description: "В этом руководстве описывается планирование фоновой работы с помощью API Android планировщика заданий."
ms.prod: xamarin
ms.assetid: 673BB8C3-C5CC-43EC-BA8F-758F15D986C9
ms.technology: xamarin-android
author: topgenorth
ms.author: toopge
ms.date: 03/19/2018
ms.openlocfilehash: dc72b7e4da330185b00541f923d9c4b64b91bc95
ms.sourcegitcommit: d450ae06065d8f8c80f3588bc5a614cfd97b5a67
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2018
---
# <a name="android-job-scheduler"></a>Планировщик заданий Android

_В этом руководстве описывается планирование фоновой работы с помощью Android API планировщика заданий, которая доступна на устройствах под управлением Android 5.0 (уровень API 21) и более поздних версий._


## <a name="overview"></a>Обзор 

Один из лучших способов обеспечения быстрого реагирования, пользователю приложения — убедитесь, что сложных или длительных работа выполняется в фоновом режиме. Тем не менее очень важно, что фоновая операция не отрицательно влияет на взаимодействие с пользователем с устройством. 

Например фоновое задание может выполнять опрос веб-сайта каждые три или четыре минуты запроса для изменения для конкретного набора данных. Это может показаться шагом информационный характер, но он будет иметь катастрофические последствия на времени работы батареи. Приложение несколько раз будет устройства из спящего режима, повышение ЦП выше состояние питания, включите радио, сделать сетевые запросы, а затем обработки результатов. Он получает хуже, так как устройство не сразу будет выключить питание и вернуться в состояние бездействия низкого энергопотребления. Плохо расписанию фоновых рабочих случайно могут обеспечить устройства в состоянии без требования к мощности ненужное и излишнее. Деятельность кажущегося безобидным (опроса веб-сайт) сделает устройства недоступными в относительно короткий период времени.

Android предоставляет следующие интерфейсы API для выполнения работы в фоновом режиме, но сами по себе они не являются достаточными для планирования интеллектуальной заданий. 

* **[Блокировка с намерением службы](~/android/app-fundamentals/services/creating-a-service/intent-services.md)**  &ndash; цель службы прекрасно подходят для выполнения работы, однако они не предоставляют способа планирования работы.
* **[AlarmManager](https://developer.android.com/reference/android/app/AlarmManager.html)**  &ndash; эти API-интерфейсы только разрешить работу, чтобы быть запланированы, но не позволяют фактически выполняют работу. Кроме того AlarmManager допускает только ограничения на основе времени, это означает, что создавать аварийный сигнал в определенное время или после истечения определенного периода времени. 
* **[Рассылка приемники](~/android/app-fundamentals/broadcast-receivers.md)**  &ndash; приложения Android можно настроить широковещательных получателей для выполнения работы в ответ на системные события или целей. Однако широковещательных получателей не обеспечивают контроля над выполнения задания. Также будет ограничивать изменения в ОС Android при широковещательных получатели будут работать или виды работ, которое может ответить. 

Существует две основные функции для эффективного выполнения фоновой работы (иногда называют _фоновое задание_ или _задания_):

1. **Интеллектуальное планирования работы** &ndash; важно, когда приложение выполняет работу в фоновом режиме, используется как хорошо угла. В идеальном случае приложения не должен требовать выполнение задания. Вместо этого приложение должно указать условия, которые должны быть выполнены для, когда задание можно запустить и запланировать выполнение задания с операционной системой, которая будет выполнять работу, при соблюдении условий. Это позволяет Android для запуска задания, для обеспечения максимальной эффективности на устройстве. Например сетевые запросы могут пакетами для выполнения всех в то же время, чтобы использовать максимально издержки в виде связанных с загрузкой сетевых драйверов.
2. **Инкапсуляция работу** &ndash; код для выполнения фоновой работы должны инкапсулироваться в дискретные компонент, который может выполняться независимо от пользовательского интерфейса и будет относительно легко перенести, если не удается завершить работу по некоторым причинам.

Android планировщик заданий — это платформа, встроенной в ОС Android, предоставляющий fluent API для упрощения планирования фоновой работы.  Планировщик заданий Android состоит из следующих типов:

* `Android.App.Job.JobScheduler` — Это системная служба, которая используется для планирования, выполнения и при необходимости отменить, задания от имени приложения.
* `Android.App.Job.JobService` — Абстрактный класс, который необходимо расширить с логикой, которая будет выполняться задание основного потока приложения. Это означает, что `JobService` отвечает за как работа будет выполняться асинхронно.
* `Android.App.Job.JobInfo` Объект содержит критерии, руководство по Android время выполнения задания.

Для планирования работы с Android планировщик заданий, приложение Xamarin.Android необходимо инкапсулировать код в класс, расширяющий `JobService` класса. `JobService` имеется три метода жизненный цикл, который может вызываться в течение времени существования задания:

* **bool (параметры JobParameters) OnStartJob** &ndash; этот метод вызывается методом `JobScheduler` для выполнения работы, а также выполняется в основном потоке приложения. Он отвечает `JobService` для асинхронного выполнения работы и `true` при наличии работы осталось, или `false` Если выполняется работа.
    
    Когда `JobScheduler` вызывает этот метод, он будет запрашивать и сохраняют wakelock из Android длительности задания. После завершения задания, он отвечает `JobService` сообщить `JobScheduler` этот факт при вызове `JobFinished` метод (описанным ниже).

* **JobFinished (параметры JobParameters, bool needsReschedule)** &ndash; этот метод должен вызываться `JobService` сообщить `JobScheduler` , выполняется работа. Если `JobFinished` не вызывается, `JobScheduler` wakelock, вызывает ненужные батареи стока не удаляются. 

* **bool (параметры JobParameters) OnStopJob** &ndash; вызывается, когда задание преждевременно остановлено системой Android. Этот метод должен возвращать `true` должен быть перепланировано задания, на основе критериев повтора (ниже более подробно).

Можно указать _ограничения_ или _триггеры_ , будет управлять может или должен выполняться задание. Например можно ограничить задание, чтобы он будет выполняться только при заряжается устройства или для запуска задания, если изображение извлекается.

В этом руководстве будет подробно способы реализации `JobService` класса и запланировать его с `JobScheduler`.

## <a name="requirements"></a>Требования

Планировщик заданий Android требуется уровень Android API 21 (Android 5.0) или более поздней версии. 

## <a name="using-the-android-job-scheduler"></a>С помощью планировщика заданий для Android

Существует три действия для использования Android JobScheduler API:

1. Создать тип JobService для инкапсуляции работу.
2. Используйте `JobInfo.Builder` объект для создания `JobInfo` объекта, который будет содержать критерии для `JobScheduler` для выполнения задания. 
3. Запланировать задание с помощью `JobScheduler.Schedule`.

### <a name="implement-a-jobservice"></a>Реализуйте JobService

Все работа, произведенная библиотеки Android планировщик заданий, которые должны выполняться в тип, который расширяет `Android.App.Job.JobService` абстрактного класса. Создание `JobService` очень похоже на создание `Service` с платформой Android: 

1. Расширить `JobService` класса.
2. Украшение подкласс с `ServiceAttribute` и задайте `Name` параметр в строку, которая состоит из имени пакета и имя класса (см. следующий пример).
3. Задать `Permission` свойство `ServiceAttribute` к строке `android.permission.BIND_JOB_SERVICE`.
4. Переопределить `OnStartJob` метода, добавив код для выполнения работы. Android будет вызывать этот метод в основном потоке приложения для запуска задания. Трудозатраты займет больше времени, что несколько миллисекунд должна выполняться в потоке, чтобы избежать блокировки приложения.
5. По завершении работы `JobService` необходимо вызвать `JobFinished` метод. Этот метод является как `JobService` сообщает `JobScheduler` выполняется работа. Сбой при вызове `JobFinished` приведет к `JobService` помещения ненужных требований на устройстве, сокращение времени работы батареи. 
6. Рекомендуется также переопределить `OnStopJob` метод. Этот метод вызывается системой Android, когда задание завершает работу, прежде чем его завершит и предоставляет `JobService` возможность правильно ликвидируйте все ресурсы. Этот метод должен возвращать `true` при необходимости изменить расписание задания, или `false` Если это не desireable для повторного выполнения задания.
   

Ниже приведен пример простой `JobService` для приложения, с помощью TPL для асинхронного выполнения некоторой задачи:

```csharp
[Service(Name = "com.xamarin.samples.downloadscheduler.DownloadJob", 
         Permission = "android.permission.BIND_JOB_SERVICE")]
public class DownloadJob : JobService
{
    public override bool OnStartJob(JobParameters jobParams)
    {            
        Task.Run(() =>
        {
            // Work is happening asynchronously
                      
            // Have to tell the JobScheduler the work is done. 
            JobFinished(jobParams, false);
        });

        // Return true because of the asynchronous work
        return true;  
    }

    public override bool OnStopJob(JobParameters jobParams)
    {
        // we don't want to reschedule the job if it is stopped or cancelled.
        return false; 
    }
}
```

### <a name="creating-a-jobinfo-to-schedule-a-job"></a>Создание JobInfo для планирования задания

Не следует создавать экземпляры приложения Xamarin.Android `JobService` напрямую, вместо этого они будут передавать `JobInfo` объект `JobScheduler`. `JobScheduler` Будет создан экземпляр запрошенного `JobService` объекта, планирования и выполнения `JobService` согласно метаданным в `JobInfo`. Объект `JobInfo` объект должен содержать следующие сведения:

* **JobId** &ndash; это `int` значение, используемое для идентификации задания `JobScheduler`. Повторное использование этого значения будет обновлять все существующие задания. Значение должно быть уникальным для приложения. 
* **JobService** &ndash; этот параметр является `ComponentName` явным образом, который обозначает тип, `JobScheduler` следует использовать для выполнения задания. 
  

Этот метод расширения демонстрирует способ создания `JobInfo.Builder` с Android `Context`, например, действия:

```csharp
public static class JobSchedulerHelpers
{
    public static JobInfo.Builder CreateJobBuilderUsingJobId<T>(this Context context, int jobId) where T:JobService
    {
        var javaClass = Java.Lang.Class.FromType(typeof(T));
        var componentName = new ComponentName(context, javaClass);
        return new JobInfo.Builder(jobId, componentName);
    }
}

// Sample usage - creates a JobBuilder for a DownloadJob andsets the Job ID to 1.
var jobBuilder = this.CreateJobBuilderUsingJobId<DownloadJob>(1);

var jobInfo = jobBuilder.Build();  // creats a JobInfo object.
```

Это мощная функция Android планировщик заданий — возможность управлять выполнения задания или условий задание может выполняться. В следующей таблице описаны некоторые методы на `JobInfo.Builder` , которые позволяют приложению влияют на время запуска задания:  


|  Метод | Описание   |
|---|---|
| `SetMinimumLatency`  | Выполнение задержки (в миллисекундах), следует руководствоваться перед заданием. |
| `SetOverridingDeadline`  | Объявляет, что задание необходимо выполнить до истечения указанного времени (в миллисекундах). |
| `SetRequiredNetworkType`  | Указывает требования к сети для задания. |
| `SetRequiresBatteryNotLow` | Задание может запущена только в том случае, когда устройство не отображает предупреждение «низкого заряда батарей» для пользователя. |
| `SetRequiresCharging` | Выполнить задание только при зарядки. |
| `SetDeviceIdle` | Задание будет выполняться, когда устройство занято. |
| `SetPeriodic` | Указывает, следует регулярно запускать задание. |
| `SetPersisted` | Задание должно perisist после перезагрузки устройства. | 


`SetBackoffCriteria` Даются рекомендации о том, как долго `JobScheduler` ожидания перед попыткой снова запустите задание. Критерии отсрочки, состоит из двух частей: задержки в миллисекундах (значение по умолчанию 30 секунд) и тип переключения в пассивный режим, который следует использовать (иногда называют _политики отсрочки_ или _политика повторов_) . Две политики, содержащийся в `Android.App.Job.BackoffPolicy` перечисления:

* `BackoffPolicy.Exponential` &ndash; Политику экспоненциального увеличения задержки будет увеличиваться экспоненциально значение начальной задержки после каждой ошибки. При первом запуске происходит сбой операции, библиотеке будет ожидать начального интервала, который указывается перед Перепланирование задания — пример 30 секунд. Во второй раз задание завершается с ошибкой, библиотеке ожидания менее 60 секунд, прежде чем пытаться выполнить задание. После третьей неудачной попытки, библиотеке ожидания 120 секунд и так далее. Это значение по умолчанию.
* `BackoffPolicy.Linear` &ndash; Эта стратегия является линейной задержки, что задания должны быть перепланировано на выполнение с заданной периодичностью (до ее успешного выполнения). Линейной задержки наилучшим образом подходит для работы, которая должна быть выполнена как можно быстрее или проблемы, которые быстро устранить самостоятельно. 

Дополнительные сведения о создании `JobInfo` объекта, прочитайте [документации Google для `JobInfo.Builder` класса](https://developer.android.com/reference/android/app/job/JobInfo.Builder.html).

#### <a name="passing-parameters-to-a-job-via-the-jobinfo"></a>Передача параметров задания посредством JobInfo

Параметры передаются в задание, создав `PersistableBundle` , передается вместе с `Job.Builder.SetExtras` метод:

```csharp
var jobParameters = new PersistableBundle();
jobParameters.PutInt("LoopCount", 11);

var jobBuilder = this.CreateJobBuilderUsingJobId<DownloadJob>(1)
                     .SetExtras(jobParameters)
                     .Build();
```

`PersistableBundle` Осуществляется из `Android.App.Job.JobParameters.Extras` свойство в `OnStartJob` метод `JobService`:

```csharp
public override bool OnStartJob(JobParameters jobParameters)
{
    var loopCount = jobParams.Extras.GetInt("LoopCount", 10);
    
    // rest of code omitted
} 
```

### <a name="scheduling-a-job"></a>Планирование задания

Чтобы запланировать задание, приложения Xamarin.Android получите ссылку на `JobScheduler` Системная служба и вызовите `JobScheduler.Schedule` метод с `JobInfo` , созданный на предыдущем шаге. `JobScheduler.Schedule` немедленно вернет с одним из двух целочисленных значений:

* **JobScheduler.ResultSuccess** &ndash; задание был успешно запланировано. 
* **JobScheduler.ResultFailure** &ndash; не удалось запланировать задание. Обычно это вызвано конфликтующие `JobInfo` параметров.

Этот код является примером планирования задания и уведомления пользователя о результатах планирования попытки:

```csharp
var jobScheduler = (JobScheduler)GetSystemService(JobSchedulerService);
var scheduleResult = jobScheduler.Schedule(jobInfo);

if (JobScheduler.ResultSuccess == scheduleResult)
{
    Snackbar.Make(FindViewById(Android.Resource.Id.Content), Resource.String.jobscheduled_success, Snackbar.LengthShort);
}
else
{
    Snackbar.Make(FindViewById(Android.Resource.Id.Content), Resource.String.jobscheduled_failure, Snackbar.LengthShort);
}
```
 
### <a name="cancelling-a-job"></a>Отмена задания

Невозможно отменить всех запланированных заданий или только одно задание с помощью `JobsScheduler.CancelAll()` метода или `JobScheduler.Cancel(jobId)` метод:

```csharp
// Cancel all jobs
jobSchduler.CancelAll(); 

// to cancel a job with jobID = 1
jobScheduler.Cancel(1)
```
  
## <a name="summary"></a>Сводка

В этом руководстве рассматривается использование Android планировщика заданий для интеллектуально выполнить работу в фоновом режиме. Обсуждали инкапсулировать работу выполняться как `JobService` и способ использования `JobScheduler` для планирования этой работы, задавая критерии с `JobTrigger` и способ обработки ошибок с `RetryStrategy`.

## <a name="related-links"></a>Связанные ссылки

- [Интеллектуальная планирования заданий](https://developer.android.com/topic/performance/scheduling.html)
- [Справочник по JobScheduler API](https://developer.android.com/reference/android/app/job/JobScheduler.html)
- [Планирование заданий как Профессионал с JobScheduler](https://medium.com/google-developers/scheduling-jobs-like-a-pro-with-jobscheduler-286ef8510129)
- [Android батареи и оптимизации памяти - 2016 Google ввода-вывода (видео)](https://www.youtube.com/watch?v=VC2Hlb22mZM&feature=youtu.be)
- [Университет Xamarin Android JobScheduler - René Рупперт-](https://www.youtube.com/watch?v=aSjBBPYjelE)