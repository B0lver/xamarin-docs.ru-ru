---
title: Планировщик заданий Android
description: В этом руководство описано, как запланировать фоновую работу с помощью API планировщика заданий Android.
ms.prod: xamarin
ms.assetid: 673BB8C3-C5CC-43EC-BA8F-758F15D986C9
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 03/19/2018
ms.openlocfilehash: 4b1e0b32050b22a63bb89b28107877ef3e196b16
ms.sourcegitcommit: 6de849e2feca928ce5d91a3897e7d4049301081c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2020
ms.locfileid: "75667043"
---
# <a name="android-job-scheduler"></a>Планировщик заданий Android

_В этом руководство описано, как запланировать фоновую работу с помощью API планировщика заданий Android, который доступен на устройствах Android с Android 5,0 (уровень API 21) и более поздних версий._

## <a name="overview"></a>Обзор 

Одним из лучших способов обеспечения реагирования на запросы пользователя к приложению Android является обеспечение выполнения сложной или длительной работы в фоновом режиме. Однако важно, чтобы фоновая работа не негативно влияла на взаимодействие пользователя с устройством. 

Например, фоновое задание может опрашивать веб-сайт каждые три или четыре минуты для запроса изменений в определенном наборе данных. Это кажется немягким, однако это повлияет на время работы от аккумулятора. Приложение будет многократно выводить устройство из спящего режима, повышать производительность процессора до более высокого состояния электропитания, включать Радио, выполнять сетевые запросы и обрабатывать результаты. Это хуже, так как устройство не будет немедленно выключено и вернуться в состояние низкого энергопотребления. Плохо запланированная фоновая работа может привести к непреднамеренному состоянию устройства с ненужными и чрезмерными требованиями к питанию. Это похожее действие безобидным (опрос веб-сайта) сделает устройство непригодным для использования в течение относительно короткого периода времени.

Android предоставляет следующие API-интерфейсы для выполнения работы в фоновом режиме, но они недостаточно для интеллектуального планирования заданий. 

- Службы **[намеренных служб](~/android/app-fundamentals/services/creating-a-service/intent-services.md)** &ndash; намеренно подходят для выполнения работы, однако они не дают возможности планировать работу.
- **[Алармманажер](https://developer.android.com/reference/android/app/AlarmManager.html)** &ndash; эти API-интерфейсы позволяют планировать работу только по расписанию, но не дают возможности реально выполнять работу. Кроме того, Алармманажер разрешает только ограничения на основе времени, что означает создание оповещения в определенное время или по истечении определенного периода времени. 
- **[Широковещательные получатели](~/android/app-fundamentals/broadcast-receivers.md)** , &ndash; приложение Android, могут настроить широковещательные приемники для выполнения работы в ответ на события на уровне системы или намерения. Однако широковещательные приемники не предоставляют контроль над временем выполнения задания. Кроме того, изменения в операционной системе Android ограничивают, когда будут работать широковещательные получатели, или на виды работы, на которую они могут отвечать. 

Существует два ключевых компонента для эффективного выполнения фоновой работы (иногда называемой _фоновым заданием_ или _заданием_):

1. **Интеллектуальное планирование работы** &ndash; важно, что когда приложение выполняет работу в фоновом режиме, которое оно делает в качестве хорошего. В идеале приложение не должно требовать выполнения задания. Вместо этого приложение должно указать условия, которые должны быть выполнены для выполнения задания, а затем запланировать это задание с операционной системой, которая будет выполнять работу при соблюдении условий. Это позволяет Android запустить задание, чтобы обеспечить максимальную эффективность устройства. Например, сетевые запросы могут быть пакетными для одновременного выполнения, чтобы обеспечить максимальное использование нагрузки, связанной с сетью.
2. **Инкапсуляция работы** &ndash; код для выполнения фоновой работы должен быть инкапсулирован в дискретный компонент, который может быть запущен независимо от пользовательского интерфейса и будет сравнительно простым в планировании, если по какой-либо причине не удается завершить работу.

Планировщик заданий Android — это платформа, встроенная в операционную систему Android, которая предоставляет API Fluent для упрощения планирования фоновой работы.  Планировщик заданий Android состоит из следующих типов:

- `Android.App.Job.JobScheduler` — это системная служба, которая используется для планирования, выполнения и при необходимости отмены заданий от имени приложения Android.
- `Android.App.Job.JobService` — это абстрактный класс, который должен быть расширен с помощью логики, которая будет выполнять задание в основном потоке приложения. Это означает, что `JobService` отвечает за то, как выполняется асинхронное выполнение работы.
- Объект `Android.App.Job.JobInfo` содержит критерии для указания Android при запуске задания.

Чтобы запланировать работу с планировщиком заданий Android, приложение Xamarin. Android должно инкапсулировать код в класс, расширяющий класс `JobService`. в `JobService` есть три метода жизненного цикла, которые могут быть вызваны в течение времени существования задания:

- **bool онстартжоб (параметры жобпараметерс)** &ndash; этот метод вызывается `JobScheduler` для выполнения работы и выполняется в основном потоке приложения. `JobService` асинхронно выполнять работу и возвращать `true` при наличии оставшейся работы или `false` по завершении работы.
    
    Когда `JobScheduler` вызывает этот метод, он запрашивает и оставляет вакелокк от Android на время выполнения задания. По завершении задания ответственность за `JobScheduler` этого факта вызовите метод `JobFinished` (см. Далее) `JobService`.

- **Жобфинишед (параметры жобпараметерс, bool нидсресчедуле)** &ndash; этот метод должен вызываться `JobService`, чтобы сообщить `JobScheduler` о том, что работа выполнена. Если `JobFinished` не вызывается, `JobScheduler` не удалит вакелокк, что приведет к ненужному сливу аккумулятора. 

- **bool онстопжоб (параметры жобпараметерс)** &ndash; это вызывается, когда задание преждевременно остановлено Android. Он должен возвращать `true`, если задание должно быть перепланировано в соответствии с критериями повтора (см. ниже подробнее).

Можно указать _ограничения_ или _триггеры_ , которые будут контролировать, когда задание может или должно выполняться. Например, можно ограничить задание, чтобы оно выполнялось только при зарядки устройства или для запуска задания при создании изображения.

В этом руководство подробно описано, как реализовать класс `JobService` и запланировать его с помощью `JobScheduler`.

## <a name="requirements"></a>Требования

Для планировщика заданий Android требуется уровень API Android 21 (Android 5,0) или более поздней версии. 

## <a name="using-the-android-job-scheduler"></a>Использование планировщика заданий Android

Использование API Жобсчедулер для Android состоит из трех этапов.

1. Реализуйте тип Жобсервице для инкапсуляции работы.
2. Используйте объект `JobInfo.Builder`, чтобы создать `JobInfo` объект, который будет содержать критерии для `JobScheduler` выполнения задания. 
3. Запланируйте задание с помощью `JobScheduler.Schedule`.

### <a name="implement-a-jobservice"></a>Реализация Жобсервице

Вся работа, выполняемая библиотекой планировщика заданий Android, должна быть выполнена в типе, расширяющем `Android.App.Job.JobService` абстрактный класс. Создание `JobService` очень похоже на создание `Service` с помощью платформы Android: 

1. Расширьте класс `JobService`.
2. Снабдите подкласс `ServiceAttribute` и задайте параметру `Name` строку, которая состоит из имени пакета и имени класса (см. Следующий пример).
3. Задайте для свойства `Permission` `ServiceAttribute` строку `android.permission.BIND_JOB_SERVICE`.
4. Переопределите метод `OnStartJob`, добавив код для выполнения работы. Android будет вызывать этот метод в основном потоке приложения для выполнения задания. Работа, которая требует больше времени на выполнение нескольких миллисекунд на поток, чтобы избежать блокировки приложения.
5. По завершении работы `JobService` должен вызвать метод `JobFinished`. Этот метод `JobService` сообщает `JobScheduler` о том, что работа выполнена. Сбой вызова `JobFinished` приведет к тому, что `JobService` помещать ненужные требования на устройство, сокращая время работы батареи. 
6. Рекомендуется также переопределить метод `OnStopJob`. Этот метод вызывается Android при завершении задания до его завершения и предоставляет `JobService` с возможностью корректного удаления любых ресурсов. Этот метод должен возвращать `true`, если необходимо перепланировать задание, или `false`, если не требуется повторное выполнение задания.

Следующий код является примером простейшего `JobService` для приложения с помощью TPL для асинхронного выполнения некоторой работы:

```csharp
[Service(Name = "com.xamarin.samples.downloadscheduler.DownloadJob", 
         Permission = "android.permission.BIND_JOB_SERVICE")]
public class DownloadJob : JobService
{
    public override bool OnStartJob(JobParameters jobParams)
    {            
        Task.Run(() =>
        {
            // Work is happening asynchronously
                      
            // Have to tell the JobScheduler the work is done. 
            JobFinished(jobParams, false);
        });

        // Return true because of the asynchronous work
        return true;  
    }

    public override bool OnStopJob(JobParameters jobParams)
    {
        // we don't want to reschedule the job if it is stopped or cancelled.
        return false; 
    }
}
```

### <a name="creating-a-jobinfo-to-schedule-a-job"></a>Создание JobInfo для планирования задания

Приложения Xamarin. Android не создают экземпляр `JobService` напрямую, вместо этого они передают `JobInfo` объект в `JobScheduler`. `JobScheduler` будет создавать экземпляр запрошенного `JobService` объекта, планировать и запускать `JobService` в соответствии с метаданными в `JobInfo`. Объект `JobInfo` должен содержать следующие сведения:

- **JobId** &ndash; это `int` значение, используемое для обнаружения задания в `JobScheduler`. Повторное использование этого значения приведет к обновлению всех существующих заданий. Значение должно быть уникальным для приложения. 
- **Жобсервице** &ndash; этот параметр является `ComponentName`, который явно определяет тип, который `JobScheduler` должен использовать для выполнения задания. 

Этот метод расширения демонстрирует создание `JobInfo.Builder` с `Context`Android, например действие:

```csharp
public static class JobSchedulerHelpers
{
    public static JobInfo.Builder CreateJobBuilderUsingJobId<T>(this Context context, int jobId) where T:JobService
    {
        var javaClass = Java.Lang.Class.FromType(typeof(T));
        var componentName = new ComponentName(context, javaClass);
        return new JobInfo.Builder(jobId, componentName);
    }
}

// Sample usage - creates a JobBuilder for a DownloadJob and sets the Job ID to 1.
var jobBuilder = this.CreateJobBuilderUsingJobId<DownloadJob>(1);

var jobInfo = jobBuilder.Build();  // creates a JobInfo object.
```

Мощная функция планировщика заданий Android — это возможность управлять выполнением задания или при условии, в каких условиях может выполняться задание. В следующей таблице описаны некоторые методы `JobInfo.Builder`, которые позволяют приложению оказывать влияние на выполнение задания.  

|  Метод | Описание   |
|---|---|
| `SetMinimumLatency`  | Указывает задержку (в миллисекундах), которая должна наблюдаться перед выполнением задания. |
| `SetOverridingDeadline`  | Объявляет, что задание должно выполняться до истечения этого времени (в миллисекундах). |
| `SetRequiredNetworkType`  | Указывает требования к сети для задания. |
| `SetRequiresBatteryNotLow` | Задание может выполняться, только если устройство не отображает предупреждение о низком уровне зарядки для пользователя. |
| `SetRequiresCharging` | Задание может выполняться только при зарядки аккумулятора. |
| `SetDeviceIdle` | Задание будет запущено, когда устройство занято. |
| `SetPeriodic` | Указывает, что задание должно выполняться регулярно. |
| `SetPersisted` | Задание должно перисист между перезагрузками устройства. | 

`SetBackoffCriteria` предоставляет некоторые рекомендации о том, как долго `JobScheduler` должна ждать, прежде чем пытаться выполнить задание снова. Существуют две части критерия перехода: задержка в миллисекундах (значение по умолчанию 30 секунд) и тип обратного отключения, который следует использовать (иногда это называется _политикой_ отфильтра или _повтором_). Две политики инкапсулируются в перечислении `Android.App.Job.BackoffPolicy`:

- `BackoffPolicy.Exponential`, &ndash; политика экспоненциальной задержки увеличит начальное значение отхода экспоненциально после каждого сбоя. При первом сбое задания библиотека будет ожидать первоначальный интервал, указанный перед повторным планированием задания, — например, 30 секунд. При втором сбое задания библиотека будет ожидать не менее 60 секунд перед попыткой запуска задания. После третьей неудачной попытки библиотека будет ждать 120 секунд и т. д. Это значение используется по умолчанию.
- `BackoffPolicy.Linear` &ndash; эта стратегия является линейной отработкой, что задание должно быть запланировано на выполнение через заданные интервалы (до тех пор, пока оно не будет выполнено). Линейная откладывание лучше всего подходит для работы, которая должна быть выполнена как можно скорее, или для проблем, которые будут быстро устранять себя. 

Дополнительные сведения о создании объекта `JobInfo` см. [в документации Google по классу `JobInfo.Builder`](https://developer.android.com/reference/android/app/job/JobInfo.Builder.html).

#### <a name="passing-parameters-to-a-job-via-the-jobinfo"></a>Передача параметров в задание через JobInfo

Параметры передаются в задание путем создания `PersistableBundle`, который передается вместе с методом `Job.Builder.SetExtras`:

```csharp
var jobParameters = new PersistableBundle();
jobParameters.PutInt("LoopCount", 11);

var jobBuilder = this.CreateJobBuilderUsingJobId<DownloadJob>(1)
                     .SetExtras(jobParameters)
                     .Build();
```

Доступ к `PersistableBundle` осуществляется из свойства `Android.App.Job.JobParameters.Extras` в методе `OnStartJob` `JobService`:

```csharp
public override bool OnStartJob(JobParameters jobParameters)
{
    var loopCount = jobParams.Extras.GetInt("LoopCount", 10);
    
    // rest of code omitted
} 
```

### <a name="scheduling-a-job"></a>Планирование задания

Чтобы запланировать задание, приложение Xamarin. Android получит ссылку на `JobScheduler` системную службу и вызовите метод `JobScheduler.Schedule` с объектом `JobInfo`, созданным на предыдущем шаге. `JobScheduler.Schedule` будет немедленно возвращаться одним из двух целочисленных значений:

- **Жобсчедулер. ресултсукцесс** &ndash; задание было успешно запланировано. 
- **Жобсчедулер. ресултфаилуре** &ndash; не удалось запланировать задание. Обычно это вызвано конфликтующими параметрами `JobInfo`.

Этот код является примером планирования задания и уведомления пользователя о результатах попытки планирования:

```csharp
var jobScheduler = (JobScheduler)GetSystemService(JobSchedulerService);
var scheduleResult = jobScheduler.Schedule(jobInfo);

if (JobScheduler.ResultSuccess == scheduleResult)
{
    var snackBar = Snackbar.Make(FindViewById(Android.Resource.Id.Content), Resource.String.jobscheduled_success, Snackbar.LengthShort);
    snackBar.Show();
}
else
{
    var snackBar = Snackbar.Make(FindViewById(Android.Resource.Id.Content), Resource.String.jobscheduled_failure, Snackbar.LengthShort);
    snackBar.Show();
}
```

### <a name="cancelling-a-job"></a>Отмена задания

Можно отменить все запланированные задания или только одно задание, используя метод `JobsScheduler.CancelAll()` или метод `JobScheduler.Cancel(jobId)`:

```csharp
// Cancel all jobs
jobScheduler.CancelAll(); 

// to cancel a job with jobID = 1
jobScheduler.Cancel(1)
```
  
## <a name="summary"></a>Сводка

В этом руководство обсуждалось, как использовать планировщик заданий Android для интеллектуального выполнения работы в фоновом режиме. В нем обсуждалось, как инкапсулировать работу, которую необходимо выполнить в качестве `JobService`, и как использовать `JobScheduler` для планирования этой работы, указания критериев с `JobTrigger` и способа обработки ошибок с `RetryStrategy`.

## <a name="related-links"></a>Связанные ссылки

- [Интеллектуальное задание — планирование](https://developer.android.com/topic/performance/scheduling.html)
- [Справочник по API Жобсчедулер](https://developer.android.com/reference/android/app/job/JobScheduler.html)
- [Планирование заданий, таких как Pro с Жобсчедулер](https://medium.com/google-developers/scheduling-jobs-like-a-pro-with-jobscheduler-286ef8510129)
- [Батарея Android и оптимизация памяти — Google I/O 2016 (видео)](https://www.youtube.com/watch?v=VC2Hlb22mZM&feature=youtu.be)
- [Android Жобсчедулер — Ренé Рупперт](https://www.youtube.com/watch?v=aSjBBPYjelE)
