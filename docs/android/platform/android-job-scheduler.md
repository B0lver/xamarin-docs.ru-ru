---
title: Планировщик заданий Android
description: В этом руководство описано, как запланировать фоновую работу с помощью API планировщика заданий Android.
ms.prod: xamarin
ms.assetid: 673BB8C3-C5CC-43EC-BA8F-758F15D986C9
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 03/19/2018
ms.openlocfilehash: 95d4194e0ed1a1da435a233e40a74f506c49b539
ms.sourcegitcommit: 1dd7d09b60fcb1bf15ba54831ed3dd46aa5240cb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/28/2019
ms.locfileid: "70119878"
---
# <a name="android-job-scheduler"></a>Планировщик заданий Android

_В этом руководство описано, как запланировать фоновую работу с помощью API планировщика заданий Android, который доступен на устройствах Android с Android 5,0 (уровень API 21) и более поздних версий._


## <a name="overview"></a>Обзор 

Одним из лучших способов обеспечения реагирования на запросы пользователя к приложению Android является обеспечение выполнения сложной или длительной работы в фоновом режиме. Однако важно, чтобы фоновая работа не негативно влияла на взаимодействие пользователя с устройством. 

Например, фоновое задание может опрашивать веб-сайт каждые три или четыре минуты для запроса изменений в определенном наборе данных. Это кажется немягким, однако это повлияет на время работы от аккумулятора. Приложение будет многократно выводить устройство из спящего режима, повышать производительность процессора до более высокого состояния электропитания, включать Радио, выполнять сетевые запросы и обрабатывать результаты. Это хуже, так как устройство не будет немедленно выключено и вернуться в состояние низкого энергопотребления. Плохо запланированная фоновая работа может привести к непреднамеренному состоянию устройства с ненужными и чрезмерными требованиями к питанию. Это похожее действие безобидным (опрос веб-сайта) сделает устройство непригодным для использования в течение относительно короткого периода времени.

Android предоставляет следующие API-интерфейсы для выполнения работы в фоновом режиме, но они недостаточно для интеллектуального планирования заданий. 

- **[Службы намерения](~/android/app-fundamentals/services/creating-a-service/intent-services.md)** &ndash; Службы с намерением прекрасно подходят для выполнения работы, однако они не дают возможности планировать работу.
- **[Алармманажер](https://developer.android.com/reference/android/app/AlarmManager.html)** &ndash; Эти API-интерфейсы позволяют планировать работу только по расписанию, но не дают возможности реально выполнять работу. Кроме того, Алармманажер разрешает только ограничения на основе времени, что означает создание оповещения в определенное время или по истечении определенного периода времени. 
- **[Широковещательные приемники](~/android/app-fundamentals/broadcast-receivers.md)** &ndash; Приложение Android может настроить широковещательные приемники для выполнения работы в ответ на события на уровне системы или намерения. Однако широковещательные приемники не предоставляют контроль над временем выполнения задания. Кроме того, изменения в операционной системе Android ограничивают, когда будут работать широковещательные получатели, или на виды работы, на которую они могут отвечать. 

Существует два ключевых компонента для эффективного выполнения фоновой работы (иногда называемой фоновым _заданием_ или _заданием_):

1. **Интеллектуальное планирование работы** &ndash; Важно, что когда приложение работает в фоновом режиме, которое оно делает в качестве хорошего. В идеале приложение не должно требовать выполнения задания. Вместо этого приложение должно указать условия, которые должны быть выполнены для выполнения задания, а затем запланировать это задание с операционной системой, которая будет выполнять работу при соблюдении условий. Это позволяет Android запустить задание, чтобы обеспечить максимальную эффективность устройства. Например, сетевые запросы могут быть пакетными для одновременного выполнения, чтобы обеспечить максимальное использование нагрузки, связанной с сетью.
2. **Инкапсуляция работы** &ndash; Код для выполнения фоновой работы должен быть инкапсулирован в дискретный компонент, который может быть запущен независимо от пользовательского интерфейса и будет сравнительно простым в планировании, если по какой-либо причине не удается завершить работу.

Планировщик заданий Android — это платформа, встроенная в операционную систему Android, которая предоставляет API Fluent для упрощения планирования фоновой работы.  Планировщик заданий Android состоит из следующих типов:

- `Android.App.Job.JobScheduler` — Это системная служба, которая используется для планирования, выполнения и при необходимости отмены заданий от имени приложения Android.
- `Android.App.Job.JobService` — Это абстрактный класс, который должен быть расширен с помощью логики, которая будет выполнять задание в основном потоке приложения. Это означает, что `JobService` отвечает за то, как выполняется асинхронное выполнение работы.
- `Android.App.Job.JobInfo` Объект содержит критерии для указания Android при запуске задания.

Чтобы запланировать работу с планировщиком заданий Android, приложение Xamarin. Android должно инкапсулировать код в класс, расширяющий `JobService` класс. `JobService`содержит три метода жизненного цикла, которые могут быть вызваны в течение времени существования задания:

- **bool онстартжоб (параметры жобпараметерс)** Этот метод вызывается `JobScheduler` объектом для выполнения работы и выполняется в основном потоке приложения. &ndash; Для асинхронного выполнения работы и при наличии оставшейся работы, `false` а `true` также при завершении работы отвечает. `JobService`
    
    `JobScheduler` Когда вызывает этот метод, он запрашивает и оставляет вакелокк от Android на время выполнения задания. По завершении задания ответственность `JobService` за то `JobScheduler` , чтобы сообщить об `JobFinished` этом факте, осуществляется путем вызова метода (описан далее).

- **Жобфинишед (параметры жобпараметерс, bool нидсресчедуле)** Этот метод должен быть вызван с помощью `JobService` , чтобы сообщить `JobScheduler` о том, что работа выполнена. &ndash; Если `JobFinished` не вызывается, то `JobScheduler` не будет удалять вакелокк, что приведет к ненужному прекращению работы аккумулятора. 

- **bool онстопжоб (параметры жобпараметерс)** &ndash; Вызывается, когда задание преждевременно остановлено Android. Он должен возвращать `true` значение, если задание должно быть перепланировано в соответствии с критериями повтора (см. ниже подробнее).

Можно указать _ограничения_ или триггеры, которые будут контролировать, когда задание может или должно выполняться. Например, можно ограничить задание, чтобы оно выполнялось только при зарядки устройства или для запуска задания при создании изображения.

В этом руководство подробно описано, как реализовать `JobService` класс и запланировать его с помощью. `JobScheduler`

## <a name="requirements"></a>Требования

Для планировщика заданий Android требуется уровень API Android 21 (Android 5,0) или более поздней версии. 

## <a name="using-the-android-job-scheduler"></a>Использование планировщика заданий Android

Использование API Жобсчедулер для Android состоит из трех этапов.

1. Реализуйте тип Жобсервице для инкапсуляции работы.
2. Используйте объект, чтобы `JobInfo` создать объект, который будет `JobScheduler` содержать критерии для запуска задания. `JobInfo.Builder` 
3. Запланируйте задание `JobScheduler.Schedule`с помощью.

### <a name="implement-a-jobservice"></a>Реализация Жобсервице

Вся работа, выполняемая библиотекой планировщика заданий Android, должна быть выполнена в типе, расширяющем `Android.App.Job.JobService` абстрактный класс. `JobService` Создание `Service` с помощью платформы Android очень похоже на создание. 

1. `JobService` Расширьте класс.
2. Снабдите подкласс атрибутом `ServiceAttribute` и `Name` задайте для параметра строку, которая состоит из имени пакета и имени класса (см. Следующий пример).
3. `ServiceAttribute` Задайте для `android.permission.BIND_JOB_SERVICE`свойства `Permission` в строку.
4. Переопределите `OnStartJob` метод, добавив код для выполнения работы. Android будет вызывать этот метод в основном потоке приложения для выполнения задания. Работа, которая требует больше времени на выполнение нескольких миллисекунд на поток, чтобы избежать блокировки приложения.
5. По завершении работы объект `JobService` должен `JobFinished` вызвать метод. Этот метод `JobService` `JobScheduler` сообщает, что работа выполнена. Сбой вызова `JobFinished` приведет к `JobService` размещению ненужных требований на устройстве, что сократит время работы батареи. 
6. Рекомендуется также переопределить `OnStopJob` метод. Этот метод вызывается Android при завершении задания до его завершения и предоставляет `JobService` возможность правильно удалить все ресурсы. Этот метод должен возвращать `true` значение, если необходимо перепланировать задание, или `false` , если не требуется повторное выполнение задания.
   

Следующий код является примером простейшего `JobService` для приложения, использующего TPL для асинхронного выполнения некоторой работы:

```csharp
[Service(Name = "com.xamarin.samples.downloadscheduler.DownloadJob", 
         Permission = "android.permission.BIND_JOB_SERVICE")]
public class DownloadJob : JobService
{
    public override bool OnStartJob(JobParameters jobParams)
    {            
        Task.Run(() =>
        {
            // Work is happening asynchronously
                      
            // Have to tell the JobScheduler the work is done. 
            JobFinished(jobParams, false);
        });

        // Return true because of the asynchronous work
        return true;  
    }

    public override bool OnStopJob(JobParameters jobParams)
    {
        // we don't want to reschedule the job if it is stopped or cancelled.
        return false; 
    }
}
```

### <a name="creating-a-jobinfo-to-schedule-a-job"></a>Создание JobInfo для планирования задания

Приложения Xamarin. Android не создают экземпляр `JobService` напрямую, вместо этого они `JobInfo` передают объект `JobScheduler`в. Будет создан экземпляр запрошенного `JobService` объекта, планирование и запуск в `JobService` соответствии с метаданными в `JobInfo`. `JobScheduler` `JobInfo` Объект должен содержать следующие сведения:

- Идентификатор **задания** Это значение используется для обнаружения задания в. `JobScheduler` &ndash; `int` Повторное использование этого значения приведет к обновлению всех существующих заданий. Значение должно быть уникальным для приложения. 
- **Жобсервице** Этот параметр указывает, что явно `JobScheduler` определяет тип, который должен использоваться для выполнения задания. `ComponentName` &ndash; 
  

Этот метод расширения демонстрирует создание `JobInfo.Builder` с помощью Android `Context`, например действия:

```csharp
public static class JobSchedulerHelpers
{
    public static JobInfo.Builder CreateJobBuilderUsingJobId<T>(this Context context, int jobId) where T:JobService
    {
        var javaClass = Java.Lang.Class.FromType(typeof(T));
        var componentName = new ComponentName(context, javaClass);
        return new JobInfo.Builder(jobId, componentName);
    }
}

// Sample usage - creates a JobBuilder for a DownloadJob and sets the Job ID to 1.
var jobBuilder = this.CreateJobBuilderUsingJobId<DownloadJob>(1);

var jobInfo = jobBuilder.Build();  // creates a JobInfo object.
```

Мощная функция планировщика заданий Android — это возможность управлять выполнением задания или при условии, в каких условиях может выполняться задание. В следующей таблице описаны некоторые методы `JobInfo.Builder` , позволяющие приложению влиять на время выполнения задания.  


|  Метод | Описание   |
|---|---|
| `SetMinimumLatency`  | Указывает задержку (в миллисекундах), которая должна наблюдаться перед выполнением задания. |
| `SetOverridingDeadline`  | Объявляет, что задание должно выполняться до истечения этого времени (в миллисекундах). |
| `SetRequiredNetworkType`  | Указывает требования к сети для задания. |
| `SetRequiresBatteryNotLow` | Задание может выполняться, только если устройство не отображает предупреждение о низком уровне зарядки для пользователя. |
| `SetRequiresCharging` | Задание может выполняться только при зарядки аккумулятора. |
| `SetDeviceIdle` | Задание будет запущено, когда устройство занято. |
| `SetPeriodic` | Указывает, что задание должно выполняться регулярно. |
| `SetPersisted` | Задание должно перисист между перезагрузками устройства. | 


Содержит некоторые рекомендации о том, `JobScheduler` как долго должно ожидать перед повторной попыткой выполнения задания. `SetBackoffCriteria` Существуют две части критерия перехода: задержка в миллисекундах (значение по умолчанию 30 секунд) и тип обратного отключения, который следует использовать (иногда это называется _политикой_ отфильтра или повтором). Две политики инкапсулируются в `Android.App.Job.BackoffPolicy` перечислении:

- `BackoffPolicy.Exponential`&ndash; Политика экспоненциальной задержки увеличит начальное значение отхода экспоненциально после каждого сбоя. При первом сбое задания библиотека будет ожидать первоначальный интервал, указанный перед повторным планированием задания, — например, 30 секунд. При втором сбое задания библиотека будет ожидать не менее 60 секунд перед попыткой запуска задания. После третьей неудачной попытки библиотека будет ждать 120 секунд и т. д. Это значение по умолчанию.
- `BackoffPolicy.Linear`&ndash; Эта стратегия является линейной отработкой, что задание должно быть запланировано на выполнение через заданные интервалы (до тех пор, пока оно не будет выполнено). Линейная откладывание лучше всего подходит для работы, которая должна быть выполнена как можно скорее, или для проблем, которые будут быстро устранять себя. 

Дополнительные сведения о создании `JobInfo` объекта см. [в `JobInfo.Builder` документации Google по классу](https://developer.android.com/reference/android/app/job/JobInfo.Builder.html).

#### <a name="passing-parameters-to-a-job-via-the-jobinfo"></a>Передача параметров в задание через JobInfo

Параметры передаются в задание путем создания `PersistableBundle` , который передается вместе `Job.Builder.SetExtras` с методом.

```csharp
var jobParameters = new PersistableBundle();
jobParameters.PutInt("LoopCount", 11);

var jobBuilder = this.CreateJobBuilderUsingJobId<DownloadJob>(1)
                     .SetExtras(jobParameters)
                     .Build();
```

Доступ к службам осуществляется `Android.App.Job.JobParameters.Extras` из свойства `JobService`в `OnStartJob` методе класса. `PersistableBundle`

```csharp
public override bool OnStartJob(JobParameters jobParameters)
{
    var loopCount = jobParams.Extras.GetInt("LoopCount", 10);
    
    // rest of code omitted
} 
```

### <a name="scheduling-a-job"></a>Планирование задания

Чтобы запланировать задание, приложение Xamarin. Android получит ссылку на `JobScheduler` системную службу и `JobScheduler.Schedule` вызовите метод с `JobInfo` объектом, созданным на предыдущем шаге. `JobScheduler.Schedule`будет немедленно возвращать одно из двух целочисленных значений:

- **Жобсчедулер. ресултсукцесс** &ndash; задание было успешно запланировано. 
- **Жобсчедулер. ресултфаилуре** &ndash; не удалось запланировать задание. Обычно это вызвано конфликтом `JobInfo` параметров.

Этот код является примером планирования задания и уведомления пользователя о результатах попытки планирования:

```csharp
var jobScheduler = (JobScheduler)GetSystemService(JobSchedulerService);
var scheduleResult = jobScheduler.Schedule(jobInfo);

if (JobScheduler.ResultSuccess == scheduleResult)
{
    var snackBar = Snackbar.Make(FindViewById(Android.Resource.Id.Content), Resource.String.jobscheduled_success, Snackbar.LengthShort);
    snackBar.Show();
}
else
{
    var snackBar = Snackbar.Make(FindViewById(Android.Resource.Id.Content), Resource.String.jobscheduled_failure, Snackbar.LengthShort);
    snackBar.Show();
}
```
 
### <a name="cancelling-a-job"></a>Отмена задания

Можно отменить все запланированные задания или только одно задание с помощью `JobsScheduler.CancelAll()` метода `JobScheduler.Cancel(jobId)` или метода:

```csharp
// Cancel all jobs
jobScheduler.CancelAll(); 

// to cancel a job with jobID = 1
jobScheduler.Cancel(1)
```
  
## <a name="summary"></a>Сводка

В этом руководство обсуждалось, как использовать планировщик заданий Android для интеллектуального выполнения работы в фоновом режиме. В нем обсуждалось, как инкапсулировать работу, которая должна быть выполнена `JobService` в виде, и как `JobScheduler` использовать, чтобы запланировать работу, `JobTrigger` указав критерии и способ обработки ошибок с помощью `RetryStrategy`.

## <a name="related-links"></a>Связанные ссылки

- [Интеллектуальное задание — планирование](https://developer.android.com/topic/performance/scheduling.html)
- [Справочник по API Жобсчедулер](https://developer.android.com/reference/android/app/job/JobScheduler.html)
- [Планирование заданий, таких как Pro с Жобсчедулер](https://medium.com/google-developers/scheduling-jobs-like-a-pro-with-jobscheduler-286ef8510129)
- [Батарея Android и оптимизация памяти — Google I/O 2016 (видео)](https://www.youtube.com/watch?v=VC2Hlb22mZM&feature=youtu.be)
- [Android Жобсчедулер — Ренé Рупперт](https://www.youtube.com/watch?v=aSjBBPYjelE)
