---
title: Многоядерные устройства и Xamarin.Android
description: ОС Android может работать в разных компьютерных архитектурах. В этом документе рассматриваются варианты архитектуры ЦП, в которых допускается выполнение приложения Xamarin.Android. Также в этом документе описываются принципы упаковки приложений Android для поддержки нескольких архитектур ЦП. Мы познакомим вас с двоичным интерфейсом приложений (ABI) и подскажем, какие интерфейсы ABI следует применять в приложениях Xamarin.Android.
ms.prod: xamarin
ms.assetid: D812883C-A14A-E74B-0F72-E50071E96328
ms.technology: xamarin-android
author: conceptdev
ms.author: crdun
ms.date: 05/30/2019
ms.openlocfilehash: 49370813f50e3b5f1a9193c542b9f5f13d65a8e1
ms.sourcegitcommit: 654df48758cea602946644d2175fbdfba59a64f3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2019
ms.locfileid: "67829956"
---
# <a name="multi-core-devices--xamarinandroid"></a>Многоядерные устройства и Xamarin.Android

_ОС Android может работать в разных компьютерных архитектурах. В этом документе рассматриваются варианты архитектуры ЦП, в которых допускается выполнение приложения Xamarin.Android. Также в этом документе описываются принципы упаковки приложений Android для поддержки нескольких архитектур ЦП. Мы познакомим вас с двоичным интерфейсом приложений (ABI) и подскажем, какие интерфейсы ABI следует применять в приложениях Xamarin.Android._

## <a name="overview"></a>Обзор

В ОС Android можно создавать "толстые" двоичные файлы с расширением `.apk`, каждый из которых содержит машинный код для работы в разных архитектурах ЦП. В этих файлах каждый фрагмент машинного кода сопоставлен с определенным *двоичным интерфейсом приложений*. Интерфейс ABI определяет, какой конкретно фрагмент машинного кода будет выполняться на конкретном физическом устройстве. Например, чтобы приложение Android работало на устройстве x86, при сборке приложения необходимо включить поддержку ABI x86.

Это означает, что каждое приложение Android поддерживает по крайней мере один *двоичный интерфейс внедренных приложений* (EABI). EABI — это соглашения, специально созданные для внедренного программного обеспечения. Типичный интерфейс EABI описывает следующие форматы:

- набор инструкций ЦП;

- порядок следования байтов для операций загрузки и сохранения в памяти во время выполнения;

- двоичный формат объектных файлов и библиотек программ, а также допустимые и поддерживаемые типы содержимого для этих файлов и библиотек;

- различные соглашения о передаче данных между кодом приложения и системой (например, порядок применения регистров и (или) стека при вызове функций, ограничения выравнивания и т. д.);

- ограничения выравнивания и размера для типов перечисления, структур, полей и массивов;

- список символов функций, доступных в машинном коде во время выполнения, обычно для конкретного узкого набора библиотек.

### <a name="armeabi-and-thread-safety"></a>Архитектура armeabi и потокобезопасность

Двоичный интерфейс приложений подробно описан ниже. Пока мы лишь напомним, что используемая Xamarin.Android среда выполнения `armeabi` *не является потокобезопасной*. Если приложение, поддерживающее `armeabi`, развертывается на устройстве `armeabi-v7a`, возникает множество странных и порой необъяснимых исключений.

Из-за ошибки, существующей в Android версий 4.0.0, 4.0.1, 4.0.2 и 4.0.3, собственные библиотеки всегда извлекаются из каталога `armeabi`, даже если присутствует каталог `armeabi-v7a` и устройство имеет архитектуру `armeabi-v7a`.

> [!NOTE]
> Xamarin.Android следит за тем, чтобы `.so` добавлялись в APK в правильном порядке. Эта ошибка не должна составлять проблему для пользователей Xamarin.Android.

### <a name="abi-descriptions"></a>Описания интерфейсов ABI

Каждый ABI, поддерживаемый в Android, имеет уникальное имя.

#### <a name="armeabi"></a>armeabi

Это имя EABI для ЦП с архитектурой ARM, поддерживающих по меньшей мере набор инструкций ARMv5TE. Android соблюдает ABI для ARM GNU/Linux с прямым порядком байтов. Этот интерфейс ABI не поддерживает вычисления с плавающей запятой с использованием аппаратуры. Все операции с плавающей запятой выполняются вспомогательными программными функциями, которые собраны в статическую библиотеку `libgcc.a` компилятора. В `armeabi` не поддерживаются устройства SMP.

> [!IMPORTANT]
> Код `armeabi` в Xamarin.Android не является потокобезопасным. Его нельзя использовать на многопроцессорных устройствах `armeabi-v7a` (как описано ниже). Код `armeabi` можно безопасно использовать на одноядерных устройствах `armeabi-v7a`.

#### <a name="armeabi-v7a"></a>armeabi-v7a

Это другой набор инструкций для ЦП с архитектурой ARM, дополняющий описанный выше интерфейс EABI `armeabi`. В EABI `armeabi-v7a` реализована поддержка операций с плавающей запятой с использованием аппаратуры и поддержка многоядерных устройств (SMP). Приложение, в котором используется EABI `armeabi-v7a`, может выполняться существенно быстрее, чем приложение с `armeabi`.

> [!NOTE]
> Машинный код `armeabi-v7a` не выполняется на устройствах ARMv5.

#### <a name="arm64-v8a"></a>arm64-v8a

Это набор 64-разрядных инструкций, основанный на архитектуре ЦП ARMv8. Эта архитектура используется в устройствах *Nexus 9*.
В Xamarin.Android 5.1 реализована поддержка этой архитектуры (дополнительные сведения см. в разделе о [поддержке 64-разрядной среды выполнения](https://github.com/xamarin/release-notes-archive/blob/master/release-notes/android/xamarin.android_5/xamarin.android_5.1/index.md#64-bit-runtime-support)).

#### <a name="x86"></a>x86

Это имя ABI для процессоров, поддерживающих набор инструкций, известный как *x86* или *IA-32*. Этот интерфейс ABI соответствует набору инструкций для Pentium Pro, включая наборы для MMX, SSE, SSE2 и SSE3. Он не включает другие необязательные расширения IA-32, такие как:

- инструкция MOVBE;
- дополнительное расширение SSE3 (SSSE3);
- любые варианты SSE4.

> [!NOTE]
> Хотя платформа Google TV работает на архитектуре x86, ее не поддерживает Android NDK.

#### <a name="x8664"></a>x86_64

Это имя ABI для процессоров, которые поддерживают 64-разрядный набор инструкций x86 (также известен как *x64* или *AMD64*). В Xamarin.Android 5.1 реализована поддержка этой архитектуры (дополнительные сведения см. в разделе о [поддержке 64-разрядной среды выполнения](https://github.com/xamarin/release-notes-archive/blob/master/release-notes/android/xamarin.android_5/xamarin.android_5.1/index.md#64-bit-runtime-support)).

#### <a name="apk-file-format"></a>Формат файлов APK

Пакет приложения Android (APK) — это формат файлов, в котором содержится весь программный код, файлы, ресурсы и сертификаты, которые используются приложением Android. По сути это файл `.zip`, но с расширением `.apk`. На снимке экрана ниже в развернутом виде представлено содержимое файла `.apk`, созданного Xamarin.Android.

[![Содержимое APK-файла](multicore-devices-images/00.png)](multicore-devices-images/00.png#lightbox)

Краткое описание содержимого файла `.apk`.

- **AndroidManifest.xml** &ndash; это файл `AndroidManifest.xml` в двоичном формате XML.

- **Classes.dex** &ndash; содержит код приложения, скомпилированный в формат `dex`, который используется в виртуальной машине среды выполнения Android.

- **resources.arsc** &ndash; содержит все ресурсы приложения в заранее скомпилированном виде.

- **lib** &ndash; каталог с кодом, скомпилированным для разных ABI. Здесь создается отдельная вложенная папка для каждого из интерфейсов ABI, которые мы перечислили в предыдущем разделе. Файл `.apk`, представленный на снимке экрана выше, содержит собственные библиотеки для `armeabi-v7a` и `x86`.

- **МЕТА-INF** &ndash; этот каталог (при наличии) содержит сведения о подписи, а также о настройке пакета и расширений.

- **res** &ndash; содержит ресурсы, для которых в `resources.arsc` не существует скомпилированной версии.

> [!NOTE]
> Файл `libmonodroid.so` является обязательной собственной библиотекой для всех приложений Xamarin.Android.

#### <a name="android-device-abi-support"></a>Поддержка ABI для устройств Android

Каждое устройство Android поддерживает выполнение машинного кода, соответствующего одному из двух ABI:

- **"Основной" интерфейс ABI** &ndash; обозначает машинный код, используемый в системном образе.

- **"Дополнительный" интерфейс ABI** &ndash; обозначает необязательный ABI, который поддерживается в системном образе.

Например, типичное устройство ARMv5TE использует только основной ABI `armeabi`, а для устройств ARMv7 определен основной ABI `armeabi-v7a` и дополнительный ABI `armeabi`. Для устройств x86 обычно указывается только основной ABI `x86`.

### <a name="android-native-library-installation"></a>Установка собственной библиотеки Android

Во время установки пакета все собственные библиотеки из `.apk` извлекаются в каталог собственных библиотек приложения (обычно это `/data/data/<package-name>/lib`, который далее будет обозначаться как `$APP/lib`).

Алгоритм установки собственных библиотек Android существенно различается для разных версий Android.

#### <a name="installing-native-libraries-pre-android-40"></a>Установка собственных библиотек: Android до версии 4.0

До версии Android 4.0 Ice Cream Sandwich собственные библиотеки извлекались только для *одного интерфейса ABI* из `.apk`. Приложения Android тех давних лет сначала пытаются извлечь все собственные библиотеки для основного интерфейса ABI, а если таковых нет, ОС Android извлекает все собственные библиотеки для дополнительного ABI. Слияние не выполняется.

Давайте рассмотрим этот подход на примере приложения, которое устанавливается на устройстве `armeabi-v7a`. Его файл `.apk,` поддерживает как `armeabi`, так и `armeabi-v7a`, и в его каталоге `lib` есть следующие каталоги и файлы для ABI:

```shell
lib/armeabi/libone.so
lib/armeabi/libtwo.so
lib/armeabi-v7a/libtwo.so
```

После установки каталог собственных библиотек будет содержать следующее:

```shell
$APP/lib/libtwo.so # from the armeabi-v7a directory in the apk
```

Другими словами, `libone.so` не устанавливается. Это приведет к проблемам, так как `libone.so` отсутствует и приложение не сможет загрузить его во время выполнения. Такое поведение нелогично, но заявка о включении его в список ошибок была классифицирована как "[работает ожидаемым образом](http://code.google.com/p/android/issues/detail?id=9089)".

Это означает, что в приложениях для Android версий старше 4.0 необходимо предоставлять *все* собственные библиотеки для *каждого* поддерживаемого интерфейса ABI, то есть каталог `.apk` должен содержать следующее:

```shell
lib/armeabi/libone.so
lib/armeabi/libtwo.so
lib/armeabi-v7a/libone.so
lib/armeabi-v7a/libtwo.so
```

#### <a name="installing-native-libraries-android-40-ndash-android-403"></a>Установка собственных библиотек: Android 4.0&ndash;4.0.3

В Android 4.0 Ice Cream Sandwich логика извлечения изменилась. Теперь Android просматривает все собственные библиотеки и для каждого файла проверяет, извлечена ли уже библиотека с таким базовым именем и выполняются ли следующие два условия:

- файл еще не извлечен;

- интерфейс ABI этой собственной библиотеки совпадает с основным или дополнительным интерфейсом ABI для целевого объекта.

Если эти условия выполняются, используется принцип "слияния". Предположим, что у нас есть `.apk` со следующим содержимым:

```shell
lib/armeabi/libone.so
lib/armeabi/libtwo.so
lib/armeabi-v7a/libtwo.so
```

После установки такого приложения каталог собственных библиотек будет содержать следующее:

```shell
$APP/lib/libone.so
$APP/lib/libtwo.so
```

К сожалению, такое поведение зависит от порядка, как описано в следующем документе: [Issue 24321: Galaxy Nexus 4.0.2 uses armeabi native code when both armeabi and armeabi-v7a is included in apk](http://code.google.com/p/android/issues/detail?id=25321) (Проблема 24321. Устройство Galaxy Nexus 4.0.2 использует машинный код armeabi, когда armeabi и armeabi-v7a одновременно включены в APK).

Собственные библиотеки обрабатываются "по порядку" (который определяется программой распаковки) и применяется *первое соответствие*. Так как `.apk` содержит одновременно версии `armeabi` и `armeabi-v7a` для файла `libtwo.so`, при этом `armeabi` указан первым, то используется именно версия `armeabi`, но *не* правильная версия `armeabi-v7a`:

```shell
$APP/lib/libone.so # armeabi
$APP/lib/libtwo.so # armeabi, NOT armeabi-v7a!
```

Более того, даже если указаны оба ABI (`armeabi` и `armeabi-v7a`), как описано ниже в разделе *Объявление поддерживаемых ABI*, Xamarin.Android создаст следующий элемент в .
`csproj`:

```xml
<AndroidSupportedAbis>armeabi,armeabi-v7a</AndroidSupportedAbis>
```

В результате библиотека `armeabi` `libmonodroid.so` будет найдена первой в составе `.apk`, и именно `armeabi` `libmonodroid.so` будет извлекаться, даже если в файле присутствует библиотека `armeabi-v7a` `libmonodroid.so`, оптимизированная для целевого устройства. Это может приводить к дополнительным неочевидным ошибкам во время выполнения, так как `armeabi` не поддерживает многоядерные устройства.


##### <a name="installing-native-libraries-android-404-and-later"></a>Установка собственных библиотек: Android 4.0.4 и более поздние версии

В Android 4.0.4 снова изменилась логика извлечения: теперь ОС перебирает все собственные библиотеки, считывает базовые имена файлов и извлекает версию для основного интерфейса ABI (если она есть) или версию для дополнительного интерфейса ABI (если она есть). Здесь реализован правильный принцип "слияния". Предположим, что у нас есть `.apk` со следующим содержимым:

```shell
lib/armeabi/libone.so
lib/armeabi/libtwo.so
lib/armeabi-v7a/libtwo.so
```

После установки такого приложения каталог собственных библиотек будет содержать следующее:

```shell
$APP/lib/libone.so # from armeabi
$APP/lib/libtwo.so # from armeabi-v7a
```

### <a name="xamarinandroid-and-abis"></a>Xamarin.Android и интерфейсы ABI

Xamarin.Android поддерживает следующие варианты _64-разрядной_ архитектуры:

- `arm64-v8a`
- `x86_64`

> [!NOTE]
> Начиная с августа 2018 г. новые приложения должны будут использовать API уровня 26, а с августа 2019 г. будет [необходимо выпускать 64-разрядные версии приложений](https://android-developers.googleblog.com/2017/12/improving-app-security-and-performance.html) в дополнение к 32-разрядным.

Xamarin.Android поддерживает следующие варианты 32-разрядной архитектуры:

- `armeabi` ^
- `armeabi-v7a`
- `x86`

> [!NOTE]
> **^** Начиная с версии [Xamarin.Android 9.2](https://docs.microsoft.com/xamarin/android/release-notes/9/9.2#removal-of-support-for-armeabi-cpu-architecture) `armeabi` больше не поддерживается.

Xamarin.Android сейчас не поддерживает `mips`.

### <a name="declaring-supported-abis"></a>Объявление поддерживаемых ABI

По умолчанию Xamarin.Android применяет `armeabi-v7a` для **сборки выпуска**, а `armeabi-v7a` и `x86` — для **отладочной сборки**. Поддержку других ABI можно задать на странице параметров для проекта Xamarin.Android. В Visual Studio эти значения настраиваются на странице **Параметры Android** в окне **Свойства**, на вкладке **Дополнительно**, как показано на следующем снимке экрана:

![Параметры Android — дополнительные свойства](multicore-devices-images/vs-abi-selections.png)

В Visual Studio для Mac поддерживаемую архитектуру можно выбрать на странице **Android Build** (Сборка Android) в разделе **Project Options** (Параметры проекта) на вкладке **Advanced** (Дополнительно), как показано на следующем снимке экрана:

[![Сборка Android — поддерживаемые ABI](multicore-devices-images/xs-abi-selections-sml.png)](multicore-devices-images/xs-abi-selections.png#lightbox)

Существуют ситуации, когда нужно объявить поддержку дополнительного интерфейса ABI, например в следующих случаях:

- развертывание приложения на устройстве `x86`;

- развертывание приложения на устройстве `armeabi-v7a` с обеспечением потокобезопасности.

## <a name="summary"></a>Сводка

В этом документе мы рассмотрели архитектуры ЦП, в которых можно запускать приложения Xamarin.Android. Здесь описана концепция двоичного интерфейса приложения и его применение в ОС Android для поддержки разнородных архитектур ЦП.
Затем мы объяснили, как правильно описать поддержку интерфейсов ABI в приложении Xamarin.Android, и рассмотрели несколько проблем, которые могут возникать при использовании приложения Xamarin.Android на устройстве `armeabi-v7a`, которое предназначено только для `armeabi`.

## <a name="related-links"></a>Связанные ссылки

- [Интерфейс ABI для архитектуры ARM (PDF)](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0036b/IHI0036B_bsabi.pdf)
- [Android NDK](https://developer.android.com/tools/sdk/ndk/index.html)
- [(Проблема 9089: на устройстве Nexus One не загружается ни одна собственная библиотека для armeabi, если есть хотя бы одна библиотека для armeabi-v7a](http://code.google.com/p/android/issues/detail?id=9089)
- [Issue 24321: Galaxy Nexus 4.0.2 uses armeabi native code when both armeabi and armeabi-v7a is included in apk](http://code.google.com/p/android/issues/detail?id=25321) (Проблема 24321. Устройство Galaxy Nexus 4.0.2 использует машинный код armeabi, когда armeabi и armeabi-v7a одновременно включены в APK)
