---
title: RecyclerView компоненты и функции
description: Обзор диспетчера макета RecyclerView, адаптер и владелец представления.
ms.prod: xamarin
ms.assetid: 54F999BE-2732-4BC7-A466-D17373961C48
ms.technology: xamarin-android
author: mgmclemore
ms.author: mamcle
ms.date: 07/13/2018
ms.openlocfilehash: 4d55124e9a02489d1f55e900c537939ff3450509
ms.sourcegitcommit: cb80df345795989528e9df78eea8a5b45d45f308
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/14/2018
ms.locfileid: "39038512"
---
# <a name="recyclerview-parts-and-functionality"></a>RecyclerView компоненты и функции


`RecyclerView` дескрипторы, некоторые задачи внутренним образом (например, прокрутка и повторное использование представлений), но он является по сути менеджером, координирующий вспомогательных классов для отображения коллекции. `RecyclerView` делегирует задачи в следующие вспомогательные классы:

-   **`Adapter`** &ndash; Увеличивает элемент макеты (создает содержимое файла макет) и выполняет привязку их данных к представлениям, которые отображаются в `RecyclerView`. Адаптер также отображаются события click элемента.

-   **`LayoutManager`** &ndash; Измеряет и помещает представления элемента в пределах `RecyclerView` и управляет политикой, для повторного использования представления.

-   **`ViewHolder`** &ndash; Ищет и сохраняет ссылки на представление. Владелец представления также помогает обеспечивать обнаружение щелчков представление элементов.

-   **`ItemDecoration`** &ndash; Позволяет приложению для добавления специальных смещения Рисование и макет для конкретных представлений для рисования разделителей между элементами, основные положения и визуальную группировку границы.

-   **`ItemAnimator`** &ndash; Определяет анимацию, возникающие во время выполнения действий с элементом или как изменения вносятся в адаптер.

Связь между `RecyclerView`, `LayoutManager`, и `Adapter` классы показан на следующей схеме:

![Схема RecyclerView, содержащая LayoutManager, с помощью адаптера для доступа к набору данных](parts-and-functionality-images/01-recyclerview-diagram.png)

Как показано на рисунке выше, `LayoutManager` может рассматриваться как посредник между `Adapter` и `RecyclerView`. `LayoutManager` Обращающийся к `Adapter` методы от имени `RecyclerView`. Например `LayoutManager` вызовы `Adapter` метод, когда придет время, чтобы создать новое представление для определенной позиции в `RecyclerView`. `Adapter` Увеличивает макета для этого элемента и создает `ViewHolder` экземпляра (не показано) для кэширования ссылок на представления, в этой позиции. Когда `LayoutManager` вызовы `Adapter` для привязки к набору данных, определенного элемента `Adapter` находит данные для этого элемента, извлекает их из набора данных и копирует его в представление связанного элемента.

При использовании `RecyclerView` в приложении, создание производных типов следующих классов является обязательным:

-   **`RecyclerView.Adapter`** &ndash; Обеспечивает привязку из набора данных приложения (которая отображается в приложение) для представления элементов, отображаемых в `RecyclerView`. Адаптер знает, как связать Каждая позиция элемента представления в `RecyclerView` в определенное расположение в источнике данных. Кроме того адаптер обрабатывает макет содержимого внутри каждого отдельного элемента и создает владелец представления для каждого представления. Адаптер также сообщает о щелчком элемента, которые определяются в представлении элемента.

-   **`RecyclerView.ViewHolder`** &ndash; Кэширует ссылки на представления в файле макета элемента, чтобы поиск ресурсов без необходимости не повторяются. Владелец представления также упорядочивает для события щелчка элемента должно перенаправляться в адаптер, когда пользователь касается представление владельца представления связанного элемента.

-   **`RecyclerView.LayoutManager`** &ndash; Помещает элементы в `RecyclerView`. Вы можете использовать один из нескольких диспетчеров стандартным макетом. или можно реализовать собственное диспетчер пользовательского макета.
    `RecyclerView` делегаты макета политику, чтобы диспетчер структуры, поэтому вы можете подключить диспетчер другой макет без необходимости вносить значительные изменения в приложение.

Кроме того, при необходимости можно расширить следующие классы для изменения внешнего вида `RecyclerView` в приложении:

-   **`RecyclerView.ItemDecoration`**
-   **`RecyclerView.ItemAnimator`**

Если вы не расширили `ItemDecoration` и `ItemAnimator`, `RecyclerView` использует по умолчанию реализации. В этом руководстве объясняют, как создавать настраиваемые `ItemDecoration` и `ItemAnimator` классы; Дополнительные сведения об этих классах см. в разделе [RecyclerView.ItemDecoration](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemDecoration.html) и [RecyclerView.ItemAnimator](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemAnimator.html).


<a name="recycling" />

### <a name="how-view-recycling-works"></a>Как просмотреть повторное использование Works

`RecyclerView` не выделяет в представлении элемента для каждого элемента в источнике данных. Вместо этого он выделяет только количество элементов представления, которые помещаются на экране, и он повторно использует эти макеты элемента прокрутке пользователем. Когда представление сначала прокручивается за пределы видимости, проходит процесс перезапуска, показано на следующем рисунке:

[![Схема, иллюстрирующая шесть шагов процедуры перезапуска представления](parts-and-functionality-images/02-view-recycling-sml.png)](parts-and-functionality-images/02-view-recycling.png#lightbox)

1.  Когда представление прокручивается за пределы видимости и больше не отображается, оно становится *отходов представление*.

2.  Представление кармана помещается в пул и становится *повторно использовать представление*.
    Этот пул — это кэш представлений, которые отображают же тип данных.

3.  Если новый элемент для отображения, представление берется из пула перезапуска для повторного использования. Так как в этом представлении должен быть повторно привязан адаптером до их отображения, он называется *"грязных" представление*.

4.  "Грязный" представление будет повторен: адаптер находит данные для следующего элемента для отображения и копирует эти данные к представлениям для данного элемента. Ссылки для этих представлений, извлекаются из владелец представления, связанные с представлением, перезапущен.

5.  Перезапущен добавляется в список элементов в `RecyclerView` , собираетесь перейти на экране.

6.  Представление перезапущен переходит на экране прокрутке пользователем `RecyclerView` к следующему элементу в списке. В то же время другое представление прокручивается за пределы видимости и будет перезапущен в соответствии с описанные выше действия.

В дополнение к повторного использования представление элементов `RecyclerView` также использует другой оптимизации эффективности: просмотр владельцев. Объект *владелец представления* — это простой класс, что кэши просматривать ссылки. Каждый раз, когда адаптер увеличивает файл макета элемента также создает соответствующий владелец представления. Владелец представления использует `FindViewById` для получения ссылок на представления в файле увеличенную макета элемента. Эти ссылки используются для загрузки новых данных в представления, каждый раз при перезапуске макет для отображения новых данных.
 


### <a name="the-layout-manager"></a>Диспетчер структуры

Диспетчер структуры отвечает за размещение элементов в `RecyclerView` отображения; он определяет тип презентации (список или таблицу), ориентации (ли элементы отображаются вертикально или горизонтально) и отображать элементы, которые направление (в обычном порядке или в обратном порядке). Диспетчер структуры также отвечает за вычисление размер и положение каждого элемента в **RecycleView** отображения.

Диспетчер структуры имеет дополнительные цели: он определяет политику для необходимость повторно использовать элемент представления, которые больше не отображаются для пользователя.
Так как диспетчер структуры учитывает какие представления являются видимыми (а какие — нет), это наилучшим образом, чтобы определить, когда представление может быть перезапущен. Повторно использовать представление, диспетчер структуры обычно выполняет вызовы к адаптеру Замените содержимое файла перезапущен представления с другими данными, как описано ранее в [представление перезапуск принцип](#recycling).

Вы можете расширить `RecyclerView.LayoutManager` создать собственный макет manager, или можно использовать диспетчер стандартным макетом. `RecyclerView` предоставляет следующие диспетчеры стандартным макетом.

-   **`LinearLayoutManager`** &ndash; Упорядочивает элементы в столбце, который может прокручиваться по вертикали, или в строке, которая может прокручиваться по горизонтали.

-   **`GridLayoutManager`** &ndash; Элементы отображаются в сетке.

-   **`StaggeredGridLayoutManager`** &ndash; Отображение элементов по ширине сетки, где некоторые элементы имеют различные значения высоты и ширины.

Чтобы указать диспетчер структуры, создать экземпляр начальника выбранного макета и передать его в `SetLayoutManager` метод. Обратите внимание, *необходимо* Укажите диспетчер структуры &ndash; `RecyclerView` не выберите диспетчер стандартным макетом. по умолчанию.

Дополнительные сведения о диспетчере макета см. в разделе [ссылки на класс RecyclerView.LayoutManager](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html).


### <a name="the-view-holder"></a>Владелец представления

Владелец представления — это класс, вы определяете для кэширования ссылок на представление. Адаптер использует эти ссылки представление для привязки каждого представления на его содержимое. Каждый элемент в `RecyclerView` имеется экземпляр держателя связанного представления, который кэширует ссылки представление для этого элемента. Чтобы создать владельца представления, следуйте инструкциям ниже для определения класса, содержащего набор представления каждого элемента:

1.  Подкласс `RecyclerView.ViewHolder`.
2.  Реализуйте конструктор, который ищет и сохраняет представление ссылки.
3.  Реализуйте свойства, которые можно использовать адаптер для доступа к эти ссылки.

Подробный пример `ViewHolder` реализация представлена на [базовый пример RecyclerView](~/android/user-interface/layouts/recycler-view/recyclerview-example.md).
Дополнительные сведения о `RecyclerView.ViewHolder`, см. в разделе [ссылки на класс RecyclerView.ViewHolder](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ViewHolder.html).


### <a name="the-adapter"></a>Адаптер

Большая часть «тяжелых» операций `RecyclerView` интеграции кода выполняется в адаптере. `RecyclerView` необходимо указать адаптер, производный от `RecyclerView.Adapter` для доступа к источнику данных и заполнения элемента с содержимым источника данных.
Потому что источник данных конкретного приложения, необходимо реализовать функциональные возможности адаптера, который понимает, как получить доступ к данным. Адаптер извлекает информацию из источника данных и загружает их в каждый элемент в `RecyclerView` коллекции.

На рисунке показано, как адаптер сопоставляются с содержимым в источнике данных через представление владельцев отдельных представлений в каждый элемент строку в `RecyclerView`:

[![Схема, иллюстрирующая подключения источника данных к ViewHolders адаптера](parts-and-functionality-images/03-recyclerviewer-adapter-sml.png)](parts-and-functionality-images/03-recyclerviewer-adapter.png#lightbox)

Адаптер загружает каждую `RecyclerView` строку с данными для конкретной строки элемента. Для позиции строки *P*, например, адаптер находит связанные данные в позиции *P* в пределах источника данных и копирует эти данные в строку элемент в позиции *P* в `RecyclerView` коллекции.
В документе выше, например, адаптер использует владелец представления для уточняющего запроса ссылки для `ImageView` и `TextView` в этой позиции, поэтому не требуется многократно вызывать `FindViewById` для этих представлений, как пользователь прокручивает по коллекции и повторно использует представления.

При реализации адаптера, необходимо переопределить следующие `RecyclerView.Adapter` методы:

-   **`OnCreateViewHolder`** &ndash; Создает владелец файла и представление макета элемента.

-   **`OnBindViewHolder`** &ndash; Загружает данные в указанной позиции в представления, ссылки для которых хранятся в владелец данного представления.

-   **`ItemCount`** &ndash; Возвращает число элементов в источнике данных.

Диспетчер структуры вызывает эти методы, хотя он размещение элементов в пределах `RecyclerView`. 



### <a name="notifying-recyclerview-of-data-changes"></a>Уведомление RecyclerView изменений данных

`RecyclerView` не обновляется автоматически его отображение при изменении; источника содержимого его данных адаптер должен уведомлять `RecyclerView` при наличии изменений в наборе данных. Набор данных можно изменять различными способами; Например можно изменить содержимое в элементе или общая структура данных может быть изменен.
`RecyclerView.Adapter` предоставляет ряд методов, которые можно вызвать, чтобы `RecyclerView` реагирует на изменения данных в наиболее эффективным способом:

-  **`NotifyItemChanged`** &ndash; Указывает, был изменен элемент в указанной позиции.

-  **`NotifyItemRangeChanged`** &ndash; Сигналы, которые были изменены элементы в указанный диапазон позиций.

-  **`NotifyItemInserted`** &ndash; Сигналы, вновь вставке элемента в указанной позиции.

-  **`NotifyItemRangeInserted`** &ndash; Сообщает, что вновь вставки элементов в указанном диапазоне позиций.

-  **`NotifyItemRemoved`** &ndash; Сообщает, что был удален элемент в указанной позиции.

-  **`NotifyItemRangeRemoved`** &ndash; Сообщает, что элементы в указанном диапазоне позиций были удалены.

-  **`NotifyDataSetChanged`** &ndash; Сообщает, набор данных был изменен (вызывает полное обновление).

Если вы знаете точно, как изменилось набора данных, можно вызвать соответствующие методы выше, чтобы обновить `RecyclerView` в наиболее эффективным способом. Если вы не знаете точно, как изменилось набора данных, можно вызвать `NotifyDataSetChanged`, который гораздо менее эффективным, так как `RecyclerView` необходимо обновить все представления, которые видны пользователю. Дополнительные сведения об этих методах см. в разделе [RecyclerView.Adapter](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html).

В следующем разделе [базовый пример RecyclerView](~/android/user-interface/layouts/recycler-view/recyclerview-example.md), чтобы продемонстрировать компоненты и функции, описанные выше примеры реальный код реализуется пример приложения.


## <a name="related-links"></a>Связанные ссылки

- [RecyclerView](~/android/user-interface/layouts/recycler-view/index.md)
- [Простой пример RecyclerView](~/android/user-interface/layouts/recycler-view/recyclerview-example.md)
- [Расширим пример RecyclerView](~/android/user-interface/layouts/recycler-view/extending-the-example.md)
- [RecyclerView](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html)
