---
title: RecyclerView части и функциональные возможности
description: Обзор диспетчера разметки RecyclerView, адаптера и владельца представления.
ms.prod: xamarin
ms.assetid: 54F999BE-2732-4BC7-A466-D17373961C48
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 07/13/2018
ms.openlocfilehash: 823215b7cc1bac8a8f6bffc6e480400135e88ce8
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73028824"
---
# <a name="recyclerview-parts-and-functionality"></a>RecyclerView части и функциональные возможности

`RecyclerView` обрабатывает некоторые задачи внутренне (например, прокрутку и повторное использование представлений), но это, по сути, руководитель, который координирует вспомогательные классы для отображения коллекции. `RecyclerView` делегирует задачи следующим вспомогательным классам:

- **`Adapter`** &ndash; размещаются макеты элементов (создает экземпляр содержимого файла макета) и привязывает данные к представлениям, отображаемым в `RecyclerView`. Адаптер также сообщает о событиях щелчка элемента.

- **`LayoutManager`** &ndash; измеряет и позиционирует представления элементов в `RecyclerView` и управляет политикой для повторного запуска представления.

- **`ViewHolder`** &ndash; ищет и сохраняет ссылки на представление. Владелец представления также помогает при обнаружении щелчков в представлении элементов.

- **`ItemDecoration`** &ndash; позволяет приложению добавлять специальные смещения рисования и макета к определенным представлениям для рисования разделителей между элементами, выделением и границами визуального группирования.

- **`ItemAnimator`** &ndash; определяет анимации, которые выполняются во время действий элемента или при внесении изменений в адаптер.

Связь между классами `RecyclerView`, `LayoutManager`и `Adapter` показана на следующей схеме:

![Схема RecyclerView, содержащая Лайаутманажер, с использованием адаптера для доступа к набору данных](parts-and-functionality-images/01-recyclerview-diagram.png)

Как показано на этом рисунке, `LayoutManager` можно рассматривать как посредник между `Adapter` и `RecyclerView`. `LayoutManager` выполняет вызовы методов `Adapter` от имени `RecyclerView`. Например, `LayoutManager` вызывает метод `Adapter`, когда пора создать новое представление для определенной позиции элемента в `RecyclerView`. `Adapter` расширяет макет для этого элемента и создает экземпляр `ViewHolder` (не показан) для кэширования ссылок на представления в этой позиции. Когда `LayoutManager` вызывает `Adapter` для привязки определенного элемента к набору данных, `Adapter` находит данные для этого элемента, извлекает их из набора данных и копирует в связанное представление элемента.

При использовании `RecyclerView` в приложении требуется создание производных типов следующих классов:

- **`RecyclerView.Adapter`** &ndash; предоставляет привязку из набора данных вашего приложения (относящегося к конкретному приложению) к представлениям элементов, отображаемым в `RecyclerView`. Адаптер знает, как связать каждую позицию представления элементов в `RecyclerView` с конкретным расположением в источнике данных. Кроме того, адаптер обрабатывает макет содержимого в каждом представлении отдельного элемента и создает держатель представления для каждого представления. Адаптер также сообщает о событиях щелчка элемента, обнаруженных представлением элементов.

- **`RecyclerView.ViewHolder`** &ndash; кэширует ссылки на представления в файле макета элемента, чтобы поиск ресурсов не повторялся без необходимости. Владелец представления также упорядочивает события щелчка по элементам, перенаправляемые адаптеру, когда пользователь касается представления элемента, связанного с владельцем представления.

- **`RecyclerView.LayoutManager`** &ndash; замещает элементы в `RecyclerView`. Можно использовать один из нескольких заранее определенных диспетчеров макетов или реализовать собственный пользовательский диспетчер макетов.
    `RecyclerView` делегирует политику макета диспетчеру макетов, поэтому вы можете подключить другой диспетчер макетов без внесения значительных изменений в приложение.

Кроме того, при необходимости можно расширить следующие классы, чтобы изменить внешний вид `RecyclerView` в приложении:

- **`RecyclerView.ItemDecoration`**
- **`RecyclerView.ItemAnimator`**

Если не расширить `ItemDecoration` и `ItemAnimator`, `RecyclerView` использует реализации по умолчанию. В этом руководство не объясняется, как создавать пользовательские классы `ItemDecoration` и `ItemAnimator`. Дополнительные сведения об этих классах см. в разделе [RecyclerView. итемдекоратион](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemDecoration.html) and [RecyclerView. итеманиматор](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemAnimator.html).

<a name="recycling" />

## <a name="how-view-recycling-works"></a>Как работает перезапуск представлений

`RecyclerView` не выделяет представление элемента для каждого элемента в источнике данных. Вместо этого он выделяет только количество представлений элементов, которые помещаются на экране, и использует эти макеты элементов при прокрутке пользователем. Когда представление сначала прокручивается, оно проходит через процесс повторного запуска, показанный на следующем рисунке:

[на схеме![показаны шесть шагов повторного запуска представления](parts-and-functionality-images/02-view-recycling-sml.png)](parts-and-functionality-images/02-view-recycling.png#lightbox)

1. Когда представление прокручивается и больше не отображается, оно становится *представлением отходов*.

2. Представление "отходы" помещается в пул и становится *представлением для очистки*.
    Этот пул представляет собой кэш представлений, отображающих данные одного и того же типа.

3. При отображении нового элемента из пула перезапускается представление для повторного использования. Так как это представление должно быть повторно привязано адаптером перед отображением, оно называется « *грязным» представлением*.

4. "Грязное" представление перезапускается: адаптер находит данные для следующего отображаемого элемента и копирует эти данные в представления для этого элемента. Ссылки на эти представления извлекаются из держателя представления, связанного с перезапущенным представлением.

5. Перезапущенное представление добавляется в список элементов в `RecyclerView`, которые будут переходить на экран.

6. Перезапущенное представление переходит на экран при прокрутке `RecyclerView` к следующему элементу в списке. В то же время другое представление прокручивается и перезапускается в соответствии с описанными выше шагами.

Помимо повторного использования представления элементов, `RecyclerView` также использует другую оптимизацию эффективности: Просмотр владельцев. *Держатель представления* — это простой класс, который кэширует ссылки на представление. Каждый раз, когда адаптер увеличивает файл макета элемента, он также создает соответствующий держатель представления. Держатель представления использует `FindViewById` для получения ссылок на представления внутри неструктурированного файла макета элемента. Эти ссылки используются для загрузки новых данных в представления каждый раз, когда макет перезапускается для отображения новых данных.

## <a name="the-layout-manager"></a>Диспетчер макетов

Диспетчер макетов отвечает за размещение элементов в `RecyclerView`ном отображении; Он определяет тип представления (список или сетка), ориентацию (элементы отображаются вертикально или горизонтально) и какие элементы направления должны отображаться (в обычном порядке или в обратном порядке). Диспетчер макетов также отвечает за вычисление размера и позиции каждого элемента на **рециклевиев** дисплее.

Диспетчер макетов имеет дополнительную цель: он определяет политику, в которой будут перезапускаться представления элементов, которые больше не видны пользователю.
Так как Диспетчер макетов осведомлен о том, какие представления видимы (а какие нет), лучше выбрать, когда представление можно перезапустить. Чтобы перезапустить представление, Диспетчер макетов обычно вызывает адаптер, чтобы заменить содержимое перезапущенного представления на другие данные, как описано выше в разделе [о том, как работает перезапуск представления](#recycling).

Можно расширить `RecyclerView.LayoutManager`, чтобы создать собственный диспетчер макетов, или использовать предварительно определенный Диспетчер макетов. `RecyclerView` предоставляет следующие стандартные диспетчеры макетов:

- **`LinearLayoutManager`** &ndash; упорядочивает элементы в столбце, который может быть вертикально прокручиваться, или в строке, которая может быть прокручиваться по горизонтали.

- **`GridLayoutManager`** &ndash; отображает элементы в сетке.

- **`StaggeredGridLayoutManager`** &ndash; отображает элементы в шахматной сетке, в которой некоторые элементы имеют различные значения высоты и ширины.

Чтобы указать Диспетчер макетов, создайте экземпляр выбранного диспетчера макетов и передайте его в метод `SetLayoutManager`. Обратите внимание, что *необходимо* указать Диспетчер макетов, &ndash; `RecyclerView` по умолчанию не выбирает стандартный Диспетчер макетов.

Дополнительные сведения о диспетчере макетов см. в [справочнике по классам RecyclerView. лайаутманажер](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html).

## <a name="the-view-holder"></a>Держатель представления

Держатель представления — это класс, определяемый для ссылок представлений кэширования. Адаптер использует эти ссылки на представление для привязки каждого представления к его содержимому. Каждый элемент в `RecyclerView` имеет связанный экземпляр держателя представления, который кэширует ссылки на представление для этого элемента. Чтобы создать держатель представления, выполните следующие действия, чтобы определить класс, в котором будет храниться точный набор представлений для каждого элемента:

1. Подкласс `RecyclerView.ViewHolder`.
2. Реализуйте конструктор, который ищет и сохраняет ссылки на представление.
3. Реализуйте свойства, которые адаптер может использовать для доступа к этим ссылкам.

Подробный пример реализации `ViewHolder` представлен в [базовом примере RecyclerView](~/android/user-interface/layouts/recycler-view/recyclerview-example.md).
Дополнительные сведения о `RecyclerView.ViewHolder`см. в [справочнике по классам RecyclerView. виевхолдер](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ViewHolder.html).

## <a name="the-adapter"></a>Адаптер

Большая часть кода интеграции `RecyclerView` выполняется в адаптере. `RecyclerView` требует предоставления адаптера, производного от `RecyclerView.Adapter`, для доступа к источнику данных и заполнения каждого элемента содержимым из источника данных.
Поскольку источник данных зависит от приложения, необходимо реализовать функциональные возможности адаптера, которые попонимают, как получить доступ к данным. Адаптер извлекает данные из источника данных и загружает их в каждый элемент коллекции `RecyclerView`.

На следующем рисунке показано, как адаптер сопоставляет содержимое в источнике данных с помощью владельцев представления с отдельными представлениями в каждом элементе строки в `RecyclerView`:

[Схема![, иллюстрирующая подключение источника данных к Виевхолдерс](parts-and-functionality-images/03-recyclerviewer-adapter-sml.png)](parts-and-functionality-images/03-recyclerviewer-adapter.png#lightbox)

Адаптер загружает каждую `RecyclerView` строку с данными для определенного элемента строки. Например, для позиции строки *p*адаптер находит связанные данные в позиции *p* в источнике данных и копирует эти данные в элемент строки в позиции *p* в коллекции `RecyclerView`.
Например, на приведенном выше рисунке адаптер использует держатель представления для поиска ссылок на `ImageView` и `TextView` в этой позиции, поэтому ему не нужно многократно вызывать `FindViewById` для этих представлений, так как пользователь прокручивает коллекцию и повторно использует представления.

При реализации адаптера необходимо переопределить следующие методы `RecyclerView.Adapter`.

- **`OnCreateViewHolder`** &ndash; создает экземпляр файла макета элемента и владельца представления.

- **`OnBindViewHolder`** &ndash; загружает данные в указанной позиции в представления, ссылки на которые хранятся в заданном заполнителье представления.

- **`ItemCount`** &ndash; возвращает число элементов в источнике данных.

Диспетчер макетов вызывает эти методы при размещении элементов в `RecyclerView`.

## <a name="notifying-recyclerview-of-data-changes"></a>Уведомление RecyclerView об изменениях данных

`RecyclerView` не обновляет автоматическое отображение при изменении содержимого источника данных; адаптер должен уведомлять `RecyclerView` при изменении в наборе данных. Набор данных может изменяться различными способами. Например, содержимое в элементе может измениться, или общая структура данных может быть изменена.
`RecyclerView.Adapter` предоставляет ряд методов, которые можно вызывать, чтобы `RecyclerView` реагировать на изменения данных наиболее эффективным образом:

- **`NotifyItemChanged`** &ndash; сигнализирует, что элемент в указанной позиции изменился.

- **`NotifyItemRangeChanged`** &ndash; сигнализирует, что элементы в указанном диапазоне должно изменились.

- **`NotifyItemInserted`** &ndash; сигнализирует, что элемент в указанной позиции был вставлен вновь.

- **`NotifyItemRangeInserted`** &ndash; сигнализирует, что элементы в указанном диапазоне должно быть вставлено недавно.

- **`NotifyItemRemoved`** &ndash; сигнализирует, что элемент в указанной позиции был удален.

- **`NotifyItemRangeRemoved`** &ndash; сигнализирует, что элементы в указанном диапазоне позиций были удалены.

- **`NotifyDataSetChanged`** &ndash; сигнализирует, что набор данных изменился (принудительно выполняет полное обновление).

Если точно известно, как был изменен набор данных, можно вызвать соответствующие методы выше, чтобы обновить `RecyclerView` наиболее эффективным способом. Если точно неизвестно, как был изменен набор данных, можно вызвать `NotifyDataSetChanged`, который гораздо менее эффективен, так как `RecyclerView` должны обновлять все представления, видимые пользователю. Дополнительные сведения об этих методах см. в разделе [RecyclerView. Adapter](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html).

В следующем разделе приводится пример [базового RecyclerView](~/android/user-interface/layouts/recycler-view/recyclerview-example.md), который позволяет продемонстрировать реальные примеры кода для частей и функций, описанных выше.

## <a name="related-links"></a>Связанные ссылки

- [RecyclerView](~/android/user-interface/layouts/recycler-view/index.md)
- [Пример базового RecyclerView](~/android/user-interface/layouts/recycler-view/recyclerview-example.md)
- [Расширение примера RecyclerView](~/android/user-interface/layouts/recycler-view/extending-the-example.md)
- [RecyclerView](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html)
