---
title: RecyclerView части и функциональные возможности
description: Обзор диспетчера разметки RecyclerView, адаптера и владельца представления.
ms.prod: xamarin
ms.assetid: 54F999BE-2732-4BC7-A466-D17373961C48
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 07/13/2018
ms.openlocfilehash: 8d987fc91544cfb87a2da6adba9f178931fee563
ms.sourcegitcommit: 93e6358aac2ade44e8b800f066405b8bc8df2510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84567814"
---
# <a name="recyclerview-parts-and-functionality"></a>RecyclerView части и функциональные возможности

`RecyclerView`обрабатывает некоторые задачи внутренне (например, прокрутку и повторное использование представлений), но это, по сути, руководитель, который координирует вспомогательные классы для отображения коллекции. `RecyclerView`делегирует задачи следующим вспомогательным классам:

- **`Adapter`**&ndash;Расширяет макеты элементов (создает экземпляр содержимого файла макета) и привязывает данные к представлениям, которые отображаются в `RecyclerView` . Адаптер также сообщает о событиях щелчка элемента.

- **`LayoutManager`**&ndash;Измеряет и позиционирует представления элементов в `RecyclerView` и управляет политикой для повторного использования представлений.

- **`ViewHolder`**&ndash;Ищет и сохраняет ссылки на представление. Владелец представления также помогает при обнаружении щелчков в представлении элементов.

- **`ItemDecoration`**&ndash;Позволяет приложению добавлять специальные смещения рисования и макета к определенным представлениям для рисования разделителей между элементами, выделением и границами визуального группирования.

- **`ItemAnimator`**&ndash;Определяет анимации, которые выполняются во время действий элемента или по мере внесения изменений в адаптер.

Связь между `RecyclerView` `LayoutManager` `Adapter` классами, и показана на следующей схеме:

![Схема RecyclerView, содержащая Лайаутманажер, с использованием адаптера для доступа к набору данных](parts-and-functionality-images/01-recyclerview-diagram.png)

Как показано на этом рисунке, `LayoutManager` можно рассматривать как посредник между `Adapter` и `RecyclerView` . `LayoutManager`Выполняет вызовы `Adapter` методов от имени `RecyclerView` . Например, компонент `LayoutManager` вызывает метод, `Adapter` когда пора создать новое представление для определенной позиции элемента в `RecyclerView` . `Adapter`Компонент расширяет макет для этого элемента и создает `ViewHolder` экземпляр (не показан) для кэширования ссылок на представления в этой позиции. Когда `LayoutManager` вызывает метод `Adapter` для привязки определенного элемента к набору данных, `Adapter` компонент выполняет поиск данных для этого элемента, извлекает его из набора данных и копирует в связанное представление элемента.

При использовании `RecyclerView` в приложении требуется создание производных типов следующих классов:

- **`RecyclerView.Adapter`**&ndash;Предоставляет привязку из набора данных вашего приложения (относящегося к конкретному приложению) к представлениям элементов, отображаемым в `RecyclerView` . Адаптер знает, как связать каждую позицию представления элемента в `RecyclerView` определенном месте источника данных. Кроме того, адаптер обрабатывает макет содержимого в каждом представлении отдельного элемента и создает держатель представления для каждого представления. Адаптер также сообщает о событиях щелчка элемента, обнаруженных представлением элементов.

- **`RecyclerView.ViewHolder`**&ndash;Кэширует ссылки на представления в файле макета элемента, чтобы поиск ресурсов не повторялся без необходимости. Владелец представления также упорядочивает события щелчка по элементам, перенаправляемые адаптеру, когда пользователь касается представления элемента, связанного с владельцем представления.

- **`RecyclerView.LayoutManager`**&ndash;Позиционирует элементы внутри `RecyclerView` . Можно использовать один из нескольких заранее определенных диспетчеров макетов или реализовать собственный пользовательский диспетчер макетов.
    `RecyclerView`делегирует политику макета диспетчеру макетов, поэтому вы можете подключить другой диспетчер макетов без внесения значительных изменений в приложение.

Кроме того, при необходимости можно расширить следующие классы, чтобы изменить внешний вид и поведение `RecyclerView` приложения:

- **`RecyclerView.ItemDecoration`**
- **`RecyclerView.ItemAnimator`**

Если не расширить `ItemDecoration` и `ItemAnimator` , `RecyclerView` использует реализации по умолчанию. В этом руководство не объясняется, как создавать `ItemDecoration` пользовательские `ItemAnimator` классы и. Дополнительные сведения об этих классах см. в разделе [RecyclerView. итемдекоратион](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemDecoration.html) and [RecyclerView. итеманиматор](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemAnimator.html).

<a name="recycling"></a>

## <a name="how-view-recycling-works"></a>Как работает перезапуск представлений

`RecyclerView`не выделяет представление элемента для каждого элемента в источнике данных. Вместо этого он выделяет только количество представлений элементов, которые помещаются на экране, и использует эти макеты элементов при прокрутке пользователем. Когда представление сначала прокручивается, оно проходит через процесс повторного запуска, показанный на следующем рисунке:

[![Схема, иллюстрирующая шесть шагов перезапуска представления](parts-and-functionality-images/02-view-recycling-sml.png)](parts-and-functionality-images/02-view-recycling.png#lightbox)

1. Когда представление прокручивается и больше не отображается, оно становится *представлением отходов*.

2. Представление "отходы" помещается в пул и становится *представлением для очистки*.
    Этот пул представляет собой кэш представлений, отображающих данные одного и того же типа.

3. При отображении нового элемента из пула перезапускается представление для повторного использования. Так как это представление должно быть повторно привязано адаптером перед отображением, оно называется « *грязным» представлением*.

4. "Грязное" представление перезапускается: адаптер находит данные для следующего отображаемого элемента и копирует эти данные в представления для этого элемента. Ссылки на эти представления извлекаются из держателя представления, связанного с перезапущенным представлением.

5. Перезапущенное представление добавляется в список элементов в `RecyclerView` , которые будут переходить на экран.

6. Перезапущенное представление переходит на экран, когда пользователь прокручивает `RecyclerView` к следующему элементу в списке. В то же время другое представление прокручивается и перезапускается в соответствии с описанными выше шагами.

Помимо повторного использования представлений элементов, `RecyclerView` также использует другую оптимизацию эффективности: Просмотр владельцев. *Держатель представления* — это простой класс, который кэширует ссылки на представление. Каждый раз, когда адаптер увеличивает файл макета элемента, он также создает соответствующий держатель представления. Владелец представления использует `FindViewById` для получения ссылок на представления внутри неструктурированного файла макета элемента. Эти ссылки используются для загрузки новых данных в представления каждый раз, когда макет перезапускается для отображения новых данных.

## <a name="the-layout-manager"></a>Диспетчер макетов

Диспетчер макетов отвечает за размещение элементов на `RecyclerView` экране; он определяет тип представления (список или сетка), ориентацию (элементы отображаются вертикально или горизонтально) и какие элементы направления должны отображаться (в обычном порядке или в обратном порядке). Диспетчер макетов также отвечает за вычисление размера и позиции каждого элемента на **рециклевиев** дисплее.

Диспетчер макетов имеет дополнительную цель: он определяет политику, в которой будут перезапускаться представления элементов, которые больше не видны пользователю.
Так как Диспетчер макетов осведомлен о том, какие представления видимы (а какие нет), лучше выбрать, когда представление можно перезапустить. Чтобы перезапустить представление, Диспетчер макетов обычно вызывает адаптер, чтобы заменить содержимое перезапущенного представления на другие данные, как описано выше в разделе [о том, как работает перезапуск представления](#recycling).

Можно расширить `RecyclerView.LayoutManager` для создания собственного диспетчера макетов или использовать предопределенный Диспетчер макетов. `RecyclerView`предоставляет следующие стандартные диспетчеры макетов:

- **`LinearLayoutManager`**&ndash;Упорядочивает элементы в столбце, который может быть вертикально прокручиваться, или в строке, которая может быть прокручиваться по горизонтали.

- **`GridLayoutManager`**&ndash;Отображает элементы в сетке.

- **`StaggeredGridLayoutManager`**&ndash;Отображает элементы в шахматной сетке, где некоторые элементы имеют различные значения высоты и ширины.

Чтобы указать Диспетчер макетов, создайте экземпляр выбранного диспетчера макетов и передайте его в `SetLayoutManager` метод. Обратите внимание, что *необходимо* указать, что Диспетчер макетов &ndash; `RecyclerView` не выбирает стандартный Диспетчер макетов по умолчанию.

Дополнительные сведения о диспетчере макетов см. в [справочнике по классам RecyclerView. лайаутманажер](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html).

## <a name="the-view-holder"></a>Держатель представления

Держатель представления — это класс, определяемый для ссылок представлений кэширования. Адаптер использует эти ссылки на представление для привязки каждого представления к его содержимому. Каждый элемент в `RecyclerView` имеет связанный экземпляр держателя представления, который кэширует ссылки на представление для этого элемента. Чтобы создать держатель представления, выполните следующие действия, чтобы определить класс, в котором будет храниться точный набор представлений для каждого элемента:

1. Подкласс `RecyclerView.ViewHolder` .
2. Реализуйте конструктор, который ищет и сохраняет ссылки на представление.
3. Реализуйте свойства, которые адаптер может использовать для доступа к этим ссылкам.

Подробный пример `ViewHolder` реализации представлен в [базовом RecyclerView примере](~/android/user-interface/layouts/recycler-view/recyclerview-example.md).
Дополнительные сведения о `RecyclerView.ViewHolder` см. в [справочнике по классам RecyclerView. виевхолдер](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ViewHolder.html).

## <a name="the-adapter"></a>Адаптер

Большая часть `RecyclerView` кода интеграции выполняется в адаптере. `RecyclerView`требует предоставления адаптера, производного от, `RecyclerView.Adapter` для доступа к источнику данных и заполнения каждого элемента содержимым из источника данных.
Поскольку источник данных зависит от приложения, необходимо реализовать функциональные возможности адаптера, которые попонимают, как получить доступ к данным. Адаптер извлекает данные из источника данных и загружает их в каждый элемент `RecyclerView` коллекции.

На следующем рисунке показано, как адаптер сопоставляет содержимое в источнике данных с помощью владельцев представления с отдельными представлениями в каждом элементе строки в `RecyclerView` :

[![Схема, иллюстрирующая подключение источника данных к Виевхолдерс](parts-and-functionality-images/03-recyclerviewer-adapter-sml.png)](parts-and-functionality-images/03-recyclerviewer-adapter.png#lightbox)

Адаптер загружает каждую `RecyclerView` строку с данными для определенного элемента строки. Например, для позиции строки *p*адаптер находит связанные данные в позиции *p* в источнике данных и копирует эти данные в элемент строки в позиции *p* в `RecyclerView` коллекции.
Например, на приведенном выше рисунке адаптер использует держатель представления для поиска ссылок на `ImageView` и `TextView` в этой позиции, поэтому ему не придется многократно вызывать эти представления, так `FindViewById` как пользователь прокручивается по коллекции и повторно использует представления.

При реализации адаптера необходимо переопределить следующие `RecyclerView.Adapter` методы.

- **`OnCreateViewHolder`**&ndash;Создает экземпляр файла макета элемента и владельца представления.

- **`OnBindViewHolder`**&ndash;Загружает данные в указанной позиции в представления, ссылки на которые хранятся в заданном заполнителе представления.

- **`ItemCount`**&ndash;Возвращает число элементов в источнике данных.

Диспетчер макетов вызывает эти методы при размещении элементов в `RecyclerView` .

## <a name="notifying-recyclerview-of-data-changes"></a>Уведомление RecyclerView об изменениях данных

`RecyclerView`не обновляет автоматическое отображение при изменении содержимого его источника данных; адаптер должен уведомлять об `RecyclerView` изменении в наборе данных. Набор данных может изменяться различными способами. Например, содержимое в элементе может измениться, или общая структура данных может быть изменена.
`RecyclerView.Adapter`предоставляет ряд методов, которые можно вызывать, чтобы `RecyclerView` реагировать на изменения данных наиболее эффективным образом:

- **`NotifyItemChanged`**&ndash;Сигнализирует, что элемент в указанной позиции изменился.

- **`NotifyItemRangeChanged`**&ndash;Сигнализирует, что элементы в указанном диапазоне должно были измениться.

- **`NotifyItemInserted`**&ndash;Сигнализирует, что элемент в указанной позиции был добавлен недавно.

- **`NotifyItemRangeInserted`**&ndash;Сигнализирует, что элементы в указанном диапазоне позиций вставлены недавно.

- **`NotifyItemRemoved`**&ndash;Сигнализирует, что элемент в указанной позиции был удален.

- **`NotifyItemRangeRemoved`**&ndash;Сигнализирует, что элементы в указанном диапазоне позиций были удалены.

- **`NotifyDataSetChanged`**&ndash;Сигнализирует, что набор данных изменился (принудительно выполняет полное обновление).

Если точно известно, как был изменен набор данных, можно вызвать соответствующие методы выше, чтобы обновить `RecyclerView` наиболее эффективным способом. Если точно неизвестно, как был изменен набор данных, можно вызвать метод `NotifyDataSetChanged` , который гораздо менее эффективен, поскольку `RecyclerView` должен обновить все представления, видимые пользователю. Дополнительные сведения об этих методах см. в разделе [RecyclerView. Adapter](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html).

В следующем разделе приводится пример [базового RecyclerView](~/android/user-interface/layouts/recycler-view/recyclerview-example.md), который позволяет продемонстрировать реальные примеры кода для частей и функций, описанных выше.

## <a name="related-links"></a>Связанные ссылки

- [RecyclerView](~/android/user-interface/layouts/recycler-view/index.md)
- [Пример базового RecyclerView](~/android/user-interface/layouts/recycler-view/recyclerview-example.md)
- [Расширение примера RecyclerView](~/android/user-interface/layouts/recycler-view/extending-the-example.md)
- [RecyclerView](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html)
