|Свойство.|Описание|Параметры|
|--- |--- |--- |
|`abi.type`|**Тип ABI** &ndash; указывает тип ABI (двоичный интерфейс приложений) для эмулированного устройства. **X86** вариант оптимален для инструкций, задайте обычно называются «x86» или «IA-32.» **X86_64** параметр предназначен для 64-разрядный x86 набор инструкций. **Armeabi-v7a** параметр — набор с v7-a ARM расширениями инструкций ARM. **Arm64-v8a** вариант оптимален для набор инструкций ARM, который поддерживает AArch64.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Раздел кэша** &ndash; определяет, использует ли эмулируемое устройство **/cache** секции на устройстве. **/Cache** (он изначально пуста) — это место, где хранятся Android, часто используемых данных и компонентов приложения. Если значение **не**, эмулятор не будет использовать **/cache** секции, а другой `disk.cache` параметры будут игнорироваться.|yes (Да), no (Нет)|
|`disk.cachePartition.path`|**Путь к разделу кэша** &ndash; указывает файл кэша секции образа на компьютере разработчика. Эмулятор будет использовать этот файл для **/cache** секции. Введите абсолютный путь или путь относительно каталога данных эмулятора. Если не задано, эмулятор создает пустой временный файл с именем **cache.img** на компьютере разработчика. Если заданный файл не существует, он будет создан с пустым содержимым. Этот параметр учитывается, если `disk.cachePartition` присваивается **не**.||
|`disk.cachePartition.size`|**Размер раздела кэша** &ndash; размер файла для раздела кэша (в байтах). Обычно этот параметр использовать не нужно, если приложение не будет скачивать огромные файлы, превышающие стандартный размер кэша 66 мегабайт. Этот параметр учитывается, если `disk.cachePartition` присваивается **не**. Если это значение является целым, он указывает размер в байтах. Также можно указать размер в килобайтах, мегабайтах или гигабайтах, добавив **K**, **M**, или **G** значению. Минимальный размер — **9 мин** и максимальный размер составляет **1023 ГБ**.||
|`disk.dataPartition.initPath`|**Начальный путь к разделу данных** &ndash; указывает исходные данные для секции. После очистки пользовательских данных эмулятор копирует содержимое указанного файла данных пользователя (по умолчанию **userdata-qemu.img**) вместо использования **userdata.img** в начальной версии.||
|`disk.dataPartition.path`|**Путь к разделу данных** &ndash; указывает пользовательском файле данных секции. Чтобы настроить сохраняемый файл пользовательских данных, введите имя файла и путь к нему на компьютере разработки. Если файл не существует, эмулятор создает образ из файла по умолчанию **userdata.img**, сохраняет его в имени файла, определяемое `disk.dataPartition.path`, и сохраняет данные пользователя при завершении работы. Если путь не указан, файл по умолчанию называется **userdata-qemu.img**. Специальное значение **<temp>** эмулятора следует создать и использовать временный файл. Если `disk.dataPartition.initPath` не установлен, его содержимое будут скопированы в `disk.dataPartition.path` файла во время загрузки. Обратите внимание, что этот параметр нельзя оставлять пустым.||
|`disk.dataPartition.size`|**Размер раздела данных** &ndash; указывает размер раздела для пользовательских данных в байтах. Если это значение является целым, он указывает размер в байтах. Также можно указать размер в килобайтах, мегабайтах или гигабайтах, добавив **K**, **M**, или **G** значению. Минимальный размер — **9 мин** и максимальный размер составляет **1023 ГБ**.||
|`disk.ramdisk.path`|**Путь к виртуальному диску** &ndash; путь к образу загрузочного раздела (виртуальному диску). Образ виртуального диска является подмножеством системных образов, который загружается ядром перед подключением образа системы. Образ виртуального диска обычно содержит двоичные файлы и скрипты инициализации для процессов загрузки. Если этот параметр не указан, по умолчанию используется **ramdisk.img** в системном каталоге эмулятора.||
|`disk.snapStorage.path`|**Путь к хранилищу моментального снимка** &ndash; путь к файлу хранилища моментальных снимков, где хранятся все моментальные снимки. В этот файл будет сохранены все моментальные снимки, созданные во время выполнения. При работе эмулятора можно восстановить только те моментальные снимки, которые сохраняются в этот файл. Если этот параметр не указан, по умолчанию используется snapshots.img в каталоге данных эмулятора.||
|`disk.systemPartition.initPath`|**Путь к системному разделу init** &ndash; путь к копии только для чтения к файлу образа системы; в частности, раздел, содержащий системные библиотеки и данные, соответствующие уровню API и какой-либо вариант. Если этот путь не указан, по умолчанию используется system.img в системном каталоге эмулятора.||
|`disk.systemPartition.path`|**Путь к системному разделу** &ndash; путь к образу системного раздела чтения и записи. Если этот путь не задан, временный файл будет создан и инициализирован из содержимого файла, указанного в `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Размер системного раздела** &ndash; идеальный размер системного раздела (в байтах). Этот размер не учитывается, если фактический образ системного раздела больше указанного здесь значения. В противном случае он ограничивает максимальный размер файла для системного раздела. Если это значение является целым, он указывает размер в байтах. Также можно указать размер в килобайтах, мегабайтах или гигабайтах, добавив **K**, **M**, или **G** значению. Минимальный размер — **9 мин** и максимальный размер составляет **1023 ГБ**.||
|`hw.accelerometer`|**Акселерометр** &ndash; определяет, содержит ли эмулируемое устройство датчик акселерометра. Акселерометр помогает устройству ориентироваться в пространстве (например, используется для автоматического поворота экрана). Акселерометр передает ускорение, действующее на устройство по трем осям датчика.|yes (Да), no (Нет)|
|`hw.audioInput`|**Поддержка записи звука** &ndash; определяет, является ли эмулируемое устройство записывать звук.|yes (Да), no (Нет)|
|`hw.audioOutput`|**Поддержка воспроизведения звука** &ndash; определяет, является ли эмулируемое устройство воспроизводить звук.|yes (Да), no (Нет)|
|`hw.battery`|**Поддержка аккумулятора** &ndash; определяет, является ли эмулируемое устройство работать от аккумулятора.|yes (Да), no (Нет)|
|`hw.camera`|**Поддержка камеры** &ndash; определяет наличие камеры эмулированного устройства.|yes (Да), no (Нет)|
|`hw.camera.back`|**Задняя камера** &ndash; настраивает заднюю камеру устройства (ту, которая направлена от пользователя). Если вы используете веб-камеру на компьютере разработчика для имитации задней камеры на эмулируемом устройстве, это значение должно быть присвоено веб-камера*n*, где _n_ выбирает веб-камеры (если у вас есть только одна веб-камера, Выберите **webcam0**). Если задано эмулировать, эмулятор имитирует камеру в программном обеспечении. Чтобы отключить заднюю камеру, это значение равно none. Если вы включите заднюю камеру, обязательно также включить `hw.camera`.|emulated (эмулируется), none (нет), webcam0 (веб-камера 0)|
|`hw.camera.front`|**Переднюю камеру** &ndash; настраивает переднюю камеру устройства (ту, которая направлена на пользователя). Если вы используете веб-камеру на компьютере разработчика для имитации передней камеры на эмулируемом устройстве, это значение должно быть присвоено веб-камера*n*, где _n_ выбирает веб-камеры (если у вас есть только одна веб-камера Выберите **webcam0**). Если задано эмулировать, эмулятор имитирует камеру в программном обеспечении. Чтобы отключить переднюю камеру, это значение равно none. Если вы включите переднюю камеру, обязательно также включить `hw.camera`.|emulated (эмулируется), none (нет), webcam0 (веб-камера 0)|
|`hw.camera.maxHorizontalPixels`|**Максимальное количество горизонтальной пикселей камеры** &ndash; настраивает максимальное разрешение по горизонтали для камеры эмулированного устройства (в пикселях).||
|`hw.camera.maxVerticalPixels`|**Максимальное количество вертикальной пикселей камеры** &ndash; настраивает максимальное разрешение по вертикали для камеры эмулированного устройства (в пикселях).||
|`hw.cpu.arch`|**Архитектура ЦП** &ndash; архитектура ЦП, которую будет эмулировать Виртуальное устройство. Если вы используете Intel HAXM для аппаратного ускорения, выберите **x86** для 32-разрядного Процессора. Выберите **x86_64** для 64-разрядных устройство с ускорением HAXM. (Не забудьте установить соответствующий образ системы Intel x86 в диспетчер пакетов SDK: например, Intel x86 Atom или Intel x86 Atom_64.) Для имитации Процессора ARM, выберите **arm** для 32-разрядной или выберите **arm64** для ARM с 64-разрядным Процессором. Учитывайте, что виртуальные устройства на основе ARM работают гораздо медленнее, чем на основе x86, поскольку для ARM не поддерживается аппаратное ускорение.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**Модель ЦП** &ndash; это значение обычно остается не задано (ему будет присвоено значение, которое является производным от `hw.cpu.arch` Если явно не задано). Но для экспериментов вы можете присвоить ему конкретную строку, значение которой зависит от эмулятора.||
|`hw.dPad`|**Клавиши DPad** &ndash; определяет, поддерживает ли эмулированное устройство Крестовина (DPad) ключи. Обычно DPad имеет четыре клавиши для выбора направления.|yes (Да), no (Нет)|
|`hw.gps`|**Поддержка GPS** &ndash; определяет наличие приемника GPS (глобальной системы позиционирования) для эмулированного устройства.|yes (Да), no (Нет)|
|`hw.gpu.enabled`|**Эмуляция GPU** &ndash; определяет поддержку эмуляции GPU для эмулированного устройства. Если включена эмуляция GPU, для отрисовки 2D и 3D графики на экране применяется Open GL для встраиваемых систем (OpenGL ES). Способ реализации для эмуляции GPU определяется связанным параметром "Режим эмуляции GPU".|yes (Да), no (Нет)|
|`hw.gpu.mode`|**Режим эмуляции GPU** &ndash; определяет способ реализации для эмуляции GPU с помощью эмулятора. Если выбран автоматически, эмулятор самостоятельно выберет ускорение оборудования и программного обеспечения, на основе настроек компьютера разработки. Если выбрать узел, эмулятор будет использовать графический процессор компьютера разработки для выполнения эмуляции GPU ускорять отображение содержимого. Если установленный GPU не совместим с эмулятором, и вы находитесь в Windows, можно попробовать угол вместо узла. Режим угол использует DirectX для сравнимую производительность с узла. Если вы выберете mesa, эмулятор будет использовать программную библиотеку Mesa 3D для отображения графики. Выберите mesa, при наличии проблемы графический процессор компьютера разработки. Режим swiftshader можно использовать для отображения графики программным способом с несколько меньшей производительностью по сравнению с использованием графического Процессора компьютера. Параметр off (отключение эмуляции графического оборудования) — устаревший параметр, который может привести к неправильной отрисовки для некоторых элементов и поэтому не рекомендуется.|auto (автоматически), host (компьютер), mesa, angle, swiftshader, off (отключено)|
|`hw.gsmModem`|**Поддержка модема GSM** &ndash; определяет, включает ли эмулируемом устройстве модема, который поддерживает систему радиосвязи GSM (глобальная система связи для мобильных устройств).|yes (Да), no (Нет)|
|`hw.initialOrientation`|**Начальная Ориентация экрана** &ndash; настраивает начальную ориентацию экрана на эмулированном устройстве (книжный или Альбомный режим). В книжной ориентации высота экрана больше, чем ширина. В альбомной ориентации ширина экрана больше, чем высота. После запуска эмулированного устройства вы можете изменить на нем ориентацию, если оба этих режима поддерживает профиль устройства.|portrait (книжная), landscape (альбомная)|
|`hw.keyboard`|**Поддержка клавиатуры** &ndash; определяет, поддерживает ли эмулированное устройство клавиатуру QWERTY.|yes (Да), no (Нет)|
|`hw.keyboard.charmap`|**Имя таблицы символов клавиатуры** &ndash; имя таблицы символов оборудования этого устройства. Примечание: Это всегда должно быть значение по умолчанию **qwerty2** необходимо внести изменения в образ системы соответствующим образом. Это имя отправляется в ядро во время загрузки. Если указать неправильное имя, виртуальное устройство будет недоступно для использования.||
|`hw.keyboard.lid`|**Поддержка крышки клавиатуры** &ndash; Если включена поддержка клавиатуры, этот параметр определяет, является ли клавиатуры QWERTY можно закрыть/спрятать и открыть /. Этот параметр будет игнорироваться, если hw.keyboard имеет значение false. Примечание: значение по умолчанию имеет значение false, если эмулированное устройство предназначено для API уровня 12 или более поздней версии.|yes (Да), no (Нет)|
|`hw.lcd.backlight`|**Подсветка ЖК-ЭКРАНА** &ndash; определяет имитируется ли подсветка ЖК-ЭКРАНА эмулированного устройства.|yes (Да), no (Нет)|
|`hw.lcd.density`|**Плотность ЖК-ЭКРАНА** &ndash; плотность ЖК-экрана эмулированного, измеряется в пикселях независимо от плотности или точки распространения (точки распространения — это единица виртуальных пикселей). Если выбрано значение 160 точек, каждый виртуальный пиксель (dp) строго соответствует одному физическому пикселю. Во время выполнения Android масштабирует все ресурсы,используя это значение, чтобы правильно отображать их на экране.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**Глубина цвета ЖК-ЭКРАНА** &ndash; глубина цвета в битах для буфера кадров эмулированного устройства, который содержит изображение для ЖК-экрана. Здесь допускаются значения 16 бит (65 536 возможных цветов) или 32 бит (16 777 216 цветов с поддержкой прозрачности). Если выбрано значение 32 бита, эмулятор может работать несколько медленнее, но зато с большей точностью цветопередачи.|16, 32|
|`hw.lcd.height`|**Высота ЖК-ЭКРАНА в пикселях** &ndash; количество пикселей, составляющих по вертикали для ЖК-экрана эмулированного.||
|`hw.lcd.width`|**Ширина ЖК-ЭКРАНА в пикселях** &ndash; количество пикселей, составляющих горизонтальный размер ЖК-экрана эмулированного.||
|`hw.mainKeys`|**Ключи назад/Home оборудования** &ndash; определяет, поддерживает ли эмулированное устройство обратно оборудования и домой. Это значение можно задать **Да** Если клавиши реализованы только в программном обеспечении. Если `hw.mainKeys` присваивается **Да**, эмулятор не будет отображать кнопки навигации на экране, но для их «нажатия» эти кнопки можно использовать боковую панель эмулятора.|yes (Да), no (Нет)|
|`hw.ramSize`|**Размер ОЗУ устройства** &ndash; объем физической памяти ОЗУ на эмулируемом устройстве, в мегабайтах. Значение по умолчанию этого параметра зависит от размера экрана или версии обложки. Если вы увеличите этот размер, эмуляция будет работать быстрее, но для этого потребуется больше ресурсов на компьютере разработки.||
|`hw.screen`|**Тип сенсорного экрана** &ndash; определяет тип создаваемого экрана на эмулированном устройстве. Мультисенсорном экране можно отслеживать двумя или более пальцами на сенсорный интерфейс. Сенсорный экран может обнаруживать только события касания одним пальцем. Нет сенсорного экрана отслеживает события касания.|touch (сенсорный), multi-touch (мультисенсорный), no-touch (не сенсорный)|
|`hw.sdCard`|**Поддержка SDCard** &ndash; определяет, поддерживает ли эмулированное устройство вставки и удаления виртуальные карты SD (Secure Digital). Эмулятор использует подключаемые образы дисков на компьютере разработчика для имитации разделов на реальных устройствах карты SD на (см. в разделе hw.sdCard.path).|yes (Да), no (Нет)|
|`sdcard.size`|**Размер карты SD** &ndash; указывает размер виртуального файла карты SD в расположении, указанном по `hw.sdCard.path`. доступно на устройстве (в байтах). Если это значение является целым, он указывает размер в байтах. Также можно указать размер в килобайтах, мегабайтах или гигабайтах, добавив **K**, **M**, или **G** значению. Минимальный размер — **9 мин** и максимальный размер составляет **1023 ГБ**.||
|`hw.sdCard.path`|**Путь к изображению SDCard** &ndash; указывает имя файла и путь к файлу образа раздела карты SD на компьютере разработчика. Например, этот путь может быть присвоено **C:\sd\sdcard.img** на Windows.||
|`hw.sensors.magnetic_field`|**Датчик магнитного поля** &ndash; определяет, поддерживает ли эмулируемое устройство датчик магнитного поля. Датчик магнитного поля (магнитометр) сообщает напряженность окружающего магнитного поля по трем осям. Включите этот параметр, если вашему приложению нужны показания компаса. Например, приложение навигации может с помощью этого датчика определять, куда смотрит пользователь.|yes (Да), no (Нет)|
|`hw.sensors.orientation`|**Датчик ориентации** &ndash; определяет ли эмулированное устройство предоставляет ориентации значения датчика. Датчик ориентации измеряет угол поворота для корпуса устройства по трем физическим осям (x, y, z). Обратите внимание, что датчик ориентации объявлен устаревшим с версии ОС Android 2.2 (API уровня 8).|yes (Да), no (Нет)|
|`hw.sensors.proximity`|**Датчик приближения** &ndash; определяет поддержку датчика приближения для эмулированного устройства. Этот датчик измеряет расстояния до ближайшего объекта от экрана устройства. Обычно с помощью этого датчика приложения определяют, что человек держит мобильный телефон возле уха.|yes (Да), no (Нет)|
|`hw.sensors.temperature`|**Датчик температуры** &ndash; определяет, поддерживает ли эмулируемое устройство датчик температуры. Этот датчик измеряет температуру устройства в градусах Цельсия (&deg;C).|yes (Да), no (Нет)|
|`hw.touchScreen`|**Поддержка сенсорного экрана** &ndash; определяет, поддерживает ли эмулированное устройство сенсорный экран. Сенсорный экран используется для прямого управления объектами, отображенными на экране.|yes (Да), no (Нет)|
|`hw.trackBall`|**Поддержка шарового манипулятора** &ndash; определяет, поддерживает ли эмулированное устройство трекбол.|yes (Да), no (Нет)|
|`hw.useext4`|**Поддержка файловой системы EXT4** &ndash; определяет, использует ли эмулируемое устройство файловой системы Linux EXT4 для разделов. В настоящее время тип файловой системы определяется автоматически, поэтому этот параметр считается устаревшим и не учитывается.|Нет|
|`kernel.newDeviceNaming`|**Именование нового устройства ядра** &ndash; используется для указания, что ядро устройства требует новую схему именования устройств. Обычно этот режим требуется для ядер Linux 3.10 и более поздних версий. Если значение **Автообнаружение**, эмулятор автоматически определит, что ядро устройства требует новую схему именования устройств.|autodetect (автоопределение), yes (да), no (нет)|
|`kernel.parameters`|**Параметры ядра** &ndash; указывает строку параметров загрузки для ядра Linux. По умолчанию этот параметр имеет пустое значение.||
|`kernel.path`|**Путь к ядру** &ndash; указывает путь к ядро Linux. Если этот путь не указан, эмулятор ищет в системном каталоге эмулятора для kernel-ranchu.||
|`kernel.supportsYaffs2`|**Поддержка разделов YAFFS2** &ndash; определяет, поддерживает ли ядро YAFFS2 секций (еще другую Flash файл System 2). Обычно это требуется только для версий ядра меньше Linux 3.10. Если значение **Автообнаружение** эмулятор автоматически обнаруживает ли решение о возможности подключения файловых систем YAFFS2.|autodetect (автоопределение), yes (да), no (нет)|
|`skin.name`|**Имя обложки** &ndash; имя для обложки эмулятора Android. Обложка — это набор файлов, которые описывают правила отображения для визуальных элементов и элементов управления. Эти правила определяют, как будет выглядеть окно AVD на компьютере разработки. От обложки зависят размер экрана, внешний вид кнопок и другие параметры оформления, но она никак не влияет на работу приложения.||
|`skin.path`|**Путь к обложке** &ndash; указан путь к каталогу, содержащему файлы обложки эмулятора в skin.name этот каталог содержит файлы hardware.ini макета и файлы изображений для элементов отображения обложки.||
|`skin.dynamic`|**Динамическая обложка** &ndash; ли обложка динамической. Обложка эмулятора считается динамической, если эмулятору нужно создать обложку определенного размера на основе значений ширины и высоты экрана.|Нет|

