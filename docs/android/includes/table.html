<table width="100%" border="1px">
<tr>
    <td><b>Свойство</b></td>
    <td><b>Описание</b></td>
    <td><b>Параметры</b></td>
</tr>
<tr>
    <td><code> abi.type </code></td>
    <td><strong>Тип ABI</strong> указывает тип ABI (двоичный интерфейс приложений) для эмулированного устройства. Вариант <code>X86</code> обозначает набор инструкций "x86", также именуемый "IA-32". Вариант <code>X86_64</code> обозначает 64-разрядный набор инструкций x86. Вариант <code>armeabi-v7a</code> обозначает набор инструкций ARM с расширениями v7-a ARM. Вариант <code>arm64-v8a</code> обозначает набор инструкций ARM, который поддерживает AArch64.  </td>
    <td> x86, x86_64, armeabi-v7a, arm64-v8a </td>
</tr>
<tr>
    <td><code> disk.cachePartition </code></td>
    <td><strong>Раздел кэша</strong> — определяет, использует ли эмулируемое устройство раздел <strong>/cache</strong>. Раздел <strong>/cache</strong> (изначально этот раздел пуст) предназначен для хранения часто используемых данных и компонентов приложений Android. Если здесь выбрано значение <code>нет</code>, эмулятор не будет использовать раздел <strong>/cache</strong> и все остальные параметры <code>disk.cache</code> игнорируются.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> disk.cachePartition.path </code></td>
    <td><strong>Путь к разделу кэша</strong> — определяет файл с образом раздела кэша на компьютере разработки. Эмулятор использует этот файл в качестве раздела <strong>/cahce</strong>. Здесь можно указать абсолютный путь или путь относительно каталога <strong>data</strong>, используемого эмулятором. Если значение не задано, эмулятор создает на компьютере разработки пустой временный файл с именем <strong>cache.img</strong>. Если заданный файл не существует, он будет создан с пустым содержимым. Этот параметр игнорируется, если для <code>disk.cachePartition</code> выбрано значение <code>нет</code>. </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.cachePartition.size </code></td>
    <td><strong>Размер раздела кэша</strong> — определяет размер файла для раздела кэша (в мегабайтах). Обычно этот параметр использовать не нужно, если приложение не будет скачивать огромные файлы, превышающие стандартный размер кэша 66 мегабайт. Этот параметр игнорируется, если для <code>disk.cachePartition</code> выбрано значение <code>нет</code>.</td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.initPath </code></td>
    <td><strong>Начальный путь к разделу данных</strong> — указывает исходные данные для секции данных. После очистки пользовательских данных эмулятор копирует в каталог пользовательских данных содержимое указанного файла (по умолчанию это файл <strong>userdata-qemu.img</strong>), а не использует <strong>userdata.img</strong> в качестве исходных данных. </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.path </code></td>
    <td><strong>Путь к разделу данных</strong> — указывает файл для раздела пользовательских данных. Чтобы настроить сохраняемый файл пользовательских данных, введите имя файла и путь к нему на компьютере разработки. Если этот файл не существует, эмулятор создает образ из файла по умолчанию <strong>userdata.img</strong>, сохраняет его с тем именем, которое указано в параметре <code>disk.dataPartition.path</code>, и при завершении работы сохраняет в этом файле все данные пользователя. Если путь не указан, файл по умолчанию получает имя <strong>userdata-qemu.img</strong>. Специальное значение <code>&lt; temp ></code> сообщает эмулятору, что следует создать и использовать временный файл. Если установлен параметр <code>disk.dataPartition.initPath</code>, во время загрузки его содержимое будет скопировано в файл <code>disk.dataPartition.path</code>. Обратите внимание, что этот параметр нельзя оставлять пустым.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.size </code></td>
    <td><strong>Размер раздела данных</strong> — указывает размер раздела для пользовательских данных в мегабайтах.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.ramdisk.path </code></td>
    <td><strong>Путь к виртуальному диску</strong> — путь к образу загрузочного раздела (виртуальному диску). Образ виртуального диска является подмножеством системных образов, который загружается ядром перед подключением образа системы. Образ виртуального диска обычно содержит двоичные файлы и скрипты инициализации для процессов загрузки. Если этот параметр не указан, по умолчанию используется файл <strong>ramdisk.img</strong> в системном каталоге эмулятора.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.snapStorage.path </code></td>
    <td><strong>Путь к хранилищу моментального снимка</strong> — путь к <i>файла хранилища моментальных снимков</i>, в котором сохраняются моментальные снимки. В этот файл будет сохранены все моментальные снимки, созданные во время выполнения. При работе эмулятора можно восстановить только те моментальные снимки, которые сохраняются в этот файл. Если этот параметр не указан, по умолчанию используется файл <strong>snapshots.img</strong> в каталоге данных эмулятора.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.initPath </code></td>
    <td><strong>Путь к системному разделу init</strong> — путь к копии файла системного образа, доступной только для чтения. Именно в этом разделе хранятся системные библиотеки и данные, относящиеся к уровню API, и все их вариации. Если этот путь не указан, по умолчанию используется файл <strong>system.img</strong> в системном каталоге эмулятора.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.path </code></td>
    <td><strong>Путь к системному разделу</strong> — путь к образу системного раздела, доступному для чтения и записи. Если этот путь не задан, будет создан временный файл и заполнен содержимым из файла, указанного в параметре <code>disk.systemPartition.initPath</code>. </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.size </code></td>
    <td><strong>Размер системного раздела</strong> — оптимальный размер системного раздела (в мегабайтах). Этот размер не учитывается, если фактический образ системного раздела больше указанного здесь значения. В противном случае он ограничивает максимальный размер файла для системного раздела.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.accelerometer </code></td>
    <td><strong>Акселерометр</strong> — определяет, содержит ли эмулируемое устройство датчик акселерометра. Акселерометр помогает устройству ориентироваться в пространстве (например, используется для автоматического поворота экрана). Акселерометр передает ускорение, действующее на устройство по трем осям датчика.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.audioInput </code></td>
    <td><strong>Поддержка записи звука</strong> — определяет, умеет ли эмулируемое устройство записывать звук.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.audioOutput </code></td>
    <td><strong>Поддержка воспроизведения звука</strong> — определяет, умеет ли эмулируемое устройство воспроизводить звук.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.battery </code></td>
    <td><strong>Поддержка аккумулятора</strong> — определяет, умеет ли эмулируемое устройство работать от аккумулятора.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.camera </code></td>
    <td><strong>Поддержка камеры</strong> — определяет, есть ли камера на эмулируемом устройстве.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.camera.back </code></td>
    <td><strong>Задняя камера</strong> — настраивает заднюю камеру устройства (ту, которая направлена в другую сторону от пользователя). Если вы используете веб-камеру на компьютере разработчика для имитации задней камеры на эмулируемом устройстве, присвойте этому параметру значение <code>webcam<i>n</i></code>, где <i>n</i> обозначает порядковый номер камеры в системе (если есть только одна веб-камера, укажите <code>webcam0</code>). Если здесь выбрано значение <code>эмулируется</code>, эмулятор имитирует камеру программным способом. Чтобы отключить заднюю камеру, задайте этому параметру значение <code>нет</code>. Если вы включите заднюю камеру, обязательно включите параметр <code>hw.camera</code>.  </td>
    <td> emulated (эмулируется), none (нет), webcam0 (веб-камера 0) </td>
</tr>
<tr>
    <td><code> hw.camera.front </code></td>
    <td><strong>Передняя камера</strong> — настраивает переднюю камеру устройства (ту, которая направлена на пользователя). Если вы используете веб-камеру на компьютере разработчика для имитации передней камеры на эмулируемом устройстве, присвойте этому параметру значение <code>webcam<i>n</i></code>, где <i>n</i> обозначает порядковый номер камеры в системе (если есть только одна веб-камера, укажите <code>webcam0</code>). Если здесь выбрано значение <code>эмулируется</code>, эмулятор имитирует камеру в программном обеспечении. Чтобы отключить переднюю камеру, задайте этому параметру значение <code>нет</code>. Если вы включите переднюю камеру, обязательно включите параметр <code>hw.camera</code>.  </td>
    <td> emulated (эмулируется), none (нет), webcam0 (веб-камера 0) </td>
</tr>
<tr>
    <td><code> hw.camera.maxHorizontalPixels </code></td>
    <td><strong>Максимальное количество пикселей камеры по горизонтали</strong> — настраивает максимальное разрешение (в пикселях) по горизонтали для камеры эмулированного устройства.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.camera.maxVerticalPixels </code></td>
    <td><strong>Максимальное количество пикселей камеры по вертикали</strong> — настраивает максимальное разрешение (в пикселях) по вертикали для камеры эмулированного устройства.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.cpu.arch </code></td>
    <td><strong>Архитектура ЦП</strong> — архитектура ЦП, которую будет эмулировать виртуальное устройство. Если вы используете Intel HAXM для аппаратного ускорения, выберите <code>x86</code> для 32-разрядного процессора. Выберите <code>x86_64</code>, если вам нужно 64-разрядное устройство с ускорением HAXM. (Не забудьте установить соответствующий образ системы Intel x86 в диспетчере SDK: например, <strong>Intel x86 Atom</strong> или <strong>Intel x86 Atom_64</strong>.) Для имитации процессора ARM выберите <code>arm</code> (32-разрядная версия) или <code>arm64</code> (64-разрядная версия). Учитывайте, что виртуальные устройства на основе ARM работают гораздо медленнее, чем на основе x86, поскольку для ARM не поддерживается аппаратное ускорение.  </td>
    <td> x86, x86_64, arm, arm64 </td>
</tr>
<tr>
    <td><code> hw.cpu.model </code></td>
    <td><strong>Модель процессора</strong> — это значение обычно не указывается (ему будет присвоено производное значение от <code>hw.cpu.arch</code>, если значение отсутствует). Но для экспериментов вы можете присвоить ему конкретную строку, значение которой зависит от эмулятора.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.dPad </code></td>
    <td><strong>Клавиши DPad</strong> — определяет, поддерживает ли эмулированное устройство навигационное устройство (DPad). Обычно DPad имеет четыре клавиши для выбора направления.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.gps </code></td>
    <td><strong>Поддержка GPS</strong> — определяет наличие приемника GPS (глобальной системы позиционирования) на эмулированном устройстве.  </td>
    <td> yes (Да), no (Нет) </td>
<tr>
</tr>
<tr>
    <td><code> hw.gpu.enabled </code></td>
    <td><strong>Эмуляция GPU</strong> — определяет поддержку эмуляции GPU для эмулированного устройства. Если включена эмуляция GPU, для отрисовки 2D и 3D графики на экране применяется Open GL для встраиваемых систем (OpenGL ES). Способ реализации для эмуляции GPU определяется связанным параметром "Режим эмуляции GPU".  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.gpu.mode </code></td>
    <td><strong>Режим эмуляции GPU</strong> — определяет способ реализации для эмуляции GPU в эмуляторе устройства. Если выбран вариант <code>auto</code>, эмулятор самостоятельно выберет режимы программного и аппаратного ускорения, исходя из настроек компьютера разработки. Если выбран вариант <code>host</code>, эмулятор будет использовать графический процессор компьютера разработки для эмуляции GPU, чтобы ускорять отображение содержимого. Если установленный GPU не совместим с эмулятором, на операционной системе Windows можно попробовать вариант <code>angle</code> вместо <code>host</code>. Режим <code>angle</code> предоставляет через DirectX примерно такую же производительность, как вариант <code>host</code>. Если выбран вариант <code>mesa</code>, эмулятор будет использовать программную библиотеку Mesa 3D для отображения графики. Выберите <code>mesa</code>, если работа с графическим процессором компьютера разработки вызывает какие-либо проблемы. Режим <code>Swiftshader</code> позволяет отображать графические элементы программным способом с несколько меньшей производительностью по сравнению с графическим процессором компьютера. Вариант <code>Off</code> (отключение эмуляции графического оборудования) мы использовать не рекомендуем, поскольку некоторые элементы в этом режиме воспроизводятся неправильно. </td>
    <td> auto (автоматически), host (компьютер), mesa, angle, swiftshader, off (отключено) </td>
</tr>
<tr>
    <td><code> hw.gsmModem </code></td>
    <td><strong>Поддержка модема GSM</strong> — определяет наличие на эмулируемом устройстве модема, который поддерживает систему радиосвязи GSM (глобальная система связи для мобильных устройств).  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.initialOrientation </code></td>
    <td><strong>Начальная ориентация экрана</strong> — настраивает начальную ориентацию экрана на эмулированном устройстве (книжный или альбомный режим). В книжной ориентации высота экрана больше, чем ширина. В альбомной ориентации ширина экрана больше, чем высота. После запуска эмулированного устройства вы можете изменить на нем ориентацию, если оба этих режима поддерживает профиль устройства.  </td>
    <td> portrait (книжная), landscape (альбомная) </td>
</tr>
<tr>
    <td><code> hw.keyboard </code></td>
    <td><strong>Поддержка клавиатуры</strong> — определяет, поддерживает ли эмулированное устройство клавиатуру QWERTY.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.keyboard.charmap </code></td>
    <td><strong>Имя таблицы символов для клавиатуры</strong> — имя таблицы символов оборудования этого устройства. Примечание. Здесь следует всегда использовать значение по умолчанию <code>qwerty2</code>, если в образ системы не внесены необходимые изменения. Это имя отправляется в ядро во время загрузки. Если указать неправильное имя, виртуальное устройство будет недоступно для использования.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.keyboard.lid </code></td>
    <td><strong>Поддержка крышки клавиатуры</strong> — если включена поддержка клавиатуры, этот параметр определяет, можно ли на устройстве закрыть/спрятать и открыть/показать клавиатуру QWERTY. Этот параметр игнорируется, если для <code>hw.keyboard</code> указано значение <code>false</code>. Примечание: по умолчанию устанавливается значение <code>false</code>, если эмулированное устройство предназначено для API уровня 12 или выше.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.lcd.backlight </code></td>
    <td><strong>Подсветка ЖК-экрана</strong> — определяет, будет ли эмулированное устройство управлять подсветкой ЖК-экрана.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.lcd.density </code></td>
    <td><strong>Плотность ЖК-экрана</strong> — плотность ЖК-экрана для эмулированного устройства, измеряется в виртуальных пикселях (<i>dp</i>), размер которых не зависит от плотности пикселей. Если выбрано значение 160 точек, каждый виртуальный пиксель (dp) строго соответствует одному физическому пикселю. Во время выполнения Android масштабирует все ресурсы,используя это значение, чтобы правильно отображать их на экране.  </td>
    <td> 120, 160, 240, 213, 320 </td>
</tr>
<tr>
    <td><code> hw.lcd.depth </code></td>
    <td><strong>Глубина цвета ЖК-экран</strong> — глубина цвета в битах для буфера кадров эмулированного устройства, в котором сохраняется изображение для отображения на ЖК-экране. Здесь допускаются значения 16 бит (65 536 возможных цветов) или 32 бит (16 777 216 цветов с поддержкой прозрачности). Если выбрано значение 32 бита, эмулятор может работать несколько медленнее, но зато с большей точностью цветопередачи.  </td>
    <td> 16, 32 </td>
</tr>
<tr>
    <td><code> hw.lcd.height </code></td>
    <td><strong>Высота ЖК-экрана в пикселях</strong> — количество пикселей по вертикали для ЖК-экрана эмулированного устройства.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.lcd.width </code></td>
    <td><strong>Ширина ЖК-экрана в пикселях</strong> — количество пикселей по горизонтали для ЖК-экрана эмулированного устройства.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.mainKeys </code></td>
    <td><strong>Аппаратные клавиши "назад" и "домой"</strong> — определяет поддержку аппаратных клавиш "назад" и "домой" для эмулированного устройства. Здесь вы можете задать значение <code>Да</code>, если клавиши реализованы только в программном обеспечении. Если для <code>hw.mainKeys</code> указать значение <code>Да</code>, эмулятор не отображает на экране кнопки навигации, но для их "нажатия" можно использовать боковую панель эмулятора.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.ramSize </code></td>
    <td><strong>Объем оперативной памяти на устройстве</strong> — определяет объем физической памяти на эмулированном устройстве в мегабайтах. Значение по умолчанию этого параметра зависит от размера экрана или версии обложки. Если вы увеличите этот размер, эмуляция будет работать быстрее, но для этого потребуется больше ресурсов на компьютере разработки.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.screen </code></td>
    <td><strong>Тип сенсорного экрана</strong> — определяет тип экрана для эмулированного устройства. В режиме <code>мультисенсорный</code> экрана отслеживает касание двумя или более пальцами. В режиме <code>сенсорный</code> экран поддерживает только события касания одним пальцем. В режиме <code>не сенсорный</code> экран не отслеживает события касания.  </td>
    <td> touch (сенсорный), multi-touch (мультисенсорный), no-touch (не сенсорный) </td>
</tr>
<tr>
    <td><code> hw.sdCard </code></td>
    <td><strong>Поддержка карты SD</strong> — определяет поддержку событий вставки и удаления карты SD (Secure Digital) на эмулированном устройстве. Эмулятор использует подключаемые образы дисков, хранящиеся на компьютере разработчика, для имитации разделов на обычных картах SD (см. также параметр <code>hw.sdCard.path</code>).  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> sdcard.size </code></td>
    <td><strong>Размер карты SD</strong> — указывает доступный для устройства размер виртуального файла карты SD, расположение которого задано параметром <code>hw.sdCard.path</code> (в байтах). Если размер задан простым целым числом, он интерпретируется как размер в байтах. Также вы можете указать размер в килобайтах, мегабайтах или гигабайтах, добавив к размеру обозначение "K","M" или "G" соответственно. Поддерживается размер в диапазоне от 9 МБ до 1023 ГБ.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.sdCard.path </code></td>
    <td><strong>Путь к образу карты SD</strong> — задает имя файла с образом раздела карты SD и путь к нему на компьютере разработки. Например, в ОС Windows этот путь может иметь значение <strong>C:\sd\sdcard.img</strong>.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.sensors.magnetic_field </code></td>
    <td><strong>Датчик магнитного поля</strong> — определяет поддержку датчика магнитного поля для эмулированного устройства. Датчик магнитного поля (магнитометр) сообщает напряженность окружающего магнитного поля по трем осям. Включите этот параметр, если вашему приложению нужны показания компаса. Например, приложение навигации может с помощью этого датчика определять, куда смотрит пользователь.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.sensors.orientation </code></td>
    <td><strong>Ориентация датчика</strong> — определяет наличие датчика ориентации на эмулированном устройстве. Датчик ориентации измеряет угол поворота для корпуса устройства по трем физическим осям (x, y, z). Обратите внимание, что датчик ориентации объявлен устаревшим с версии ОС Android 2.2 (API уровня 8).  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.sensors.proximity </code></td>
    <td><strong>Датчик приближения</strong> — определяет поддержку датчика приближения для эмулированного устройства. Этот датчик измеряет расстояния до ближайшего объекта от экрана устройства. Обычно с помощью этого датчика приложения определяют, что человек держит мобильный телефон возле уха.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.sensors.temperature </code></td>
    <td><strong>Датчик температуры</strong> — определяет поддержку датчика температуры для эмулированного устройства. Этот датчик измеряет температуру устройства в градусах Цельсия (° C).  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.touchScreen </code></td>
    <td><strong>Поддержка сенсорного экрана </strong> — определяет, поддерживает ли эмулированное устройство сенсорный экран. Сенсорный экран используется для прямого управления объектами, отображенными на экране.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.trackBall </code></td>
    <td><strong>Поддержка шарового манипулятора</strong> — определяет, поддерживает ли эмулированное устройство трекбол.  </td>
    <td> yes (Да), no (Нет) </td>
</tr>
<tr>
    <td><code> hw.useext4 </code></td>
    <td><strong>Поддержка файловой системы EXT4</strong> — определяет поддержку файловой системы Linux EXT4 для разделов эмулированного устройства. В настоящее время тип файловой системы определяется автоматически, поэтому этот параметр считается устаревшим и не учитывается.  </td>
    <td> Нет </td>
</tr>
<tr>
    <td><code> kernel.newDeviceNaming </code></td>
    <td><strong>Новая схема именования устройств для ядра</strong> — указывает, что ядро устройства требует использовать новую схему именования устройств. Обычно этот режим требуется для ядер Linux 3.10 и более поздних версий. Установите значение <code>автоопределение</code>, чтобы эмулятор самостоятельно принимал решение об использовании новой схемы именования устройств.  </td>
    <td> autodetect (автоопределение), yes (да), no (нет) </td>
</tr>
<tr>
    <td><code> kernel.parameters </code></td>
    <td><strong>Параметры ядра</strong> — указывает строку параметров загрузки для ядра Linux. По умолчанию этот параметр имеет пустое значение.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> kernel.path </code></td>
    <td><strong>Путь к ядру</strong> — определяет путь к ядру Linux. Если этот путь не указан, эмулятор по умолчанию ищет файл <code>kernel-ranchu</code> в своем системном каталоге.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> kernel.supportsYaffs2 </code></td>
    <td><strong>Поддержка разделов YAFFS2</strong> — определяет, поддерживает ли ядро разделы с файловой системой YAFFS2. Обычно это требуется только для версий ядра меньше Linux 3.10. Установите значение <code>автоопределение</code>, чтобы эмулятор самостоятельно принимал решение о возможности подключения файловых систем YAFFS2.  </td>
    <td> autodetect (автоопределение), yes (да), no (нет) </td>
</tr>
<tr>
    <td><code> skin.name </code></td>
    <td><strong>Имя обложки</strong> — имя для обложки эмулятора Android. Обложка — это набор файлов, которые описывают правила отображения для визуальных элементов и элементов управления. Эти правила определяют, как будет выглядеть окно AVD на компьютере разработки. От обложки зависят размер экрана, внешний вид кнопок и другие параметры оформления, но она никак не влияет на работу приложения. </td>
    <td> </td>
</tr>
<tr>
    <td><code> skin.path </code></td>
    <td><strong>Путь к обложке</strong> — путь к каталогу, который содержит файлы обложки, имя которой указано в параметре <code>skin.name</code>. В этом каталоге должны размещаться файлы макета <code>hardware.ini</code> и файлы изображений, используемых в обложке для элементов отображения. </td>
    <td> </td>
</tr>
<tr>
    <td><code> skin.dynamic </code></td>
    <td><strong>Динамическая обложка</strong> — определяет, является ли обложка динамической. Обложка эмулятора считается динамической, если эмулятору нужно создать обложку определенного размера на основе значений ширины и высоты экрана. </td>
    <td> Нет </td>
</tr>
</table>
