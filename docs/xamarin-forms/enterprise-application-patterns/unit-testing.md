---
title: Модульного тестирования корпоративных приложений
description: В этой главе объясняется, как модульное тестирование выполняется в мобильном приложении eShopOnContainers.
ms.prod: xamarin
ms.assetid: 4af82e52-f99b-4cad-b278-1745f190c240
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 06cd89e0b0871eac723e8580340173f77821e4ed
ms.sourcegitcommit: 66682dd8e93c0e4f5dee69f32b5fc5a96443e307
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/08/2018
ms.locfileid: "35242535"
---
# <a name="unit-testing-enterprise-apps"></a>Модульного тестирования корпоративных приложений

Мобильные приложения имеют уникальные проблемы, которые настольных и веб-приложения не нужно беспокоиться о. Мобильные пользователи будут отличаться в устройствах, которые в них используются, в сетевом подключении, доступность служб, а также ряд других факторов. Таким образом мобильные приложения необходимо протестировать, как они будут использоваться в реальном мире, чтобы улучшить качество, надежность и производительность. Существует много типов тестирования, которые должны быть выполнены для приложения, включая модульное тестирование, тестирование интеграции и тестирование, с помощью модульных тестов, выполняется наиболее распространенная форма тестирования пользовательского интерфейса.

Модульный тест принимает небольшое устройство приложения, обычно метод, изолирует ее из оставшаяся часть кода и проверяет, что оно правильно работает. Его задача — проверьте каждую единицу функциональности правильную, так что ошибок не распространятся приложения. Обнаружение ошибок, где они происходят более эффективна, наблюдая влияния данной ошибки косвенно во вторичной точки сбоя.

Модульное тестирование обладает максимально влияет на качество кода, если является неотъемлемой частью рабочего процесса разработки программного обеспечения. Как только будет записана метод модульные тесты должны быть написаны для проверки поведения метода в ответ на стандартные, граничные и некорректные случаи ввода данных, и что эта проверка явные или предполагаемые допущения, сделанные кодом. Кроме того с Разработка через тестирование, модульные тесты записываются до выполнения кода. В этом случае модульных тестов в качестве технической документации и спецификации функциональности.

> [!NOTE]
> Модульные тесты — это очень эффективна против регрессии — то есть функции, предназначенных для работы, но были задействуются неисправное обновление.

Модульные тесты обычно использовать шаблон упорядочить act assert.

-   *Упорядочить* метода модульного тестирования инициализирует объекты и устанавливает значение данных, передаваемый тестируемого метода.
-   *Действовать* вызывает метод теста с необходимым набором аргументов.
-   *Assert* проверяет, метод для теста действовал, как ожидалось.

Следуя этому шаблону обеспечивает модульные тесты для чтения и согласованность.

## <a name="dependency-injection-and-unit-testing"></a>Внедрение зависимостей и модульного тестирования

Одной из причин заимствования архитектуру слабо связанных — что он облегчает тестирование. Является одним из типов, зарегистрированных с Autofac `OrderService` класса. В следующем примере кода показано структуры этого класса:

```csharp
public class OrderDetailViewModel : ViewModelBase  
{  
    private IOrderService _ordersService;  

    public OrderDetailViewModel(IOrderService ordersService)  
    {  
        _ordersService = ordersService;  
    }  
    ...  
}
```

`OrderDetailViewModel` Класс имеет зависимость от `IOrderService` тип, который контейнер разрешается, когда он создает `OrderDetailViewModel` объекта. Тем не менее, а не создавать `OrderService` объекта модульный тест `OrderDetailViewModel` класса, замените, `OrderService` объект с макетов с целью выполнения тестов. Данная связь показана на рис. 10-1.

![](unit-testing-images/unittesting.png "Классы, реализующие интерфейс IOrderService")

**Рис. 10-1:** классы, реализующие интерфейс IOrderService

Такой подход позволяет `OrderService` объекту быть переданным в `OrderDetailViewModel` классов во время выполнения и в интересах тестирования, она позволяет `OrderMockService` класса для передачи в `OrderDetailViewModel` класса во время выполнения теста. Главным преимуществом такого подхода является то, что можно выполнять модульные тесты для выполнения без необходимости громоздким ресурсы, такие как веб-службы или баз данных.

## <a name="testing-mvvm-applications"></a>Тестирование приложений MVVM

Тестирование моделей и Просмотр моделей из приложений MVVM идентична тестирование любые другие классы, и можно использовать те же средства и методы, такие как модульное тестирование и имитации. Однако существуют некоторые шаблоны, характерных для модели и представления модели классов, которые могут использовать преимущества методики тестирования конкретного устройства.

> [!TIP]
> Проверьте одно с каждым модульным тестом. Не возникнуть желание сделать модульного тестирования упражнении более чем одним из аспектов поведения устройства. Это ведет к тестам, которые трудно читать и обновлять. Оно может также привести к несогласованности при интерпретации сбоя.

Использование мобильного приложения eShopOnContainers [xUnit](https://xunit.github.io/) для выполнения модульное тестирование, который поддерживает два различных типа модульных тестов:

-   Факты, тесты, которые всегда имеют значение true, какой тест неизменяемых условий.
-   Теории, тесты, которые выполняются только для определенного набора данных.

Модульных тестов, включенных в мобильном приложении eShopOnContainers являются проверками фактов, и поэтому снабжен каждый метод модульного теста `[Fact]` атрибута.

> [!NOTE]
> средства выполнения тестов, выполняемых тестов xUnit. Для выполнения тестов, запустите проект eShopOnContainers.TestRunner для платформы, необходимые.

### <a name="testing-asynchronous-functionality"></a>Тестирование асинхронных функциональных возможностей

При реализации шаблона MVVM Просмотр моделей обычно операции служб, часто асинхронного вызова. Тесты для кода, вызывающего эти операции обычно служит замены макеты для фактических служб. В следующем примере кода демонстрируется проверка асинхронной функциональности путем передачи в модель представления макета службы:

```csharp
[Fact]  
public async Task OrderPropertyIsNotNullAfterViewModelInitializationTest()  
{  
    var orderService = new OrderMockService();  
    var orderViewModel = new OrderDetailViewModel(orderService);  

    var order = await orderService.GetOrderAsync(1, GlobalSetting.Instance.AuthToken);  
    await orderViewModel.InitializeAsync(order);  

    Assert.NotNull(orderViewModel.Order);  
}
```

Этот модульный тест проверяет, что `Order` свойство `OrderDetailViewModel` экземпляр будет иметь значение после `InitializeAsync` метод был вызван. `InitializeAsync` Метод вызывается при переходе на соответствующее представление модели представления. Дополнительные сведения о навигации, см. в разделе [навигации](~/xamarin-forms/enterprise-application-patterns/navigation.md).

Когда `OrderDetailViewModel` , создается экземпляр ожидает `OrderService` экземпляра, указанное в качестве аргумента. Однако `OrderService` получает данные из веб-службы. Таким образом `OrderMockService` экземпляра, то есть имитационную версию объекта `OrderService` класса, указанное в качестве аргумента для `OrderDetailViewModel` конструктор. Затем, когда модель представления `InitializeAsync` вызывается метод, который вызывает `IOrderService` фиктивные данные операции, полученных, а не взаимодействует с веб-службы.

### <a name="testing-inotifypropertychanged-implementations"></a>Тестирование реализации интерфейс INotifyPropertyChanged

Реализация `INotifyPropertyChanged` интерфейс позволяет представления для реагирования на изменения, которые получаются из представления модели и модели. Эти изменения не ограничиваются данным, отображаемым в элементах управления, они также используются для управления представления, такие как представление состояний модели, вызывающие анимации для запуска или элементов управления требуется отключить.

Свойства, которые могут быть обновлены непосредственно, модульный тест можно протестировать путем присоединения обработчик событий к `PropertyChanged` событий и проверка, является ли это событие возникает после задания нового значения для свойства. В следующем примере кода показан такой тест:

```csharp
[Fact]  
public async Task SettingOrderPropertyShouldRaisePropertyChanged()  
{  
    bool invoked = false;  
    var orderService = new OrderMockService();  
    var orderViewModel = new OrderDetailViewModel(orderService);  

    orderViewModel.PropertyChanged += (sender, e) =>  
    {  
        if (e.PropertyName.Equals("Order"))  
            invoked = true;  
    };  
    var order = await orderService.GetOrderAsync(1, GlobalSetting.Instance.AuthToken);  
    await orderViewModel.InitializeAsync(order);  

    Assert.True(invoked);  
}
```

Этот модульный тест вызывает `InitializeAsync` метод `OrderViewModel` класса, что приводит его `Order` обновляемое свойство. Модульный тест выполняется успешно, при условии, что `PropertyChanged` событие вызывается для `Order` свойства.

### <a name="testing-message-based-communication"></a>Тестирование связи на основе сообщений

Просмотр модели, использующие [ `MessagingCenter` ](https://developer.xamarin.com/api/type/Xamarin.Forms.MessagingCenter/) класса для обмена данными между слабо связанными классами единицы тестируется подписавшись на сообщения, отправляемого по тестируемый код, как показано в следующем примере кода:

```csharp
[Fact]  
public void AddCatalogItemCommandSendsAddProductMessageTest()  
{  
    bool messageReceived = false;  
    var catalogService = new CatalogMockService();  
    var catalogViewModel = new CatalogViewModel(catalogService);  

    Xamarin.Forms.MessagingCenter.Subscribe<CatalogViewModel, CatalogItem>(  
        this, MessageKeys.AddProduct, (sender, arg) =>  
    {  
        messageReceived = true;  
    });  
    catalogViewModel.AddCatalogItemCommand.Execute(null);  

    Assert.True(messageReceived);  
}
```

Этот модульный тест проверяет, что `CatalogViewModel` публикует `AddProduct` сообщение в ответ на его `AddCatalogItemCommand` при выполнении. Поскольку [ `MessagingCenter` ](https://developer.xamarin.com/api/type/Xamarin.Forms.MessagingCenter/) класс поддерживает подписки многоадресного сообщения, модульный тест можно подписаться на `AddProduct` сообщение и выполняются в ответ на его получение делегат обратного вызова. Этот делегат обратного вызова, указанный как лямбда-выражение задает `boolean` поле, используемое по `Assert` инструкции для проверки поведения теста.

### <a name="testing-exception-handling"></a>Тестирование обработка исключений

Модульные тесты можно также записать, убедитесь, что конкретных исключений недопустимый действий или входные данные, как показано в следующем примере кода:

```csharp
[Fact]  
public void InvalidEventNameShouldThrowArgumentExceptionText()  
{  
    var behavior = new MockEventToCommandBehavior  
    {  
        EventName = "OnItemTapped"  
    };  
    var listView = new ListView();  

    Assert.Throws<ArgumentException>(() => listView.Behaviors.Add(behavior));  
}
```

Этот модульный тест вызывает исключение, так как [ `ListView` ](https://developer.xamarin.com/api/type/Xamarin.Forms.ListView/) управления не имеет события с именем `OnItemTapped`. `Assert.Throws<T>` Метод является универсальным методом где `T` тип ожидаемого исключения. Аргумент, передаваемый `Assert.Throws<T>` метод является лямбда-выражение, которое вызовет исключение. Таким образом, модульный тест выполняется успешно при условии, что лямбда-выражение вызывает `ArgumentException`.

>💡 **Совет**: Избегайте написания модульных тестов, которые анализируют строки сообщения исключений. Строки сообщения исключений могут измениться с течением времени и поэтому модульные тесты, которые зависят от их наличие рассматриваются как нестабильной.

### <a name="testing-validation"></a>Тестирование проверки

Есть два аспекта тестирование реализации проверки: тестирование правильно реализованы все правила проверки и тестирования, `ValidatableObject<T>` класса так, как ожидалось.

Логика проверки реализуется обычно простой проверить, так как он обычно является самодостаточным процесса, где результат зависит от входных данных. На результаты вызова должен быть тесты `Validate` метод для каждого свойства, которое имеет по крайней мере один связанный условие, как показано в следующем примере кода:

```csharp
[Fact]  
public void CheckValidationPassesWhenBothPropertiesHaveDataTest()  
{  
    var mockViewModel = new MockViewModel();  
    mockViewModel.Forename.Value = "John";  
    mockViewModel.Surname.Value = "Smith";  

    bool isValid = mockViewModel.Validate();  

    Assert.True(isValid);  
}
```

Этот модульный тест проверяет, что проверка проходит успешно, если два `ValidatableObject<T>` свойства в `MockViewModel` оба экземпляра имеют данных.

А также проверки, проверка завершается успешно, модульные тесты для проверки необходимо также проверить значения `Value`, `IsValid`, и `Errors` каждого экземпляра `ValidatableObject<T>` экземпляра, чтобы убедиться, что класс так, как ожидалось. В следующем примере кода демонстрируется модульный тест, который делает это:

```csharp
[Fact]  
public void CheckValidationFailsWhenOnlyForenameHasDataTest()  
{  
    var mockViewModel = new MockViewModel();  
    mockViewModel.Forename.Value = "John";  

    bool isValid = mockViewModel.Validate();  

    Assert.False(isValid);  
    Assert.NotNull(mockViewModel.Forename.Value);  
    Assert.Null(mockViewModel.Surname.Value);  
    Assert.True(mockViewModel.Forename.IsValid);  
    Assert.False(mockViewModel.Surname.IsValid);  
    Assert.Empty(mockViewModel.Forename.Errors);  
    Assert.NotEmpty(mockViewModel.Surname.Errors);  
}
```

Этот модульный тест проверяет, что при сбое проверки `Surname` свойство `MockViewModel` не содержит данных и `Value`, `IsValid`, и `Errors` свойства каждого `ValidatableObject<T>` экземпляр заданы правильно.

## <a name="summary"></a>Сводка

Модульный тест принимает небольшое устройство приложения, обычно метод, изолирует ее из оставшаяся часть кода и проверяет, что оно правильно работает. Его задача — проверьте каждую единицу функциональности правильную, так что ошибок не распространятся приложения.

Поведение объекта тестируемого могут быть изолированы, заменив зависимые объекты макетов объектов, которые имитируют поведение зависимых объектов. Это позволяет модульных тестов для выполнения без необходимости громоздким ресурсы, такие как веб-службы или баз данных.

Тестирование моделей и Просмотр моделей из приложений MVVM идентична тестирование любые другие классы, и можно использовать те же средства и методы.


## <a name="related-links"></a>Связанные ссылки

- [Загрузить электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
