---
title: Модульного тестирования корпоративных приложений
description: В данной главе объясняется, как модульное тестирование выполняется в мобильном приложении eShopOnContainers.
ms.prod: xamarin
ms.assetid: 4af82e52-f99b-4cad-b278-1745f190c240
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 02aeedd5498c47950e2fbc0d218de05bc0bb3204
ms.sourcegitcommit: 6e955f6851794d58334d41f7a550d93a47e834d2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/12/2018
ms.locfileid: "38998687"
---
# <a name="unit-testing-enterprise-apps"></a>Модульного тестирования корпоративных приложений

Мобильные приложения имеют уникальные проблемы, настольных и веб-приложений не нужно беспокоиться о. Мобильные пользователи будут отличаться по устройства, которые они используют, в сетевом подключении, доступность служб, а также ряд других факторов. Таким образом мобильные приложения должны тестироваться, так как они понадобятся в реальном мире для улучшения их качества, надежности и производительности. Существует много типов тестирования, которые должны выполняться для приложения, включая модульное тестирование, тестирование интеграции и тестирования с модульным тестированием, что наиболее распространенная форма тестирования пользовательского интерфейса.

Модульный тест занимает небольшое устройство приложения, обычно метод и изолировать ее оставшаяся часть кода проверяет, что она правильно работает. Наша цель — проверить, что каждая единица функции выполняет надлежащим образом, позволяющий ошибки не распространились в приложение. Обнаружение ошибок, где они происходят более эффективен, наблюдая за последствия ошибку косвенно на вторичный точки сбоя.

Модульное тестирование максимально влияет на качество кода при является неотъемлемой частью рабочего процесса разработки программного обеспечения. Как только метод записана, модульные тесты должны быть написаны для проверки поведения метода в ответ на стандартные, граничные и некорректные случаи ввода данных, и что эта проверка явные или предполагаемые допущения, сделанные кодом. Кроме того с Разработка на основе тестирования, модульные тесты создаются прежде чем код. В этом случае модульные тесты в качестве технической документации и спецификации функциональности.

> [!NOTE]
> Модульные тесты — очень эффективна против регрессии — то есть функциональные возможности, предназначенных для работы, но были задействуются по сбоя во время обновления.

Модульные тесты обычно используется шаблон расположение act утверждение:

-   *Упорядочить* разделе метода модульного тестирования инициализирует объекты и устанавливает значение данных, который передается методу для теста.
-   *Действовать* разделе вызывает метод для теста с необходимым набором аргументов.
-   *Assert* раздел проверяет, что метод для теста действовал, должным образом.

Следовать этому шаблону гарантирует, что модульные тесты доступны для чтения и согласованность.

## <a name="dependency-injection-and-unit-testing"></a>Внедрение зависимостей и модульное тестирование

Одним из этих причин заимствования используется слабо связанная архитектура является, что она упрощает модульное тестирование. Одним из типов, зарегистрированных с помощью Autofac является `OrderService` класса. В следующем примере кода показано структуры этого класса:

```csharp
public class OrderDetailViewModel : ViewModelBase  
{  
    private IOrderService _ordersService;  

    public OrderDetailViewModel(IOrderService ordersService)  
    {  
        _ordersService = ordersService;  
    }  
    ...  
}
```

`OrderDetailViewModel` Класс имеет зависимость от `IOrderService` типа контейнера разрешается, когда он создает экземпляр `OrderDetailViewModel` объекта. Тем не менее не нужно создавать `OrderService` модульный тест, который `OrderDetailViewModel` класса, замените, `OrderService` объект с макет для тестов. Данная связь показана на рис. 10-1.

![](unit-testing-images/unittesting.png "Классы, реализующие интерфейс IOrderService")

**Рис. 10-1:** классы, реализующие интерфейс IOrderService

Такой подход позволяет `OrderService` объекту быть переданным в `OrderDetailViewModel` классов во время выполнения и в целях тестирования, она позволяет `OrderMockService` класс, передаваемый в `OrderDetailViewModel` класса во время тестирования. Основное преимущество этого подхода заключается том, что он позволяет модульных тестов для выполнения без необходимости громоздким ресурсы, такие как веб-службы или базы данных.

## <a name="testing-mvvm-applications"></a>Тестирование приложений MVVM

Тестирование модели и модели представлений из приложений MVVM идентична тестирование любые другие классы, и те же средства и методы — например модульного тестирования и макетирования, может использоваться. Тем не менее существуют некоторые шаблоны, что характерно для модели и классов модели представления, которые могут использовать преимущества методики тестирования для конкретного устройства.

> [!TIP]
> Протестируйте одну вещь, с каждым модульным тестом. Не следует соблазняться позволит провести модульное тестирование упражнении более чем одним из аспектов поведения устройства. Это ведет к тесты, которые сложно читать и обновлять. Он может также привести к путанице при интерпретации сбоя.

Использование мобильного приложения eShopOnContainers [xUnit](https://xunit.github.io/) для выполнения модульного тестирования, которое поддерживает два различных типа модульных тестов:

-   Факты, тесты, которые всегда являются значение равно true, какой тест неизменяемых условий.
-   Теорий, тесты, которые выполняются только для определенного набора данных.

Модульные тесты, включенные в мобильном приложении eShopOnContainers, тесты фактов, и поэтому каждый метод модульного теста снабжен `[Fact]` атрибута.

> [!NOTE]
> Средство выполнения тестов, выполняемых тестов xUnit. Для выполнения тестов, запустите проект eShopOnContainers.TestRunner для платформы, необходимые.

### <a name="testing-asynchronous-functionality"></a>Тестирование асинхронные функции

При реализации шаблона MVVM, Просмотр моделей обычно операции служб, часто асинхронного вызова. Тесты для кода, вызывающего эти операции обычно служит замены макеты для служб. В следующем примере кода показано тестирование асинхронных функциональных возможностей, передав услуга макетов в модель представления:

```csharp
[Fact]  
public async Task OrderPropertyIsNotNullAfterViewModelInitializationTest()  
{  
    var orderService = new OrderMockService();  
    var orderViewModel = new OrderDetailViewModel(orderService);  

    var order = await orderService.GetOrderAsync(1, GlobalSetting.Instance.AuthToken);  
    await orderViewModel.InitializeAsync(order);  

    Assert.NotNull(orderViewModel.Order);  
}
```

Этот модульный тест проверяет, что `Order` свойство `OrderDetailViewModel` экземпляр будет иметь значение после `InitializeAsync` метод был вызван. `InitializeAsync` Метод вызывается при переходе в соответствующее представление модели представления. Дополнительные сведения о навигации, см. в разделе [навигации](~/xamarin-forms/enterprise-application-patterns/navigation.md).

Когда `OrderDetailViewModel` создается экземпляр, ожидается, что `OrderService` можно определить в качестве аргумента экземпляр. Тем не менее `OrderService` извлекает данные из веб-службы. Таким образом `OrderMockService` экземпляра, то есть имитационную версию объекта `OrderService` класса, указанное в качестве аргумента для `OrderDetailViewModel` конструктор. Затем, когда модель представления `InitializeAsync` вызывается метод, который вызывает `IOrderService` фиктивных данных операций, полученных, а не взаимодействует с веб-службы.

### <a name="testing-inotifypropertychanged-implementations"></a>Тестирование реализации INotifyPropertyChanged

Реализация `INotifyPropertyChanged` интерфейс позволяет представления, чтобы реагировать на изменения, которые получены из представления модели и модели. Эти изменения не только данные, отображаемые в элементах управления – они также используются для управления представления, например состояний модели представления, вызывающие анимации для запуска или элементы управления, должно быть отключено.

Свойства, которые могут обновляться непосредственно через модульного теста можно протестировать путем присоединения обработчика событий к `PropertyChanged` событий и проверки, нужно ли создавать события после установки нового значения для свойства. В следующем примере кода показан такой тест:

```csharp
[Fact]  
public async Task SettingOrderPropertyShouldRaisePropertyChanged()  
{  
    bool invoked = false;  
    var orderService = new OrderMockService();  
    var orderViewModel = new OrderDetailViewModel(orderService);  

    orderViewModel.PropertyChanged += (sender, e) =>  
    {  
        if (e.PropertyName.Equals("Order"))  
            invoked = true;  
    };  
    var order = await orderService.GetOrderAsync(1, GlobalSetting.Instance.AuthToken);  
    await orderViewModel.InitializeAsync(order);  

    Assert.True(invoked);  
}
```

Этот модульный тест вызывает `InitializeAsync` метод `OrderViewModel` класса, что приводит его `Order` обновляемое свойство. Модульный тест выполняется успешно, при условии, что `PropertyChanged` события для `Order` свойство.

### <a name="testing-message-based-communication"></a>Тестирование обмена сообщениями

Представление модели, использующие [ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter) класс для взаимодействия между классами слабосвязанных единицы тестируются путем подписки на сообщения, отправляемого с кодом, как показано в следующем примере кода:

```csharp
[Fact]  
public void AddCatalogItemCommandSendsAddProductMessageTest()  
{  
    bool messageReceived = false;  
    var catalogService = new CatalogMockService();  
    var catalogViewModel = new CatalogViewModel(catalogService);  

    Xamarin.Forms.MessagingCenter.Subscribe<CatalogViewModel, CatalogItem>(  
        this, MessageKeys.AddProduct, (sender, arg) =>  
    {  
        messageReceived = true;  
    });  
    catalogViewModel.AddCatalogItemCommand.Execute(null);  

    Assert.True(messageReceived);  
}
```

Этот модульный тест проверяет, что `CatalogViewModel` публикует `AddProduct` сообщение в ответ на его `AddCatalogItemCommand` выполняемой. Так как [ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter) класс поддерживает сообщения многоадресной передачи подписок, модульного теста можно подписаться на `AddProduct` сообщений и выполнения делегат обратного вызова в ответ на его получение. Этот делегат обратного вызова, заданный как лямбда-выражение, задает `boolean` поле, которое используется `Assert` инструкцию, чтобы проверить поведение теста.

### <a name="testing-exception-handling"></a>Тестирование обработки исключений

Модульные тесты можно также записать, убедитесь, что определенные исключения для недопустимые действия или входные данные, как показано в следующем примере кода:

```csharp
[Fact]  
public void InvalidEventNameShouldThrowArgumentExceptionText()  
{  
    var behavior = new MockEventToCommandBehavior  
    {  
        EventName = "OnItemTapped"  
    };  
    var listView = new ListView();  

    Assert.Throws<ArgumentException>(() => listView.Behaviors.Add(behavior));  
}
```

Этот модульный тест приведет к возникновению исключения, так как [ `ListView` ](xref:Xamarin.Forms.ListView) управления не имеет событие с именем `OnItemTapped`. `Assert.Throws<T>` Метод является универсальным методом где `T` — это тип ожидаемого исключения. Аргумент, переданный в `Assert.Throws<T>` метод является лямбда-выражение, которое вызовет исключение. Таким образом, пройдет модульного теста, при условии, что лямбда-выражение вызывает `ArgumentException`.

>💡 **Совет**: избежать написания модульных тестов, которые анализируют строки сообщения исключений. Строки сообщения исключений могут изменяться с течением времени, и поэтому модульные тесты, которые полагаются на их наличие считаются значительно усложняло работу.

### <a name="testing-validation"></a>Тестирование проверки

Существует два аспекта тестирование реализации проверки: тестирование, что правильно реализованы в все правила проверки и тестирования, `ValidatableObject<T>` класс выполняет должным образом.

Логика проверки обычно прост для тестирования, так как это обычно автономные процесса, где выходных данных зависит от входных данных. В результаты вызова должен быть тесты `Validate` метод в каждом свойстве, имеет по крайней мере один связанное правило проверки, как показано в следующем примере кода:

```csharp
[Fact]  
public void CheckValidationPassesWhenBothPropertiesHaveDataTest()  
{  
    var mockViewModel = new MockViewModel();  
    mockViewModel.Forename.Value = "John";  
    mockViewModel.Surname.Value = "Smith";  

    bool isValid = mockViewModel.Validate();  

    Assert.True(isValid);  
}
```

Этот модульный тест проверяет, что проверка проходит успешно, когда два `ValidatableObject<T>` свойств в `MockViewModel` оба экземпляра имеют данных.

А также проверки, что проверка прошла успешно, модульные тесты для проверки следует также проверить значения `Value`, `IsValid`, и `Errors` свойства каждого `ValidatableObject<T>` экземпляр, чтобы убедиться, что класс выполняет должным образом. В следующем примере кода демонстрируется модульный тест, который делает это:

```csharp
[Fact]  
public void CheckValidationFailsWhenOnlyForenameHasDataTest()  
{  
    var mockViewModel = new MockViewModel();  
    mockViewModel.Forename.Value = "John";  

    bool isValid = mockViewModel.Validate();  

    Assert.False(isValid);  
    Assert.NotNull(mockViewModel.Forename.Value);  
    Assert.Null(mockViewModel.Surname.Value);  
    Assert.True(mockViewModel.Forename.IsValid);  
    Assert.False(mockViewModel.Surname.IsValid);  
    Assert.Empty(mockViewModel.Forename.Errors);  
    Assert.NotEmpty(mockViewModel.Surname.Errors);  
}
```

Этот модульный тест проверяет, что при сбое проверки `Surname` свойство `MockViewModel` не содержит данных и `Value`, `IsValid`, и `Errors` свойства каждого `ValidatableObject<T>` экземпляр заданы правильно.

## <a name="summary"></a>Сводка

Модульный тест занимает небольшое устройство приложения, обычно метод и изолировать ее оставшаяся часть кода проверяет, что она правильно работает. Наша цель — проверить, что каждая единица функции выполняет надлежащим образом, позволяющий ошибки не распространились в приложение.

Поведение объекта тестируемого могут быть изолированы, заменив зависимых объектов в макеты объектов, которые имитируют поведение зависимые объекты. Это позволяет модульных тестов для выполнения без необходимости громоздким ресурсы, такие как веб-службы или базы данных.

Тестирование модели и модели представлений из приложений MVVM идентична тестирование любые другие классы, и можно использовать те же средства и методы.


## <a name="related-links"></a>Связанные ссылки

- [Скачайте электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
