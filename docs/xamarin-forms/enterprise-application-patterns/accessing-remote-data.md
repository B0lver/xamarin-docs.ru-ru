---
title: Удаленного доступа к данным
description: В этой главе объясняется, как eShopOnContainers мобильное приложение обращается к данным из контейнерного микрослужбами.
ms.prod: xamarin
ms.assetid: 42eba6f5-9784-4e1a-9943-5c1fbeea7452
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: a140560731cc68dd85c97dc5a89aedcb32abd405
ms.sourcegitcommit: 66682dd8e93c0e4f5dee69f32b5fc5a96443e307
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/08/2018
ms.locfileid: "35242093"
---
# <a name="accessing-remote-data"></a>Удаленного доступа к данным

Многие современные решения веб-сделать использование веб-служб, размещенных на веб-серверах для предоставления функций удаленного клиентского приложения. Операции, которые веб-служба предоставляет составляют веб-API.

Клиентские приложения должен быть сможет использовать веб-API, не зная, как реализованы данных или операций, которые предоставляет API. Для этого API придерживается общих стандартов, которые позволяют приложения и веб-служба клиента согласовать какие форматы данных и структуры данных, которыми обмениваются клиентские приложения и веб-службы.

## <a name="introduction-to-representational-state-transfer"></a>Общие сведения о Representational State Transfer

Representational State Transfer (REST) представляет собой архитектурный стиль для построения распределенных систем, в зависимости от гипермедиа. Основное преимущество модели REST является основанная на открытых стандартах и не выполняет привязку реализация модели или клиентских приложений, получающих доступ к любой конкретной реализации. Таким образом веб-служба REST может осуществляться с помощью Microsoft ASP.NET MVC ядра и клиентские приложения могут разработки с помощью любого языка и инструментов, в котором можно создавать HTTP-запросы и проанализировать HTTP-ответов.

Модели REST использует навигационный схему для представления объектов и служб в сети, называемые ресурсами. Системы, которые обычно реализуют REST протокола HTTP позволяет передавать запросы на доступ к этим ресурсам. В таких системах клиентское приложение отправляет запрос в виде URI, который идентифицирует ресурс и метод HTTP (например, GET, POST, PUT или DELETE), указывающее операцию для выполнения на этом ресурсе. Текст HTTP-запрос содержит все данные, необходимые для выполнения операции.

> [!NOTE]
> REST определяет модель данных без сохранения состояния запроса. Таким образом HTTP-запросы должны быть независимыми и могут возникать в любом порядке.

Ответ от ОСТАЛЬНОЙ запрос делает использование стандартные коды состояния HTTP. Например запрос, который возвращает действительные данные должны включать код ответа HTTP 200 (ОК), а запрос, который не удается найти или удалить указанный ресурс должен вернуть ответ, который включает код состояния HTTP 404 (не найдено).

RESTful веб-API предоставляет набор связанных ресурсов, а также основные операции, которые позволяют приложению управлять этими ресурсами и легко перемещаться между ними. По этой причине URI, которые составляют типичные RESTful веб-API, которые направлены в сторону важных данных, которая предоставляет и использовать средства по HTTP для работы с этими данными.

Данные, включенные в клиентском приложении в HTTP-запроса и соответствующие ответные сообщения из веб-сервера может представлены в различных форматах, известные как типы носителей. Когда клиентское приложение отправляет запрос, который возвращает данные в теле сообщения, его можно указать типы носителей, он позволяет обрабатывать `Accept` заголовок запроса. Если веб-сервер поддерживает этот тип носителя, он может в ответ ответ, который включает в себя `Content-Type` заголовок, который задает формат данных в теле сообщения. Он отвечает затем клиентское приложение для синтаксического анализа ответное сообщение и интерпретации результатов в тексте сообщения соответствующим образом.

Дополнительные сведения о REST см. в разделе [структура API](/azure/architecture/best-practices/api-design/) и [реализации API](/azure/architecture/best-practices/api-implementation/).

## <a name="consuming-restful-apis"></a>Использование интерфейсов API RESTful

Мобильное приложение eShopOnContainers использует шаблон Model-View-ViewModel (MVVM) и элементы модели представляет шаблон сущности домена, используемые в приложении. Классы контроллера и репозитория в приложении ссылку eShopOnContainers принимать и возвращать многие из этих объектов модели. Таким образом они используются как объекты передачи данных (DTO), которые содержат все данные, которые передаются между контейнерного микрослужбами и мобильные приложения. Основным преимуществом использования DTO для передачи данных и получения данных из веб-службы является при помощи передачи большего объема данных в рамках одного вызова удаленного, приложение может снизить число удаленных вызовов, которые должны быть выполнены.

### <a name="making-web-requests"></a>Выполнение веб-запросов

Использование мобильного приложения eShopOnContainers `HttpClient` класса для выполнения запросов по протоколу HTTP с JSON, используется в качестве типа носителя. Этот класс предоставляет функциональные возможности для асинхронной отправки HTTP-запросов и получения HTTP-ответов от URI определен ресурс. `HttpResponseMessage` Класс представляет сообщение ответа HTTP, полученных от API-Интерфейс REST, после внесения HTTP-запроса. Он содержит сведения об ответе, включая код состояния, заголовки и любой текст. `HttpContent` Класс представляет основного текста HTTP и заголовки содержимого, такие как `Content-Type` и `Content-Encoding`. Содержимое можно просмотреть с помощью любой из `ReadAs` методы, такие как `ReadAsStringAsync` и `ReadAsByteArrayAsync`, в зависимости от формата данных.

<a name="making_a_get_request" />

#### <a name="making-a-get-request"></a>Запрос GET

`CatalogService` Класс используется для управления процесса извлечения данных из каталога микрослужбы. В `RegisterDependencies` метод в `ViewModelLocator` класса `CatalogService` класс регистрируется как сопоставления типов с `ICatalogService` тип с контейнер внедрения зависимостей Autofac. Затем, когда экземпляр `CatalogViewModel` создается класс, его конструктор принимает `ICatalogService` тип, который разрешается Autofac, возвращение экземпляра `CatalogService` класса. Дополнительные сведения о внедрения зависимостей см. в разделе [введение в внедрения зависимостей](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md#introduction_to_dependency_injection).

Рис. 10-1 отображается взаимодействие классов, которые считывают данные каталога из микрослужбу каталога для отображения `CatalogView`.

[![](accessing-remote-data-images/catalogdata.png "Получение данных из каталога микрослужбу")](accessing-remote-data-images/catalogdata-large.png#lightbox "извлечения данных из каталога микрослужбу")

**Рис. 10-1**: получение данных из каталога микрослужбу

Когда `CatalogView` осуществляется переход, `OnInitialize` метод в `CatalogViewModel` класс называется. Этот метод получает данные каталога из каталога микрослужбу, как показано в следующем примере кода:

```csharp
public override async Task InitializeAsync(object navigationData)  
{  
    ...  
    Products = await _productsService.GetCatalogAsync();  
    ...  
}
```

Этот метод вызывает метод `GetCatalogAsync` метод `CatalogService` экземпляр, который был вставлен в `CatalogViewModel` по Autofac. В следующем примере кода показан `GetCatalogAsync` метод:

```csharp
public async Task<ObservableCollection<CatalogItem>> GetCatalogAsync()  
{  
    UriBuilder builder = new UriBuilder(GlobalSetting.Instance.CatalogEndpoint);  
    builder.Path = "api/v1/catalog/items";  
    string uri = builder.ToString();  

    CatalogRoot catalog = await _requestProvider.GetAsync<CatalogRoot>(uri);  
    ...  
    return catalog?.Data.ToObservableCollection();            
}
```

Этот метод строит URI, который идентифицирует ресурс, запрос будет отправлен и использует `RequestProvider` для вызова метода GET HTTP для ресурса, прежде чем возвратить результаты в `CatalogViewModel`. `RequestProvider` Класс содержит функции, который отправляет запрос в виде URI, который идентифицирует ресурс, метод HTTP, указывающее операцию для выполнения на этом ресурсе и текст, который содержит все данные, необходимые для выполнения операции. Сведения о том, как `RequestProvider` класс вставляется в `CatalogService class`, в разделе [введение в внедрения зависимостей](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md#introduction_to_dependency_injection).

В следующем примере кода показан `GetAsync` метод `RequestProvider` класса:

```csharp
public async Task<TResult> GetAsync<TResult>(string uri, string token = "")  
{  
    HttpClient httpClient = CreateHttpClient(token);  
    HttpResponseMessage response = await httpClient.GetAsync(uri);  

    await HandleResponse(response);  
    string serialized = await response.Content.ReadAsStringAsync();  

    TResult result = await Task.Run(() =>   
        JsonConvert.DeserializeObject<TResult>(serialized, _serializerSettings));  

    return result;  
}
```

Этот метод вызывает метод `CreateHttpClient` метод, возвращающий экземпляр `HttpClient` класс с используемым набором соответствующие заголовки. Затем он отправляет асинхронный запрос GET для ресурса с URI, с сохранением в ответ `HttpResponseMessage` экземпляра. `HandleResponse` Затем вызывается метод, который вызывает исключение, если ответ не содержит успех код состояния HTTP. Ответ читается как строку, преобразованную из JSON, а затем `CatalogRoot` объекта, а также возвращаются `CatalogService`.

`CreateHttpClient` В следующем примере кода показан метод:

```csharp
private HttpClient CreateHttpClient(string token = "")  
{  
    var httpClient = new HttpClient();  
    httpClient.DefaultRequestHeaders.Accept.Add(  
        new MediaTypeWithQualityHeaderValue("application/json"));  

    if (!string.IsNullOrEmpty(token))  
    {  
        httpClient.DefaultRequestHeaders.Authorization =   
            new AuthenticationHeaderValue("Bearer", token);  
    }  
    return httpClient;  
}
```

Этот метод создает новый экземпляр `HttpClient` классу и `Accept` заголовок запросов, выполняемых `HttpClient` экземпляр `application/json`, указывающая, что ожидается, что содержимое сообщения ответа для форматирования с помощью JSON. Затем, если маркер доступа был передан в качестве аргумента для `CreateHttpClient` , он добавляется метод `Authorization` заголовок запросов, выполняемых `HttpClient` экземпляра, префикс строки `Bearer`. Дополнительные сведения об авторизации см. в разделе [авторизации](~/xamarin-forms/enterprise-application-patterns/authentication-and-authorization.md#authorization).

При `GetAsync` метод в `RequestProvider` класса вызывает `HttpClient.GetAsync`, `Items` метод `CatalogController` вызывается класса в проекте Catalog.API, как показано в следующем примере кода:

```csharp
[HttpGet]  
[Route("[action]")]  
public async Task<IActionResult> Items(  
    [FromQuery]int pageSize = 10, [FromQuery]int pageIndex = 0)  
{  
    var totalItems = await _catalogContext.CatalogItems  
        .LongCountAsync();  

    var itemsOnPage = await _catalogContext.CatalogItems  
        .OrderBy(c=>c.Name)  
        .Skip(pageSize * pageIndex)  
        .Take(pageSize)  
        .ToListAsync();  

    itemsOnPage = ComposePicUri(itemsOnPage);  
    var model = new PaginatedItemsViewModel<CatalogItem>(  
        pageIndex, pageSize, totalItems, itemsOnPage);             

    return Ok(model);  
}
```

Этот метод получает данные каталога из базы данных SQL с использованием EntityFramework и возвращает его в качестве ответного сообщения, включающий успех код состояния HTTP и коллекцию JSON в формате `CatalogItem` экземпляров.

#### <a name="making-a-post-request"></a>Отправить запрос POST

`BasketService` Класс используется для управления извлечения данных и процесса обновления с микрослужбу корзины. В `RegisterDependencies` метод в `ViewModelLocator` класса `BasketService` класс регистрируется как сопоставления типов с `IBasketService` тип с контейнер внедрения зависимостей Autofac. Затем, когда экземпляр `BasketViewModel` создается класс, его конструктор принимает `IBasketService` тип, который разрешается Autofac, возвращение экземпляра `BasketService `класса. Дополнительные сведения о внедрения зависимостей см. в разделе [введение в внедрения зависимостей](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md#introduction_to_dependency_injection).

На рис. 10-2 показано взаимодействие классов, отправляющих данные корзины, отображаются с `BasketView`, чтобы микрослужбу корзины.

[![](accessing-remote-data-images/basketdata.png "Отправка данных в корзину микрослужбу")](accessing-remote-data-images/basketdata-large.png#lightbox "отправки данных микрослужбу корзины")

**На рис. 10-2**: отправка данных микрослужбу корзины

При добавлении элемента в корзину `ReCalculateTotalAsync` метод в `BasketViewModel` класс называется. Этот метод обновляет общее число элементов в корзине и отправляет данные корзины микрослужбу корзины, как показано в следующем примере кода:

```csharp
private async Task ReCalculateTotalAsync()  
{  
    ...  
    await _basketService.UpdateBasketAsync(new CustomerBasket  
    {  
        BuyerId = userInfo.UserId,   
        Items = BasketItems.ToList()  
    }, authToken);  
}
```

Этот метод вызывает метод `UpdateBasketAsync` метод `BasketService` экземпляр, который был вставлен в `BasketViewModel` по Autofac. В следующем показан метод `UpdateBasketAsync` метод:

```csharp
public async Task<CustomerBasket> UpdateBasketAsync(CustomerBasket customerBasket, string token)  
{  
    UriBuilder builder = new UriBuilder(GlobalSetting.Instance.BasketEndpoint);  
    string uri = builder.ToString();  
    var result = await _requestProvider.PostAsync(uri, customerBasket, token);  
    return result;  
}
```

Этот метод строит URI, который идентифицирует ресурс, запрос будет отправлен и использует `RequestProvider` для вызова метода POST HTTP для ресурса, перед возвратом результатов для `BasketViewModel`. Обратите внимание, что маркер доступа, полученный из IdentityServer в процессе проверки подлинности, необходимые для авторизации запросов на микрослужбу корзины. Дополнительные сведения об авторизации см. в разделе [авторизации](~/xamarin-forms/enterprise-application-patterns/authentication-and-authorization.md#authorization).

В следующем примере кода показан один из `PostAsync` методы в `RequestProvider` класса:

```csharp
public async Task<TResult> PostAsync<TResult>(  
    string uri, TResult data, string token = "", string header = "")  
{  
    HttpClient httpClient = CreateHttpClient(token);  
    ...  
    var content = new StringContent(JsonConvert.SerializeObject(data));  
    content.Headers.ContentType = new MediaTypeHeaderValue("application/json");  
    HttpResponseMessage response = await httpClient.PostAsync(uri, content);  

    await HandleResponse(response);  
    string serialized = await response.Content.ReadAsStringAsync();  

    TResult result = await Task.Run(() =>  
        JsonConvert.DeserializeObject<TResult>(serialized, _serializerSettings));  

    return result;  
}
```

Этот метод вызывает метод `CreateHttpClient` метод, возвращающий экземпляр `HttpClient` класс с используемым набором соответствующие заголовки. Затем он отправляет асинхронный запрос POST к ресурсу, определяемому URI с данные сериализованного корзины, отправляемых в формате JSON и ответ, хранимых в `HttpResponseMessage` экземпляра. `HandleResponse` Затем вызывается метод, который вызывает исключение, если ответ не содержит успех код состояния HTTP. После этого ответа читается как строку, преобразованную в формат JSON для `CustomerBasket` объекта, а также возвращаются `BasketService`. Дополнительные сведения о `CreateHttpClient` метода, в разделе [внесения получить запрос на](#making_a_get_request).

При `PostAsync` метод в `RequestProvider` класса вызывает `HttpClient.PostAsync`, `Post` метод `BasketController` вызывается класса в проекте Basket.API, как показано в следующем примере кода:

```csharp
[HttpPost]  
public async Task<IActionResult> Post([FromBody]CustomerBasket value)  
{  
    var basket = await _repository.UpdateBasketAsync(value);  
    return Ok(basket);  
}
```

Этот метод использует экземпляр `RedisBasketRepository` класса для сохранения данных в кэш Redis корзины и возвращает его, отформатированное сообщение ответа, включающий успех код состояния HTTP и JSON `CustomerBasket` экземпляра.

#### <a name="making-a-delete-request"></a>Запрос DELETE

На рис. 10-3 показывает взаимодействия, классов, которые удаления устаревших данных из микрослужбу корзины, корзины `CheckoutView`.

![](accessing-remote-data-images/checkoutdata.png "Удалении данных из микрослужбу корзины")

**На рис. 10-3**: удаление данных из микрослужбу корзины

При вызове извлечение `CheckoutAsync` метод в `CheckoutViewModel` класс называется. Этот метод создает новый заказ, перед очисткой корзины покупок, как показано в следующем примере кода:

```csharp
private async Task CheckoutAsync()  
{  
    ...  
    await _basketService.ClearBasketAsync(_shippingAddress.Id.ToString(), authToken);  
    ...  
}
```

Этот метод вызывает метод `ClearBasketAsync` метод `BasketService` экземпляр, который был вставлен в `CheckoutViewModel` по Autofac. В следующем показан метод `ClearBasketAsync` метод:

```csharp
public async Task ClearBasketAsync(string guidUser, string token)  
{  
    UriBuilder builder = new UriBuilder(GlobalSetting.Instance.BasketEndpoint);  
    builder.Path = guidUser;  
    string uri = builder.ToString();  
    await _requestProvider.DeleteAsync(uri, token);  
}
```

Этот метод строит URI, который идентифицирует ресурс, запрос будет отправлен и использует `RequestProvider` для вызова метода DELETE HTTP с ресурсом. Обратите внимание, что маркер доступа, полученный из IdentityServer в процессе проверки подлинности, необходимые для авторизации запросов на микрослужбу корзины. Дополнительные сведения об авторизации см. в разделе [авторизации](~/xamarin-forms/enterprise-application-patterns/authentication-and-authorization.md#authorization).

В следующем примере кода показан `DeleteAsync` метод `RequestProvider` класса:

```csharp
public async Task DeleteAsync(string uri, string token = "")  
{  
    HttpClient httpClient = CreateHttpClient(token);  
    await httpClient.DeleteAsync(uri);  
}
```

Этот метод вызывает метод `CreateHttpClient` метод, возвращающий экземпляр `HttpClient` класс с используемым набором соответствующие заголовки. Затем он отправляет асинхронный запрос DELETE к ресурсу, определяемому URI. Дополнительные сведения о `CreateHttpClient` метода, в разделе [внесения получить запрос на](#making_a_get_request).

При `DeleteAsync` метод в `RequestProvider` класса вызывает `HttpClient.DeleteAsync`, `Delete` метод `BasketController` вызывается класса в проекте Basket.API, как показано в следующем примере кода:

```csharp
[HttpDelete("{id}")]  
public void Delete(string id)  
{  
    _repository.DeleteBasketAsync(id);  
}
```

Этот метод использует экземпляр `RedisBasketRepository` класса для удаления данных корзины из кэша Redis.

## <a name="caching-data"></a>Кэширование данных

Можно повысить производительность приложения путем кэширования часто используемых данных, чтобы Быстродействующее устройство хранения, размещенную закрыть приложение. Если Быстродействующее устройство хранения расположен ближе к приложению, чем исходный, то кэширование может значительно повысить ответа раз при получении данных.

Наиболее распространенная форма кэширования — сквозного кэширования, где приложение получает данные с помощью ссылки на кэш. Если данные не в кэше, извлекаются из хранилища данных и добавления в кэш. Приложения могут реализовывать сквозного кэширование с шаблоном отдельно от кэша. Этот шаблон определяет, является ли элемент в данный момент в кэше. Если элемент отсутствует в кэше, чтения из хранилища данных и добавления в кэш. Дополнительные сведения см. в разделе [отдельно от кэша](/azure/architecture/patterns/cache-aside/) шаблон.

> [!TIP]
> Данные, считываемые часто и редко изменяются, кэша. Эти данные могут добавляться в кэш по требованию впервые, он извлекается приложением. Это означает, что приложению для выборки данных только один раз в хранилище данных и что последующий доступ к нему можно удовлетворить из кэша.

Распределенные приложения, такие как eShopOnContainers обращение к приложению, должны предоставить один или оба следующих кэши:

-   Общий кэш, который может осуществляться несколькими процессами или машины.
-   Закрытый кэша, где данных хранится локально на устройстве под управлением приложения.

Мобильное приложение eShopOnContainers использует закрытый кэш, где данных хранится локально на устройстве, на котором выполняется экземпляр приложения. Сведения о кэше, используемые приложением eShopOnContainers ссылку в разделе [Микрослужбами .NET: архитектура контейнерных приложений .NET](https://aka.ms/microservicesebook).

> [!TIP]
> Кэш можно представить как хранилище временных данных, будет исчезать в любое время. Убедитесь, что данные хранятся в хранилище исходных данных, а также в кэше. Затем к минимуму вероятность потери данных, если кэш становится недоступным.

### <a name="managing-data-expiration"></a>Управление истечение срока действия

Нецелесообразно ожидать, что кэшированные данные всегда будут согласованы с исходными данными. Данные в хранилище исходных данных может измениться после он был кэширован, вызывает кэшированных данных будут просрочены. Таким образом приложения следует реализовать стратегию, которая позволяет гарантировать, что данные в кэше с актуальными, но также определяет и обработки ситуаций, возникающих при данные в кэше устарела. Наиболее кэширования Включение кэша должно быть настроено на срок действия данных и таким образом уменьшить период, для которого данные могут быть устаревшими.

> [!TIP]
> Значение по умолчанию время при настройке кэша. Многие кэши реализовать истечения срока действия, который делает недействительными данные и удаляет его из кэша, если он не осуществляется за указанный период. Тем не менее необходимо соблюдать осторожность при выборе срока действия. Если он слишком короткий, данных истекает слишком быстро и будет уменьшена преимущества кэширования. Если он становится слишком длинное устаревшими риски данных. Таким образом время истечения срока действия должна соответствовать шаблону доступа для приложений, использующих данные.

После истечения срока действия кэшированных данных, ее нужно удалить из кэша и приложение должно получать данные из исходных данных, хранения и поместите его обратно в кэш.

Также возможно, что кэш может заполнить Если данных может оставаться слишком долго. Таким образом, запросы на добавление новых элементов в кэш может потребоваться удалить некоторые элементы в процессе, называемом *вытеснения*. Обычно службы кэширования исключите данные на основе наименее недавно использовавшихся. Однако существуют другие политики вытеснения, включая недавно использованных и первым пришел первым вышел. Дополнительные сведения см. в разделе [кэширование руководство](/azure/architecture/best-practices/caching/).

<a name="caching_images" />

### <a name="caching-images"></a>Кэширование изображений

Мобильное приложение eShopOnContainers потребляет изображения удаленных продуктов, которые получают преимущества от кэширования. Эти изображения отображаются по [ `Image` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Image/) управления и `CachedImage` управления, предоставляемые [FFImageLoading](https://www.nuget.org/packages/Xamarin.FFImageLoading.Forms/) библиотеки.

Xamarin.Forms [ `Image` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Image/) элемент управления поддерживает кэширование загруженных образов. Кэширование включено по умолчанию и сохраняется локально на 24 часа. Кроме того, можно настроить время истечения срока действия [ `CacheValidity` ](https://developer.xamarin.com/api/property/Xamarin.Forms.UriImageSource.CacheValidity/) свойство. Дополнительные сведения см. в разделе [загрузить образ кэширование](~/xamarin-forms/user-interface/images.md#Image_Caching).

В FFImageLoading `CachedImage` управления — это замена для Xamarin.Forms [ `Image` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Image/) управления, предоставляя дополнительные свойства, включения дополнительных функциональных возможностей. Среди этих функциональных возможностей управления предоставляет, можно настроить кэширование, при поддержке ошибки и загрузки изображения-заполнители. В следующем примере кода показано, как eShopOnContainers мобильное приложение использует `CachedImage` управления в `ProductTemplate`, который является шаблон данных, используемые [ `ListView` ](https://developer.xamarin.com/api/type/Xamarin.Forms.ListView/) управления в `CatalogView`:

```xaml
<ffimageloading:CachedImage
    Grid.Row="0"
    Source="{Binding PictureUri}"     
    Aspect="AspectFill">
    <ffimageloading:CachedImage.LoadingPlaceholder>
        <OnPlatform x:TypeArguments="ImageSource">
            <On Platform="iOS, Android" Value="default_campaign" />
            <On Platform="UWP" Value="Assets/default_campaign.png" />
        </OnPlatform>
    </ffimageloading:CachedImage.LoadingPlaceholder>
    <ffimageloading:CachedImage.ErrorPlaceholder>
        <OnPlatform x:TypeArguments="ImageSource">
            <On Platform="iOS, Android" Value="noimage" />
            <On Platform="UWP" Value="Assets/noimage.png" />
        </OnPlatform>
    </ffimageloading:CachedImage.ErrorPlaceholder>
</ffimageloading:CachedImage>
```

`CachedImage` Задает `LoadingPlaceholder` и `ErrorPlaceholder` свойства для образов платформ. `LoadingPlaceholder` Свойство задает изображение, отображаемое при изображение, указанное свойством `Source` извлекается свойство и `ErrorPlaceholder` свойство задает изображение, отображаемое в том случае, если произошла ошибка при попытке получения изображения заданные `Source` свойство.

Как следует из имен, `CachedImage` управления кэширует удаленного изображения на устройстве в течение времени, заданного параметром значения `CacheDuration` свойство. Если значение этого свойства не задано явно, применяется значение по умолчанию 30 дней.

## <a name="increasing-resilience"></a>Повышение устойчивости

Все приложения, которые взаимодействуют с удаленной службы и ресурсы должно быть от временных сбоев. Временные сбои являются небольшой потере сетевого подключения к службам, Временная недоступность службы или временем ожидания, возникают, когда служба занята. Эти ошибки часто являются самоустраняющимися, и если действие повторяется после подходящий задержки, вероятно, для успешного выполнения.

Временные сбои может иметь значительного влияния на предполагаемых качество приложения, даже если он тщательно протестирован ни при каких обстоятельствах ожидаемых. Для обеспечения надежной работает приложение, которое взаимодействует со службами удаленных должен уметь выполнять любые из следующих:

-   Обнаружить ошибки при их выполнения и определить, если сообщения об ошибках могут быть временной.
-   Повторите операцию, если он определяет, что ошибки скорее всего, носить временный характер и отслеживать количество повторных попыток операция.
-   Используйте подходящую стратегию повторных попыток, который указывает количество повторных попыток, задержка между попытками, а также действиях, выполняемых после неудачной попытки.

Эта обработка временных сбоев может осуществляться путем заключения всех попыток доступа к удаленной службе в код, который реализует шаблон "Повторить".

### <a name="retry-pattern"></a>Повторите шаблон

Приложение обнаруживает сбой при попытке отправить запрос к удаленной службе, возможность обработки ошибки в любом из следующих способов:

-   Повторите операцию. Приложение может немедленно повторять запрос сбоя.
-   Повторите операцию через некоторое время. Приложения следует подождать подходящий объем времени перед повторным выполнением запроса.
-   Если отменить операцию. Приложение должно отменить операцию и сообщения об исключении.

Стратегия повторов должен быть настроен так, в соответствии с требованиями бизнеса приложения. Например очень важно для оптимизации число повторных попыток и интервал, чтобы данная операция повтора. Если операция является частью взаимодействия с пользователем, интервал повторных попыток следует short и только несколько попыток Чтобы избежать создания пользователей ожидать ответа. Если операция является частью долго выполняющегося рабочего процесса, где Отмена и перезапуск рабочего процесса или слишком много времени, необходимые для увеличения времени ожидания между попытками и повторить еще раз.

> [!NOTE]
> Стратегии Агрессивный Повтор с минимальной задержкой между попытками и большое количество повторных попыток, может привести к снижению удаленной службы, на котором выполняется, закрыть или с нагрузкой. Кроме того стратегия повторов может также повлиять на скорость реагирования приложения Если постоянно попытка выполнить операцию сбоя.

Если запрос по-прежнему не работает после нескольких повторных попыток, рекомендуется для приложений для предотвращения дальнейших запросов, перейдя к тому же ресурсу и сообщает об ошибке. Затем после определенного периода, приложение может сделать один или несколько запросов к ресурсу для просмотра, если они успешно. Дополнительные сведения см. в разделе [шаблон Размыкатель цепи](#circuit_breaker_pattern).

> [!TIP]
> Никогда не реализуют механизм неограниченное число повторных попыток. Использовать ограниченное число повторных попыток, либо реализовать [Размыкатель цепи](/azure/architecture/patterns/circuit-breaker/) шаблон, чтобы разрешить службе для восстановления.

EShopOnContainers мобильного приложения в настоящее время не реализует шаблон повторения попытки при обеспечении RESTful веб-запросов. Тем не менее `CachedImage` управления, предоставляемые [FFImageLoading](https://www.nuget.org/packages/Xamarin.FFImageLoading.Forms/) библиотека поддерживает обработки временных сбоев, повторив образа загрузки. Если происходит сбой загрузки изображения, дальнейшие попытки выполняться. Число попыток определяется `RetryCount` свойство и повторных попыток будет выполняться после задержки, заданной `RetryDelay` свойство. Если значения этих свойств не задано явным образом, значения по умолчанию применяются значения – 3 для `RetryCount` свойство и 250 секунд для `RetryDelay` свойства. Дополнительные сведения о `CachedImage` управления см. в разделе [кэширования изображений](#caching_images).

Ссылка приложения eShopOnContainers реализовывать шаблон "Повторить". Дополнительные сведения, включая описание способов объединения шаблон повторения попытки с `HttpClient` см. в описании [Микрослужбами .NET: архитектура контейнерных приложений .NET](https://aka.ms/microservicesebook).

Дополнительные сведения о шаблоне повтора см. в разделе [повторите](/azure/architecture/patterns/retry/) шаблон.

<a name="circuit_breaker_pattern" />

### <a name="circuit-breaker-pattern"></a>Шаблон Размыкатель цепи

В некоторых случаях ошибок может произойти из-за ожидаемых событий, которые занимают больше исправить. Эти ошибки находится в диапазоне от частичная потеря подключения до завершения сбоя службы. В таких ситуациях не имеет смысла, если для приложения и повторите операцию, скорее всего, завершатся успешно и вместо этого следует принять сбой операции и соответствующим образом обрабатывать этот сбой.

Шаблон Размыкатель цепи можно предотвратить приложения несколько раз при попытке выполнить операцию, которая может привести к отказу в то же время приложение, чтобы определить, устранена ли ошибка.

> [!NOTE]
> Назначение шаблона размыкателя цепи отличается от шаблон повторения попытки. Шаблон повторения попытки позволяет приложению, повторите операцию в предположении, что она будет выполнена успешно. Шаблон Размыкатель цепи не позволяет приложению выполнять операцию, которая может привести к отказу.

Размыкатель цепи действует как прокси для операций, которые может завершиться ошибкой. Прокси-сервер должен отслеживать количество последние ошибки, произошедшие и использовать эту информацию, чтобы решить, следует ли разрешить операцию для продолжения или немедленно возвращать исключения.

В настоящее время eShopOnContainers мобильное приложение не реализует шаблон Размыкатель цепи. Однако eShopOnContainers выполняет. Дополнительные сведения см. в разделе [Микрослужбами .NET: архитектура контейнерных приложений .NET](https://aka.ms/microservicesebook).

> [!TIP]
> Объединять шаблоны повторных попыток и Размыкатель цепи. Приложение можно объединять шаблоны повторных попыток и Размыкатель цепи, используя шаблон повторения попытки вызвать операцию с использованием Размыкатель цепи. Тем не менее логика повторных попыток следует зависит от любые исключения, возвращенных Размыкатель цепи и отказаться от повторных попыток, если Размыкатель цепи указывает, что ошибка не является временной.

Дополнительные сведения о шаблоне Размыкатель цепи см. в разделе [Размыкатель цепи](/azure/architecture/patterns/circuit-breaker/) шаблон.

## <a name="summary"></a>Сводка

Многие современные решения веб-сделать использование веб-служб, размещенных на веб-серверах для предоставления функций удаленного клиентского приложения. Операции, которые веб-служба предоставляет составляют веб-API и клиентские приложения должны иметь возможность использовать веб-API, не зная, как реализованы данных или операций, которые предоставляет API.

Можно повысить производительность приложения путем кэширования часто используемых данных, чтобы Быстродействующее устройство хранения, размещенную закрыть приложение. Приложения могут реализовывать сквозного кэширование с шаблоном отдельно от кэша. Этот шаблон определяет, является ли элемент в данный момент в кэше. Если элемент отсутствует в кэше, чтения из хранилища данных и добавления в кэш.

При обмене данными с веб-API, приложения должны иметь чувствительна к временные сбои. Временные сбои являются небольшой потере сетевого подключения к службам, Временная недоступность службы или временем ожидания, возникают, когда служба занята. Эти ошибки часто являются самоустраняющимися, и если действие повторяется после подходящий задержки, то это скорее всего, для успешного выполнения. Таким образом приложений должно быть перенесено, все попытки доступа к веб-API в код, который реализует временных сбоев, механизм обработки.


## <a name="related-links"></a>Связанные ссылки

- [Загрузить электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
