---
title: "Внедрение зависимостей"
ms.topic: article
ms.prod: xamarin
ms.assetid: a150f2d1-06f8-4aed-ab4e-7a847d69f103
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 538bb3f67a0612a93b8c3eb7f9de557ad6f321e3
ms.sourcegitcommit: 61f5ecc5a2b5dcfbefdef91664d7460c0ee2f357
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2018
---
# <a name="dependency-injection"></a>Внедрение зависимостей

Как правило конструктор класса вызывается при создании экземпляра объекта и любые значения, которые требуется объект передаются как аргументы в конструктор. Это является примером внедрения зависимостей и в частности называется *внедрение конструктора*. Зависимости, необходимые объект добавляются в конструктор.

Указание зависимостей как типы интерфейса, внедрения зависимости позволяет отделить конкретные типы из кода, который зависит от этих типов. Как правило, она использует контейнер, который содержит список регистраций и сопоставления между интерфейсы и абстрактные типы и конкретные типы, которые реализуют или расширяют эти типы.

Существуют также другие типы внедрения зависимости, такие как *внедрение метод задания свойства*, и *путем внедрения кода вызова метода*, но наименее часто они отображаются. Таким образом в этой главе будут сосредоточиться исключительно на выполнение внедрение конструктора с контейнер внедрения зависимостей.

<a name="introduction_to_dependency_injection" />

## <a name="introduction-to-dependency-injection"></a>Общие сведения о внедрения зависимости

Внедрение зависимостей находится специализированную версию шаблона инверсии управления (IoC) инвертированный заботиться процесс получения необходимой зависимости. С помощью внедрения зависимости другой класс отвечает за внедрение зависимостей в объект во время выполнения. В следующем примере кода показан способ `ProfileViewModel` класс структурирован, когда с помощью внедрения зависимости:

```csharp
public class ProfileViewModel : ViewModelBase  
{  
    private IOrderService _orderService;  

    public ProfileViewModel(IOrderService orderService)  
    {  
        _orderService = orderService;  
    }  
    ...  
}
```

`ProfileViewModel` Конструктор получает `IOrderService` экземпляр в качестве аргумента, введенный в другом классе. Зависимость только в `ProfileViewModel` класс является типом интерфейса. Таким образом `ProfileViewModel` класс не имеет каких-либо знаний класса, который отвечает за создание экземпляров `IOrderService` объекта. Класс, который отвечает за создание экземпляров `IOrderService` объекта и их вставка в `ProfileViewModel` класса, называется *контейнер внедрения зависимостей*.

Контейнеры для введения зависимостей уменьшить взаимозависимости между объектами, предоставляя возможность создания экземпляров класса и управлять их время существования, на основе конфигурации контейнера. При создании объектов контейнера внедряет все зависимости, необходимые для объекта в его. Если эти зависимости не был создан, контейнер создает и разрешает их зависимости сначала.

> [!NOTE]
> Внедрение зависимостей может также быть реализован вручную с помощью фабрик. Однако с помощью контейнера обеспечивает дополнительные возможности, такие как управление жизненным циклом и регистрации сборок сканирования.

Существует несколько преимуществ использования контейнер внедрения зависимостей.

-   Контейнер избавляет от необходимости для класса найти его зависимости и управление временем существования.
-   Контейнер позволяет сопоставление реализованный зависимостей без влияния на класс.
-   Контейнер реализует возможности тестирования, позволяя зависимости макетирование.
-   Контейнер повышает удобство поддержки, позволяя новые классы для легко добавить в приложение.

В контексте приложения Xamarin.Forms, которое использует MVVM контейнер внедрения зависимостей обычно будет использоваться, для регистрации и разрешения на просмотр моделей, а также для регистрации служб и добавление их в модели представления.

Существует много контейнеров внедрения зависимостей, с мобильным приложением eShopOnContainers, с помощью Autofac для управления при создании экземпляра представления модели и классы в приложении службы. Autofac облегчает построение слабо связанных приложений, а также предоставляет все возможности, которые часто встречаются в контейнеров внедрения зависимостей, включая методы для регистрации сопоставления типов и экземпляров объектов, определяет объекты, управлять временем жизни объектов и вставки зависимые объекты в конструкторы объектов, которые разрешается. Дополнительные сведения о Autofac см. в разделе [Autofac](http://autofac.readthedocs.io/en/latest/index.html) на readthedocs.io.

В Autofac `IContainer` интерфейс предоставляет контейнер внедрения зависимостей. Рисунок 3-1 показаны зависимости при использовании этого контейнера, который создает экземпляр `IOrderService` объекта и вставляет его в `ProfileViewModel` класса.

![](dependency-injection-images/dependencyinjection.png "Например зависимостей, когда с помощью внедрения зависимости")

**Рисунок 3-1:** зависимостями, когда с помощью внедрения зависимости

Во время выполнения, контейнер необходимо знать, какая реализация `IOrderService` следует создать, прежде чем он может создать экземпляр интерфейса `ProfileViewModel` объекта. Включает в себя:

-   Контейнер, для того создать экземпляр объекта, который реализует `IOrderService` интерфейса. Это называется *регистрации*.
-   При создании экземпляра объекта, который реализует контейнера `IOrderService` интерфейс и `ProfileViewModel` объекта. Это называется *разрешение*.

В конечном счете, приложение будет готово с помощью `ProfileViewModel` объект и он станет доступным для сборки мусора. На этом этапе следует освободить сборщик мусора `IOrderService` экземпляра, если только другие классы не используйте тот же экземпляр.

> [!TIP]
> Напишите код, зависящий от контейнера. Всегда пытаться написать код, зависящий от контейнера для отделения приложения из зависимости на уровне контейнера, используемый.

## <a name="registration"></a>Регистрация

Прежде зависимости могут быть добавлены в объект, типы зависимостей, сначала должно быть зарегистрировано с контейнером. При регистрации типа обычно состоит из передачи контейнера интерфейс и конкретный тип, реализующий интерфейс.

Существует два способа регистрации типов и объектов в контейнере с использованием кода:

-   Зарегистрируйте тип или сопоставление с контейнером. При необходимости, контейнер будет построена экземпляр заданного типа.
-   Существующий объект в контейнере можно зарегистрируйте как Singleton-класс. При необходимости, возвращает ссылку на существующий объект контейнера.

> [!TIP]
> Контейнеры для введения зависимостей не всегда подходит. Внедрение зависимостей представлены дополнительные сложности и требования, которые могут быть не соответствующие или полезны для небольших приложений. Если класс не поддерживает все зависимости, или не зависимость для других типов, он не может быть целесообразно поместить его в контейнере. Кроме того Если у класса имеется один набор зависимостей, которые являются неотъемлемой частью типа и не изменится, он не может быть целесообразно поместить его в контейнере.

Регистрация типы, требующие внедрения зависимостей должна выполняться в одном методе в приложении, и этот метод должен вызываться ранних этапах жизненного цикла приложения, чтобы убедитесь, что приложение знать о зависимостях между его классы. В мобильном приложении eShopOnContainers это выполняется путем `ViewModelLocator` класса, какие сборки `IContainer` объекта и является единственным классом, в приложении, которое содержит ссылку на этот объект. В следующем примере кода показано, как объявляет мобильного приложения eShopOnContainers `IContainer` объекта в `ViewModelLocator` класса:

```csharp
private static IContainer _container;
```

Зарегистрированные типы и экземпляры в `RegisterDependencies` метод `ViewModelLocator` класса. Это достигается путем первоначального создания `ContainerBuilder` экземпляра, как показано в следующем примере кода:

```csharp
var builder = new ContainerBuilder();
```

Типы и экземпляры затем регистрируется `ContainerBuilder` объекта, а также в следующем примере кода показано наиболее распространенная форма регистрации типа:

```csharp
builder.RegisterType<RequestProvider>().As<IRequestProvider>();
```

`RegisterType` Метод, показанный здесь сопоставляет конкретный тип является типом интерфейса. Он указывает контейнеру для создания экземпляра `RequestProvider` объекта, когда он создает объект, который требуется Вставка `IRequestProvider` через конструктор.

Конкретные типы также могут быть зарегистрированы непосредственно, без сопоставления из типа интерфейса, как показано в следующем примере кода:

```csharp
builder.RegisterType<ProfileViewModel>();
```

Когда `ProfileViewModel` тип разрешена, контейнер будет ввести его необходимые зависимости.

Autofac позволяет регистрация экземпляра, где контейнера отвечает за ведение ссылку на одноэлементный экземпляр типа. Например, в следующем примере кода показано, как eShopOnContainers мобильное приложение регистрирует конкретного типа для использования при `ProfileViewModel` экземпляр должен иметь `IOrderService` экземпляр:

```csharp
builder.RegisterType<OrderService>().As<IOrderService>().SingleInstance();
```

`RegisterType` Метод, показанный здесь сопоставляет конкретный тип является типом интерфейса. `SingleInstance` Метод настраивает регистрацию таким образом, чтобы один и тот же общий экземпляр получает всех зависимых объектов. Таким образом только один `OrderService` экземпляр будет существовать в контейнере, который является общим для объектов, которые требуют введения `IOrderService` через конструктор.

Регистрация экземпляра можно также выполнить с `RegisterInstance` метода, как показано в следующем примере кода:

```csharp
builder.RegisterInstance(new OrderMockService()).As<IOrderService>();
```

`RegisterInstance` Создает новый метод, показанный здесь `OrderMockService` экземпляра и регистрирует его с контейнером. Таким образом только один `OrderMockService` экземпляр существует в контейнере, который является общим для объектов, которые требуют введения `IOrderService` через конструктор.

После регистрации тип и экземпляр, `IContainer` объекта должны быть построены, что показано в следующем примере кода:

```csharp
_container = builder.Build();
```

Вызов `Build` метод `ContainerBuilder` экземпляр создает новый контейнер внедрения зависимостей, который содержит список регистраций, которые были внесены.

>💡 **Совет**: рассмотрите возможность `IContainer` как неизменяемый. Хотя Autofac обеспечивает `Update` метод для обновления регистрации в существующий контейнер, вызов этого метода следует по возможности избегать. Существуют угрозы изменения контейнер после был построен, особенно в том случае, если контейнер используется. Дополнительные сведения см. в разделе [рассмотрим контейнера как неизменяемого](http://docs.autofac.org/en/latest/best-practices/#consider-a-container-as-immutable) на readthedocs.io.

<a name="resolution" />

## <a name="resolution"></a>Решение

После регистрации типа его можно разрешить или добавить как зависимость. Если разрешается типа контейнера должен создать новый экземпляр, он вставляет все зависимости в экземпляр.

Как правило когда разрешен тип, одно из трех происходит:

1.  Если тип не был зарегистрирован, контейнер вызывает исключение.
1.  Если тип был зарегистрирован как Singleton-класс, контейнер возвращает одноэлементный экземпляр. Если при первом запуске типа вызывается для контейнер его при необходимости создает и обслуживает ссылки на него.
1.  Если тип не был зарегистрирован как Singleton-класс, контейнер возвращает новый экземпляр и не поддерживает ссылки на него.

В следующем примере кода показан способ `RequestProvider` тип, который был зарегистрирован с Autofac можно разрешить:

```csharp
var requestProvider = _container.Resolve<IRequestProvider>();
```

В этом примере запрашивается Autofac для конкретного типа для разрешения `IRequestProvider` типа, а также любые зависимости. Как правило `Resolve` метод вызывается, когда требуется экземпляр определенного типа. Сведения о управление временем существования объектов разрешенных разделе [управления временем жизни объекта разрешить объектами](#managing_the_lifetime_of_resolved_objects).

В следующем примере кода показано, как eShopOnContainers мобильное приложение создает экземпляр модели Просмотр типов и их зависимости.

```csharp
var viewModel = _container.Resolve(viewModelType);
```

В этом примере Autofac будет предложено разрешить тип представления модели для модели требуемого представления и контейнер будет также разрешить все зависимости. При разрешении `ProfileViewModel` — зависимостей для разрешения типа `IOrderService` объекта. Таким образом, сначала создает Autofac `OrderService` объекта, а затем передает его в конструктор `ProfileViewModel` класса. Дополнительные сведения о как eShopOnContainers мобильное приложение создает представление модели и связывает их с представлениями, см. в разделе [автоматическое создание модели представления с локатора модели представления](~/xamarin-forms/enterprise-application-patterns/mvvm.md#automatically_creating_a_view_model_with_a_view_model_locator).

> [!NOTE]
> Регистрация и разрешение типов с контейнером влияет на производительность из-за контейнера использование отражения для создания каждого типа, особенно в том случае, если зависимости воссоздаются для каждого навигацию по страницам в приложении. Если имеется много или глубокой зависимости, затраты на создание может значительно возрасти.

<a name="managing_the_lifetime_of_resolved_objects" />

## <a name="managing-the-lifetime-of-resolved-objects"></a>Управление временем существования объектов, разрешения

После регистрации типа, поведение по умолчанию для Autofac — для создания нового экземпляра зарегистрированного типа каждый раз типа разрешается или когда механизм зависимостей внедряет экземпляров в другие классы. В этом случае контейнер не содержит ссылку на объект разрешения. Тем не менее при регистрации экземпляра, поведение по умолчанию для Autofac является управление временем существования объекта как Singleton-класс. Таким образом экземпляр остается в области находится в области контейнера, а также удаляется, когда контейнер выходит за пределы области и обрабатывается сборщиком мусора или код явно удаляет контейнер.

В области экземпляра Autofac можно использовать для указания поведения singleton для объекта, который создает Autofac из зарегистрированного типа. Autofac экземпляр областей управление временем жизни объектов, создавать экземпляры контейнером. Область экземпляра по умолчанию для `RegisterType` метод `InstancePerDependency` области. Тем не менее `SingleInstance` область может использоваться с `RegisterType` метода, чтобы контейнер создает или возвращает одноэлементный экземпляр типа, при вызове `Resolve` метода. В следующем примере кода показано, как Autofac предлагается создать одноэлементный экземпляр `NavigationService` класса:

```csharp
builder.RegisterType<NavigationService>().As<INavigationService>().SingleInstance();
```

При первой `INavigationService` интерфейс разрешена, создает новый контейнер `NavigationService` объекта и сохраняет ссылку на него. На все последующие разрешение `INavigationService` интерфейс, контейнер возвращает ссылку на `NavigationService` объект, который был создан ранее.

> [!NOTE]
> Область SingleInstance удаляет созданные объекты при удалении контейнера.

Autofac включает дополнительный экземпляр области. Дополнительные сведения см. в разделе [область экземпляра](http://autofac.readthedocs.io/en/latest/lifetime/instance-scope.html) на readthedocs.io.

## <a name="summary"></a>Сводка

Внедрение зависимостей позволяет отделить конкретные типы из кода, который зависит от этих типов. Обычно он использует контейнер, который содержит список регистраций и сопоставления между интерфейсы и абстрактные типы и конкретные типы, которые реализуют или расширяют эти типы.

Autofac облегчает построение слабо связанных приложений, а также предоставляет все возможности, которые часто встречаются в контейнеров внедрения зависимостей, включая методы для регистрации сопоставления типов и экземпляров объектов, определяет объекты, управлять временем жизни объектов и вставки зависимые объекты в конструкторы объектов, которые разрешается.


## <a name="related-links"></a>Связанные ссылки

- [Загрузить электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
