---
title: Внедрение зависимостей
description: В этой главе объясняется, как мобильное приложение eShopOnContainers использует внедрение зависимостей для отделения конкретные типы из кода, который зависит от этих типов.
ms.prod: xamarin
ms.assetid: a150f2d1-06f8-4aed-ab4e-7a847d69f103
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: fb225349b9ffb1c950486a817897b3c26c6ffbe4
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61300276"
---
# <a name="dependency-injection"></a>Внедрение зависимостей

Как правило вызывается конструктор класса, при создании экземпляра объекта, и все значения, необходимые для объекта передаются как аргументы в конструктор. Это может служить примером внедрения зависимостей и в частности называется *внедрение через конструктор*. Зависимости, необходимые на объекте добавляются в конструктор.

Указав зависимости как типы интерфейса, внедрение зависимостей обеспечивает разделение конкретные типы из кода, который зависит от этих типов. Обычно в нем контейнер, который содержит список регистраций и сопоставления между интерфейсы и абстрактные типы и конкретные типы, которые реализуют или расширяют эти типы.

Существуют также другие типы внедрения зависимостей, таких как *путем внедрения кода метода задания свойства*, и *путем внедрения кода вызов метода*, но они видны редко. Таким образом в этой главе основное внимание уделяется исключительно выполнения внедрение конструктора с помощью контейнера внедрения зависимостей.

<a name="introduction_to_dependency_injection" />

## <a name="introduction-to-dependency-injection"></a>Общие сведения о внедрения зависимостей

Внедрение зависимостей является специальной версией шаблона Inversion of Control (IoC), где есть опасение Инвертированная — это процесс получения необходимую зависимость. С помощью внедрения зависимостей другой класс отвечает за внедрение зависимостей в объект во время выполнения. В следующем примере кода показано как `ProfileViewModel` класс структурирован, при использовании внедрения зависимостей:

```csharp
public class ProfileViewModel : ViewModelBase  
{  
    private IOrderService _orderService;  

    public ProfileViewModel(IOrderService orderService)  
    {  
        _orderService = orderService;  
    }  
    ...  
}
```

`ProfileViewModel` Конструктор получает `IOrderService` экземпляр в качестве аргумента, внедрены в другом классе. Единственная зависимость в `ProfileViewModel` класс находится в типе интерфейса. Таким образом `ProfileViewModel` класс не имеет каких-либо знаний класса, который отвечает за создание экземпляра `IOrderService` объекта. Класс, который отвечает за создание экземпляра `IOrderService` объекта и вставить эти данные в `ProfileViewModel` класса, называется *контейнера внедрения зависимостей*.

Контейнеры для введения зависимостей уменьшить взаимозависимость между объектами, предоставляя средства для создания экземпляров класса и управления временем их существования, в зависимости от конфигурации контейнера. Во время создания объекта контейнера внедряет все зависимости, требуемые для объекта требуется в нее. Если эти зависимости не был создан, создает контейнер и сначала устраняет их зависимости.

> [!NOTE]
> Внедрение зависимостей может также быть реализован вручную с помощью фабрик. Тем не менее используя контейнер предоставляет дополнительные возможности, такие как управление временем существования и регистрации сборки сканирования.

Существует несколько преимуществ в использовании контейнера внедрения зависимостей.

-   Контейнер избавляет от необходимости для класса найти его зависимости и управлять временем их существования.
-   Контейнер позволяет сопоставление зависимостей, реализованных без влияния на класс.
-   Контейнер реализует возможности тестирования, позволяя зависимости макетирование.
-   Контейнер повышает удобство поддержки, позволяя новые классы, позволяющие легко добавить в приложение.

В контексте приложения Xamarin.Forms, которое использует шаблон MVVM контейнер внедрения зависимостей будет обычно использоваться для регистрации и разрешения на просмотр моделей, а также для регистрации служб и вставляя их в модели представления.

Доступно множество контейнеры для введения зависимостей, используя мобильное приложение eShopOnContainers использует Autofac для управления созданием экземпляров модели представления и классы в приложении службы. Autofac вспомогательного при создании слабо связанных приложений и предоставляет все функции, которые часто встречаются в контейнеры для введения зависимостей, включая методы для регистрации сопоставления типов и экземпляров объектов, разрешения объектов, управление временем существования объектов и внедрить зависимые объекты в конструкторы объектов, которые он разрешает. Дополнительные сведения о Autofac, см. в разделе [Autofac](http://autofac.readthedocs.io/en/latest/index.html) на сайте readthedocs.io.

В Autofac `IContainer` интерфейс предоставляет контейнера внедрения зависимостей. Рис. 3-1 показаны зависимости, при использовании этого контейнера, который создает экземпляр `IOrderService` объекта и вставляет его в `ProfileViewModel` класса.

![](dependency-injection-images/dependencyinjection.png "Пример зависимости при использовании внедрения зависимостей")

**Рис. 3-1.** Зависимости при использовании внедрения зависимостей

Во время выполнения, контейнер необходимо знать, какую реализацию из `IOrderService` интерфейс, он должен создать экземпляр, прежде чем его можно создать экземпляр `ProfileViewModel` объекта. Это включает в себя:

-   Выбор способа создания экземпляра объекта, реализующего контейнера `IOrderService` интерфейс. Этот процесс называется *регистрации*.
-   Контейнер, создание экземпляра объекта, который реализует `IOrderService` интерфейс и `ProfileViewModel` объекта. Этот процесс называется *разрешение*.

Со временем, приложение будет готово, с помощью `ProfileViewModel` объектом и он станет доступным для сборки мусора. На этом этапе следует освободить сборщик мусора `IOrderService` экземпляра, если другие классы, не используйте тот же экземпляр.

> [!TIP]
> Напишите код, независимый от контейнера. Всегда пытаться написать код независимой от контейнера, чтобы отделить приложение из контейнера конкретных зависимостей используется.

## <a name="registration"></a>Регистрация

Прежде чем зависимости могут внедряться в объект, типы зависимостей сначала должны регистрироваться с контейнером. Регистрация типа обычно включает в себя передачи в контейнер интерфейса и конкретный тип, реализующий интерфейс.

Существует два способа регистрации типов и объектов в контейнере с помощью кода:

-   Зарегистрируйте тип или сопоставление с контейнером. При необходимости, контейнер будет создавать экземпляр указанного типа.
-   Регистрация существующего объекта в контейнере как единственный экземпляр. При необходимости контейнера будет возвращать ссылку на существующий объект.

> [!TIP]
> Контейнеры для введения зависимостей не всегда подходит. Внедрение зависимостей представляет дополнительные сложности и требования, которые не могут быть соответствующие или полезные для небольших приложений. Если класс не имеет зависимые компоненты, или не является зависимость для других типов, не может быть целесообразно поместить его в контейнере. Кроме того Если класс имеет один набор зависимостей, которые являются неотъемлемой частью типа и никогда не изменится, не может быть целесообразно, чтобы поместить его в контейнер.

Следует выполнять регистрацию типов, требующих внедрение зависимостей в единственном методе в приложении, и этот метод должен вызываться на ранних этапах жизненного цикла приложения, чтобы убедиться, что приложение будет знать о зависимости между его классы. В мобильном приложении eShopOnContainers это выполняется с помощью `ViewModelLocator` класса, какие сборки `IContainer` объекта и является единственным классом в приложение, которое содержит ссылку на этот объект. В следующем примере кода показано, как мобильное приложение eShopOnContainers объявляет `IContainer` объекта в `ViewModelLocator` класса:

```csharp
private static IContainer _container;
```

Типы и экземпляры регистрируются в `RegisterDependencies` метод в `ViewModelLocator` класса. Это достигается путем предварительного создания `ContainerBuilder` экземпляра, как показано в следующем примере кода:

```csharp
var builder = new ContainerBuilder();
```

Типы и экземпляры затем регистрируется `ContainerBuilder` объекта, а также в следующем примере кода показано, наиболее распространенной формой типа регистрации:

```csharp
builder.RegisterType<RequestProvider>().As<IRequestProvider>();
```

`RegisterType` Приведенный здесь метод является типом интерфейса сопоставляется с конкретным типом. Сообщает контейнеру, для создания экземпляра `RequestProvider` объекта, когда он создает экземпляр объекта, который требует внедрение `IRequestProvider` через конструктор.

Конкретные типы также могут быть зарегистрированы напрямую без сопоставления из типа интерфейса, как показано в следующем примере кода:

```csharp
builder.RegisterType<ProfileViewModel>();
```

Когда `ProfileViewModel` тип разрешена, контейнер будет внедрять его необходимые зависимости.

Autofac также позволяет регистрация экземпляра, где контейнер отвечает за ведение ссылку на одноэлементный экземпляр типа. Например, в следующем примере кода показано, как мобильное приложение eShopOnContainers регистрирует конкретный тип для использования при `ProfileViewModel` экземпляр должен иметь `IOrderService` экземпляр:

```csharp
builder.RegisterType<OrderService>().As<IOrderService>().SingleInstance();
```

`RegisterType` Приведенный здесь метод является типом интерфейса сопоставляется с конкретным типом. `SingleInstance` Метод настроить регистрацию таким образом, чтобы один и тот же общий экземпляр получает все зависимые объекты. Таким образом только один `OrderService` экземпляр будет существовать в контейнере, который совместно используется объектами, которые требуют внедрение `IOrderService` через конструктор.

Регистрация экземпляра также может быть выполнена с `RegisterInstance` метод, как показано в следующем примере кода:

```csharp
builder.RegisterInstance(new OrderMockService()).As<IOrderService>();
```

`RegisterInstance` Приведенный здесь метод создает новую `OrderMockService` экземпляра и регистрирует его с контейнером. Таким образом только один `OrderMockService` экземпляр существует в контейнере, который совместно используется объектами, которые требуют внедрение `IOrderService` через конструктор.

После регистрации типа и экземпляра, `IContainer` объекта должны быть построены, который показан в следующем примере кода:

```csharp
_container = builder.Build();
```

Вызов `Build` метод `ContainerBuilder` экземпляр создает новый контейнер внедрения зависимостей, содержащий регистрации, которые были внесены.

>💡 **Совет**: Рассмотрите возможность `IContainer` как неизменяемый. Тогда как Autofac предоставляет `Update` метода, чтобы обновить регистрацию в существующий контейнер, вызов этого метода следует избегать, где это возможно. Существуют риски для изменения контейнера после был построен, особенно в том случае, если используется контейнер. Дополнительные сведения см. в разделе [рассмотрим контейнере, как неизменяемые](http://docs.autofac.org/en/latest/best-practices/#consider-a-container-as-immutable) на сайте readthedocs.io.

<a name="resolution" />

## <a name="resolution"></a>Решение

После регистрации тип, его можно разрешить или внедрены в качестве зависимости. Когда необходимо разрешить тип и контейнер должен создать новый экземпляр, оно внедряет зависимые компоненты в экземпляре.

Как правило при разрешении типа одно из трех действий происходит:

1.  Если тип не был зарегистрирован, контейнер вызывает исключение.
1.  Если тип был зарегистрирован как единственный экземпляр, контейнер возвращает одноэлементный экземпляр. Если это в первый раз вызов для метода типа, контейнер создает ее при необходимости и сохраняет ссылку на него.
1.  Если тип не был зарегистрирован как единственный экземпляр, контейнер возвращает новый экземпляр и не поддерживает ссылки на него.

В следующем примере кода показано как `RequestProvider` тип, который был зарегистрирован ранее Autofac можно разрешить:

```csharp
var requestProvider = _container.Resolve<IRequestProvider>();
```

В этом примере Autofac будет предложено разрешить конкретный тип для `IRequestProvider` типа, а также любые зависимости. Как правило `Resolve` метод вызывается, когда требуется экземпляр определенного типа. Сведения об управлении временем существования объектов разрешения, см. в разделе [управления временем существования объекта разрешен объектами](#managing_the_lifetime_of_resolved_objects).

В следующем примере кода показано, как мобильное приложение eShopOnContainers создает экземпляры типов модели представления и их зависимости:

```csharp
var viewModel = _container.Resolve(viewModelType);
```

В этом примере Autofac будет предложено разрешить тип модели представления для модели требуемого представления и контейнер также разрешается зависимые компоненты. При разрешении `ProfileViewModel` , устранить зависимость от измеряется `IOrderService` объекта. Таким образом, сначала создает Autofac `OrderService` и затем передает его в конструктор `ProfileViewModel` класса. Дополнительные сведения о том, как мобильное приложение eShopOnContainers создает представление модели и связывает их с представлениями, см. в разделе [автоматическое создание модели представления с указателем модели представления](~/xamarin-forms/enterprise-application-patterns/mvvm.md#automatically_creating_a_view_model_with_a_view_model_locator).

> [!NOTE]
> Регистрация и разрешение типов с помощью контейнера имеет к снижению производительности из-за контейнера использование отражения для создания каждого типа, особенно в том случае, если зависимости воссоздаются для каждого Навигация по страницам в приложении. Если существует много или всех зависимостей, затраты на создание может значительно возрасти.

<a name="managing_the_lifetime_of_resolved_objects" />

## <a name="managing-the-lifetime-of-resolved-objects"></a>Управление временем существования объектов разрешена

После регистрации типа, поведение по умолчанию для Autofac — для создания нового экземпляра зарегистрированного типа каждый раз типа разрешается или когда механизмом зависимостей внедряет экземпляров в другие классы. В этом случае контейнер не хранит ссылку на объект разрешения. Тем не менее при регистрации экземпляра, поведение по умолчанию для Autofac является управление временем существования объекта как единственный экземпляр. Таким образом экземпляр остается в области, пока контейнер находится в области и удаляется, когда контейнер выходит за пределы области и обрабатывается сборщиком мусора или код явно удаляет контейнер.

Областью Autofac экземпляр может использоваться для задания алгоритма одноэлементный объект, который создает Autofac из зарегистрированного типа. Autofac областями действия экземпляра управляют временем жизни объектов, создаваться контейнером. Область экземпляра по умолчанию для `RegisterType` метод `InstancePerDependency` области. Тем не менее `SingleInstance` область может использоваться с `RegisterType` метод, таким образом, создает контейнер, или возвращает одноэлементный экземпляр типа, при вызове `Resolve` метод. В следующем примере кода показано, как Autofac дано указание создать одноэлементный экземпляр `NavigationService` класса:

```csharp
builder.RegisterType<NavigationService>().As<INavigationService>().SingleInstance();
```

При первой `INavigationService` интерфейс разрешена, создает новый контейнер `NavigationService` объекта и сохраняет ссылку на него. На любые последующие разрешение `INavigationService` интерфейс, контейнер возвращает ссылку на `NavigationService` объект, который был создан ранее.

> [!NOTE]
> Область SingleInstance удаляет созданные объекты при удалении контейнера.

Autofac включает дополнительный экземпляр области. Дополнительные сведения см. в разделе [область экземпляра](http://autofac.readthedocs.io/en/latest/lifetime/instance-scope.html) на сайте readthedocs.io.

## <a name="summary"></a>Сводка

Внедрение зависимостей обеспечивает разделение конкретные типы из кода, который зависит от этих типов. Обычно в нем контейнер, который содержит список регистраций и сопоставления между интерфейсы и абстрактные типы и конкретные типы, которые реализуют или расширяют эти типы.

Autofac вспомогательного при создании слабо связанных приложений и предоставляет все функции, которые часто встречаются в контейнеры для введения зависимостей, включая методы для регистрации сопоставления типов и экземпляров объектов, разрешения объектов, управление временем существования объектов и внедрить зависимые объекты в конструкторы объектов, которые он разрешает.


## <a name="related-links"></a>Связанные ссылки

- [Скачайте электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
