---
title: Внедрение зависимостей
description: В этой главе объясняется, как мобильное приложение eShopOnContainers использует внедрение зависимостей для отделения конкретных типов от кода, который зависит от этих типов.
ms.prod: xamarin
ms.assetid: a150f2d1-06f8-4aed-ab4e-7a847d69f103
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 975b32610b4b496e329c5c5a29b79efd2874d8cf
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73029505"
---
# <a name="dependency-injection"></a>Внедрение зависимостей

Как правило, конструктор класса вызывается при создании экземпляра объекта, а все значения, необходимые объекту, передаются в конструктор в качестве аргументов. Это пример внедрения зависимостей, который, в частности, называется *внедрением конструктора*. Зависимости, необходимые объекту, вставляются в конструктор.

Указывая зависимости как типы интерфейсов, внедрение зависимостей позволяет разделять конкретные типы от кода, зависящего от этих типов. Обычно используется контейнер, содержащий список регистраций и сопоставлений между интерфейсами и абстрактными типами, а также конкретные типы, реализующие или расширяющие эти типы.

Существуют также другие типы внедрения зависимостей, такие как *внедрение свойства*и *Внедрение вызова метода*, но они являются менее часто видимыми. Поэтому в этой главе основное внимание уделяется только выполнению внедрения конструктора с помощью контейнера внедрения зависимостей.

<a name="introduction_to_dependency_injection" />

## <a name="introduction-to-dependency-injection"></a>Введение в внедрение зависимостей

Внедрение зависимостей представляет собой специализированную версию шаблона инверсии управления (IoC), где отзываемая проблема — это процесс получения необходимой зависимости. При внедрении зависимостей другой класс отвечает за внедрение зависимостей в объект во время выполнения. В следующем примере кода показано, как структурирован класс `ProfileViewModel` при использовании внедрения зависимостей.

```csharp
public class ProfileViewModel : ViewModelBase  
{  
    private IOrderService _orderService;  

    public ProfileViewModel(IOrderService orderService)  
    {  
        _orderService = orderService;  
    }  
    ...  
}
```

Конструктор `ProfileViewModel` получает экземпляр `IOrderService` в качестве аргумента, который вставляется другим классом. Единственной зависимостью в классе `ProfileViewModel` является тип интерфейса. Таким образом, класс `ProfileViewModel` не имеет сведений о классе, который отвечает за создание экземпляра объекта `IOrderService`. Класс, отвечающий за создание экземпляра объекта `IOrderService`, и его вставка в класс `ProfileViewModel`, называется *контейнером внедрения зависимостей*.

Контейнеры внедрения зависимостей уменьшают взаимосвязь между объектами, предоставляя возможность создавать экземпляры классов и управлять временем существования в зависимости от конфигурации контейнера. Во время создания объектов контейнер внедряет все зависимости, необходимые объекту. Если эти зависимости еще не созданы, контейнер сначала создает и разрешает их зависимости.

> [!NOTE]
> Внедрение зависимостей также может быть реализовано вручную с помощью фабрик. Однако использование контейнера предоставляет дополнительные возможности, такие как управление жизненным циклом и регистрация через сканирование сборок.

Использование контейнера внедрения зависимостей имеет несколько преимуществ.

- Контейнер устраняет необходимость класса для определения его зависимостей и управления временем существования.
- Контейнер позволяет сопоставлять реализованные зависимости, не влияя на класс.
- Контейнер упрощает тестирование, позволяя макетирование зависимостей.
- Контейнер повышает удобство поддержки, позволяя легко добавлять новые классы в приложение.

В контексте приложения Xamarin. Forms, использующего MVVM, контейнер внедрения зависимостей обычно используется для регистрации и разрешения моделей представлений, а также для регистрации служб и их внедрения в модели представления.

Существует множество доступных контейнеров внедрения зависимостей с помощью мобильного приложения eShopOnContainers, использующего Autofac для управления созданием экземпляров модели представления и классов служб в приложении. Autofac упрощает создание слабо связанных приложений и предоставляет все функции, которые часто обнаруживаются в контейнерах внедрения зависимостей, в том числе методы для регистрации сопоставлений типов и экземпляров объектов, разрешения объектов, управления жизненным циклом объектов и вставки зависимые объекты в конструкторы объектов, которые он разрешает. Дополнительные сведения о Autofac см. в разделе [Autofac](https://autofac.readthedocs.io/en/latest/index.html) on readthedocs.IO.

В Autofac интерфейс `IContainer` предоставляет контейнер внедрения зависимостей. На рис. 3-1 показаны зависимости при использовании этого контейнера, который создает экземпляр объекта `IOrderService` и внедряет его в класс `ProfileViewModel`.

![](dependency-injection-images/dependencyinjection.png "Dependencies example when using dependency injection")

**Рис. 3-1.** Зависимости при использовании внедрения зависимостей

Во время выполнения контейнер должен быть уверен, какую реализацию интерфейса `IOrderService` следует создать, прежде чем он сможет создать экземпляр объекта `ProfileViewModel`. Это включает в себя следующее:

- Контейнер, который решает, как создать экземпляр объекта, реализующего интерфейс `IOrderService`. Это называется *регистрацией*.
- Контейнер, создающий экземпляр объекта, который реализует интерфейс `IOrderService`, и объект `ProfileViewModel`. Это называется *разрешением*.

В конечном итоге приложение завершит использование объекта `ProfileViewModel`, и оно станет доступным для сборки мусора. На этом этапе сборщик мусора должен удалить экземпляр `IOrderService`, если другие классы не используют один и тот же экземпляр.

> [!TIP]
> Написание кода, независимого от контейнера. Всегда пытайтесь записать код, не зависящий от контейнера, чтобы отделить приложение от конкретного используемого контейнера зависимостей.

## <a name="registration"></a>Регистрация

Прежде чем можно будет внедрить зависимости в объект, необходимо сначала зарегистрировать типы зависимостей в контейнере. Регистрация типа обычно подразумевает передачу контейнера интерфейс и конкретный тип, реализующий интерфейс.

Существует два способа регистрации типов и объектов в контейнере с помощью кода:

- Зарегистрируйте тип или сопоставление с контейнером. При необходимости контейнер будет строить экземпляр указанного типа.
- Зарегистрируйте существующий объект в контейнере как одноэлементный. При необходимости контейнер вернет ссылку на существующий объект.

> [!TIP]
> Контейнеры внедрения зависимостей не всегда подходят. Внедрение зависимостей предоставляет дополнительные сложности и требования, которые могут быть нецелесообразными или полезными для небольших приложений. Если у класса нет зависимостей или он не зависит от других типов, он может не иметь смысла размещать его в контейнере. Кроме того, если класс содержит один набор зависимостей, которые являются неотъемлемой частью типа и никогда не изменяются, может не иметь смысла размещать его в контейнере.

Регистрация типов, требующих внедрения зависимостей, должна выполняться в одном методе в приложении, и этот метод должен вызываться на раннем этапе жизненного цикла приложения, чтобы гарантировать, что приложение знает о зависимостях между его классами. В мобильном приложении eShopOnContainers это выполняется классом `ViewModelLocator`, который создает объект `IContainer` и является единственным классом в приложении, который содержит ссылку на этот объект. В следующем примере кода показано, как мобильное приложение eShopOnContainers объявляет объект `IContainer` в классе `ViewModelLocator`:

```csharp
private static IContainer _container;
```

Типы и экземпляры регистрируются в методе `RegisterDependencies` класса `ViewModelLocator`. Для этого сначала создается экземпляр `ContainerBuilder`, который демонстрируется в следующем примере кода:

```csharp
var builder = new ContainerBuilder();
```

Затем типы и экземпляры регистрируются в объекте `ContainerBuilder`, а в следующем примере кода демонстрируется наиболее распространенная форма регистрации типа:

```csharp
builder.RegisterType<RequestProvider>().As<IRequestProvider>();
```

Показанный здесь метод `RegisterType` сопоставляет тип интерфейса с конкретным типом. Он указывает контейнеру создать экземпляр объекта `RequestProvider` при создании экземпляра объекта, который требует введения `IRequestProvider` с помощью конструктора.

Конкретные типы также могут быть зарегистрированы напрямую без сопоставления типа интерфейса, как показано в следующем примере кода:

```csharp
builder.RegisterType<ProfileViewModel>();
```

При разрешении типа `ProfileViewModel` контейнер будет внедрять необходимые зависимости.

Autofac также позволяет регистрировать экземпляры, где контейнер отвечает за поддержание ссылки на одноэлементный экземпляр типа. Например, в следующем примере кода показано, как мобильное приложение eShopOnContainers регистрирует конкретный тип для использования, когда экземпляру `ProfileViewModel` требуется экземпляр `IOrderService`.

```csharp
builder.RegisterType<OrderService>().As<IOrderService>().SingleInstance();
```

Показанный здесь метод `RegisterType` сопоставляет тип интерфейса с конкретным типом. Метод `SingleInstance` настраивает регистрацию таким образом, что каждый зависимый объект получает один и тот же общий экземпляр. Таким образом, в контейнере будет существовать только один экземпляр `OrderService`, который совместно используется объектами, требующими введения `IOrderService` с помощью конструктора.

Регистрацию экземпляра также можно выполнить с помощью метода `RegisterInstance`, как показано в следующем примере кода:

```csharp
builder.RegisterInstance(new OrderMockService()).As<IOrderService>();
```

Метод `RegisterInstance`, показанный здесь, создает новый экземпляр `OrderMockService` и регистрирует его в контейнере. Таким образом, в контейнере существует только один экземпляр `OrderMockService`, который совместно используется объектами, требующими введения `IOrderService` с помощью конструктора.

После регистрации типа и экземпляра объект `IContainer` должен быть построен, что демонстрируется в следующем примере кода:

```csharp
_container = builder.Build();
```

При вызове метода `Build` в экземпляре `ContainerBuilder` создается новый контейнер внедрения зависимостей, который содержит выполненные регистрации.

> [!TIP]
> Рассмотрим `IContainer` как неизменяемый. Хотя Autofac предоставляет метод `Update` для обновления регистраций в существующем контейнере, по возможности следует избегать вызова этого метода. Существует несколько рисков по изменению контейнера после его сборки, особенно если контейнер используется. Дополнительные сведения см. в разделе [рассмотрение контейнера как неизменяемого](https://docs.autofac.org/en/latest/best-practices/#consider-a-container-as-immutable) в readthedocs.IO.

<a name="resolution" />

## <a name="resolution"></a>Разрешение

После регистрации типа его можно разрешить или внедрить как зависимость. Если тип разрешается и контейнеру необходимо создать новый экземпляр, он внедряет все зависимости в экземпляр.

Как правило, при разрешении типа происходит одно из трех действий:

1. Если тип не был зарегистрирован, контейнер создает исключение.
1. Если тип был зарегистрирован как одноэлементный, контейнер возвращает одноэлементный экземпляр. Если этот тип вызывается в первый раз, контейнер создает его при необходимости и сохраняет ссылку на него.
1. Если тип не был зарегистрирован как singleton, контейнер возвращает новый экземпляр и не поддерживает ссылку на него.

В следующем примере кода показано, как можно разрешить тип `RequestProvider`, который был ранее зарегистрирован в Autofac:

```csharp
var requestProvider = _container.Resolve<IRequestProvider>();
```

В этом примере Autofac запрашивает разрешение конкретного типа для `IRequestProvider` типа вместе с любыми зависимостями. Как правило, метод `Resolve` вызывается, когда требуется экземпляр определенного типа. Сведения об управлении временем существования разрешенных объектов см. [в разделе Управление временем существования разрешенных объектов](#managing_the_lifetime_of_resolved_objects).

В следующем примере кода показано, как мобильное приложение eShopOnContainers создает экземпляры типов моделей представления и их зависимостей:

```csharp
var viewModel = _container.Resolve(viewModelType);
```

В этом примере Autofac запрос на разрешение типа модели представления для запрошенной модели представления, и контейнер также будет разрешать все зависимости. При разрешении типа `ProfileViewModel` зависимость, которую необходимо разрешить, является объектом `IOrderService`. Таким образом, Autofac сначала конструирует объект `OrderService`, а затем передает его конструктору класса `ProfileViewModel`. Дополнительные сведения о том, как конструкция eShopOnContainers Mobile App формирует модели представления и связывает их с представлениями, см. в разделе [Автоматическое создание модели представления с указателем модели представления](~/xamarin-forms/enterprise-application-patterns/mvvm.md#automatically_creating_a_view_model_with_a_view_model_locator).

> [!NOTE]
> Регистрация и разрешение типов в контейнере влечет затраты с точки зрения производительности из-за использования отражения в контейнере для создания каждого типа, особенно если зависимости перестраиваются при каждом переходе по страницам в приложении. При наличии большого числа зависимостей или глубоких зависимостей стоимость создания может значительно возрасти.

<a name="managing_the_lifetime_of_resolved_objects" />

## <a name="managing-the-lifetime-of-resolved-objects"></a>Управление временем существования разрешенных объектов

После регистрации типа поведением по умолчанию для Autofac является создание нового экземпляра зарегистрированного типа каждый раз, когда тип разрешается, или когда механизм зависимости внедряет экземпляры в другие классы. В этом сценарии контейнер не хранит ссылку на разрешенный объект. Однако при регистрации экземпляра поведением по умолчанию для Autofac является управление временем существования объекта в виде одноэлементного элемента. Таким образом, экземпляр остается в области, пока контейнер находится в области, и удаляется, когда контейнер выходит из области действия и уничтожается сборщиком мусора, или когда код явным образом удаляет контейнер.

Область экземпляра Autofac можно использовать для указания одноэлементного поведения для объекта, который Autofac создает из зарегистрированного типа. Области экземпляра Autofac управляют временем существования объектов, создаваемых контейнером. Областью экземпляра по умолчанию для метода `RegisterType` является область `InstancePerDependency`. Однако область `SingleInstance` можно использовать с методом `RegisterType`, чтобы контейнер создавал или возвращал одноэлементный экземпляр типа при вызове метода `Resolve`. В следующем примере кода показано, как Autofac указывает, как создать одноэлементный экземпляр класса `NavigationService`:

```csharp
builder.RegisterType<NavigationService>().As<INavigationService>().SingleInstance();
```

При первом разрешении `INavigationService`ного интерфейса контейнер создает новый объект `NavigationService` и сохраняет ссылку на него. При каждом последующих разрешениях интерфейса `INavigationService` контейнер возвращает ссылку на объект `NavigationService`, который был создан ранее.

> [!NOTE]
> Область Синглеинстанце удаляет созданные объекты при удалении контейнера.

Autofac включает дополнительные области экземпляров. Дополнительные сведения см. в разделе [scope of instance](https://autofac.readthedocs.io/en/latest/lifetime/instance-scope.html) on readthedocs.IO.

## <a name="summary"></a>Сводка

Внедрение зависимостей позволяет разделять конкретные типы от кода, который зависит от этих типов. Обычно используется контейнер, содержащий список регистраций и сопоставлений между интерфейсами и абстрактными типами, а также конкретные типы, реализующие или расширяющие эти типы.

Autofac упрощает создание слабо связанных приложений и предоставляет все функции, которые часто обнаруживаются в контейнерах внедрения зависимостей, в том числе методы для регистрации сопоставлений типов и экземпляров объектов, разрешения объектов, управления жизненным циклом объектов и вставки зависимые объекты в конструкторы объектов, которые он разрешает.

## <a name="related-links"></a>Связанные ссылки

- [Скачать электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
