---
title: Контейнерные микрослужбы
description: В этой главе объясняется, как использование микрослужб и контейнеров для создания гибкой, масштабируемой и надежной современных облачных приложений.
ms.prod: xamarin
ms.assetid: 5872ad92-04e0-4f1a-9691-79d5602f5683
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 33be84bc17f72c8b70d117a0742b001f1f763d3d
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61300762"
---
# <a name="containerized-microservices"></a>Контейнерные микрослужбы

Разработка приложений клиент сервер помог сосредоточиться на создании многоуровневых приложений, использования определенных технологий на каждом уровне. Такие приложения часто называются *монолитных* приложений того они упаковываются на оборудовании, предварительно масштабируется для пиковых нагрузок. Основные недостатки этого подхода разработки являются тесную связь между компонентами в пределах каждого уровня, что нельзя легко масштабировать отдельные компоненты и затраты на проверку. Простое обновление может иметь непредвиденные последствия на остальных уровня, и поэтому изменение компонент приложения требует его весь уровень повторного тестирования и повторного развертывания.

Особенно обсуждение в эпоху облака, что отдельные компоненты не может быть легко масштабируется. Монолитное приложение содержит функциональные возможности доменного и обычно делится на функциональные уровни, такие как внешний интерфейс, бизнес-логики и хранилища данных. Монолитное приложение масштабируется путем клонирования всего приложения на нескольких компьютерах, как показано на рисунке 8-1.

![](containerized-microservices-images/monolithicapp.png "Масштабный подход монолитного приложения")

**Рис. 8-1**: Масштабный подход монолитного приложения

## <a name="microservices"></a>Микрослужбы

Микрослужбы предлагают другой подход для разработки и развертывания приложений, подход, который подходит для гибкости, масштабирования и требования к надежности работы современных облачных приложений. Приложение для микрослужб разлагаются на независимые компоненты, которые вместе работают над достижением общей функциональности приложения. Особое внимание уделяется микрослужбы термин, что должно составлять приложения из службы достаточно небольшим, чтобы отразить независимых проблем, чтобы каждая микрослужба реализует одной функции. Кроме того каждая микрослужба имеет четко определенные контракты, чтобы другие микрослужбы могут взаимодействовать и обмениваться данными с ним. Типичные примеры микрослужб включают корзин, складских запасах обработки, подсистемами и обработка платежей.

Микрослужбы можно горизонтально масштабировать независимо друг от друга, по сравнению с огромным монолитных приложений, которые масштабируются вместе. Это означает, что можно масштабировать конкретной функциональной области, требующий обработки питание или сетевое пропускная способность для поддержки запросу, вместо того чтобы излишне масштабирование других областей приложения. Рис. 8-2 показан этот подход, где развертываете микрослужбы и масштабировать независимо друг от друга, создавая экземпляры служб между компьютерами.

![](containerized-microservices-images/microservicesapp.png "Масштабирование приложения микрослужб")

**Рис. 8-2**: Масштабирование приложения микрослужб

Горизонтальное масштабирование Микрослужб может быть практически мгновенно, что позволяет приложению адаптироваться к изменению загрузок. Например одна микрослужба в функциональные возможности веб-приложения может быть только микрослужбы в приложении, которое необходимо горизонтальное масштабирование для обработки дополнительных входящего трафика.

Классическую модель для обеспечения масштабируемости приложения является уровня с балансировкой нагрузки, без отслеживания состояния с общий внешнее хранилище данных для хранения постоянных данных. Микрослужбы с отслеживанием состояния управлять собственные постоянных данных, обычно запоминался локально на серверах, на которых они размещены, чтобы избежать затрат на сетевой доступ и сложности между службами операций. Это обеспечивает быструю обработку возможных данных и позволяет избавиться от необходимости для систем. Кроме того масштабируемых микрослужб с отслеживанием состояния обычно секционирования данных между экземплярами их для управления размером и передачи пропускная способность выходе за которые может поддерживать один сервер.

Микрослужбы также поддерживать независимые обновления. Слабая связь между микрослужбами обеспечивает развитие быстрое и надежное приложение. Своей природе независимые, распределенная поддерживает последовательные обновления, когда будет обновлять только подмножество экземпляров одной микрослужбы в любой момент времени. Таким образом Если обнаруживается проблема, ошибками обновления можно откатить назад, прежде чем обновить все экземпляры с ошибочного кода или конфигурации. Аналогичным образом микрослужб обычно используют управление версиями схемы, таким образом, клиенты могут видеть согласованность версий при обновления, независимо от того, какие микрослужба передаваемых экземпляра с.

Таким образом микрослужба приложения имеют множество преимуществ над монолитных приложений:

-   Каждая микрослужба относительно небольшой, легко управлять и развивать.
-   Каждая микрослужба разработки и развертывать независимо от других служб.
-   Каждая микрослужба может быть масштабирован независимо друг от друга. Например службы каталога или службе корзины для покупок может потребоваться больше, чем служба заказов быть горизонтальным масштабированием. Таким образом полученный инфраструктуры более эффективно будет потреблять ресурсы при масштабировании.
-   Каждая микрослужба изолирует все проблемы. Например если имеется проблема в службе он влияет только на эту службу. Другие службы могут продолжать обрабатывать запросы.
-   Каждая микрослужба может использовать новейшие технологии. Так как микрослужбы являются автономными и выполнения side-by-side, последних технологий и платформ можно использовать, вместо того чтобы использовать на старой платформе, которые могут быть использованы монолитного приложения.

Тем не менее решение на основе микрослужб также имеет потенциальные недостатки:

-   Выбрать способ разделения приложения на микрослужбы может оказаться сложной задачей, так как каждая микрослужба должна быть полностью автономными, end-to-end, включая ответственность за его источники данных.
-   Разработчики должны реализовать взаимодействие между службами, который добавляет сложности и задержки в приложения.
-   Атомарные транзакции между несколькими микрослужбами обычно невозможны. Таким образом бизнес-требования должны учитывать итоговую согласованность между микрослужбами.
-   В рабочей среде нет сложности при развертывании и управлении системы включает в себя множество независимых служб.
-   Прямое взаимодействие клиента с микрослужбой будет трудно рефакторинга контрактов микрослужб. Например со временем как разделения системы в службы может потребоваться изменить. Одна служба может разбивается на два или несколько служб, а может объединить две службы. Когда клиенты взаимодействуют непосредственно с микрослужбами, эта работа рефакторинга может нарушить совместимость с клиентскими приложениями.

## <a name="containerization"></a>Контейнеризация

Контейнеризация — это подход к разработке программного обеспечения, в котором приложение и его версий набором зависимостей, а также его конфигурации среды, которые абстрагированы как файлы манифеста развертывания, упаковываются вместе в образ контейнера, как единое целое, и развернуть операционную систему узлов.

Контейнер — изолированной, ресурсов управляемой и переносимой среде, где приложение может работать, не изменяя при этом ресурсы другими контейнерами или узлом. Таким образом контейнер выглядит и работает как недавно установленные физический компьютер или виртуальную машину.

Есть много общего между контейнерами и виртуальные машины, как показано на рисунке 8-3.

![](containerized-microservices-images/containersvsvirtualmachines.png "Масштабирование приложения микрослужб")

**Рис. 8-3**: Сравнение виртуальных машин и контейнеров

Контейнер с операционной системой, содержит файловую систему и может осуществляться по сети, как если бы он был физической или виртуальной машины. Тем не менее технологии и основные понятия, используемые контейнерами очень отличаются от виртуальных машин. Виртуальные машины оснащены приложения, необходимые зависимости, а также всю операционную систему. Контейнеры включают в себя приложение и его зависимости, но совместно использовать операционную систему с другими контейнерами, как изолированные процессы в операционной системе узла (помимо контейнеры Hyper-V, которые выполняются в специальной виртуальной машине каждого контейнера). Таким образом контейнеры совместно используют ресурсы и обычно требуют меньше ресурсов, чем виртуальные машины.

Контейнер ориентированного подхода разработки и развертывания удобен тем, что оно устраняет большинство проблем, которые возникают из-за настроек несогласованные среды и проблем, которые поставляются с ними. Кроме того контейнеры позволяют функциональные возможности вертикального масштабирования ускоренного восстановления приложений путем создания экземпляров новых контейнеров при необходимости.

Ниже приведены основные понятия при создании и работе с контейнерами.

-   Узел контейнера: Физической или виртуальной машине, настроенной для размещения контейнеров. На узле контейнера будет выполняться один или несколько контейнеров.
-   Образ контейнера: Изображение состоит из объединения многоуровневой файловые системы, расположены друг над другом и лежит в основе контейнера. Изображение не имеет состояния, и он никогда не изменяется по мере ее развертывания в разных средах.
-   Контейнер: Контейнер — это экземпляр среды выполнения изображения.
-   Образ ОС контейнера: Контейнеры развертываются из образов. Образ ОС контейнера — первый уровень в возможного множества слоев образа, составляющих контейнер. В операционной системе контейнера является неизменяемым и не может быть изменен.
-   Репозиторий контейнеров: Каждый раз, когда создается образ контейнера, изображения и его зависимости сохраняются в локальном репозитории. Эти образы можно использовать повторно много раз на узле контейнера. Образы контейнеров также могут храниться в открытом или закрытом реестре, такие как [Docker Hub](https://hub.docker.com/), так что они могут использоваться в различных узлах контейнеров.

Предприятия все чаще внедряют контейнеры, при реализации микрослужбы на основе приложений, а Docker стал стандартный контейнер реализацию, которая была принята большинство платформ программного обеспечения и поставщики облачных служб.

Для размещения четырех контейнерные микрослужбы серверной части, образце приложения eShopOnContainers используется Docker, как показано на рисунке 8-4.

![](containerized-microservices-images/microservicesarchitecture.png "eShopOnContainers ссылаться на внутренние микрослужбы приложения")

**Рис. 8-4**: eShopOnContainers ссылаться на внутренние микрослужбы приложения

Архитектура служб серверной части в справочное приложение делится на несколько автономных подсистемах в виде совместно работающих микрослужб и контейнеров. Каждая микрослужба предоставляет одну область функций: это служба удостоверений, службы каталога, служба заказов и служба корзины.

Каждая микрослужба имеет свою собственную базу данных, позволяя ему быть полностью отделенной от других микрослужб. При необходимости согласованность между базами данных разных микрослужб достигается с помощью события уровня приложения. Дополнительные сведения см. в разделе [обмен данными между Микрослужбами](#communication_between_microservices).

Дополнительные сведения о эталонного приложения, см. в разделе [Микрослужбы .NET: архитектура контейнерных приложений .NET](https://aka.ms/microservicesebook).

<a name="communication_between_client_and_microservices" />

## <a name="communication-between-client-and-microservices"></a>Обмен данными между клиентом и Микрослужб

Мобильное приложение eShopOnContainers взаимодействует с контейнерные микрослужбы серверной части с помощью *направить клиента с микрослужбой* взаимодействия, как показано на рисунке 8-5.

![](containerized-microservices-images/directclienttomicroservicecommunication.png "Масштабирование приложения микрослужб")

**Рис. 8-5**: Прямое взаимодействие между клиентом и микрослужбой

С прямым взаимодействием клиента с микрослужбой мобильное приложение выполняет запросы к каждой микрослужбе напрямую через общедоступную конечную точку с помощью другого порта TCP каждой микрослужбы. В рабочей среде конечной точки обычно будут сопоставлены с балансировки нагрузки микрослужб, которая распределяет запросы между доступных экземпляров.

> [!TIP]
> Рассмотрите возможность использования связь шлюза API. Прямое взаимодействие клиента с микрослужбой может иметь определенные недостатки, когда создание больших и сложных микрослужб на основе приложения, но это более чем достаточно для небольших приложений. При разработке крупных микрослужбы на основе приложения с десятками микрослужб, рассмотрите возможность использования связь шлюза API. Дополнительные сведения см. в разделе [Микрослужбы .NET: архитектура контейнерных приложений .NET](https://aka.ms/microservicesebook).

<a name="communication_between_microservices" />

## <a name="communication-between-microservices"></a>Взаимодействие между Микрослужбами

Приложение для микрослужб на основе является распределенной системой, потенциально работает на нескольких компьютерах. Обычно каждый экземпляр службы — это процесс. Таким образом службы должны взаимодействовать, используя протокол межпроцессного взаимодействия, таких как HTTP, TCP, Advanced Message Queuing Protocol (AMQP) или двоичные протоколы, в зависимости от характера каждой службы.

Два обычных подхода к взаимодействие микрослужбы и микрослужбы являются средств связи REST, на основе HTTP, при запросе данных и легкие асинхронные сообщения при обмене данными обновлений в нескольких микрослужбах.

Асинхронного обмена сообщениями на основе управляемое событиями взаимодействие крайне важен в том случае, если распространение изменений в нескольких микрослужбах. В этом случае микрослужба публикует событие, когда что-либо заметных может произойти, например, при обновлении бизнес-сущность. Другие микрослужбы подписываются на эти события. Затем когда микрослужба получает событие, он обновляет свой собственный бизнес-сущности, которые в свою очередь может привести к публикации дополнительных событий. Это публикация-подписка на функциональные возможности обычно достигается с помощью шины событий.

Шина событий позволяет взаимодействие между микрослужбами, не требуя компоненты, которые необходимо явно учитывает друг с другом, как показано на рисунке 8-6 публикации и подписки.

![](containerized-microservices-images/eventbus.png "Публикации и подписки с помощью шины событий")

**Рис. 8-6.** Публикации и подписки с помощью шины событий

С точки зрения приложения, шина событий — просто публикация-подписка канала, предоставляемые через интерфейс. Тем не менее можно изменять способ реализации шины событий. Например RabbitMQ, служебная шина Azure или других служебных шин, например NServiceBus, MassTransit использовать реализация шины событий. Рис. 8-7 показано, как шины событий используется в образце приложения eShopOnContainers.

![](containerized-microservices-images/microservicesarchitecturewitheventbus.png "Асинхронное взаимодействие, управляемые событиями, в приложении ссылку")

**Рис. 8-7:** Асинхронное взаимодействие, управляемые событиями, в приложении ссылку

Шина событий eShopOnContainers, реализованные с помощью RabbitMQ, предоставляет один ко многим асинхронной публикации и подписки функциональные возможности. Это означает, что после публикации события, может существовать несколько подписчиков, прослушивающих того же события. Данная связь показана на рис. 8-9.

![](containerized-microservices-images/eventdrivencommunication.png "Один ко многим связи")

**Рис. 8-9**: Один ко многим связи

Этот подход взаимодействия один ко многим использует события для реализации бизнес-транзакций, которые охватывают несколько служб, обеспечивая согласованность между службами. Итоговая согласованность транзакций состоит из ряда распределенных действий. Таким образом Получив команду UpdateUser, в микрослужбе профиля пользователя обновляет сведения о пользователе в базе данных и публикует событие UserUpdated в шине событий. В микрослужбе корзины и микрослужбе оформили подписку для получения этого события и в ответ обновления сведения о своем покупателя в соответствующие базы данных.

> [!NOTE]
> Шина событий eShopOnContainers, реализованные с помощью RabbitMQ, предназначен для использования только в качестве подтверждения концепции. Для производственных систем следует рассматривать реализаций шины альтернативные событий.

Сведения о реализации шины событий, см. в разделе [Микрослужбы .NET: архитектура контейнерных приложений .NET](https://aka.ms/microservicesebook).

## <a name="summary"></a>Сводка

Микрослужбы открывают подход к разработке приложений и развертывания, в соответствии с требованиями гибкость, масштабируемость и надежность современных облачных приложений. Одно из основных преимуществ микрослужб является, что они могут быть масштабируемыми независимо друг от друга, что означает, что определенной функциональной области можно масштабировать, требуются дополнительные обработки или сетевых ресурсов для поддержки требованию, без без необходимости масштабирования области приложение, которое не наблюдается повышение спроса.

Контейнер — изолированной, ресурсов управляемой и переносимой среде, где приложение может работать, не изменяя при этом ресурсы другими контейнерами или узлом. Предприятия все чаще внедряют контейнеры, при реализации микрослужбы на основе приложений, а Docker стал стандартный контейнер реализацию, которая была принята большинство платформ программного обеспечения и поставщики облачных служб.


## <a name="related-links"></a>Связанные ссылки

- [Скачайте электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
