---
title: Взаимодействие между слабо связанными компонентами
description: 'В данной главе объясняется, как мобильное приложение eShopOnContainers реализует публикации-подписки шаблон, позволяя обмена сообщениями между компонентами, которые было неудобно для связывания с ссылки на объект и тип '
ms.prod: xamarin
ms.assetid: 1194af33-8a91-48d2-88b5-b84d77f2ce69
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: ddc33d28aad4e00c9259893c0f8e7a1ab40ee429
ms.sourcegitcommit: 6e955f6851794d58334d41f7a550d93a47e834d2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/12/2018
ms.locfileid: "38998548"
---
# <a name="communicating-between-loosely-coupled-components"></a>Взаимодействие между слабо связанными компонентами

Публикация-подписка шаблон — это шаблон обмена сообщениями, в котором издатели отправляют сообщения без необходимости знания любые приемники, известный как подписчики. Аналогично подписчики прослушивать специальных сообщений, без необходимости знать ни одного издателя.

События в .NET реализовывать публикации-подписки шаблон и являются наиболее простым и понятным способом связующий слой между компонентами, если слабые связи не требуется, например элемент управления и содержащая его страница. Тем не менее время существования издателем и подписчиком связаны друг с другом, ссылки на объекты друг с другом, и тип подписчика должны содержать ссылку на тип издателя. Это может создать памяти по вопросам управления, особенно при наличии количества кратковременных объектов, которые подписаны на события объекта статическими или долговременными. Если не удалить обработчик событий, подписчик будет поддерживаться по ссылке на него в издателе, и это будет заблокирована или задержана мусора подписчика.

## <a name="introduction-to-messagingcenter"></a>Знакомство с помощью MessagingCenter

Xamarin.Forms [ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter) класс реализует публикации-подписки шаблон, позволяя обмена сообщениями между компонентами, которые было неудобно для связывания с ссылки на объект и тип. Этот механизм позволяет издателями и подписчиками, обмениваться данными без ссылку друг с другом, позволяя сократить зависимостей между компонентами, позволяя компонентов независимо друг от друга и тестировать.

[ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter) Класс предоставляет многоадресной рассылки публикации и подписки функциональные возможности. Это означает, что может существовать несколько издателей, которые публикуют одно сообщение что может существовать несколько подписчиков, прослушивающих для одного сообщения. Данная связь показана на рис. 4-1:

![](communicating-between-loosely-coupled-components-images/messagingcenter.png "Многоадресная рассылка публикации и подписки функциональные возможности")

**Рис. 4-1:** многоадресной рассылки публикации и подписки функциональные возможности

Издатели отправляют сообщения с помощью [ `MessagingCenter.Send` ](xref:Xamarin.Forms.MessagingCenter.Send*) метод, пока подписчики прослушивать сообщения с помощью [ `MessagingCenter.Subscribe` ](xref:Xamarin.Forms.MessagingCenter.Subscribe*) метод. Кроме того, подписчики может также отменить подписку на сообщения подписок, при необходимости с [ `MessagingCenter.Unsubscribe` ](xref:Xamarin.Forms.MessagingCenter.Unsubscribe*) метод.

На внутреннем уровне [ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter) класс использует слабые ссылки. Это означает, что он будет не поддерживать объекты в активном состоянии и дают возможность быть подвергнута сбору мусора. Таким образом он должен быть только необходимо отменить подписку на сообщения, когда класс больше не хочет получать сообщения.

Использование мобильного приложения eShopOnContainers [ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter) класс для обмена данными между слабо связанными компонентами. Приложение определяет три сообщения:

-   `AddProduct` Опубликованное сообщение `CatalogViewModel` класс при добавлении элемента в корзину. Взамен `BasketViewModel` класс подписывается на сообщение и увеличивает количество элементов в корзине в ответ. Кроме того `BasketViewModel` класс также отменяет подписку на это сообщение.
-   `Filter` Опубликованное сообщение `CatalogViewModel` класса при вызове пользователем сорт фильтр для элементов, отображенных из каталога. Взамен `CatalogView` класс подписывается на сообщения и обновляет пользовательский Интерфейс, чтобы отображались только элементы, соответствующие условиям фильтра.
-   `ChangeTab` Опубликованное сообщение `MainViewModel` класса, если `CheckoutViewModel` переходит к `MainViewModel` после успешного создания и отправки нового заказа. Взамен `MainView` класс подписывается на сообщения и обновления пользовательского интерфейса таким образом, **Мой профиль** активна вкладка, чтобы показать заказы на пользователя.

> [!NOTE]
> Хотя [ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter) класс разрешает обмен данными между слабо связанных классов, не предлагается только архитектурные решения этой проблемы. Например обмен данными между модель представления и представления также достигается ядром привязки и через уведомления об изменении свойств. Кроме того обмен данными между двумя моделями представления также достигается путем передачи данных во время перехода.

В мобильном приложении eShopOnContainers[ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter) используется для обновления в пользовательском Интерфейсе в ответ на действие в другом классе. Таким образом сообщения публикуются в потоке пользовательского интерфейса с подписчиками, получения сообщения в одном потоке.

> [!TIP]
> Маршалинг в поток пользовательского интерфейса, при выполнении пользовательского интерфейса обновлений. Если сообщение, которое отправляется из фонового потока требуется для обновления пользовательского интерфейса, обработать сообщение в потоке пользовательского интерфейса в подписчике, вызвав [ `Device.BeginInvokeOnMainThread` ](xref:Xamarin.Forms.Device.BeginInvokeOnMainThread(System.Action)) метод.

Дополнительные сведения о [ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter), см. в разделе [помощью MessagingCenter](~/xamarin-forms/app-fundamentals/messaging-center.md).

## <a name="defining-a-message"></a>Определение сообщения

[`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) сообщения, строки, которые используются для идентификации сообщений. В следующем примере кода показаны сообщения, определенные в мобильном приложении eShopOnContainers:

```csharp
public class MessengerKeys  
{  
    // Add product to basket  
    public const string AddProduct = "AddProduct";  

    // Filter  
    public const string Filter = "Filter";  

    // Change selected Tab programmatically  
    public const string ChangeTab = "ChangeTab";  
}
```

В этом примере сообщения можно сформировать с помощью констант. Преимуществом такого подхода является то, что обеспечивается безопасность типов во время компиляции и оптимизации кода.

## <a name="publishing-a-message"></a>Публикация сообщения

Издатели уведомления подписчиков сообщения с одним из [ `MessagingCenter.Send` ](xref:Xamarin.Forms.MessagingCenter.Send*) перегрузки. В следующем примере кода демонстрируется публикация `AddProduct` сообщение:

```csharp
MessagingCenter.Send(this, MessengerKeys.AddProduct, catalogItem);
```

В этом примере [ `Send` ](xref:Xamarin.Forms.MessagingCenter.Send*) метод задает три аргумента:

-   Первый аргумент указывает класс отправителя. Класс отправителя необходимо указать с любой из подписчиков, которые хотят получать сообщения.
-   Второй аргумент задает сообщение.
-   Третий аргумент задает полезные данные, отправляемые на подписчик. В данном случае является полезных данных `CatalogItem` экземпляра.

[ `Send` ](xref:Xamarin.Forms.MessagingCenter.Send*) Метод будет публиковать сообщение и его полезные данные, используя подход выстрелил и забыл. Таким образом сообщение отправляется, даже если нет подписчиков, зарегистрированных для получения сообщения. В этом случае игнорируется отправленного сообщения.

> [!NOTE]
> [ `MessagingCenter.Send` ](xref:Xamarin.Forms.MessagingCenter.Send*) Метод можно использовать универсальные параметры для управления, как доставляются сообщения. Таким образом разные подписчики могут получать несколько сообщений, которые совместно используют идентификатор сообщения, но отправлять различные типы полезных данных данных.

## <a name="subscribing-to-a-message"></a>Подписка на сообщение

Подписчики может зарегистрироваться для получения сообщения с помощью одного из [ `MessagingCenter.Subscribe` ](xref:Xamarin.Forms.MessagingCenter.Subscribe*) перегрузки. В следующем примере кода показано, как подписывается на мобильное приложение eShopOnContainers и обрабатывает, `AddProduct` сообщение:

```csharp
MessagingCenter.Subscribe<CatalogViewModel, CatalogItem>(  
    this, MessageKeys.AddProduct, async (sender, arg) =>  
{  
    BadgeCount++;  

    await AddCatalogItemAsync(arg);  
});
```

В этом примере [ `Subscribe` ](xref:Xamarin.Forms.MessagingCenter.Subscribe*) метод подписывается на `AddProduct` сообщений и выполняет делегат обратного вызова в ответ на получение сообщения. Этот делегат обратного вызова, заданный как лямбда-выражение, выполняет код, который обновляет пользовательский Интерфейс.

> [!TIP]
> Рассмотрите возможность использования неизменяемый полезные данные. Не пытайтесь изменить полезные данные из в делегат обратного вызова, так как несколько потоков можно получать доступ к полученных данных одновременно. В этом случае полезные данные должны быть неизменными во избежание ошибок параллелизма.

Подписчик может не понадобиться обрабатывать каждое вхождение опубликованного сообщения, и это также может управляться аргументы универсального типа, которые определены на [ `Subscribe` ](xref:Xamarin.Forms.MessagingCenter.Subscribe*) метод. В этом примере, подписчик получит только `AddProduct` сообщений, отправленных из `CatalogViewModel` класса, данные которого полезные данные `CatalogItem` экземпляра.

## <a name="unsubscribing-from-a-message"></a>Отмена подписки на сообщение

Подписчики могут отменить подписку на сообщения, которые больше не хотите получать. Это достигается с помощью одного из [ `MessagingCenter.Unsubscribe` ](xref:Xamarin.Forms.MessagingCenter.Unsubscribe*) перегружает, как показано в следующем примере кода:

```csharp
MessagingCenter.Unsubscribe<CatalogViewModel, CatalogItem>(this, MessengerKeys.AddProduct);
```

В этом примере [ `Unsubscribe` ](xref:Xamarin.Forms.MessagingCenter.Unsubscribe*) синтаксис метода отражает аргументы типа, указанный при подписке на получение `AddProduct` сообщения.

## <a name="summary"></a>Сводка

Xamarin.Forms [ `MessagingCenter` ](xref:Xamarin.Forms.MessagingCenter) класс реализует публикации-подписки шаблон, позволяя обмена сообщениями между компонентами, которые было неудобно для связывания с ссылки на объект и тип. Этот механизм позволяет издателями и подписчиками, обмениваться данными без ссылку друг с другом, позволяя сократить зависимостей между компонентами, позволяя компонентов независимо друг от друга и тестировать.


## <a name="related-links"></a>Связанные ссылки

- [Скачайте электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
