---
title: Шаблон Model-View-ViewModel
description: В данной главе объясняется, как мобильное приложение eShopOnContainers использует шаблон MVVM для четко отделить бизнеса и логику представления приложения из его интерфейса пользователя.
ms.prod: xamarin
ms.assetid: dd8c1813-df44-4947-bcee-1a1ff2334b87
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 87448c556c66ea086db70699848227e1f671792b
ms.sourcegitcommit: 3489c281c9eb5ada2cddf32d73370943342a1082
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "59019390"
---
# <a name="the-model-view-viewmodel-pattern"></a>Шаблон Model-View-ViewModel

Процесс разработки Xamarin.Forms обычно подразумевает создание пользовательского интерфейса в XAML и последующего добавления кода, работающая в пользовательском интерфейсе. Как приложения изменяются и увеличения размера и области, сложное обслуживание проблемы могут возникнуть. Эти проблемы включают тесной связи между элементами управления пользовательского интерфейса и бизнес-логику, что увеличивает расходы на изменения пользовательского интерфейса и сложности модульное тестирование такого кода.

Шаблон Model-View-ViewModel (MVVM) помогает четко отделить бизнеса и логику представления приложения из его пользовательский интерфейс (UI). Поддержание четкое разделение между логикой приложения и пользовательский Интерфейс помогает решить множество проблем разработки и позволяют запускать приложения проще тестировать, обслуживать и развиваться. Его можно также значительно улучшают возможности повторного использования кода и позволяет разработчикам и конструкторы пользовательского интерфейса для более тесно сотрудничать при разработке их соответствующих частей приложения.

## <a name="the-mvvm-pattern"></a>Шаблон MVVM

В шаблон MVVM есть три основных компонента: модель, представление и модель представления. Каждый предназначен для различных целей. Рис. 2-1 показаны связи между тремя компонентами.

![](mvvm-images/mvvm.png "Шаблон MVVM")

**Рис. 2-1**: Шаблон MVVM

Помимо понимания задачи каждого из компонентов, также важно понимать, как они взаимодействуют друг с другом. На высоком уровне представление «знает» модели представления, модель представления «знает» модель, но модели не знает о модели представления и знают о представлении модели представления. Таким образом модель представления изолирует представление из модели и позволяет развиваться независимо от представления модели.

Ниже приведены преимущества использования шаблона MVVM.

-   Если есть реализация модели, инкапсулирующий существующую бизнес-логику, бывает сложно или опасных для его изменения. В этом случае модель представления выполняет функции адаптера для классов модели и позволяет избежать внесения основных изменений кода модели.
-   Разработчики могут создавать модульные тесты для модели представления и модель, без использования представления. Модульные тесты для модели представления можно использовать точно же функциональность, что используемые в представлении.
-   В пользовательском Интерфейсе может быть переработано без изменения кода, при условии, что представление реализуется полностью в XAML. Таким образом новая версия представления должны работать с существующей модели представления.
-   Дизайнеры и разработчики могут работать независимо друг от друга и параллельно своих компонентов во время разработки. Разработчики смогут сконцентрироваться на представлении, хотя разработчики могут работать на модели представления и модель компонентов.

Ключом к эффективному использованию MVVM заключается в понимание того, как для разделения кода приложения в вызываемых классов и понять, как взаимодействуют классы. В следующих разделах рассматриваются функциональные обязанности каждого класса в шаблон MVVM.

### <a name="view"></a>Просмотр

Представление несет ответственность за определение структуры, макет и внешний вид, что пользователь видит на экране. В идеале каждое представление определяется в XAML, с ограниченной с выделенным кодом, содержащий бизнес-логики. Однако в некоторых случаях кода может содержать логика пользовательского интерфейса, который реализует визуальное поведение, которые трудно выразить в XAML, такие как анимация.

В приложении Xamarin.Forms, представление — это обычно [ `Page` ](xref:Xamarin.Forms.Page)-производным или [ `ContentView` ](xref:Xamarin.Forms.ContentView)-производного класса. Тем не менее представления также могут быть представлены в шаблон данных, который определяет элементы пользовательского интерфейса, используемый для визуального представления объекта, когда она появится. Шаблон данных как представление не имеет любого кода и предназначена для привязки к определенному представлению типу модели.

> [!TIP]
> Избегайте Включение и отключение элементов пользовательского интерфейса в код программной части. Убедитесь, что просмотр моделей несут ответственность за определение состояния логического изменения, которые влияют на некоторые аспекты отображения представления, например, доступен ли команда или указывает на то что ожидается операция. Таким образом Включение и отключение элементов пользовательского интерфейса с помощью привязки, чтобы просмотреть свойства модели, а не Включение и отключение их в коде программной.

Существует несколько вариантов для выполнения кода на модели представления в ответ на взаимодействие с представлением, таких как нажатие кнопки или выбора элемента. Если элемент управления поддерживает команды, элемент управления `Command` свойства могут быть привязаны к `ICommand` свойство модели представления. При вызове команды элемента управления, будет выполняться код в модели представления. Помимо команды поведения можно подключить к объекту в представлении и может прослушивать событие или вызывать команду. В ответ, можно вызывать поведение `ICommand` на модели представления или метода в модели представления.

### <a name="viewmodel"></a>Модель представления

Модель представления реализует свойства и команды, на которых представление может привязки данных к и уведомляет представление об изменения состояния через события уведомления об изменении. Свойства и команды, которые предоставляет модели представления в определении функциональности предлагаемый пользовательского интерфейса, но представление определяет, как этот подход для отображения.

> [!TIP]
> Синхронизировать пользовательский Интерфейс, быстро реагирующих с асинхронными операциями. Мобильные приложения следует хранить в потоке пользовательского интерфейса, разблокировать, чтобы улучшить восприятие пользователем производительности. Таким образом в модели представления, используйте асинхронные методы для операций ввода-вывода и вызывать события, чтобы асинхронно уведомить представления об изменении свойств.

Модель представления также отвечает за координацию представления взаимодействия с любой классов модели, которые являются обязательными. Обычно устанавливается отношение "один ко многим" между модели представления и классы моделей. Модель представления можно предоставлять классы моделей непосредственно к представлению, чтобы элементы управления в представлении выполнить привязку данных непосредственно к ним. В этом случае классы моделей будет должны быть разработаны для поддержки привязки данных и события уведомления об изменении.

Каждая модель представления предоставляет данные из модели в форме, которую можно легко использовать представление. Чтобы добиться этого, модель представления иногда выполняет преобразование данных. Размещение этого преобразования данных в модели представления, имеет смысл, так как он предоставляет свойства, которые можно привязать представление. Например модель представления может объединить значения из двух свойств, чтобы упростить для отображения в представлении.

> [!TIP]
> Централизация преобразования данных в слой преобразования. Можно также использовать преобразователь как уровень преобразования отдельных данных, которая размещается между модели представления и представления. Это может быть необходимо, например, когда требуется специальное форматирование, которое не предоставляет модели представления данных.

Чтобы участвовать в двухстороннюю привязку данных с представлением модели представления, необходимо изменить его свойства `PropertyChanged` событий. Просмотр моделей удовлетворяют этим требованиям, реализовав `INotifyPropertyChanged` интерфейс и вызов `PropertyChanged` событие при изменении свойства.

Для коллекций, используется понятное представление `ObservableCollection<T>` предоставляется. Эта коллекция применяет изменения коллекции уведомлений, освобождая разработчика от необходимости реализовывать разработчика `INotifyCollectionChanged` интерфейс для коллекций.

### <a name="model"></a>Модель

Классы модели являются невизуальный классов, инкапсулирующих данные приложения. Таким образом модель может рассматриваться как представляющий модели домена приложения, который обычно содержит модель данных, а также проверки и бизнес-логики. Модель объектов относятся объекты передачи данных (DTO), обычные старые объекты CLR (POCO) и созданной сущности и прокси-объектов.

Классы модели обычно используются в сочетании со службами или репозиториев, которые инкапсулируют доступ к данным и кэширования.

## <a name="connecting-view-models-to-views"></a>Подключение к представлениям Просмотр моделей

Просмотр моделей может подключаться к представлениям с помощью Xamarin.Forms возможности привязки данных. Существует множество подходов, которые можно использовать для создания представлений, а также просматривать модели и связывать их во время выполнения. Эти подходы делятся на две категории, называемые первый создание представлений и Создание первой модели представлений. Выбор между первой создание представлений и просматривать композиции первой модели — вопрос предпочтений и сложности. Тем не менее все подходы совместное использование одной целью, являющийся для представления модели представления, для свойства контекста BindingContext.

С представлением первой композиции приложения по сути состоит из представления, которые подключаются к модели представления, для которых они зависят. Основное преимущество такого подхода является то, что он упрощает просто создавать слабо связанных модульного тестирования приложений так, как модели представления имеют зависимость от представления, сами. Это также легко понять структуру приложения, следуя визуальной структуры, вместо того чтобы отслеживать выполнение кода, чтобы понять, как создаются и связанных классов. Кроме того представление первого построения выравнивает по Xamarin.Forms системы навигации, ответственный за создании страницы, когда происходит переход, что упрощает создание первой модели представлений, сложные и невыровненных с платформой.

С представлением модели первой композиции приложения концептуально состоит из модели представлений со службой, отвечает за поиск представления для модели представления. Создание первой модели представлений является более естественным для некоторых разработчиков, так как создание представления могут быть абстрагированы, позволяя им сосредоточиться на структуре логической без пользовательского интерфейса приложения. Кроме того она позволяет Просмотр моделей с другими моделями представления. Тем не менее, этот подход часто бывают сложными и трудно понять, как различные части приложения создаются и связанные.

> [!TIP]
> Оставьте в независимых модели представления и представления. Привязка представления к свойству в источнике данных должен быть представления участника зависимость от его соответствующей модели представления. В частности, не ссылку на представление типов, таких как [ `Button` ](xref:Xamarin.Forms.Button) и [ `ListView` ](xref:Xamarin.Forms.ListView), из модели представления. Следуя принципам, описанным здесь, Просмотр моделей можно протестировать в изоляции, таким образом уменьшая вероятность дефектов программного обеспечения путем ограничения области действия.

В следующих разделах рассматриваются основных подхода к подключению Просмотр моделей с представлениями.

### <a name="creating-a-view-model-declaratively"></a>Создание модели представления декларативно

Самым простым подходом является для представления для декларативного создания экземпляра его соответствующей модели представления в XAML. При создании представления будет также создан соответствующий объект модели представления. Этот подход демонстрируется в следующем примере кода:

```xaml
<ContentPage ... xmlns:local="clr-namespace:eShop">  
    <ContentPage.BindingContext>  
        <local:LoginViewModel />  
    </ContentPage.BindingContext>  
    ...  
</ContentPage>
```

Когда [ `ContentPage` ](xref:Xamarin.Forms.ContentPage) создается экземпляр `LoginViewModel` автоматически создается и задать в качестве представления [ `BindingContext` ](xref:Xamarin.Forms.BindableObject.BindingContext).

Этот декларативный Создание и назначение модели представления в представлении имеет то преимущество, что он прост, но есть недостаток, что требуется конструктор по умолчанию (без параметров) в модели представления.

### <a name="creating-a-view-model-programmatically"></a>Создание модели представления программными средствами

Представление может включать код в файл с выделенным кодом, которое приводит к модели представления, назначаемый его [ `BindingContext` ](xref:Xamarin.Forms.BindableObject.BindingContext) свойство. Это часто выполняется в конструкторе представления, как показано в следующем примере кода:

```csharp
public LoginView()  
{  
    InitializeComponent();  
    BindingContext = new LoginViewModel(navigationService);  
}
```

Программное создание и назначение модели представления в представлении кода имеет то преимущество, что это просто. Однако основной недостаток этого подхода является представлению необходимо предоставить все необходимые зависимости в модели представления. С помощью контейнера внедрения зависимостей может помочь поддерживать ослабить связь между представлением и моделью представления. Дополнительные сведения см. в разделе [внедрения зависимостей](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md).

### <a name="creating-a-view-defined-as-a-data-template"></a>Создание представления, определенного как шаблон данных

Представления можно определить в качестве шаблона данных и связанных с типом модели представления. Шаблоны данных могут быть определены как ресурсы, или они могут быть встроенными в элементе управления, который будет отображать модели представления. Содержимое элемента управления экземпляр модели представления, и шаблон данных используется для визуального представления. Этот метод является примером ситуации, в котором модель представления создается во-первых, после чего представления.

<a name="automatically_creating_a_view_model_with_a_view_model_locator" />

### <a name="automatically-creating-a-view-model-with-a-view-model-locator"></a>Автоматическое создание модели представления с указателем модели представления

Указатель модели представления — пользовательского класса, который управляет созданием экземпляров Просмотр моделей и их связь с представлениями. В мобильном приложении eShopOnContainers `ViewModelLocator` класс имеет присоединенное свойство, `AutoWireViewModel`, который используется для сопоставления модели представлений с представлениями. В представлении XAML это вложенное свойство имеет значение true, чтобы указать, что модель представления должны быть автоматически подключены к представления, как показано в следующем примере кода:

```xaml
viewModelBase:ViewModelLocator.AutoWireViewModel="true"
```

`AutoWireViewModel` Свойство является свойством привязки, присваивается значение false, и при изменении значения `OnAutoWireViewModelChanged` вызывается обработчик события. Этот метод разрешает модели представления для представления. В следующем примере кода показано, как это сделать:

```csharp
private static void OnAutoWireViewModelChanged(BindableObject bindable, object oldValue, object newValue)  
{  
    var view = bindable as Element;  
    if (view == null)  
    {  
        return;  
    }  

    var viewType = view.GetType();  
    var viewName = viewType.FullName.Replace(".Views.", ".ViewModels.");  
    var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName;  
    var viewModelName = string.Format(  
        CultureInfo.InvariantCulture, "{0}Model, {1}", viewName, viewAssemblyName);  

    var viewModelType = Type.GetType(viewModelName);  
    if (viewModelType == null)  
    {  
        return;  
    }  
    var viewModel = _container.Resolve(viewModelType);  
    view.BindingContext = viewModel;  
}
```

`OnAutoWireViewModelChanged` Метод пытается разрешить модели представления, используя подход на основе соглашения. Это соглашение предполагается, что:

-   Просмотр моделей находятся в той же сборке, как типы представлений.
-   Представления находятся в. Дочернее пространство имен представлений.
-   Просмотр моделей находятся в. Дочернее пространство имен ViewModels.
-   Просмотр модели имена соответствуют имена представлений и последним символом «ViewModel».

Наконец `OnAutoWireViewModelChanged` метода задает [ `BindingContext` ](xref:Xamarin.Forms.BindableObject.BindingContext) типа представления для типа модели Разрешить представления. Дополнительные сведения о разрешении типа модели представления, см. в разделе [разрешение](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md#resolution).

Этот подход имеет преимущество, что приложение имеет один класс, отвечающий за создание экземпляров Просмотр моделей и их подключение к представлениям.

> [!TIP]
> Используйте указатель модели представления для удобства подстановки. Локатора модели представления можно также использоваться как точки замены альтернативных реализаций зависимости, такие как для данных временных модульного тестирования или разработки.

## <a name="updating-views-in-response-to-changes-in-the-underlying-view-model-or-model"></a>Просмотреть обновления представления в ответ на изменения в базовой модели или модели

Все модели представления и классы моделей, доступных для представления следует реализовать `INotifyPropertyChanged` интерфейс. Реализация этого интерфейса в модели представления или класс модели позволяет класс для получения уведомлений об изменениях любые элементы управления с привязкой к данным в представлении, при изменении базового значения свойства.

Приложения должны быть разработана для правильного использования уведомления об изменении свойства, с учетом следующих требований:

-   Всегда вызов `PropertyChanged` событие при изменении значения открытое свойство. Не следует предполагать, что вызов `PropertyChanged` событий может быть пропущено из-за знания о том, как происходит привязка XAML.
-   Всегда вызов `PropertyChanged` событий для любого вычисляемые свойства, значения которых используются другие свойства в представлении модели или модели.
-   Всегда вызов `PropertyChanged` событие в конце метода, который позволяет изменить свойства, или когда происходит обращение к объекту в безопасном состоянии. Порождает событие прерывает операцию путем вызова обработчиков событий синхронно. Если это происходит в процессе выполнения операции, может предоставлять объект функции обратного вызова, когда он находится в состоянии unsafe, частично обновленный. Кроме того, существует возможность каскадных изменений, которое будет вызвано `PropertyChanged` события. Как правило, каскадные изменения требуют обновлений быть завершена, прежде чем каскадных изменений является безопасным для выполнения.
-   Никогда не вызов `PropertyChanged` событие, если свойство не будет изменяться. Это означает, что необходимо сравнить старое и новое значения перед порождением `PropertyChanged` событий.
-   Никогда не вызов `PropertyChanged` событие при выполнении конструктор модели представления при инициализации свойства. Элементы управления с привязкой данных в представлении будет не подписаны на этом этапе получать уведомления об изменениях.
-   Никогда не более одного вызова `PropertyChanged` событие с тем же аргументом имя свойства в один синхронный вызов общего метода класса. Например, если `NumberOfItems` резервным хранилищем которого является свойство `_numberOfItems` поле, если метода увеличивает `_numberOfItems` 50 раз во время выполнения цикла, он должен только вызывать уведомление об изменении свойства на `NumberOfItems` один раз, свойство После завершения всех действий. Асинхронные методы вызывают `PropertyChanged` событие для данного имени свойства в каждом сегменте синхронной цепочки асинхронное продолжение.

Мобильное приложение eShopOnContainers использует `ExtendedBindableObject` класс для предоставления уведомления об изменении, как показано в следующем примере кода:

```csharp
public abstract class ExtendedBindableObject : BindableObject  
{  
    public void RaisePropertyChanged<T>(Expression<Func<T>> property)  
    {  
        var name = GetMemberInfo(property).Name;  
        OnPropertyChanged(name);  
    }  

    private MemberInfo GetMemberInfo(Expression expression)  
    {  
        ...  
    }  
}
```

В Xamarin.Form [ `BindableObject` ](xref:Xamarin.Forms.BindableObject) класс реализует `INotifyPropertyChanged` интерфейсов и предоставляет [ `OnPropertyChanged` ](xref:Xamarin.Forms.BindableObject.OnPropertyChanged(System.String)) метод. `ExtendedBindableObject` Класс предоставляет `RaisePropertyChanged` метод, который вызывается свойство уведомления об изменениях и при этом использует функциональные возможности, предоставляемые `BindableObject` класса.

Каждый класс модели представления в мобильном приложении eShopOnContainers является производным от `ViewModelBase` класс, который в свою очередь является производным от `ExtendedBindableObject` класса. Таким образом, каждый класс модели представления используется `RaisePropertyChanged` метод в `ExtendedBindableObject` класс для предоставления уведомления об изменении свойства. В следующем примере кода показано, как мобильное приложение eShopOnContainers вызывает уведомления об изменении свойства, используя лямбда-выражения:

```csharp
public bool IsLogin  
{  
    get  
    {  
        return _isLogin;  
    }  
    set  
    {  
        _isLogin = value;  
        RaisePropertyChanged(() => IsLogin);  
    }  
}
```

Обратите внимание на то, что подобное использование лямбда-выражение включает в себя низкой производительности, так как лямбда-выражение должно вычисляться для каждого вызова. Несмотря на то, что снижение производительности мал и не повлияет на обычно приложения, можно провести затраты, при, что многие уведомления об изменении. Тем не менее преимущество этого подхода заключается в обеспечении безопасности типов во время компиляции и оптимизации кода при переименовании свойства.

## <a name="ui-interaction-using-commands-and-behaviors"></a>Взаимодействие с пользовательским Интерфейсом с помощью команд и поведения

В мобильных приложениях действия обычно вызываются в ответ на действия пользователя, например нажатие кнопки, который можно реализовать путем создания обработчика событий в файл с выделенным кодом. Тем не менее в шаблон MVVM, ответственных за реализацию действия связаны с модели представления и следует избегать размещения кода в код программной части.

Команды предоставляют удобный способ представляют действия, которые могут быть привязаны к элементам управления в пользовательском Интерфейсе. Они инкапсулируют код, который реализует действие и помогают обеспечить его отделены от его визуальное представление, в представлении. Xamarin.Forms включает в себя элементы управления, которые можно декларативно подключать к команде, и эти элементы управления вызовет команду, когда пользователь взаимодействует с элементом управления.

Поведение также позволяет элементам управления декларативно быть подключены к команде. Тем не менее можно использовать поведения для вызова действия, связанный с диапазоном событий, вызываемых элементом управления. Таким образом поведение решать многие из сценариев, где элементы управления с поддержкой команды, обеспечивая большую степень гибкости и контроля. Кроме того поведение также можно использоваться для присоединения к ним объекты команд или методы, которые не были специально разработаны для взаимодействия с помощью команд.

### <a name="implementing-commands"></a>Реализация команд

Просмотр моделей обычно предоставляют свойства команды, для привязки из представления, которые являются экземплярами объектов, реализующих `ICommand` интерфейс. Предоставляют ряд элементов управления Xamarin.Forms `Command` , который может быть данных, привязанное к `ICommand` объекта, предоставляемого модели представления. `ICommand` Интерфейс определяет `Execute` метод, который инкапсулирует самой операции, `CanExecute` метод, который указывает, действительно ли команда может быть вызвана и `CanExecuteChanged` событие, возникающее при внесении изменений, влияющих на ли будет выполняться. [ `Command` ](xref:Xamarin.Forms.Command) И [ `Command<T>` ](xref:Xamarin.Forms.Command) реализовать классы, предоставляемые Xamarin.Forms, `ICommand` интерфейс, где `T` — это тип аргументов `Execute`и `CanExecute`.

В модели представления, должно быть объектом типа [ `Command` ](xref:Xamarin.Forms.Command) или [ `Command<T>` ](xref:Xamarin.Forms.Command) для каждого открытого свойства в модели представления типа `ICommand`. `Command` Или `Command<T>` конструктор требует `Action` объект обратного вызова, который вызывается, когда `ICommand.Execute` вызывается метод. `CanExecute` Метод — конструктор необязательный параметр и является `Func` , возвращающий `bool`.

В следующем коде показано, как [ `Command` ](xref:Xamarin.Forms.Command) экземпляр, который представляет команду register, создается путем указания делегат `Register` просмотра модели метода:

```csharp
public ICommand RegisterCommand => new Command(Register);
```

Команда предоставляется представлению через свойство, возвращающее ссылку на `ICommand`. Когда `Execute` вызывается метод [ `Command` ](xref:Xamarin.Forms.Command) объекта, он только передает вызов метода в модели представления через делегат, который был указан в `Command` конструктор.

Асинхронный метод может вызываться с помощью команды с помощью `async` и `await` ключевые слова, при указании команды `Execute` делегировать. Это означает, что обратный вызов `Task` и следует ожидать. Например, в следующем коде показано, как [ `Command` ](xref:Xamarin.Forms.Command) экземпляр, который представляет команду, входа в систему, создается путем указания делегат `SignInAsync` просмотра модели метода:

```csharp
public ICommand SignInCommand => new Command(async () => await SignInAsync());
```

Параметры могут быть переданы `Execute` и `CanExecute` действия с помощью [ `Command<T>` ](xref:Xamarin.Forms.Command) класс для создания команды. Например, в следующем коде показано, как `Command<T>` экземпляр используется для указания того, что `NavigateAsync` метод потребует аргумент типа `string`:

```csharp
public ICommand NavigateCommand => new Command<string>(NavigateAsync);
```

В обоих [ `Command` ](xref:Xamarin.Forms.Command) и [ `Command<T>` ](xref:Xamarin.Forms.Command) классы, делегат, который `CanExecute` метод в каждом конструкторе является необязательным. Если делегат не задано, `Command` вернет `true` для `CanExecute`. Тем не менее, модель представления можно указать изменения в команды `CanExecute` состояния путем вызова `ChangeCanExecute` метод `Command` объекта. В результате `CanExecuteChanged` возникает событие. Все элементы управления в пользовательском Интерфейсе, привязанные к команде обновляют их включенное состояние доступности команды привязкой к данным.

#### <a name="invoking-commands-from-a-view"></a>Вызов команд из представления

В следующем примере кода как [ `Grid` ](xref:Xamarin.Forms.Grid) в `LoginView` привязывается к `RegisterCommand` в `LoginViewModel` , используя [ `TapGestureRecognizer` ](xref:Xamarin.Forms.TapGestureRecognizer) экземпляр:

```xaml
<Grid Grid.Column="1" HorizontalOptions="Center">  
    <Label Text="REGISTER" TextColor="Gray"/>  
    <Grid.GestureRecognizers>  
        <TapGestureRecognizer Command="{Binding RegisterCommand}" NumberOfTapsRequired="1" />  
    </Grid.GestureRecognizers>  
</Grid>
```

Параметр команды также можно при необходимости определить с помощью [ `CommandParameter` ](xref:Xamarin.Forms.TapGestureRecognizer.CommandParameter) свойство. Тип ожидаемого аргумента указывается в `Execute` и `CanExecute` целевых методов. [ `TapGestureRecognizer` ](xref:Xamarin.Forms.TapGestureRecognizer) Автоматически будет вызывать команду target, когда пользователь взаимодействует с присоединенного элемента управления. Параметр команды, если указано, будет передан в качестве аргумента команды `Execute` делегировать.

<a name="implementing_behaviors" />

### <a name="implementing-behaviors"></a>Реализация поведения

Поведение позволяет функциональные возможности для добавления элементов управления пользовательского интерфейса без необходимости подкласс их. Функциональность реализуется в классе реакции на событие и присоединяется к элементу управления так, как если бы она была его частью. Поведения позволяют реализовать код, который обычно пришлось бы записывать в виде кода программной части, так как она взаимодействует напрямую с помощью элемента управления, так что его можно кратко присоединенных к элементу управления и упаковать для повторного использования на более чем одной представления или приложение API. В контексте MVVM поведения являются полезным подходом для к команды элементов управления.

Поведение, которое присоединяется к элементу управления через вложенные свойства называется *подключить поведение*. Поведение можно использовать предоставленные API элемента, к которому он присоединен Добавление функциональных возможностей элемента управления или других элементов управления в визуальном дереве представления. Мобильное приложение eShopOnContainers содержит `LineColorBehavior` класс, который является присоединенного поведением. Дополнительные сведения об этом поведении см. в разделе [отображение ошибок проверки](~/xamarin-forms/enterprise-application-patterns/validation.md#displaying_validation_errors).

Поведение Xamarin.Forms — это класс, производный от [ `Behavior` ](xref:Xamarin.Forms.Behavior) или [ `Behavior<T>` ](xref:Xamarin.Forms.Behavior`1) класса, где `T `является тип элемента управления, к которому следует применить поведение. Эти классы предоставляют `OnAttachedTo` и `OnDetachingFrom` методы, которые следует переопределить, чтобы предоставить логику, которая будет выполняться при поведение, подключенный к и отсоединить от элементов управления.

В мобильном приложении eShopOnContainers `BindableBehavior<T>` класс является производным от [ `Behavior<T>` ](xref:Xamarin.Forms.Behavior`1) класса. Цель `BindableBehavior<T>` класса заключается в предоставлении базовый класс для реакции на событие Xamarin.Forms, требующих [ `BindingContext` ](xref:Xamarin.Forms.BindableObject.BindingContext) поведения будет присвоено присоединенного элемента управления.

`BindableBehavior<T>` Класс предоставляет переопределяемый `OnAttachedTo` метод, который задает [ `BindingContext` ](xref:Xamarin.Forms.BindableObject.BindingContext) поведение и переопределяемым `OnDetachingFrom` метод, который очищает `BindingContext`. Кроме того, класс хранит ссылку на присоединенный элемент управления в свойстве `AssociatedObject`.

В мобильном приложении eShopOnContainers включает `EventToCommandBehavior` класс, который выполняет команду в соответствии с событием. Этот класс является производным от `BindableBehavior<T>` таким образом, поведение можно привязать к и выполнить `ICommand` определяется `Command` свойства при использовании поведения. Следующий пример кода демонстрирует класс `EventToCommandBehavior`:

```csharp
public class EventToCommandBehavior : BindableBehavior<View>  
{  
    ...  
    protected override void OnAttachedTo(View visualElement)  
    {  
        base.OnAttachedTo(visualElement);  

        var events = AssociatedObject.GetType().GetRuntimeEvents().ToArray();  
        if (events.Any())  
        {  
            _eventInfo = events.FirstOrDefault(e => e.Name == EventName);  
            if (_eventInfo == null)  
                throw new ArgumentException(string.Format(  
                        "EventToCommand: Can't find any event named '{0}' on attached type",   
                        EventName));  

            AddEventHandler(_eventInfo, AssociatedObject, OnFired);  
        }  
    }  

    protected override void OnDetachingFrom(View view)  
    {  
        if (_handler != null)  
            _eventInfo.RemoveEventHandler(AssociatedObject, _handler);  

        base.OnDetachingFrom(view);  
    }  

    private void AddEventHandler(  
            EventInfo eventInfo, object item, Action<object, EventArgs> action)  
    {  
        ...  
    }  

    private void OnFired(object sender, EventArgs eventArgs)  
    {  
        ...  
    }  
}
```

`OnAttachedTo` И `OnDetachingFrom` методы используются для регистрации и отмены регистрации обработчик событий для события, определенного в `EventName` свойство. Теперь, когда событие запускается, `OnFired` вызывается метод, который выполняет команду.

Преимущество использования `EventToCommandBehavior` для выполнения команды в том случае, когда создается событие, является, что команды могут быть связаны с элементами управления, которые не были предназначены для взаимодействия с помощью команд. Кроме того оно перемещает код обработки событий Просмотр моделей, где можно подвергать модульному тестированию.

#### <a name="invoking-behaviors-from-a-view"></a>Вызов поведения из представления

`EventToCommandBehavior` Особенно полезна для подключение команды к элементу управления, который не поддерживает команды. Например `ProfileView` использует `EventToCommandBehavior` для выполнения `OrderDetailCommand` при [ `ItemTapped` ](xref:Xamarin.Forms.ListView.ItemTapped) событие запускается на [ `ListView` ](xref:Xamarin.Forms.ListView) , содержащая список заказов для пользователя, как показано в следующем коде:

```xaml
<ListView>  
    <ListView.Behaviors>  
        <behaviors:EventToCommandBehavior             
            EventName="ItemTapped"  
            Command="{Binding OrderDetailCommand}"  
            EventArgsConverter="{StaticResource ItemTappedEventArgsConverter}" />  
    </ListView.Behaviors>  
    ...  
</ListView>
```

Во время выполнения `EventToCommandBehavior` будет отвечать на действия с [ `ListView` ](xref:Xamarin.Forms.ListView). При выборе элемента в `ListView`, [ `ItemTapped` ](xref:Xamarin.Forms.ListView.ItemTapped) событие будет срабатывать, которой будет выполнен `OrderDetailCommand` в `ProfileViewModel`. По умолчанию аргументы события для события передаются в команду. Эти данные преобразуются при передаче между источником и целью конвертера, указанный в `EventArgsConverter` свойство, которое возвращает [ `Item` ](xref:Xamarin.Forms.ItemTappedEventArgs.Item) из `ListView` из [ `ItemTappedEventArgs` ](xref:Xamarin.Forms.ItemTappedEventArgs). Таким образом, когда `OrderDetailCommand` выполнения выбранного `Order` передается как параметр зарегистрированных действий.

Дополнительные сведения о поведениях см. в разделе [поведения](~/xamarin-forms/app-fundamentals/behaviors/index.md).

## <a name="summary"></a>Сводка

Шаблон Model-View-ViewModel (MVVM) помогает четко отделить бизнеса и логику представления приложения из его пользовательский интерфейс (UI). Поддержание четкое разделение между логикой приложения и пользовательский Интерфейс помогает решить множество проблем разработки и позволяют запускать приложения проще тестировать, обслуживать и развиваться. Его можно также значительно улучшают возможности повторного использования кода и позволяет разработчикам и конструкторы пользовательского интерфейса для более тесно сотрудничать при разработке их соответствующих частей приложения.

С помощью MVVM узор, пользовательский Интерфейс приложения и базовая представления и бизнес-логика разделена на три различных класса: представление, которое инкапсулирует пользовательского интерфейса и пользовательского интерфейса логики; модель представления, который инкапсулирует логику представления и состоянии; и модель, которая инкапсулирует бизнес-логику и данные приложения.


## <a name="related-links"></a>Связанные ссылки

- [Скачайте электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
