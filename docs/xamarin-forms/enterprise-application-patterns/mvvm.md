---
title: Шаблон Model-View-ViewModel
description: В этой главе объясняется, как мобильное приложение eShopOnContainers использует шаблон MVVM для четкого отделения логики бизнеса и представления приложения от пользовательского интерфейса.
ms.prod: xamarin
ms.assetid: dd8c1813-df44-4947-bcee-1a1ff2334b87
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: d6c9b74c9abc1a2c493c31699b52969a7d129429
ms.sourcegitcommit: eca3b01098dba004d367292c8b0d74b58c4e1206
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/13/2020
ms.locfileid: "79306383"
---
# <a name="the-model-view-viewmodel-pattern"></a>Шаблон Model-View-ViewModel

Процесс разработки Xamarin. Forms обычно включает в себя создание пользовательского интерфейса в XAML, а затем Добавление кода программной части, которое работает в пользовательском интерфейсе. При изменении приложений и увеличении размера и области действия могут возникать сложные проблемы обслуживания. Эти проблемы включают тесную связь между элементами управления пользовательского интерфейса и бизнес-логикой, что увеличивает затраты на внесение изменений пользовательского интерфейса и сложность модульного тестирования такого кода.

Шаблон Model-View-ViewModel (MVVM) позволяет четко отделить бизнес-логику и представление представления приложения от пользовательского интерфейса. Поддержание чистого разделения логики приложения и пользовательского интерфейса помогает устранить многочисленные проблемы разработки и упростить тестирование, Обслуживание и развитие приложения. Она также может значительно улучшить возможности повторного использования кода и позволяет разработчикам и дизайнерам пользовательского интерфейса упростить совместную работу при разработке соответствующих частей приложения.

## <a name="the-mvvm-pattern"></a>Шаблон MVVM

В шаблоне MVVM есть три основных компонента: модель, представление и модель представления. Каждый из них обслуживает отдельную цель. На рис. 2-1 показаны связи между тремя компонентами.

![](mvvm-images/mvvm.png "The MVVM pattern")

**Рис. 2-1**. шаблон MVVM

Кроме понимания обязанностей каждого компонента, важно понимать, как они взаимодействуют друг с другом. На высоком уровне в представлении «известно о модели представления и модели представления» известно о модели, но модель не знает модель представления, а модель представления не знает об этом представлении. Таким образом, модель представления изолирует представление от модели и позволяет модели развиваться независимо от представления.

Ниже приведены преимущества использования шаблона MVVM.

- Если реализована существующая реализация модели, которая инкапсулирует существующую бизнес-логику, она может быть сложной или рискованной для ее изменения. В этом сценарии модель представления выступает в качестве адаптера для классов модели и позволяет избежать внесения значительных изменений в код модели.
- Разработчики могут создавать модульные тесты для модели представления и модели без использования представления. Модульные тесты для модели представления могут выполнять точно те же функциональные возможности, которые используются в представлении.
- Пользовательский интерфейс приложения можно переконструировать, не затрагивая код, при условии, что представление полностью реализовано в XAML. Поэтому Новая версия представления должна работать с существующей моделью представления.
- Разработчики и разработчики могут одновременно работать с компонентами в процессе разработки. Дизайнеры могут сосредоточиться на представлении, тогда как разработчики могут работать над моделью представления и компонентами модели.

Ключ к использованию MVVM эффективно полагается на понимание того, как разделить код приложения на правильные классы и как понять, как взаимодействуют классы. В следующих разделах рассматриваются обязанности каждого класса в шаблоне MVVM.

### <a name="view"></a>Вид

Представление отвечает за определение структуры, макета и внешнего вида того, что видит пользователь на экране. В идеале каждое представление определяется в XAML с ограниченным кодом программной части, который не содержит бизнес-логику. Однако в некоторых случаях код программной части может содержать логику пользовательского интерфейса, которая реализует визуальное поведение, которое сложно выразить в XAML, например анимации.

В приложении Xamarin. Forms представление обычно является производным от [`Page`](xref:Xamarin.Forms.Page)или [`ContentView`](xref:Xamarin.Forms.ContentView)производным от него классом. Однако представления также могут быть представлены шаблоном данных, который указывает элементы пользовательского интерфейса, используемые для визуального представления объекта при его отображении. Шаблон данных в качестве представления не имеет кода программной части и предназначен для привязки к определенному типу модели представления.

> [!TIP]
> Избегайте включения и отключения элементов пользовательского интерфейса в коде программной части. Убедитесь, что модели представления отвечают за определение логических изменений состояния, влияющих на некоторые аспекты отображения представления, например, доступна ли команда, или указывает, что операция находится в состоянии ожидания. Таким образом, можно включить и отключить элементы пользовательского интерфейса путем привязки для просмотра свойств модели, а не включать и отключать их в коде программной части.

Существует несколько вариантов для запуска кода в модели представления в ответ на взаимодействия в представлении, например нажатие кнопки или выбор элемента. Если элемент управления поддерживает команды, свойство `Command` элемента управления может быть привязано к данным свойства `ICommand` в модели представления. При вызове команды элемента управления будет выполнен код в модели представления. В дополнение к командам, поведения могут быть присоединены к объекту в представлении и могут прослушивать либо вызываемую команду, либо вызываемое событие. В ответ это поведение может вызвать `ICommand` для модели представления или метода в модели представления.

### <a name="viewmodel"></a>ViewModel

Модель представления реализует свойства и команды, к которым может быть привязано представление данных, и уведомляет представление о любых изменениях состояния с помощью событий уведомления об изменениях. Свойства и команды, предоставляемые моделью представления, определяют функциональные возможности, предоставляемые пользовательским интерфейсом, но представление определяет, как эти функции должны отображаться.

> [!TIP]
> Обеспечьте реагирование пользовательского интерфейса с помощью асинхронных операций. В мобильных приложениях поток пользовательского интерфейса должен оставаться незаблокированным, чтобы повысить производительность пользователя. Таким образом, в модели представления используйте асинхронные методы для операций ввода-вывода и инициируйте события для асинхронного уведомления представлений об изменениях свойств.

Модель представления также отвечает за координацию взаимодействия представления с любыми необходимыми классами модели. Как правило, существует связь «один ко многим» между моделью представления и классами модели. Модель представления может предоставить доступ к классам модели непосредственно в представлении, чтобы элементы управления в представлении могли привязывать данные к ним напрямую. В этом случае классы модели должны быть спроектированы для поддержки привязки данных и событий уведомления об изменении.

Каждая модель представления предоставляет данные из модели в форме, которую представление может легко использовать. Для этого модель представления иногда выполняет преобразование данных. Размещение этого преобразования данных в модели представления является хорошей идеей, поскольку она предоставляет свойства, к которым может быть привязано представление. Например, модель представления может сочетать значения двух свойств, чтобы упростить отображение представления.

> [!TIP]
> Централизация преобразований данных на уровне преобразования. Кроме того, преобразователи можно использовать как отдельный слой преобразования данных, расположенный между моделью представления и представлением. Это может быть необходимо, например, когда для данных требуется специальное форматирование, не предоставляемое моделью представления.

Чтобы модель представления принимала участие в двусторонней привязке данных с представлением, ее свойства должны вызывать событие `PropertyChanged`. Модель представления удовлетворяет этому требованию, реализуя интерфейс `INotifyPropertyChanged` и вызывая событие `PropertyChanged` при изменении свойства.

Для коллекций предоставляется `ObservableCollection<T>`, удобное для просмотра. Эта коллекция реализует уведомление об изменении коллекции, освобождая разработчика разработчику от необходимости реализовывать интерфейс `INotifyCollectionChanged` в коллекциях.

### <a name="model"></a>Модель

Классы моделей — это классы, не являющиеся визуальными, которые инкапсулируют данные приложения. Таким образом, модель можно рассматривать как представление модели предметной области приложения, которая обычно включает в себя модель данных, а также логику бизнес-процессов и проверки. Примерами объектов модели являются объекты перемещения данных (DTO), обычные старые объекты CLR (POCO), а затем созданные объекты сущностей и прокси-объектов.

Классы модели обычно используются совместно со службами или репозиториями, которые инкапсулируют доступ к данным и кэширование.

## <a name="connecting-view-models-to-views"></a>Подключение представлений моделей к представлениям

Модели представления можно подключать к представлениям с помощью возможностей привязки данных Xamarin. Forms. Существует множество подходов, которые можно использовать для создания представлений и просмотра моделей и их связывания во время выполнения. Эти подходы делятся на две категории, называемые «Просмотр первой композиции» и «Просмотр первой структуры модели». Выбор между просмотром первой композиции и просмотром модели First композиция является проблемой предпочтения и сложности. Однако все подходы используют одну и ту же цель, то есть представление может иметь модель представления, назначенную ее свойству BindingContext.

С просмотром первой композиции приложение концептуально состоит из представлений, которые подключаются к моделям, от которых они зависят. Основное преимущество этого подхода заключается в том, что он позволяет легко создавать слабо связанные приложения с модульным тестированием, поскольку модели представления не имеют зависимости от самих представлений. Также можно легко понять структуру приложения, следуя его визуальной структуре, а не отслеживанию выполнения кода, чтобы понять, как создаются и связываются классы. Кроме того, представление первая конструкция соответствует системе навигации Xamarin. Forms, которая отвечает за создание страниц при переходе, что делает модель представления первой сложной и неправильно согласованной с платформой.

С помощью представления «Просмотр модели» сначала приложение концептуально состоит из моделей представления, а служба отвечает за поиск представления для модели представления. Просмотр первой структуры модели более естественна для некоторых разработчиков, так как создание представления может быть абстрактным, что позволяет им сосредоточиться на логической структуре приложения без пользовательского интерфейса. Кроме того, он позволяет создавать модели представления в других моделях представления. Однако этот подход часто сложен и может быть трудно понять, как создаются и связываются различные части приложения.

> [!TIP]
> Обеспечьте независимость моделей и представлений представления. Привязка представлений к свойству в источнике данных должна быть зависимостью основного представления от соответствующей модели представления. В частности, не следует ссылаться на типы представлений, такие как [`Button`](xref:Xamarin.Forms.Button) и [`ListView`](xref:Xamarin.Forms.ListView), из моделей представления. Следуя описанным здесь принципам, можно протестировать модели представления, таким образом уменьшая вероятность дефектов программного обеспечения, ограничивая область.

В следующих разделах обсуждаются основные подходы к подключению моделей представления к представлениям.

### <a name="creating-a-view-model-declaratively"></a>Декларативное создание модели представления

Самый простой подход заключается в том, чтобы представление декларативно создавало соответствующую модель представления в XAML. При создании представления также будет создан соответствующий объект модели представления. Этот подход демонстрируется в следующем примере кода:

```xaml
<ContentPage ... xmlns:local="clr-namespace:eShop">  
    <ContentPage.BindingContext>  
        <local:LoginViewModel />  
    </ContentPage.BindingContext>  
    ...  
</ContentPage>
```

При создании [`ContentPage`](xref:Xamarin.Forms.ContentPage) экземпляр `LoginViewModel` автоматически создается и задается как [`BindingContext`](xref:Xamarin.Forms.BindableObject.BindingContext)представления.

Эта декларативная конструкция и назначение модели представления в представлении имеют преимущество, что оно просто, но имеет недостаток, что в модели представления требуется конструктор по умолчанию (без параметров).

### <a name="creating-a-view-model-programmatically"></a>Создание модели представления программным способом

Представление может содержать код в файле кода программной части, в результате чего модель представления назначается свойству [`BindingContext`](xref:Xamarin.Forms.BindableObject.BindingContext) . Часто это делается в конструкторе представления, как показано в следующем примере кода:

```csharp
public LoginView()  
{  
    InitializeComponent();  
    BindingContext = new LoginViewModel(navigationService);  
}
```

Программное создание и назначение модели представления в коде программной части представления имеет преимущество, что оно просто. Однако основным недостатком этого подхода является то, что представление должно предоставить модель представления с любыми необходимыми зависимостями. Использование контейнера внедрения зависимостей помогает поддерживать слабую связь между представлением и моделью представления. Дополнительные сведения см. в разделе [внедрение зависимостей](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md).

### <a name="creating-a-view-defined-as-a-data-template"></a>Создание представления, определенного как шаблон данных

Представление может быть определено как шаблон данных и связано с типом модели представления. Шаблоны данных могут быть определены как ресурсы или могут быть определены встроенными в элементе управления, который будет отображать модель представления. Содержимым элемента управления является экземпляр модели представления, и шаблон данных используется для визуального представления. Этот метод является примером ситуации, в которой сначала создается экземпляр модели представления, а затем ее создание.

<a name="automatically_creating_a_view_model_with_a_view_model_locator" />

### <a name="automatically-creating-a-view-model-with-a-view-model-locator"></a>Автоматическое создание модели представления с указателем на представление модели

Указатель модели представления — это пользовательский класс, который управляет созданием экземпляров моделей представления и их взаимосвязью с представлениями. В мобильном приложении eShopOnContainers класс `ViewModelLocator` имеет присоединенное свойство `AutoWireViewModel`, которое используется для связывания моделей представления с представлениями. В XAML представления этому присоединенному свойству присваивается значение true, чтобы указать, что модель представления должна автоматически подключаться к представлению, как показано в следующем примере кода:

```xaml
viewModelBase:ViewModelLocator.AutoWireViewModel="true"
```

Свойство `AutoWireViewModel` является связываемым свойством, которое инициализируется значением false, а при изменении его значения вызывается обработчик событий `OnAutoWireViewModelChanged`. Этот метод разрешает модель представления для представления. В следующем примере кода показано, как это достигается:

```csharp
private static void OnAutoWireViewModelChanged(BindableObject bindable, object oldValue, object newValue)  
{  
    var view = bindable as Element;  
    if (view == null)  
    {  
        return;  
    }  

    var viewType = view.GetType();  
    var viewName = viewType.FullName.Replace(".Views.", ".ViewModels.");  
    var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName;  
    var viewModelName = string.Format(  
        CultureInfo.InvariantCulture, "{0}Model, {1}", viewName, viewAssemblyName);  

    var viewModelType = Type.GetType(viewModelName);  
    if (viewModelType == null)  
    {  
        return;  
    }  
    var viewModel = _container.Resolve(viewModelType);  
    view.BindingContext = viewModel;  
}
```

Метод `OnAutoWireViewModelChanged` пытается разрешить модель представления, используя подход на основе соглашения. В этом соглашении предполагается, что:

- Модели представления находятся в той же сборке, что и типы представлений.
- Представления находятся в. Дочернее пространство имен views.
- Модели представления находятся в. Дочернее пространство имен ViewModel.
- Просмотрите имена моделей, соответствующие именам представлений и заканчивающиеся на "ViewModel".

Наконец, метод `OnAutoWireViewModelChanged` устанавливает [`BindingContext`](xref:Xamarin.Forms.BindableObject.BindingContext) типа представления в разрешенный тип модели представления. Дополнительные сведения о разрешении типа модели представления см. в разделе [разрешение](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md#resolution).

Этот подход имеет преимущество, так как у приложения есть один класс, отвечающий за создание экземпляров моделей представления и их подключение к представлениям.

> [!TIP]
> Используйте локатор модели представления для простоты подстановки. Указатель модели представления можно также использовать в качестве точки подстановки для альтернативных реализаций зависимостей, например для модульного тестирования или данных времени разработки.

## <a name="updating-views-in-response-to-changes-in-the-underlying-view-model-or-model"></a>Обновление представлений в ответ на изменения в базовой модели или модели представления

Все модели представления и классы моделей, доступные для представления, должны реализовывать интерфейс `INotifyPropertyChanged`. Реализация этого интерфейса в модели представления или классе модели позволяет классу предоставлять уведомления об изменениях для любых элементов управления с привязкой к данным в представлении при изменении значения базового свойства.

Приложения должны быть спроектированы для правильного использования уведомлений об изменении свойств путем соблюдения следующих требований.

- Всегда вызывая событие `PropertyChanged` при изменении значения общего свойства. Не следует рассчитывать на то, что вызов события `PropertyChanged` можно игнорировать из-за знаний о том, как происходит привязка XAML.
- Всегда вызывая событие `PropertyChanged` для всех вычисляемых свойств, значения которых используются другими свойствами модели представления или модели.
- Всегда вызывая событие `PropertyChanged` в конце метода, который изменяет свойство, или, если известно, что объект находится в надежном состоянии. Вызов события прерывает операцию, вызывая обработчики события синхронно. Если это происходит в середине операции, он может предоставить объекту функции обратного вызова, если он находится в ненадежном состоянии с частичным обновлением. Кроме того, каскадные изменения можно активировать с помощью `PropertyChanged` событий. Каскадные изменения обычно потребует завершения обновлений, прежде чем каскадное изменение станет ненадежным для выполнения.
- Никогда не вызывая событие `PropertyChanged`, если свойство не изменяется. Это означает, что перед вызовом события `PropertyChanged` необходимо сравнить старые и новые значения.
- Никогда не вызывая событие `PropertyChanged` во время конструктора модели представления при инициализации свойства. На этом этапе элементы управления с привязкой к данным в представлении не будут подписаны на получение уведомлений об изменениях.
- Никогда не вызывая более одного `PropertyChanged` события с одним и тем же аргументом имени свойства в рамках одного синхронного вызова открытого метода класса. Например, при наличии свойства `NumberOfItems`, резервное хранилище которого является `_numberOfItems` полем, если метод увеличивает `_numberOfItems` 50 раз во время выполнения цикла, он должен только вызвать уведомление об изменении свойства в свойстве `NumberOfItems`, после завершения всей работы. Для асинхронных методов вызовите событие `PropertyChanged` для заданного имени свойства в каждом синхронном сегменте асинхронной цепочки продолжений.

Мобильное приложение eShopOnContainers использует класс `ExtendedBindableObject` для предоставления уведомлений об изменениях, который показан в следующем примере кода:

```csharp
public abstract class ExtendedBindableObject : BindableObject  
{  
    public void RaisePropertyChanged<T>(Expression<Func<T>> property)  
    {  
        var name = GetMemberInfo(property).Name;  
        OnPropertyChanged(name);  
    }  

    private MemberInfo GetMemberInfo(Expression expression)  
    {  
        ...  
    }  
}
```

Класс [`BindableObject`](xref:Xamarin.Forms.BindableObject) Xamarin. Form реализует интерфейс `INotifyPropertyChanged` и предоставляет метод [`OnPropertyChanged`](xref:Xamarin.Forms.BindableObject.OnPropertyChanged(System.String)) . Класс `ExtendedBindableObject` предоставляет метод `RaisePropertyChanged` для вызова уведомления об изменении свойства, и в этом случае использует функциональные возможности, предоставляемые классом `BindableObject`.

Каждый класс модели представления в мобильном приложении eShopOnContainers является производным от класса `ViewModelBase`, который, в свою очередь, является производным от класса `ExtendedBindableObject`. Таким образом, каждый класс модели представления использует метод `RaisePropertyChanged` в классе `ExtendedBindableObject` для предоставления уведомления об изменении свойства. В следующем примере кода показано, как мобильное приложение eShopOnContainers вызывает уведомление об изменении свойства с помощью лямбда-выражения:

```csharp
public bool IsLogin  
{  
    get  
    {  
        return _isLogin;  
    }  
    set  
    {  
        _isLogin = value;  
        RaisePropertyChanged(() => IsLogin);  
    }  
}
```

Обратите внимание, что использование лямбда-выражения таким образом подразумевает небольшое снижение производительности, поскольку лямбда-выражение должно оцениваться для каждого вызова. Хотя затраты на производительность невелики и обычно не влияют на работу приложения, затраты могут начисляться при наличии множества уведомлений об изменениях. Однако преимущество такого подхода заключается в том, что он обеспечивает безопасность типов во время компиляции и поддержку рефакторинга при переименовании свойств.

## <a name="ui-interaction-using-commands-and-behaviors"></a>Взаимодействие пользовательского интерфейса с помощью команд и поведений

В мобильных приложениях действия обычно вызываются в ответ на действие пользователя, например нажатие кнопки, которое может быть реализовано путем создания обработчика событий в файле кода программной части. Однако в шаблоне MVVM ответственность за реализацию действия заключается в использовании модели представления и помещать код в код программной части следует избегать.

Команды предоставляют удобный способ представления действий, которые можно привязать к элементам управления в пользовательском интерфейсе. Они инкапсулируют код, реализующий действие, и помогают избежать его отсоединения от визуального представления в представлении. Xamarin. Forms включает элементы управления, которые можно декларативно подключить к команде, и эти элементы управления будут вызывать команду, когда пользователь взаимодействует с элементом управления.

Поведения также позволяют декларативно подключать элементы управления к команде. Однако поведение можно использовать для вызова действия, связанного с диапазоном событий, вызванных элементом управления. Таким образом, поведения устраняют многие из тех же сценариев, что и элементы управления с поддержкой команд, обеспечивая большую степень гибкости и контроля. Кроме того, поведение можно использовать для связывания объектов команд или методов с элементами управления, не предназначенными специально для взаимодействия с командами.

### <a name="implementing-commands"></a>Реализация команд

Представления модели обычно предоставляют свойства команд для привязки из представления, которые являются экземплярами объектов, реализующими интерфейс `ICommand`. Ряд элементов управления Xamarin. Forms предоставляет свойство `Command`, которое может быть привязано к `ICommand` объекту, предоставленному моделью представления. Интерфейс `ICommand` определяет метод `Execute`, который инкапсулирует саму операцию, метод `CanExecute`, указывающий, можно ли вызвать команду, и событие `CanExecuteChanged`, происходящее при внесении изменений, влияющих на то, должна ли выполняться команда. Классы [`Command`](xref:Xamarin.Forms.Command) и [`Command<T>`](xref:Xamarin.Forms.Command) , предоставляемые Xamarin. Forms, реализуют интерфейс `ICommand`, где `T` — это тип аргументов для `Execute` и `CanExecute`.

В модели представления должен быть объект типа [`Command`](xref:Xamarin.Forms.Command) или [`Command<T>`](xref:Xamarin.Forms.Command) для каждого открытого свойства в модели представления типа `ICommand`. Конструктору `Command` или `Command<T>` требуется объект обратного вызова `Action`, который вызывается при вызове метода `ICommand.Execute`. Метод `CanExecute` является необязательным параметром конструктора и является `Func`, который возвращает `bool`.

В следующем коде показано, как экземпляр [`Command`](xref:Xamarin.Forms.Command) , представляющий команду Register, создается путем указания делегата для метода `Register` представления модели:

```csharp
public ICommand RegisterCommand => new Command(Register);
```

Команда предоставляется в представлении через свойство, которое возвращает ссылку на `ICommand`. При вызове метода `Execute` для объекта [`Command`](xref:Xamarin.Forms.Command) он просто перенаправляет вызов метода в модели представления через делегат, указанный в конструкторе `Command`.

Асинхронный метод может быть вызван командой с использованием `async` и `await` ключевых слов при указании делегата `Execute` команды. Это означает, что обратный вызов является `Task` и должен быть ожидаемым. Например, в следующем коде показано, как экземпляр [`Command`](xref:Xamarin.Forms.Command) , представляющий команду входа, создается путем указания делегата для метода `SignInAsync` представления модели:

```csharp
public ICommand SignInCommand => new Command(async () => await SignInAsync());
```

Параметры можно передать `Execute` и `CanExecute` действиям с помощью класса [`Command<T>`](xref:Xamarin.Forms.Command) для создания экземпляра команды. Например, в следующем коде показано, как экземпляр `Command<T>` используется, чтобы указать, что методу `NavigateAsync` потребуется аргумент типа `string`:

```csharp
public ICommand NavigateCommand => new Command<string>(NavigateAsync);
```

В классах [`Command`](xref:Xamarin.Forms.Command) и [`Command<T>`](xref:Xamarin.Forms.Command) делегат к методу `CanExecute` в каждом конструкторе является необязательным. Если делегат не указан, `Command` будет возвращать `true` для `CanExecute`. Однако модель представления может указывать на изменение состояния `CanExecute` команды путем вызова метода `ChangeCanExecute` для объекта `Command`. Это приводит к возникновению события `CanExecuteChanged`. Все элементы управления в пользовательском интерфейсе, привязанные к команде, будут обновлять их состояние Enabled, чтобы отразить доступность команды, привязанной к данным.

#### <a name="invoking-commands-from-a-view"></a>Вызов команд из представления

В следующем примере кода показано, как [`Grid`](xref:Xamarin.Forms.Grid) в `LoginView` привязывается к `RegisterCommand` в классе `LoginViewModel` с помощью экземпляра [`TapGestureRecognizer`](xref:Xamarin.Forms.TapGestureRecognizer) :

```xaml
<Grid Grid.Column="1" HorizontalOptions="Center">  
    <Label Text="REGISTER" TextColor="Gray"/>  
    <Grid.GestureRecognizers>  
        <TapGestureRecognizer Command="{Binding RegisterCommand}" NumberOfTapsRequired="1" />  
    </Grid.GestureRecognizers>  
</Grid>
```

Параметр команды можно также определить с помощью свойства [`CommandParameter`](xref:Xamarin.Forms.TapGestureRecognizer.CommandParameter) . Тип ожидаемого аргумента указан в методах `Execute` и `CanExecute` целевого объекта. [`TapGestureRecognizer`](xref:Xamarin.Forms.TapGestureRecognizer) будет автоматически вызывать целевую команду, когда пользователь взаимодействует с присоединенным элементом управления. Параметр команды, если он указан, будет передан в качестве аргумента в делегат `Execute` команды.

<a name="implementing_behaviors" />

### <a name="implementing-behaviors"></a>Реализация поведений

Поведения позволяют добавлять функции в элементы управления пользовательского интерфейса без необходимости создавать их подкласс. Функциональность реализуется в классе реакции на событие и присоединяется к элементу управления так, как если бы она была его частью. Поведения позволяют реализовать код, который обычно приходится писать как код программной части, так как он напрямую взаимодействует с API элемента управления, таким образом, что он может быть кратко присоединен к элементу управления и упакован для повторного использования в нескольких представлениях или приложениях. В контексте MVVM поведение — это полезный подход к подключению элементов управления к командам.

Поведение, присоединенное к элементу управления через присоединенные свойства, называется *вложенным поведением*. После этого поведение может использовать предоставленный API элемента, к которому он присоединен, для добавления функциональных возможностей к этому элементу управления или другим элементам управления в визуальном дереве представления. Мобильное приложение eShopOnContainers содержит класс `LineColorBehavior`, который является вложенным поведением. Дополнительные сведения об этом поведении см. в разделе [Отображение ошибок проверки](~/xamarin-forms/enterprise-application-patterns/validation.md#displaying_validation_errors).

Поведение Xamarin. Forms — это класс, производный от класса [`Behavior`](xref:Xamarin.Forms.Behavior) или [`Behavior<T>`](xref:Xamarin.Forms.Behavior`1) , где `T` — это тип элемента управления, к которому должно применяться поведение. Эти классы предоставляют методы `OnAttachedTo` и `OnDetachingFrom`, которые должны быть переопределены для предоставления логики, которая будет выполняться, когда поведение прикрепляется к элементам управления и отсоединяется от них.

В мобильном приложении eShopOnContainers класс `BindableBehavior<T>` является производным от класса [`Behavior<T>`](xref:Xamarin.Forms.Behavior`1) . Целью класса `BindableBehavior<T>` является предоставление базового класса для поведений Xamarin. Forms, требующего, чтобы [`BindingContext`](xref:Xamarin.Forms.BindableObject.BindingContext) поведения присвоено присоединенному элементу управления.

Класс `BindableBehavior<T>` предоставляет переопределяемый метод `OnAttachedTo`, который задает [`BindingContext`](xref:Xamarin.Forms.BindableObject.BindingContext) поведения и переопределяемый метод `OnDetachingFrom`, очищающий `BindingContext`. Кроме того, класс хранит ссылку на присоединенный элемент управления в свойстве `AssociatedObject`.

Мобильное приложение eShopOnContainers включает класс `EventToCommandBehavior`, который выполняет команду в ответ на событие. Этот класс является производным от класса `BindableBehavior<T>`, чтобы поведение можно было привязать к и выполнить `ICommand`, заданные свойством `Command` при использовании поведения. Следующий пример кода демонстрирует класс `EventToCommandBehavior`:

```csharp
public class EventToCommandBehavior : BindableBehavior<View>  
{  
    ...  
    protected override void OnAttachedTo(View visualElement)  
    {  
        base.OnAttachedTo(visualElement);  

        var events = AssociatedObject.GetType().GetRuntimeEvents().ToArray();  
        if (events.Any())  
        {  
            _eventInfo = events.FirstOrDefault(e => e.Name == EventName);  
            if (_eventInfo == null)  
                throw new ArgumentException(string.Format(  
                        "EventToCommand: Can't find any event named '{0}' on attached type",   
                        EventName));  

            AddEventHandler(_eventInfo, AssociatedObject, OnFired);  
        }  
    }  

    protected override void OnDetachingFrom(View view)  
    {  
        if (_handler != null)  
            _eventInfo.RemoveEventHandler(AssociatedObject, _handler);  

        base.OnDetachingFrom(view);  
    }  

    private void AddEventHandler(  
            EventInfo eventInfo, object item, Action<object, EventArgs> action)  
    {  
        ...  
    }  

    private void OnFired(object sender, EventArgs eventArgs)  
    {  
        ...  
    }  
}
```

Методы `OnAttachedTo` и `OnDetachingFrom` используются для регистрации и отмены регистрации обработчика событий для события, определенного в свойстве `EventName`. Затем при срабатывании события вызывается метод `OnFired`, который выполняет команду.

Преимущество использования `EventToCommandBehavior` для выполнения команды при срабатывании события заключается в том, что команды могут быть связаны с элементами управления, не предназначенными для взаимодействия с командами. Кроме того, он перемещает код обработки событий, чтобы просмотреть модели, где ее можно протестировать.

#### <a name="invoking-behaviors-from-a-view"></a>Вызов поведений из представления

`EventToCommandBehavior` особенно удобно использовать для присоединения команды к элементу управления, который не поддерживает команды. Например, `ProfileView` использует `EventToCommandBehavior` для выполнения `OrderDetailCommand` при срабатывании события [`ItemTapped`](xref:Xamarin.Forms.ListView.ItemTapped) в [`ListView`](xref:Xamarin.Forms.ListView) , в котором перечислены заказы пользователя, как показано в следующем коде:

```xaml
<ListView>  
    <ListView.Behaviors>  
        <behaviors:EventToCommandBehavior             
            EventName="ItemTapped"  
            Command="{Binding OrderDetailCommand}"  
            EventArgsConverter="{StaticResource ItemTappedEventArgsConverter}" />  
    </ListView.Behaviors>  
    ...  
</ListView>
```

Во время выполнения `EventToCommandBehavior` будет реагировать на взаимодействие с [`ListView`](xref:Xamarin.Forms.ListView). При выборе элемента в `ListView`будет срабатывать событие [`ItemTapped`](xref:Xamarin.Forms.ListView.ItemTapped) , которое будет выполнять `OrderDetailCommand` в `ProfileViewModel`. По умолчанию аргументы события для события передаются в команду. Эти данные преобразуются при передаче между источником и целевым объектом преобразователем, заданным в свойстве `EventArgsConverter`, которое возвращает [`Item`](xref:Xamarin.Forms.ItemTappedEventArgs.Item) `ListView` из [`ItemTappedEventArgs`](xref:Xamarin.Forms.ItemTappedEventArgs). Таким образом, при выполнении `OrderDetailCommand` выбранный `Order` передается в качестве параметра зарегистрированному действию.

Дополнительные сведения о поведении см. в разделе [варианты поведения](~/xamarin-forms/app-fundamentals/behaviors/index.md).

## <a name="summary"></a>Сводка

Шаблон Model-View-ViewModel (MVVM) позволяет четко отделить бизнес-логику и представление представления приложения от пользовательского интерфейса. Поддержание чистого разделения логики приложения и пользовательского интерфейса помогает устранить многочисленные проблемы разработки и упростить тестирование, Обслуживание и развитие приложения. Она также может значительно улучшить возможности повторного использования кода и позволяет разработчикам и дизайнерам пользовательского интерфейса упростить совместную работу при разработке соответствующих частей приложения.

С помощью шаблона MVVM пользовательский интерфейс приложения, базовая структура и бизнес-логика разделяются на три отдельных класса: представление, которое инкапсулирует логику пользовательского интерфейса и пользовательского интерфейса. модель представления, которая инкапсулирует логику представления и состояние; и модель, которая инкапсулирует бизнес-логику и данные приложения.

## <a name="related-links"></a>Связанные ссылки

- [Скачать электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
