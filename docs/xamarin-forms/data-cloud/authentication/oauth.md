---
title: Проверка подлинности пользователей с помощью поставщика удостоверений
description: Xamarin.Auth является SDK кросс платформенных для проверки подлинности пользователей и хранения учетных записей. Он включает средства проверки подлинности OAuth, которые предоставляют поддержку использования поставщиков удостоверений, например Google, Microsoft, Facebook и Twitter. В этой статье описывается использование Xamarin.Auth для управления процессом проверки подлинности в приложении Xamarin.Forms.
ms.prod: xamarin
ms.assetid: D44745D5-77BB-4596-9B8C-EC75C259157C
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 06/19/2017
ms.openlocfilehash: 26e85a37cfd36b5d4f045273548efafccca79e1a
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/04/2018
---
# <a name="authenticating-users-with-an-identity-provider"></a>Проверка подлинности пользователей с помощью поставщика удостоверений

_Xamarin.Auth является SDK кросс платформенных для проверки подлинности пользователей и хранения учетных записей. Он включает средства проверки подлинности OAuth, которые предоставляют поддержку использования поставщиков удостоверений, например Google, Microsoft, Facebook и Twitter. В этой статье описывается использование Xamarin.Auth для управления процессом проверки подлинности в приложении Xamarin.Forms._

OAuth открытый стандарт для проверки подлинности и позволяет владелец ресурса для уведомления поставщика ресурса в предоставлении этого разрешения третьим лицам для доступа к их данным без совместного использования удостоверений владельцев ресурса. Примером этого может предоставление пользователю известить поставщика удостоверений (например, Google, Microsoft, Facebook или Twitter) разрешение должно предоставляться к приложению для доступа к данным без удостоверения пользователя для управления доступом. Обычно он используется как подход для пользователей для входа в веб-сайтов и приложений с помощью поставщика удостоверений, но без предоставления пароля для веб-сайта или приложения.

Общий обзор проверки подлинности потока при использовании поставщика удостоверений OAuth выглядит следующим образом:

1. Приложение переходит в браузере URL-адрес поставщика удостоверений.
1. Поставщик удостоверений выполняет проверку подлинности пользователя и возвращает код авторизации для приложения.
1. Приложение выполняет обмен кода авторизации для токена доступа от поставщика удостоверений.
1. Приложение использует маркер доступа для доступа к API-интерфейсов на поставщик удостоверений, например API-Интерфейс для запрашивающего основные сведения о пользователях.

Образец приложения показано, как реализуется с помощью Xamarin.Auth поток собственный проверки подлинности от Google. Google используется в качестве поставщика удостоверений в этом разделе, подход применяется одинаково для других поставщиков удостоверений. Дополнительные сведения о проверке подлинности с помощью конечной точки Google OAuth 2.0 см. в разделе [OAuth2.0 с помощью API-интерфейсов доступа Google](https://developers.google.com/identity/protocols/OAuth2) на веб-сайте Google.

> [!NOTE]
> В iOS 9 и более поздней версии безопасность транспорта приложения (ATS) обеспечивает безопасное соединение между Интернет-ресурсов (например, приложение серверных) и приложения, чтобы предотвратить случайное раскрытие конфиденциальных сведений. Поскольку ATS включена по умолчанию в приложениях, разработанных для iOS 9, все соединения будут применяться ATS требования безопасности. Если соединения не удовлетворяют этим требованиям, произойдет сбой с исключением.
> Если это не позволяет использовать ATS могут быть присоединены из `HTTPS` протокола и безопасную передачу Интернет-ресурсов. Это можно сделать путем обновления приложения **Info.plist** файла. Дополнительные сведения см. [безопасность транспорта приложения](~/ios/app-fundamentals/ats.md).

## <a name="using-xamarinauth-to-authenticate-users"></a>С помощью Xamarin.Auth для проверки подлинности пользователей

Xamarin.Auth поддерживает два подхода к приложениям взаимодействовать с конечной точкой авторизации поставщика удостоверений:

1. Использование внедренных веб-представление. Хотя это было принято, больше не рекомендуется по следующим причинам:

    - Приложения, на котором размещается веб-представление может получить доступ к полной проверки подлинности учетные данные пользователя, не только предоставления авторизации OAuth, предназначенного для приложения. Это приводит к нарушению принципа наименьших прав доступа, эти приложения имеют доступ к более мощных учетные данные, чем нужно, потенциально увеличивает уязвимость приложения.
    - Ведущее приложение может записать имена пользователей и пароли, автоматически отправлять формы и обход согласие пользователя и скопируйте файлы cookie сеанса и использовать их для выполнения действий, прошедшего проверку подлинности имени пользователя.
    - Внедренные веб-представления не разглашаем состояния проверки подлинности веб-браузере устройства, поскольку требует от пользователя вход в систему для каждого запроса авторизации, который считается меньше пользователем или другими приложениями.
    - Некоторые конечные точки авторизации выполните действия для обнаружения и блокировки авторизации запросов, поступающих из веб-представления.

1. С помощью устройства веб-браузере является рекомендуемым. С помощью обозревателя устройства для OAuth запросов повышает удобство использования приложения, как пользователям нужно только для входа на поставщике удостоверений один раз на устройство, повышение скорости преобразования потоков входа и авторизации в приложении. Обозреватель устройства также обеспечивает повышенную безопасность, как приложения, могут проверять и изменять содержимое в веб-представление, но не содержимое, отображаемое в браузере. Это подходов, использованных в этом статья и образец приложения.

На следующей диаграмме показан общий обзор как образец приложения использует Xamarin.Auth для проверки подлинности пользователей и извлечения их основные данные:

![](oauth-images/google-auth.png "С помощью Xamarin.Auth для проверки подлинности Google")

Приложение делает запрос на проверку подлинности с помощью Google `OAuth2Authenticator` класса. Ответ проверки подлинности возвращается, когда пользователь успешно проверку подлинности с Google через их на странице входа, включая маркер доступа. Затем приложение выполняет запрос в Google для основных пользовательских данных, с помощью `OAuth2Request` класс, токен доступа, включаются в запрос.

### <a name="setup"></a>Установка

Для входа в Google интегрировать приложения Xamarin.Forms, необходимо создать проект консоли Google API. Это можно обеспечить, выполнив следующие действия.

1. Последовательно выберите пункты [консоли Google API](http://console.developers.google.com) веб-сайта и выполните вход с помощью учетных данных учетной записи Google.
1. Из раскрывающегося списка проект выберите существующий проект или создайте новый.
1. В боковой панели в разделе «Диспетчер API» выберите **учетные данные**, а затем выберите **вкладка экран согласия OAuth**. Выберите **адрес электронной почты**, укажите **название продукта, показываемые пользователям**и нажмите клавишу **Сохранить**.
1. В **учетные данные** выберите **создать учетные данные** раскрывающегося списка, а затем выберите **идентификатор клиента OAuth**.
1. В разделе **тип приложения**, выберите платформу, которая выполняется мобильного приложения (**iOS** или **Android**).
1. Заполните необходимые сведения и выбрать **создать** кнопки.

> [!NOTE]
> Идентификатор клиента позволяет приложению доступ к API включен Google и для приложений для мобильных устройств является уникальным для одну платформу. Таким образом **идентификатор клиента OAuth** следует создавать для каждой платформы, которую будет использовать входа в Google.

После выполнения этих действий, Xamarin.Auth можно использовать для инициации потока проверки подлинности OAuth2 с Google.

### <a name="creating-and-configuring-an-authenticator"></a>Создание и настройка средства проверки подлинности

В Xamarin.Auth `OAuth2Authenticator` класс отвечает за обработку процесс проверки подлинности OAuth. В следующем примере кода показано создание экземпляров `OAuth2Authenticator` класс при проверке подлинности с помощью веб-браузере устройства:

```csharp
var authenticator = new OAuth2Authenticator(
    clientId,
    null,
    Constants.Scope,
    new Uri(Constants.AuthorizeUrl),
    new Uri(redirectUri),
    new Uri(Constants.AccessTokenUrl),
    null,
    true);
```

`OAuth2Authenticator` Класса требуется ряд параметров, которые выглядят следующим:

- **Идентификатор клиента** — это идентифицирует клиента, который выполняет запрос и может быть получен из проекта в [консоли Google API](http://console.developers.google.com).
- **Секрет клиента** — это должен быть `null` или `string.Empty`.
- **Область** — это определяет доступ к API, запрашиваемый приложением, а также значение сообщает экран согласия, отображаемые для пользователя. Дополнительные сведения об областях см. в разделе [запроса авторизации API](https://developers.google.com/+/web/api/rest/oauth) на веб-сайте Google.
- **Авторизация URL-адрес** — это определяет URL-адрес, где будет получен код авторизации из.
- **URL-адрес перенаправления** — это определяет URL-адрес, по которому будут отправляться ответ. Значение этого параметра должно соответствовать одному из значений, которое отображается в **учетные данные** вкладки для проекта в [Google Developers Console](https://console.developers.google.com/).
- **URL-адрес AccessToken** — это определяет URL-адрес, используемый для запроса маркеров доступа, после получения кода авторизации.
- **GetUserNameAsync Func** — необязательный `Func` будет использоваться асинхронно получить имя пользователя учетной записи, когда он является успешно проверена.
- **Использовать собственный пользовательский Интерфейс** — `boolean` значение, указывающее, следует ли использовать веб-браузере устройства для выполнения запроса проверки подлинности.

### <a name="setup-authentication-event-handlers"></a>Настройка обработчиков событий проверки подлинности

Перед представлением пользовательского интерфейса, обработчик событий для `OAuth2Authenticator.Completed` событие должно быть зарегистрировано, как показано в следующем примере кода:

```csharp
authenticator.Completed += OnAuthCompleted;
```

Это событие будет срабатывать, если пользователь успешно проходит проверку подлинности или отменяет входа.

Кроме того, обработчик событий для `OAuth2Authenticator.Error` событие также может быть зарегистрировано.

### <a name="presenting-the-sign-in-user-interface"></a>Презентация входа в пользовательский интерфейс

Интерфейс входа в систему пользователя могут быть представлены пользователю с помощью имени входа Xamarin.Auth докладчика, в которой должны быть инициализированы в каждый проект платформы. В следующем примере кода показано, как инициализировать докладчика входа в `AppDelegate` класса в проекте iOS:

```csharp
global::Xamarin.Auth.Presenters.XamarinIOS.AuthenticationConfiguration.Init();
```

В следующем примере кода показано, как инициализировать докладчика входа в `MainActivity` класса в проекте Android:

```csharp
global::Xamarin.Auth.Presenters.XamarinAndroid.AuthenticationConfiguration.Init(this, bundle);
```

Проект переносимой библиотеки классов (PCL) затем может вызывать докладчика входа следующим образом:

```csharp
var presenter = new Xamarin.Auth.Presenters.OAuthLoginPresenter();
presenter.Login(authenticator);
```

Обратите внимание, что аргумент `Xamarin.Auth.Presenters.OAuthLoginPresenter.Login` метод `OAuth2Authenticator` экземпляра. Когда `Login` вызывается метод, интерфейс входа в систему пользователя для пользователя на вкладке выводится из веб-браузере устройства, как показано на следующих снимках экрана:

![](oauth-images/login.png "Вход Google")

### <a name="processing-the-redirect-url"></a>При обработке URL-адрес перенаправления

Пользователь не завершит процесс проверки подлинности, элемент управления будет возвращать приложению из вкладку веб-браузера. Это достигается путем регистрации пользовательской схемы URL-адрес для перенаправления URL-адрес, возвращенный процесс проверки подлинности, а затем обнаружение и обработка пользовательский URL-адрес после отправки.

При выборе пользовательской схемы URL-адрес для связи с приложением, приложения должны использовать схему на основе имени под их управлением. Это можно сделать с помощью имя идентификатора пакета на iOS и имя пакета на Android, а затем изменив их, чтобы сделать схему URL-адрес. Однако некоторые поставщики удостоверений, например Google, присваивает идентификаторы клиента на основе имен доменов, которые затем меняется и использовать в качестве схемы URL-адрес. Например, если идентификатор клиента создает Google `902730282010-ks3kd03ksoasioda93jldas93jjj22kr.apps.googleusercontent.com`, схема URL-адрес будет `com.googleusercontent.apps.902730282010-ks3kd03ksoasioda93jldas93jjj22kr`. Обратите внимание, что только один `/` может располагаться после компонент схемы. Таким образом, полный пример использования пользовательской схемы URL-адрес перенаправления URL-адреса является `com.googleusercontent.apps.902730282010-ks3kd03ksoasioda93jldas93jjj22kr:/oauth2redirect`.

Когда веб-браузер получает ответ от поставщика удостоверений, содержащую пользовательские схему URL-адрес, он пытается загрузить URL-адрес, который не удастся. Вместо этого пользовательские схемы URL-адрес выдается для операционной системы при возникновении события. Операционная система осуществляет поиск зарегистрированных схем, и если он найден, операционная система запуска приложения, зарегистрированный схему и отправить его URL-адрес перенаправления.

Механизм для регистрации пользовательской схемы URL-адрес с операционной системой и обработке схему конкретной платформы.

#### <a name="ios"></a>iOS

На iOS, пользовательской схемы URL-адрес, зарегистрированный в **Info.plist**, как показано на следующем снимке экрана:

![](oauth-images/info-plist.png "Регистрация URL-адреса схемы")

**Идентификатор** значение может быть любым и **роли** должно быть присвоено значение **просмотра**. **URL-схем** значение, которое начинается с `com.googleusercontent.apps`, можно получить из идентификатора клиента операций ввода-вывода для проекта на [консоли Google API](http://console.developers.google.com).

По завершении запроса авторизации поставщик удостоверений перенаправляет URL-адрес перенаправления для приложения. Поскольку URL-адрес использует пользовательской схемы, это приводит к запуска приложения iOS, передача в URL-АДРЕСЕ как параметр запуска, где оно обрабатывается `OpenUrl` переопределить приложения `AppDelegate` класса, как показано в следующем примере кода:

```csharp
public override bool OpenUrl(UIApplication app, NSUrl url, NSDictionary options)
{
    // Convert NSUrl to Uri
    var uri = new Uri(url.AbsoluteString);

    // Load redirectUrl page
    AuthenticationState.Authenticator.OnPageLoading(uri);

    return true;
}
```

`OpenUrl` Метод преобразует полученных URL-адрес из `NSUrl` для .NET `Uri`, перед обработкой URL-адрес перенаправления с `OnPageLoading` открытый метод `OAuth2Authenticator` объекта. В этом случае Xamarin.Auth чтобы закрыть вкладку веб-браузера и выполнить синтаксический анализ полученных данных OAuth.

#### <a name="android"></a>Android

В Android пользовательской схемы URL-адрес зарегистрирован, указав [ `IntentFilter` ](https://developer.xamarin.com/api/type/Android.App.IntentFilterAttribute/) атрибут `Activity` , обрабатывающий схему. По завершении запроса авторизации поставщик удостоверений перенаправляет URL-адрес перенаправления для приложения. Как URL-адрес использует пользовательской схемы, это приводит к Android при запуске приложения, передачи в URL-адрес в качестве параметра запуска, где оно обрабатывается `OnCreate` метод `Activity` зарегистрирован для обработки пользовательских схема URL-адресов. В следующем примере кода показан класс, из примера приложения, который обрабатывает пользовательские схемы URL-адрес:

```csharp
[Activity(Label = "CustomUrlSchemeInterceptorActivity", NoHistory = true, LaunchMode = LaunchMode.SingleTop )]
[IntentFilter(
    new[] { Intent.ActionView },
    Categories = new [] { Intent.CategoryDefault, Intent.CategoryBrowsable },
    DataSchemes = new [] { "<insert custom URL here>" },
    DataPath = "/oauth2redirect")]
public class CustomUrlSchemeInterceptorActivity : Activity
{
    protected override void OnCreate(Bundle savedInstanceState)
    {
        base.OnCreate(savedInstanceState);

        // Convert Android.Net.Url to Uri
        var uri = new Uri(Intent.Data.ToString());

        // Load redirectUrl page
        AuthenticationState.Authenticator.OnPageLoading(uri);

        Finish();
    }
}
```

`DataSchemes` Свойство [ `IntentFilter` ](https://developer.xamarin.com/api/type/Android.App.IntentFilterAttribute/) должно быть присвоено обратном клиентский идентификатор, полученный из идентификатора клиента Android для проекта на [консоли Google API](http://console.developers.google.com).

`OnCreate` Метод преобразует полученных URL-адрес из `Android.Net.Url` для .NET `Uri`, перед обработкой URL-адрес перенаправления с `OnPageLoading` открытый метод `OAuth2Authenticator` объекта. В этом случае Xamarin.Auth закрыть вкладку веб-браузера, а синтаксический анализ полученных данных OAuth.

> [!IMPORTANT]
> В Android использует Xamarin.Auth `CustomTabs` API для взаимодействия с веб-браузер и операционной системы. Однако он не гарантирует, что `CustomTabs` совместимый обозреватель будет установлен на устройстве пользователя.

### <a name="examining-the-oauth-response"></a>Проверки в ответе OAuth

После синтаксического анализа полученных данных OAuth, будут вызывать Xamarin.Auth `OAuth2Authenticator.Completed` событий. В обработчике событий для этого события `AuthenticatorCompletedEventArgs.IsAuthenticated` свойство может использоваться для идентификации ли проверка подлинности успешно пройдена, как показано в следующем примере кода:

```csharp
async void OnAuthCompleted(object sender, AuthenticatorCompletedEventArgs e)
{
  ...
  if (e.IsAuthenticated)
  {
    ...
  }
}
```

Данные, полученные при успешной проверки подлинности недоступны в `AuthenticatorCompletedEventArgs.Account` свойство. Сюда входят маркер доступа, который может использоваться для подписывания запросов для данных к API, предоставляемые поставщиком удостоверений.

### <a name="making-requests-for-data"></a>Выполнение запросов для данных

После приложение получает токен доступа, он будет использован для создания запроса к `https://www.googleapis.com/oauth2/v2/userinfo` API запрашивать обычный пользователь данные от поставщика удостоверений. Этот запрос выполняется с его Xamarin.Auth `OAuth2Request` класс, который представляет запрос, который проходит проверку подлинности с помощью учетной записи, полученные из `OAuth2Authenticator` экземпляра, как показано в следующем примере кода:

```csharp
// UserInfoUrl = https://www.googleapis.com/oauth2/v2/userinfo
var request = new OAuth2Request ("GET", new Uri (Constants.UserInfoUrl), null, e.Account);
var response = await request.GetResponseAsync ();
if (response != null)
{
  string userJson = response.GetResponseText ();
  var user = JsonConvert.DeserializeObject<User> (userJson);
}
```

А также метод HTTP и URL-адрес API `OAuth2Request` экземпляр также задает `Account` экземпляр, который содержит маркер доступа, подписывает запрос на URL-адрес указанный `Constants.UserInfoUrl` свойство. Поставщик удостоверений затем возвращает основные сведения о пользователях в качестве ответа JSON, включая имя пользователя и адрес электронной почты, при условии, что маркер доступа распознает как допустимые. Ответ JSON считывается и десериализуются `user` переменной.

Дополнительные сведения см. в разделе [вызов Google API](https://developers.google.com/identity/protocols/OAuth2InstalledApp#callinganapi) на портале разработчиков Google.

### <a name="storing-and-retrieving-account-information-on-devices"></a>Хранения и извлечения сведений учетной записи на устройствах

Xamarin.Auth надежно сохраняет `Account` объекты в учетной записи хранения, чтобы приложения не всегда требовалось пройти повторную проверку подлинности пользователей. `AccountStore` Класс хранит сведения об учетной записи и поддерживаемый службами цепочке ключей в iOS и `KeyStore` класса в Android.

В следующем коде показано, как `Account` безопасно сохранения объекта:

```csharp
AccountStore.Create ().Save (e.Account, Constants.AppName);
```

Сохраненные учетные записи уникально идентифицируются с помощью ключа, состоящего из учетной записи пользователя `Username` свойство и идентификатор службы, которая представляет собой строку, используемую при получении учетных записей из учетной записи хранилища. Если `Account` был ранее сохранен, вызвав `Save` метод снова перезапишет его.

`Account` объекты для службы можно получить, вызвав `FindAccountsForService` метода, как показано в следующем примере кода:

```csharp
var account = AccountStore.Create ().FindAccountsForService (Constants.AppName).FirstOrDefault();
```

`FindAccountsForService` Возвращает `IEnumerable` коллекцию `Account` объектов с первого элемента в коллекции, как сопоставленная учетной записи.

## <a name="summary"></a>Сводка

В этой статье описано использование Xamarin.Auth для управления процессом проверки подлинности в приложении Xamarin.Forms. Предоставляет Xamarin.Auth `OAuth2Authenticator` и `OAuth2Request` классы, которые используются приложениями Xamarin.Forms использовать Поставщики удостоверений, например Google, Microsoft, Facebook и Twitter.


## <a name="related-links"></a>Связанные ссылки

- [OAuthNativeFlow (пример)](https://developer.xamarin.com/samples/xamarin-forms/WebServices/OAuthNativeFlow/)
- [OAuth 2.0 для собственных приложений](https://tools.ietf.org/html/draft-ietf-oauth-native-apps-12)
- [С помощью OAuth2.0 для доступа к API Google](https://developers.google.com/identity/protocols/OAuth2)
- [Xamarin.Auth (NuGet)](https://www.nuget.org/packages/xamarin.auth/)
- [Xamarin.Auth (GitHub)](https://github.com/xamarin/Xamarin.Auth)
