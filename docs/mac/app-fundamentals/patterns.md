---
title: Общие шаблоны и идиомы в Xamarin. Mac
description: В этом документе описываются распространенные шаблоны проектирования, используемые при создании приложений Xamarin. Mac. В нем обсуждается шаблон модель-представление-контроллер, источник данных и шаблоны делегатов, а также протоколы.
ms.prod: xamarin
ms.assetid: BF0A3517-17D8-453D-87F7-C8A34BEA8FF5
ms.technology: xamarin-mac
author: conceptdev
ms.author: crdun
ms.date: 06/17/2016
ms.openlocfilehash: b4934fa82d862ad2e8ab53579137873ed9e4bcca
ms.sourcegitcommit: 57f815bf0024b1afe9754c0e28054fc0a53ce302
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70770169"
---
# <a name="common-patterns-and-idioms-in-xamarinmac"></a>Общие шаблоны и идиомы в Xamarin. Mac

В интерфейсах API Apple, C#предоставляемых через, некоторые идиомы и закономерности снова возходят и снова. Если у вас есть опыт программирования с помощью Xamarin. iOS, они могут показаться знакомыми. Документация часто относится к этим шаблонам и идиомам многократно, поэтому знание этих шаблонов поможет понять, как вы найдете документацию.

## <a name="mvc---model-view-controller"></a>MVC — контроллер представления модели

Модель представления модели или MVC для коротких версий — очень распространенный шаблон, который находится в Cocoa. Подробное обсуждение выходит за рамки данного документа, но в кратком смысле это способ структуризации приложения на компоненты:

- Объекты **модели** представляют базовые данные, просматриваемые и обрабатываемые (например, адреса в адресной книге).
- Объекты **представления** обрабатывают Рисование данного объекта на экране и обрабатывая взаимодействие с пользователем (текстовое поле, в котором отображается адрес на экране)
- Объекты **контроллера** обработают взаимодействие между моделью и представлением. Они отправляют изменения модели "Up" для обновления представления и отправки "вниз" изменений из представления при внесении пользователями изменений в пользовательский интерфейс.

Если вы знакомы с MVVM (представление модели ViewModel) из других библиотек, таких как WPF, контроллер действует аналогично ViewModel, но часто более тесно связан с конкретными элементами пользовательского интерфейса.

Дополнительные сведения можно найти здесь:

- [Изучение MVC на веб-сайте Apple](https://developer.apple.com/library/ios/documentation/general/conceptual/devpedia-cocoacore/MVC.html)

- [Контроллер представления модели в цели-C](https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html)
- [Работа с Windows](~/mac/user-interface/window.md)

## <a name="data-source--delegate--subclassing"></a>Источник данных, делегаты и подклассы

Другой очень распространенный шаблон в Cocoa заключается в предоставлении данных элементам пользовательского интерфейса и реагировании на взаимодействия пользователей. Используя `NSTableView` в качестве примера, необходимо каким – то образом предоставлять данные для каждой строки, некоторый набор элементов пользовательского интерфейса, представляющих эту строку, некоторый набор поведений, реагирующий на взаимодействие с пользователем, и, возможно, некоторый объем настройки. Шаблоны источников данных и делегатов позволяют справиться с большинством случаев, не прибегая к подклассу `NSTableView` .

- Свойству назначается экземпляр пользовательского `NSTableViewDataSource` подкласса, который вызывается для заполнения таблицы данными (через `GetRowCount` и `GetObjectValue`). `DataSource`

- `GetViewForItem` `NSTableViewDelegate` `MouseDownInHeaderOfTableColumn` `DidClickTableColumn`Свойству назначается экземпляр пользовательского подкласса, который предоставляет представление для данного объекта модели (через) и обрабатывает взаимодействия пользовательского интерфейса (через, и т. д.). `Delegate`

В некоторых случаях требуется настроить элемент управления за пределами обработчиков, указанных в делегате или источнике данных, и можно напрямую создать подкласс представления. Обратите внимание, что во многих случаях при переопределении поведения по умолчанию потребуется самостоятельно обрабатывать все это поведение (Настройка поведения выбора может потребовать реализации всех вариантов поведения выбора).

В Xamarin. iOS некоторые API, например `UITableView` , были расширены с помощью свойства, реализующего делегат и источник данных (`UITableViewSource`). Это позволяет обойти общее ограничение того, что один C# класс может иметь только один базовый класс, и наши отображая протоколов выполняются через базовые классы.

Дополнительные сведения о работе с табличными представлениями в приложении Xamarin. Mac см. в нашей документации по [табличному представлению](~/mac/user-interface/table-view.md) .

## <a name="protocols"></a>Протоколы

Протоколы в цели-C можно сравнивать с интерфейсами C#в, и во многих случаях они используются в подобных ситуациях. Например, в `NSTableView` приведенном выше примере делегат и источник данных фактически являются протоколами. Xamarin. Mac предоставляет эти базовые классы с виртуальными методами, которые можно переопределить. Основное различие между C# интерфейсами и протоколами цели-C заключается в том, что некоторые методы в протоколе могут быть необязательными для реализации. Чтобы определить, что является необязательным, необходимо ознакомиться с документацией и (или) определением API.

Дополнительные сведения см. в документации наших [делегатов, протоколов и событий](~/ios/app-fundamentals/delegates-protocols-and-events.md) .

## <a name="related-links"></a>Связанные ссылки

- [Табличные представления](~/mac/user-interface/table-view.md)
- [Работа с Windows](~/mac/user-interface/window.md)
- [Делегаты, протоколы и события](~/ios/app-fundamentals/delegates-protocols-and-events.md)
- [Модель-представление-контроллер](https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html)
