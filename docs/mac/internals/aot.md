---
title: Xamarin.Mac опережает время компиляции
description: В этом документе описывается опережает время компиляции в Xamarin.Mac. Он сравнивает компиляция AOT, JIT-компиляции, объясняется, как включить AOT и смотрит на гибридную компиляцию AOT.
ms.prod: xamarin
ms.assetid: 38B8A017-5A58-429C-A6E9-9860A1DCEF63
ms.technology: xamarin-mac
author: lobrien
ms.author: laobri
ms.date: 11/10/2017
ms.openlocfilehash: e155a394afd68d9970ee32785f6d0aeda6e2d129
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61034208"
---
# <a name="xamarinmac-ahead-of-time-compilation"></a>Xamarin.Mac опережает время компиляции

## <a name="overview"></a>Обзор

Ahead time (AOT) компиляции является методика мощные оптимизации быстрый запуск. Тем не менее оно также влияет на время сборки, размер приложения и выполнение программы в эффективных средств. Сведения о необходимых действиях, которые он накладывает, мы будем немного углубиться в компиляции и выполнения приложения.

Код, написанный на управляемые языки, такие как C# и F#, компилируется в промежуточное представление называется IL. Этот IL, хранящихся в сборках библиотеки и программы, является относительно compact и переносить между архитектурами процессоров. IL, тем не менее, не только промежуточного набор инструкций и в будущем, необходимо перевести в конкретного процессора машинный код IL.

Существует две точки, в которых такая обработка может выполняться.

- **Только в определенное время (JIT)** — во время запуска и выполнения приложения IL-код компилируется в памяти в машинный код.
- **Вперед из time (AOT)** — во время сборки IL-код компилируется и записываются обратно в собственные библиотеки и хранятся в ваш пакет приложения.

Каждый вариант имеет ряд преимущества и недостатки:

- **JIT**
  - **Время запуска** — JIT-компиляции, которые должны выполняться при запуске. Для большинства приложений это порядка 100 мс, но для больших приложений это время может быть значительно больше.
  - **Выполнение** — как JIT-код можно оптимизировать для конкретного процессора, могут создаваться несколько повысить качество кода. В большинстве приложений это несколько процентах быстрее максимум.
- **AOT**
  - **Время запуска** — Загрузка предварительно скомпилированных dylibs происходит значительно быстрее, чем сборок JIT-компилятора.
  - **Место на диске** — тем не менее эти dylibs может занять значительный объем места на диске. В зависимости от того, какие сборки являются AOTed, можно дважды или более размер часть кода приложения.
  - **Время сборки** — компиляция AOT значительно медленнее, что JIT-компилятора и приведет к снижению сборок, использующих его. Замедление могут варьироваться от нескольких секунд до 1 минуты или более в зависимости от размера и количества сборки, скомпилированные.
  - **Запутывания** — как IL, что гораздо проще для реконструирования чем машинный код, не обязательно требуется его могут быть удалены для маскировки важного кода. Для этого требуется параметр описания ниже «смешанный».

## <a name="enabling-aot"></a>Включение AOT

Параметры AOT будут добавляться на панель сборки Mac в будущем обновлении. До тех пор Включение AOT требует передачи аргумента командной строки через поле «Дополнительные аргументы mmp» в сборки Mac. Это свойство может принимать следующие значения.


      --aot[=VALUE]          Specify assemblies that should be AOT compiled
                               - none - No AOT (default)
                               - all - Every assembly in MonoBundle
                               - core - Xamarin.Mac, System, mscorlib
                               - sdk - Xamarin.Mac.dll and BCL assemblies
                               - |hybrid after option enables hybrid AOT which
                               allows IL stripping but is slower (only valid
                               for 'all')
                                - Individual files can be included for AOT via +
                               FileName.dll and excluded via -FileName.dll

                               Examples:
                                 --aot:all,-MyAssembly.dll
                                 --aot:core,+MyOtherAssembly.dll,-mscorlib.dll



## <a name="hybrid-aot"></a>Гибридную компиляцию AOT

Во время выполнения приложения macOS среда выполнения по умолчанию использует машинный код, загружаются из собственных библиотек, созданные в процессе компиляции AOT. Тем не менее, существуют некоторые области кода, например trampolines, где JIT-компиляция может привести к значительно более оптимизированного результатам. Для этого требуется управляемых сборок IL доступен. В iOS приложениям запрещено использование JIT-компиляции; Эти части кода, компиляции, а также с помощью AOT.

Использовании смешанного варианта предписывает компилятору обоих компиляции эти раздел (например iOS), но также к предполагается, что IL не будут доступны во время выполнения. Этот IL затем могут быть удалены после ее построения. Как отмечалось выше, среда выполнения будут вынуждены использовать менее оптимизированный подпрограммы в некоторых местах.

## <a name="further-considerations"></a>Дополнительные вопросы

Отрицательные последствия AOT масштабирования размеры и количество обработанных сборок. Полный [требуемой версии .NET framework](~/mac/platform/target-framework.md) пример содержит намного больше библиотеке базовых классов (BCL) чем современный и таким образом AOT будет выполняться значительно дольше, создают пакеты большего размера. Это также связана с полной платформы несовместимости с компоновки, который удаляет неиспользуемый код. Рекомендуется переместить приложение компоновка современных и включить для получения наилучших результатов.

Дополнительным преимуществом AOT поставляется с улучшенное взаимодействие с собственного отладки и профилирования цепочек инструментов. Так как большинство базы кода будут скомпилированы заранее, она будет иметь имена функций и символов, которые будут более удобными для чтения внутри отчетов сбоев в машинном коде, профилирования и отладки. Созданный JIT-компилятора функции не имеют следующие имена и часто проявляются как неименованные hex смещения, которые очень сложно устранить.
