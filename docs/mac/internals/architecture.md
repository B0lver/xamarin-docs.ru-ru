---
title: Архитектура Xamarin.Mac
description: В этом руководстве описано Xamarin.Mac и его связь Objective-c на низком уровне. Здесь описываются концепции, такие как компиляции, селекторы, регистраторов, запуск приложения и генератор.
ms.prod: xamarin
ms.assetid: 74D1FF57-4F2A-4646-8669-003DE99671D4
ms.technology: xamarin-mac
author: lobrien
ms.author: laobri
ms.date: 04/12/2017
ms.openlocfilehash: 7b9b3b648f6ac66859714052e916407026da10d4
ms.sourcegitcommit: 7eed80186e23e6aff3ddbbf7ce5cd1fa20af1365
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/11/2018
ms.locfileid: "51526940"
---
# <a name="xamarinmac-architecture"></a>Архитектура Xamarin.Mac

_В этом руководстве описано Xamarin.Mac и его связь Objective-c на низком уровне. Здесь описываются концепции, такие как компиляции, селекторы, регистраторов, запуск приложения и генератор._

## <a name="overview"></a>Обзор

Xamarin.Mac приложения выполняются в среде выполнения Mono и использовать компилятор Xamarin для компиляции до промежуточного языка (IL), который затем является Just-in-Time (JIT) скомпилированы в машинный код во время выполнения. Эта команда запускает side-by-side в среде выполнения Objective-C. Обе эти среды выполнения выполняются на основе UNIX-подобных ядро, в частности XNU и предоставлять различные интерфейсы API для пользовательского кода, что позволяет разработчикам получать доступ к базовой системы машинного или управляемого.

На следующей схеме показан общий обзор этой архитектуры:

[![Схема, показывающая общий обзор архитектуры](architecture-images/mac-arch.png "схема, показывающая общий обзор архитектуры")](architecture-images/mac-arch-large.png#lightbox)

### <a name="native-and-managed-code"></a>Машинного и управляемого кода

При разработке для Xamarin, условия *собственного* и *управляемых* кода часто используются. Управляемый код — это код, с его выполнения под управлением .NET Framework среда CLR, или в случае Xamarin: среда выполнения Mono.

Машинный код приведен код, который будет выполняться в собственном коде на конкретную платформу (например, Objective-C или даже код компиляции AOT, в микросхеме ARM). В этом руководстве описано как управляемый код компилируется в машинный код и объясняется, как работает приложение Xamarin.Mac, интенсивно использовать интерфейсам API Apple Mac при помощи привязок, имея доступ к. NET BCL и сложный язык, такой как C#.

## <a name="requirements"></a>Требования

Для разработки приложения macOS с помощью Xamarin.Mac macOS требуется следующее:

- Компьютер Mac с macOS Sierra (10.12) или более поздней версии.
- Актуальная версия Xcode (установить из [App Store](https://itunes.apple.com/us/app/xcode/id497799835?mt=12))
- Последняя версия Xamarin.Mac и Visual Studio для Mac

Для запуска приложений Mac, созданных с помощью Xamarin.Mac, необходимо выполнить следующие системные требования:

- Компьютер Mac под управлением Mac OS X 10.7 или более поздней версии.

## <a name="compilation"></a>.NET

При компиляции любого приложения Xamarin платформы Mono C# (или F#) компилятор будет выполняться и будет компилироваться в C# и F# код в промежуточный язык Майкрософт (MSIL или IL). Затем использует Xamarin.Mac *Just in Time (JIT)* компилятора во время выполнения для компиляции машинного кода, позволяя выполнение на правильной архитектуры, при необходимости.

Это отличается от Xamarin.iOS, который использует компиляция AOT. При использовании компилятора AOT, все сборки, а также все методы в них компилируются во время сборки. С помощью JIT-компилятора компиляция происходит по требованию только для методов, которые выполняются.

С помощью приложений Xamarin.Mac Mono обычно является встроенным в пакет приложений (и называются **Mono внедренного**). При использовании классического интерфейса API Xamarin.Mac, приложение может использовать вместо этого **Mono системы**, однако это не поддерживается в единый API. Система Mono ссылается на Mono, которая была установлена в операционной системе. При запуске приложения приложения Xamarin.Mac будет использован.

## <a name="selectors"></a>Селекторы

С помощью Xamarin, у нас есть два отдельных экосистемы .NET и Apple, которую нам нужно перевести вместе, чтобы показаться как упрощенная, как можно точнее, чтобы убедиться, что конечная цель — для удобства пользователей. Мы видели в разделе выше взаимодействие две среды выполнения, и вы очень хорошо выдающимся физиком того термин «привязки», который позволяет собственных API Mac для использования в Xamarin. Привязки рассматриваются подробно в [документации привязки Objective-C](~/mac/platform/binding.md), поэтому сейчас давайте рассмотрим, как работает Xamarin.Mac взгляд изнутри.

Во-первых, есть ли способ предоставления Objective-C, чтобы C#, который делается с помощью селекторов. Селектор — это сообщение, отправляемое объект или класс. С помощью Objective-C это делается с помощью [objc_msgSend](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html) функции. Дополнительные сведения об использовании селекторы см. iOS [селекторы Objective-C](~/ios/internals/objective-c-selectors.md) руководства. Также должен быть способ предоставления управляемого кода Objective-C, который более сложен, тем, что Objective-C не знает ничего о управляемого кода. Чтобы обойти эту проблему, мы используем [регистратора](~/mac/internals/registrar.md). Это более подробно в следующем разделе.

## <a name="registrar"></a>регистратор

Как упоминалось выше, регистратор кода, предоставляет доступ к управляемому коду Objective-C. Это достигается путем создания списка каждый управляемый класс, производный от NSObject:

- Для всех классов, которые не создается программа-оболочка существующего класса Objective-C, он создает новый класс Objective-C с Objective-C участниками зеркального отображения все управляемые элементы с суффиксом `[Export]` атрибута.
- В реализациях для каждого члена Objective-C код для вызова зеркальных управляемого элемента добавляется автоматически.

В приведенном ниже коде псевдо является примером этого является:

**C#(управляемый код):**

```csharp
class MyViewController : UIViewController{
    [Export ("myFunc")]
    public void MyFunc ()
    {
    }
 }
 ```

**Objective-C (машинного кода):**

```objc
@interface MyViewController : UIViewController
 - (void)myFunc;
@end 

@implementation MyViewController
- (void)myFunc {
    // Code to call the managed C# MyFunc method in MyViewController
}
@end
```

Управляемый код может содержать атрибуты `[Register]` и `[Export]`, который использует регистратор, чтобы знать, что объект должен предоставляться Objective-C. Атрибут [регистрация] используется для указания имени создаваемого класса Objective-C, если созданное по умолчанию имя не подходит. Все классы, производные от NSObject автоматически регистрируются с Objective-C. Обязательный атрибут [экспорта] содержит строку, которая является селектор, используемый в созданном классе ему Objective-C.

Существует два типа регистраторов, используемых в Xamarin.Mac — динамический и статический.

- Динамические регистраторов — это регистратор по умолчанию для всех сборок Xamarin.Mac. Динамические регистратор выполняет регистрацию всех типов в сборку во время выполнения. Это делается с помощью функций, предоставляемых API среды выполнения Objective-C. Таким образом, динамические регистратор имеет медленнее запуска, но более быстрой во время сборки. Неуправляемые функции (обычно в C), вызванные trampolines, используются в качестве реализации метода, при использовании динамического регистраторов. Они отличаются в разных архитектур.
- Статические регистраторов — статический регистратор создает код Objective-C во время сборки, который затем компилируется в статическую библиотеку и связанные в исполняемый файл. Это позволяет для быстрого запуска, но занимает больше времени, во время сборки.

## <a name="application-launch"></a>Запуск приложения

Логика запуска Xamarin.Mac будут различаться в зависимости от ли внедренные или используется система Mono. Чтобы просмотреть код и шаги для запуска приложений Xamarin.Mac, изучите [заголовка запуска](https://github.com/xamarin/xamarin-macios/blob/master/runtime/xamarin/launch.h) файл в общедоступном репозитории xamarin macios.

## <a name="generator"></a>Generator

Xamarin.Mac содержит определения для каждого API Mac. Можно выполнять поиск любого из этих на [репозиторий github MaciOS](https://github.com/xamarin/xamarin-macios/tree/master/src). Эти определения содержат интерфейсы с атрибутами, а также все необходимые методы и свойства. Например, следующий код используется для определения NSBox в [пространства имен AppKit](https://github.com/xamarin/xamarin-macios/blob/master/src/appkit.cs#L1465-L1526). Обратите внимание на то, что он является интерфейсом ряд методов и свойств:

```csharp
[BaseType (typeof (NSView))]
public interface NSBox {

        …

        [Export ("borderRect")]
        CGRect BorderRect { get; }

        [Export ("titleRect")]
        CGRect TitleRect { get; }

        [Export ("titleCell")]
        NSObject TitleCell { get; }

        [Export ("sizeToFit")]
        void SizeToFit ();

        [Export ("contentViewMargins")]
        CGSize ContentViewMargins { get; set; }

        [Export ("setFrameFromContentFrame:")]
        void SetFrameFromContentFrame (CGRect contentFrame);

        …

}
```

Генератор, вызывается `bmac` в Xamarin.Mac, принимает эти файлы определения и использует средства .NET, чтобы скомпилировать их во временную сборку. Тем не менее это временная сборка непригоден для вызова кода Objective-C. Генератор, затем считывает временную сборку и создает C# код, который может использоваться во время выполнения. Это, почему, например, при добавлении случайных атрибут для определения CS-файле, оно не будет отображаться в outputted коде. Генератор не знает об этом и поэтому `bmac` не знает, искать его в временную сборку, чтобы вывести его.

Когда Xamarin.Mac.dll будет создана, упаковщик, `mmp`, будут объединены все компоненты.

На высоком уровне это достигается путем выполнения следующих задач:

- Создайте структуру пакета приложения.
- Копирование управляемых сборок.
- Если связывание включено, то запустите управляемых компоновщик для оптимизации сборок путем удаления неиспользуемых частей.
- Создайте приложение средства запуска, связывание в коде запуска говорили о вместе с кодом системе, если в статическом режиме.

Это, а затем Запуск от имени пользователя процесса, который компилируется в сборку пользовательского кода Xamarin.Mac.dll и выполняется такая ссылка `mmp` для упрощения пакета

Дополнительные сведения о компоновщик и как они используются, см. в IOS [компоновщика](~/ios/deploy-test/linker.md) руководства.

## <a name="summary"></a>Сводка

В этом руководстве рассмотрены компиляцию приложений Xamarin.Mac и изучать Xamarin.Mac и его связь с Objective-C.
