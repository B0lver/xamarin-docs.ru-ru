---
title: Как работает Xamarin.Mac
description: В этом документе описывается механизмах Xamarin.Mac. В частности он рассматривает конструкторы, управление памятью, опережает время компиляции и регистратор.
ms.prod: xamarin
ms.assetid: C2053ABB-6DBF-4233-AEEA-B72FC6A81FE1
ms.technology: xamarin-mac
author: lobrien
ms.author: laobri
ms.date: 05/25/2017
ms.openlocfilehash: 0635e110cb2aa7bc00234d3d06df57e0fd6f966e
ms.sourcegitcommit: 6f728aa0c1775224e16c0f3e583cf843d34270f9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2019
ms.locfileid: "59893235"
---
# <a name="how-xamarinmac-works"></a>Как работает Xamarin.Mac

В большинстве случаев разработчик будет никогда не нужно беспокоиться о внутренней «magic» xamarin.Mac, тем не менее, наличие грубого понимание того, как работает вещей взгляд изнутри помогут в обоих интерпретирующего существующую документацию с C# группы связанных элементов и отладка проблемы при их возникновении.

В Xamarin.Mac приложение связывает двух миров: Objective-C на основе среды выполнения, содержащая экземпляры собственные классы (`NSString`, `NSApplication`и т. д) и имеется C# среды выполнения, содержащая экземпляры управляемые классы (`System.String`, `HttpClient`и т. д). Между этими двумя мирами Xamarin.Mac создает два способа моста, поэтому приложение может вызывать методы (селекторы) на Objective-C (такие как `NSApplication.Init`) и Objective-C может вызвать приложение C# методы резервного (например, методы в делегат приложения). В общем случае вызовы в Objective-C обрабатываются прозрачно через **P/Invoke** и кода среды выполнения, Xamarin предоставляет.

<a name="exposing-classes" />

## <a name="exposing-c-classes--methods-to-objective-c"></a>Предоставление доступа к C# классы и методы для Objective-C

Тем не менее для Objective-C, выполнить обратный вызов приложения C# объекты, они должны быть доступны в виде, можно понять, Objective-C. Это делается с помощью `Register` и `Export` атрибуты. Рассмотрим следующий пример:

```csharp
[Register ("MyClass")]
public class MyClass : NSObject
{
   [Export ("init")]
   public MyClass ()
   {
   }

   [Export ("run")]
   public void Run ()
   {
   }
}
```

В этом примере среда выполнения Objective-C, теперь будут знать о класс с именем `MyClass` с именем селекторы `init` и `run`.

В большинстве случаев это деталь реализации, разработчик может игнорировать, так как большинство обратные вызовы, приложение получает будет работать, либо с помощью переопределенные методы `base` классов (таких как `AppDelegate`, `Delegates`, `DataSources`) или на  **Действия** передан в API-интерфейсы. Во всех этих случаях `Export` атрибуты не требуются в C# кода.

## <a name="constructor-runthrough"></a>Конструктор runthrough

Во многих случаях разработчику потребуется предоставить доступ к приложения C# классы конструкцию API среды выполнения Objective-C, поэтому он может быть создан из мест, например, при вызове в Storyboard "или" XIB файлов. Ниже приведены пять наиболее распространенных конструкторы, используемые в приложениях для Xamarin.Mac.

```csharp
// Called when created from unmanaged code
public CustomView (IntPtr handle) : base (handle)
{
   Initialize ();
}

// Called when created directly from a XIB file
[Export ("initWithCoder:")]
public CustomView (NSCoder coder) : base (coder)
{
   Initialize ();
}

// Called from C# to instance NSView with a Frame (initWithFrame)
public CustomView (CGRect frame) : base (frame)
{
}

// Called from C# to instance NSView without setting the frame (init)
public CustomView () : base ()
{
}

// This is a special case constructor that you call on a derived class when the derived called has an [Export] constructor.
// For example, if you call init on NSString then you don’t want to call init on NSObject.
public CustomView () : base (NSObjectFlag.Empty)
{
}
```

В общем случае следует оставить разработчик `IntPtr` и `NSCoder` конструкторы, которые создаются при создании некоторых типов, таких как настраиваемые `NSViews` отдельно. Если вы удалили Xamarin.Mac необходимо вызвать один из этих конструкторов в ответ на запрос среде выполнения Objective-C, произойдет сбой приложения в машинном коде и сложно выявить точно проблему.

## <a name="memory-management-and-cycles"></a>Управление памятью и циклы

Управление памятью в Xamarin.Mac является во многих отношениях, очень похожа на Xamarin.iOS. Он также является непростой проблемой, один выходит за рамки этого документа. См. в статье [памяти и рекомендации по повышению производительности](~/cross-platform/deploy-test/memory-perf-best-practices.md).

## <a name="ahead-of-time-compilation"></a>Преимущества времени компиляции

Как правило, приложений .NET не компилируются в машинный код при построении, вместо этого они компилируются в промежуточный слой называется код IL, который получает _Just-In-Time_ (JIT) скомпилированные в машинный код при запуске приложения.

Время, необходимое среда выполнения mono JIT-компиляцию этого кода может замедлить запуск приложения Xamarin.Mac на 20%, занять некоторое время для необходимых машинный код будет создан.

Из-за ограничений, налагаемых Apple на устройствах iOS JIT-компиляция кода IL не доступен для Xamarin.iOS. В результате все приложения Xamarin.iOS полны _Ahead-Of-Time_ (AOT) компиляции в машинный код в процессе построения.

Новый на Xamarin.Mac является возможность AOT код IL в процессе построения приложения так же, как можно Xamarin.iOS. Использует Xamarin.Mac _гибридных_ AOT подход, который компилирует большую часть необходимых машинный код, но позволяет среде выполнения для компиляции необходимые trampolines и характеризуется гибкостью, продолжают поддерживать Reflection.Emit (и других целей обращения, в настоящее время работает на Xamarin.Mac).

Существует два основных областей, где AOT могут помочь приложения Xamarin.Mac.

- **Лучше журналы сбоев «собственных»** - в случае сбоя приложения Xamarin.Mac в машинном коде, который является обычное дело при выполнении недопустимый вызовов в API-интерфейсов Cocoa (например, отправку `null` в метод, который не принимает ее) собственных журналов с помощью JIT-компилятора сбоев кадры трудны для анализа. Так как фреймы JIT Нет отладочной информации, будет существовать несколько строк с помощью шестнадцатеричных смещения и не может понять, что происходило. AOT создает «настоящий» именованный кадров и трассировки гораздо удобнее для чтения. Это также означает приложения Xamarin.Mac будет улучшается взаимодействие с помощью собственных средств например **lldb** и **Instruments**.
- **Лучше запуска производительность во время** — для больших приложений Xamarin.Mac с помощью нескольких запуска повторно, JIT-компиляция весь код может занять значительное время. AOT выполняет эту работу.

### <a name="enabling-aot-compilation"></a>Включение компиляции AOT

AOT включен в Xamarin.Mac, дважды щелкнув **имя_проекта** в **обозревателе решений**, переходе по адресу **сборки Mac** и добавление `--aot:[options]` для  **Дополнительные аргументы mmp:** поле (где `[options]` — один или несколько параметров типа AOT элемента управления, см. ниже). Пример:

![Добавление AOT дополнительные аргументы mmp](how-it-works-images/aot01.png "Добавление AOT, чтобы дополнительные аргументы mmp")

> [!IMPORTANT]
> Включение AOT компиляции значительно увеличивает время сборки, иногда до нескольких минут, но оно может улучшить время запуска приложения в среднем на 20%. В результате компиляции AOT следует включать только на **выпуска** сборки приложения Xamarin.Mac.

### <a name="aot-compilation-options"></a>Параметры компиляции AOT

Существует несколько различных параметров, которые можно настраивать при включении AOT-компиляцию для приложения Xamarin.Mac.

- `none` — Должен отсутствовать компиляция AOT. Этот параметр используется по умолчанию.
- `all` -AOT компиляция каждая сборка MonoBundle.
- `core` -Компиляция AOT `Xamarin.Mac`, `System` и `mscorlib` сборок.
- `sdk` -Компиляция AOT `Xamarin.Mac` и сборки библиотеки базовых классов (BCL).
- `|hybrid` — Добавление это одно из перечисленных выше включает гибридную компиляцию AOT, что позволяет исключить промежуточный язык, но будет приводят к увеличению времени компиляции.
- `+` — Включает в себя один файл для компиляции AOT.
- `-` — Удаляет файл из компиляции AOT.

Например `--aot:all,-MyAssembly.dll` позволит компиляция AOT на все сборки в MonoBundle _за исключением_ `MyAssembly.dll` и `--aot:core|hybrid,+MyOtherAssembly.dll,-mscorlib.dll` бы Включение в гибридной среде, включите код AOT `MyOtherAssembly.dll` и исключение `mscorlib.dll`.

## <a name="partial-static-registrar"></a>Частичные статический регистратора

При разработке приложения Xamarin.Mac, сводя к минимуму время между завершение, изменение и его тестирование может стать важным к соблюдению сроков разработки. Стратегии например модульность базы кода и модульные тесты может помочь позволяет сократить время компиляции, так как они уменьшают количество раз, что приложение потребуется дорогостоящие полное перестроение.

Кроме того и знакомы с Xamarin.Mac, _частичного статический регистратора_ (как впервые введены в Xamarin.iOS) может значительно сократить время запуска приложения Xamarin.Mac в **Отладка** конфигурации. Понимание того, как можно с помощью частичного статический регистратора сжато почти улучшения в 5 раз в запуске отладки займет немного фона на такое регистратор, какова разница между статических и динамических и что делает эта версия «частичное static».

### <a name="about-the-registrar"></a>О регистратор

Что скрывается за любой Xamarin.Mac приложения лежит платформа Cocoa Apple и среды выполнения Objective-C. Создание моста между этой «машинного кода» и «управляемым миром» C# является основной обязанностью Xamarin.Mac. В рамках этого задания обрабатывается регистратор, который выполняется внутри `NSApplication.Init ()` метод. Это одна из причин, требующий использование API-интерфейсов Cocoa в Xamarin.Mac `NSApplication.Init` вызывается первой.

Задание регистратора — для информирования о существовании приложения среды выполнения Objective-C C# классы, производные от классов, таких как `NSApplicationDelegate`, `NSView`, `NSWindow`, и `NSObject`. Это требует просмотра всех типов в приложении, чтобы определить, требующие регистрации и какие элементы на каждого типа отчета.

Такая проверка может выполняться либо **динамически**, при запуске приложения с помощью отражения, или **статически**, в качестве шага время сборки. При выборе типа регистрации, разработчику следует иметь в виду следующие:

- Статические регистрации может значительно сократить время запуска, но может замедлить раз сборок значительно (обычно более чем в два раза время отладочной сборки). Это будет по умолчанию для **выпуска** конфигурации построения.
- Динамическая регистрация откладывается до этой работы приложения, запустите и пропускает создание кода, но дополнительной работы можно создать заметно паузу (по крайней мере две секунды) в запуска приложений. Это особенно заметно в отладочных сборках конфигурации, который по умолчанию для динамической регистрации и занимает больше времени, отражения.

Частичные статические регистрации, впервые представленный в Xamarin.iOS 8.13 дает разработчику лучшее из обоих вариантов. Путем предварительного вычисления сведения о регистрации каждого элемента в `Xamarin.Mac.dll` и доставки этих данных с помощью Xamarin.Mac в статической библиотеке (которому требуется только перейти во время сборки), как корпорация Майкрософт устранила большую часть времени отражения динамической Регистратор ущерба время сборки.

### <a name="enabling-the-partial-static-registrar"></a>Включение частичного статический регистратора

Частичные статический регистратор включен в Xamarin.Mac, дважды щелкнув **имя_проекта** в **обозревателе решений**, переходе по адресу **сборки Mac** и добавление `--registrar:static` для **дополнительные аргументы mmp:** поля. Пример:

![Добавление частичного статический регистратор дополнительные аргументы mmp](how-it-works-images/psr01.png "Добавление частичного статический регистратор дополнительные аргументы mmp")

## <a name="additional-resources"></a>Дополнительные ресурсы

Ниже приведены более подробные пояснения сведениями о работе внутренним образом.

- [Селекторы Objective-C](~/ios/internals/objective-c-selectors.md)
- [Регистратор](~/ios/internals/registrar.md)
- [Единый API Xamarin для iOS и OS X](~/cross-platform/macios/unified/index.md)
- [Основы theading](~/ios/app-fundamentals/threading.md)
- [Делегаты, протоколов и событий](~/ios/app-fundamentals/delegates-protocols-and-events.md)
- [О `newrefcount`](~/ios/internals/newrefcount.md)

