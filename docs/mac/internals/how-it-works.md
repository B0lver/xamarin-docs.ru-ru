---
title: Как работает Xamarin.Mac
description: В этом документе описываются внутренние работы Xamarin. Mac. В частности, в нем рассматриваются конструкторы, управление памятью, предварительная компиляция и регистратор.
ms.prod: xamarin
ms.assetid: C2053ABB-6DBF-4233-AEEA-B72FC6A81FE1
ms.technology: xamarin-mac
author: davidortinau
ms.author: daortin
ms.date: 05/25/2017
ms.openlocfilehash: 347fb1021a290fa849ae354468bc66b0cdd8b684
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73017595"
---
# <a name="how-xamarinmac-works"></a>Как работает Xamarin.Mac

В большинстве случаев разработчику никогда не придется беспокоиться о внутренней «волшебности» Xamarin. Mac, но при этом вы сможете понять, как именно работает работа, и как интерпретировать существующую документацию с C# объективом и отладкой. проблемы, возникающие при их возникновении.

В Xamarin. Mac приложение связывает две части: существует среда выполнения на основе цели, содержащая экземпляры собственных классов (`NSString`, `NSApplication`и т. д.), и существует C# среда выполнения, содержащая экземпляры управляемых классов (`System.String`,`HttpClient`и т. д.). . Между этими двумя мировыми приложениями Xamarin. Mac создает двусторонний мост, чтобы приложение вызывало методы (селекторы) в цели-C (например, `NSApplication.Init`) и цель-C может вызывать C# методы приложения обратно (например, методы в делегате приложения). Как правило, вызовы цели-C обрабатываются прозрачно через **P/Invokes** и в некоторый код среды выполнения Xamarin предоставляется.

<a name="exposing-classes" />

## <a name="exposing-c-classes--methods-to-objective-c"></a>Предоставление C# классов и методов цели-C

Однако для цели-C, чтобы выполнить обратный вызов C# объектов приложения, они должны быть предоставлены таким образом, что цель-c может понять. Это делается с помощью атрибутов `Register` и `Export`. Рассмотрим следующий пример:

```csharp
[Register ("MyClass")]
public class MyClass : NSObject
{
   [Export ("init")]
   public MyClass ()
   {
   }

   [Export ("run")]
   public void Run ()
   {
   }
}
```

В этом примере среда выполнения цели-C теперь будет иметь представление о классе с именем `MyClass` с селекторами, которые называются `init` и `run`.

В большинстве случаев это сведения о реализации, которые разработчик может игнорировать, так как большинство обратных вызовов, получаемых приложением, будет либо через переопределенные методы в `base` классы (такие как `AppDelegate`, `Delegates`, `DataSources`) или **действия** , передаваемые в интерфейсы API. Во всех этих случаях в C# коде не требуется `Export` атрибутов.

## <a name="constructor-runthrough"></a>Обзор конструктора

Во многих случаях разработчику необходимо предоставить API-интерфейс создания C# классов приложения исполняющей среде целевой среды, чтобы его можно было создать из таких мест, как при вызове в файлах STORYBOARD или XIB. Ниже приведены пять наиболее распространенных конструкторов, используемых в приложениях Xamarin. Mac:

```csharp
// Called when created from unmanaged code
public CustomView (IntPtr handle) : base (handle)
{
   Initialize ();
}

// Called when created directly from a XIB file
[Export ("initWithCoder:")]
public CustomView (NSCoder coder) : base (coder)
{
   Initialize ();
}

// Called from C# to instance NSView with a Frame (initWithFrame)
public CustomView (CGRect frame) : base (frame)
{
}

// Called from C# to instance NSView without setting the frame (init)
public CustomView () : base ()
{
}

// This is a special case constructor that you call on a derived class when the derived called has an [Export] constructor.
// For example, if you call init on NSString then you don’t want to call init on NSObject.
public CustomView () : base (NSObjectFlag.Empty)
{
}
```

В общем случае разработчик должен оставить конструкторы `IntPtr` и `NSCoder`, которые создаются при создании некоторых типов, таких как пользовательские `NSViews`. Если Xamarin. Mac должен вызывать один из этих конструкторов в ответ на запрос выполнения целевой-C, и вы удалили его, приложение аварийно завершит работу внутри машинного кода, и, возможно, будет трудно определить именно эту ошибку.

## <a name="memory-management-and-cycles"></a>Управление памятью и циклы

Управление памятью в Xamarin. Mac во многом похоже на Xamarin. iOS. Это также сложная тема, которая выходит за рамки этого документа. Ознакомьтесь с рекомендациями по [использованию памяти и производительности](~/cross-platform/deploy-test/memory-perf-best-practices.md).

## <a name="ahead-of-time-compilation"></a>Компиляция перед временем

Как правило, приложения .NET не компилируются в машинный код при их построении, а компилируются в промежуточный уровень, именуемый кодом IL, который получает JIT _-_ компиляцию в машинный код при запуске приложения.

Время, которое требуется среде выполнения Mono для JIT-компиляции. Этот машинный код может замедлять запуск приложения Xamarin. Mac до 20%, так как требует времени на создание необходимого кода компьютера.

Из-за ограничений, накладываемых Apple на iOS, JIT-компиляция кода IL недоступна для Xamarin. iOS. В результате все приложение Xamarin. iOS полностью подготовлено к _работе (AOT_ ), скомпилированное в машинный код во время цикла сборки.

Новые возможности Xamarin. Mac — это возможность AOT-кода IL во время цикла сборки приложения, как и в случае с Xamarin. iOS. Xamarin. Mac использует _гибридный_ подход AOT, который компилирует большую часть необходимого машинного кода, но позволяет среде выполнения компилировать необходимые трамполинес и гибкость для поддержки отражения. Emit (и других вариантов использования, которые в настоящее время работают в Xamarin. Mac).

Существует две основные области, в которых AOT может помочь приложению Xamarin. Mac:

- **Лучшие "собственные" журналы аварийного** восстановления. Если приложение Xamarin. Mac аварийно завершает работу в машинном коде, что является распространенным событием при недопустимых вызовах API Cocoa (например, отправка `null` в метод, который не принимает его), собственные журналы аварийного завершения с кадрами JIT-компилятора сложно анализировать. Так как в кадрах JIT нет отладочной информации, будет несколько строк с шестнадцатеричными смещениями и никакими сведениями о том, что происходит. AOT создает "реальные" Именованные фреймы, и трассировки гораздо легче читать. Это также означает, что приложение Xamarin. Mac будет работать лучше с собственными средствами, такими как **lldb** и **Instruments**.
- **Более высокая производительность во время запуска** . для больших приложений Xamarin. Mac с множественным временем запуска JIT-компиляция всего кода может занять значительное время. AOT выполняет эту работу заранее.

### <a name="enabling-aot-compilation"></a>Включение компиляции AOT

Для включения AOT в Xamarin. Mac дважды щелкните **имя проекта** в **Обозреватель решений**, перейдите к **сборке Mac** и добавьте `--aot:[options]` в поле **Дополнительные аргументы MMP:** (где `[options]` — один или несколько параметров для Управление типом AOT см. ниже. Пример:

![Добавление AOT в дополнительные аргументы MMP](how-it-works-images/aot01.png "Добавление AOT в дополнительные аргументы MMP")

> [!IMPORTANT]
> Включение компиляции AOT значительно увеличивает время сборки, иногда до нескольких минут, но может повысить время запуска приложения в среднем на 20%. В результате компиляция AOT должна быть включена только для сборок **выпуска** приложения Xamarin. Mac.

### <a name="aot-compilation-options"></a>Параметры компиляции AOT

Существует несколько различных параметров, которые можно изменить при включении компиляции AOT в приложении Xamarin. Mac:

- `none` — компиляция AOT не производится. Этот параметр используется по умолчанию.
- `all`-AOT компилирует каждую сборку в виде пакета.
- `core`-AOT компилирует сборки `Xamarin.Mac`, `System` и `mscorlib`.
- `sdk`-AOT компилирует сборки `Xamarin.Mac` и библиотеки базовых классов (BCL).
- `|hybrid` Добавление этого параметра к одному из указанных выше параметров позволяет выполнять гибридную AOT, которая позволяет выключать IL, но приводит к более длительному времени компиляции.
- `+` — включает один файл для компиляции AOT.
- `-` — удаляет один файл из компиляции AOT.

Например, `--aot:all,-MyAssembly.dll` включит компиляцию AOT для всех сборок в виде пакета, _за исключением_ `MyAssembly.dll` и `--aot:core|hybrid,+MyOtherAssembly.dll,-mscorlib.dll` включит гибридную функцию, код AOT включает `MyOtherAssembly.dll` и исключение `mscorlib.dll`.

## <a name="partial-static-registrar"></a>Частичный статический регистратор

При разработке приложения Xamarin. Mac необходимо свести к минимуму время между выполнением изменений и тестированием, которое может оказаться важным для достижения сроков разработки. Такие стратегии, как модульная архитектура баз кода и модульных тестов, позволяют уменьшить время компиляции, так как они уменьшают количество случаев, когда приложению потребуется дорогостоящее полное перестроение.

Кроме того, и новые возможности Xamarin. Mac, _частичный регистратор_ (как в составе Xamarin. IOS) может значительно сократить время запуска приложения Xamarin. Mac в конфигурации **отладки** . Понимание того, как использование частичного статического регистратора может быть сжато почти 5x усовершенствованием при запуске отладки, повлечет немного опыта работы регистратора, различия между статичными и динамическими, а также то, что делает эта «частичная статическая» версия.

### <a name="about-the-registrar"></a>Сведения о регистраторе

Внутри любого приложения Xamarin. Mac лежит Cocoa Framework от Apple и исполняющей среды цели-C. Создание моста между этим "собственным миром" и "управляемым миром" C# является основной обязанностью Xamarin. Mac. Часть этой задачи обрабатывается регистратором, который выполняется внутри метода `NSApplication.Init ()`. Это одна из причин того, что для использования API-интерфейсов Cocoa в Xamarin. Mac необходимо сначала вызвать `NSApplication.Init`.

Задача регистратора — сообщить среде выполнения цель-C о существовании C# классов приложения, производных от классов, таких как`NSApplicationDelegate`,`NSView`,`NSWindow`и`NSObject`. Для этого необходимо проверить все типы в приложении, чтобы определить, какие требования необходимо зарегистрировать и какие элементы каждого типа следует сообщить.

Эту проверку можно выполнить **динамически**, при запуске приложения с помощью отражения или **статически**, как шаг времени сборки. При выборе типа регистрации разработчик должен учитывать следующее:

- Статическая регистрация может радикально сократить время запуска, но может значительно замедлить работу сборок (обычно более чем двойная Отладка времени сборки). Это будет значение по умолчанию для сборок конфигурации **выпуска** .
- Динамическая регистрация задерживает эту работу до запуска приложения и пропускает создание кода, но эта дополнительная работа может создать заметную паузу (по крайней мере две секунды) при запуске приложения. Это особенно заметно в отладочных сборках конфигурации, в которых по умолчанию используется динамическая регистрация, а отражение выполняется медленнее.

Частичная статическая регистрация, впервые представленная в Xamarin. iOS 8,13, дает разработчику лучшее из обоих вариантов. Предварительное вычисление сведений о регистрации каждого элемента в `Xamarin.Mac.dll` и отправка этих сведений с помощью Xamarin. Mac в статической библиотеке (которая должна быть связана только во время сборки), корпорация Майкрософт удалила большую часть времени отражения динамического регистратора. Хотя это не влияет на время сборки.

### <a name="enabling-the-partial-static-registrar"></a>Включение частичного статического регистратора

Частичный статический регистратор включен в Xamarin. Mac. для этого дважды щелкните **имя проекта** в **Обозреватель решений**, перейдите к **сборке Mac** и добавьте `--registrar:static` в поле **Дополнительные аргументы MMP:** . Пример:

![Добавление частичного статического регистратора к дополнительным аргументам MMP](how-it-works-images/psr01.png "Добавление частичного статического регистратора к дополнительным аргументам MMP")

## <a name="additional-resources"></a>Дополнительные ресурсы

Ниже приведены некоторые более подробные объяснения того, как работают внутренние компоненты:

- [Селекторы цели-C](~/ios/internals/objective-c-selectors.md)
- [Регистратор](~/ios/internals/registrar.md)
- [Xamarin Unified API для iOS и OS X](~/cross-platform/macios/unified/index.md)
- [Основы сеадинг](~/ios/app-fundamentals/threading.md)
- [Делегаты, протоколы и события](~/ios/app-fundamentals/delegates-protocols-and-events.md)
- [О `newrefcount`](~/ios/internals/newrefcount.md)
