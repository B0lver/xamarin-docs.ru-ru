---
title: Как работает Xamarin.Mac
description: В этом документе описываются внутренние работы Xamarin. Mac. В частности, в нем рассматриваются конструкторы, управление памятью, предварительная компиляция и регистратор.
ms.prod: xamarin
ms.assetid: C2053ABB-6DBF-4233-AEEA-B72FC6A81FE1
ms.technology: xamarin-mac
author: conceptdev
ms.author: crdun
ms.date: 05/25/2017
ms.openlocfilehash: 24ddd71fe1468edc70ec4d487dc2cb2dbd4da1b6
ms.sourcegitcommit: 57f815bf0024b1afe9754c0e28054fc0a53ce302
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70769812"
---
# <a name="how-xamarinmac-works"></a>Как работает Xamarin.Mac

В большинстве случаев разработчику никогда не придется беспокоиться о внутренней «волшебности» Xamarin. Mac, но при этом вы сможете понять, как именно работает работа, и как интерпретировать существующую документацию с C# объективом и отладкой. проблемы, возникающие при их возникновении.

В Xamarin. Mac приложение связывает две мировые задачи: Существует среда выполнения на основе цели, содержащая экземпляры собственных классов (`NSString`, `NSApplication`и т. д.), и существует C# среда выполнения, содержащая экземпляры управляемых классов`System.String`( `HttpClient`, и т. д.). Между этими двумя мировыми приложениями Xamarin. Mac создает двусторонний мост, поэтому приложение может вызывать методы (селекторы) в цели-c (например,) и `NSApplication.Init`цель-c — могут вызывать C# методы приложения обратно (например, методы в делегате приложения). Как правило, вызовы цели-C обрабатываются прозрачно через **P/Invokes** и в некоторый код среды выполнения Xamarin предоставляется.

<a name="exposing-classes" />

## <a name="exposing-c-classes--methods-to-objective-c"></a>Предоставление C# классов и методов цели-C

Однако для цели-C, чтобы выполнить обратный вызов C# объектов приложения, они должны быть предоставлены таким образом, что цель-c может понять. Это делается с `Register` помощью атрибутов и `Export` . Рассмотрим следующий пример:

```csharp
[Register ("MyClass")]
public class MyClass : NSObject
{
   [Export ("init")]
   public MyClass ()
   {
   }

   [Export ("run")]
   public void Run ()
   {
   }
}
```

В этом примере среда выполнения цели-C теперь будет иметь представление о классе, который `MyClass` называется с помощью селекторов `run` `init` и.

В большинстве случаев это сведения о реализации, которые разработчик может игнорировать, так как большинство обратных вызовов, получаемых приложением, будет либо через переопределенные методы `base` в классах ( `AppDelegate`например `Delegates`, `DataSources`,), либо в **действиях** . передается в интерфейсы API. Во всех этих случаях `Export` атрибуты не нужны в C# коде.

## <a name="constructor-runthrough"></a>Обзор конструктора

Во многих случаях разработчику необходимо предоставить API-интерфейс создания C# классов приложения исполняющей среде целевой среды, чтобы его можно было создать из таких мест, как при вызове в файлах STORYBOARD или XIB. Ниже приведены пять наиболее распространенных конструкторов, используемых в приложениях Xamarin. Mac:

```csharp
// Called when created from unmanaged code
public CustomView (IntPtr handle) : base (handle)
{
   Initialize ();
}

// Called when created directly from a XIB file
[Export ("initWithCoder:")]
public CustomView (NSCoder coder) : base (coder)
{
   Initialize ();
}

// Called from C# to instance NSView with a Frame (initWithFrame)
public CustomView (CGRect frame) : base (frame)
{
}

// Called from C# to instance NSView without setting the frame (init)
public CustomView () : base ()
{
}

// This is a special case constructor that you call on a derived class when the derived called has an [Export] constructor.
// For example, if you call init on NSString then you don’t want to call init on NSObject.
public CustomView () : base (NSObjectFlag.Empty)
{
}
```

В общем случае разработчик должен оставить `IntPtr` конструкторы и `NSCoder` , созданные при создании некоторых типов, например, только пользовательских. `NSViews` Если Xamarin. Mac должен вызывать один из этих конструкторов в ответ на запрос выполнения целевой-C, и вы удалили его, приложение аварийно завершит работу внутри машинного кода, и, возможно, будет трудно определить именно эту ошибку.

## <a name="memory-management-and-cycles"></a>Управление памятью и циклы

Управление памятью в Xamarin. Mac во многом похоже на Xamarin. iOS. Это также сложная тема, которая выходит за рамки этого документа. Ознакомьтесь с рекомендациями по [использованию памяти и производительности](~/cross-platform/deploy-test/memory-perf-best-practices.md).

## <a name="ahead-of-time-compilation"></a>Компиляция перед временем

Как правило, приложения .NET не компилируются в машинный код при их построении, а компилируются в промежуточный уровень, именуемый кодом IL, который получает JIT _-_ компиляцию в машинный код при запуске приложения.

Время, которое требуется среде выполнения Mono для JIT-компиляции. Этот машинный код может замедлять запуск приложения Xamarin. Mac до 20%, так как требует времени на создание необходимого кода компьютера.

Из-за ограничений, накладываемых Apple на iOS, JIT-компиляция кода IL недоступна для Xamarin. iOS. В результате все приложение Xamarin. iOS полностью подготовлено к _работе (AOT_ ), скомпилированное в машинный код во время цикла сборки.

Новые возможности Xamarin. Mac — это возможность AOT-кода IL во время цикла сборки приложения, как и в случае с Xamarin. iOS. Xamarin. Mac использует _гибридный_ подход AOT, который компилирует большую часть необходимого машинного кода, но позволяет среде выполнения компилировать необходимые трамполинес и гибкость для поддержки отражения. Emit (и других вариантов использования, которые в настоящее время работают в Xamarin. Mac).

Существует две основные области, в которых AOT может помочь приложению Xamarin. Mac:

- **Более эффективные "собственные" журналы аварийного** восстановления — если приложение Xamarin. Mac аварийно завершает работу в машинном коде, что является распространенным событием при недопустимых вызовах API Cocoa (например, отправка `null` в метод, который не принимает его), собственные журналы аварийного завершения с кадрами JIT сложно анализировать. Так как в кадрах JIT нет отладочной информации, будет несколько строк с шестнадцатеричными смещениями и никакими сведениями о том, что происходит. AOT создает "реальные" Именованные фреймы, и трассировки гораздо легче читать. Это также означает, что приложение Xamarin. Mac будет работать лучше с собственными средствами, такими как **lldb** и **Instruments**.
- **Более высокая производительность во время запуска** . для больших приложений Xamarin. Mac с множественным временем запуска JIT-компиляция всего кода может занять значительное время. AOT выполняет эту работу заранее.

### <a name="enabling-aot-compilation"></a>Включение компиляции AOT

Для включения AOT в Xamarin. Mac дважды щелкните **имя проекта** в **Обозреватель решений**, перейдите к **сборке Mac** и добавьте `--aot:[options]` в поле **Дополнительные аргументы MMP:** (где `[options]` — один или несколько объектов). параметры для управления типом AOT см. ниже. Например:

![Добавление AOT в дополнительные аргументы MMP](how-it-works-images/aot01.png "Добавление AOT в дополнительные аргументы MMP")

> [!IMPORTANT]
> Включение компиляции AOT значительно увеличивает время сборки, иногда до нескольких минут, но может повысить время запуска приложения в среднем на 20%. В результате компиляция AOT должна быть включена только для сборок **выпуска** приложения Xamarin. Mac.

### <a name="aot-compilation-options"></a>Параметры компиляции AOT

Существует несколько различных параметров, которые можно изменить при включении компиляции AOT в приложении Xamarin. Mac:

- `none`— Без компиляции AOT. Этот параметр используется по умолчанию.
- `all`-AOT компилирует каждую сборку в виде пакета.
- `core`-AOT компилирует `Xamarin.Mac` `System` сборки и `mscorlib` .
- `sdk`-AOT компилирует `Xamarin.Mac` сборки и библиотеки базовых классов (BCL).
- `|hybrid`-Добавление этого параметра к одному из указанных выше параметров позволяет выполнять гибридную AOT, которая позволяет выключать IL, но приводит к более длительному времени компиляции.
- `+`— Включает один файл для компиляции AOT.
- `-`— Удаляет один файл из компиляции AOT.

Например, `--aot:all,-MyAssembly.dll` может включить компиляцию AOT для всех сборок в пакете, _за исключением того_ `MyAssembly.dll` , что `--aot:core|hybrid,+MyOtherAssembly.dll,-mscorlib.dll` будет `mscorlib.dll`использовать гибридную версию, код AOT `MyOtherAssembly.dll` должен включать и исключать.

## <a name="partial-static-registrar"></a>Частичный статический регистратор

При разработке приложения Xamarin. Mac необходимо свести к минимуму время между выполнением изменений и тестированием, которое может оказаться важным для достижения сроков разработки. Такие стратегии, как модульная архитектура баз кода и модульных тестов, позволяют уменьшить время компиляции, так как они уменьшают количество случаев, когда приложению потребуется дорогостоящее полное перестроение.

Кроме того, и новые возможности Xamarin. Mac, _частичный регистратор_ (как в составе Xamarin. IOS) может значительно сократить время запуска приложения Xamarin. Mac в конфигурации **отладки** . Понимание того, как использование частичного статического регистратора может быть сжато почти 5x усовершенствованием при запуске отладки, повлечет немного опыта работы регистратора, различия между статичными и динамическими, а также то, что делает эта «частичная статическая» версия.

### <a name="about-the-registrar"></a>Сведения о регистраторе

Внутри любого приложения Xamarin. Mac лежит Cocoa Framework от Apple и исполняющей среды цели-C. Создание моста между этим "собственным миром" и "управляемым миром" C# является основной обязанностью Xamarin. Mac. Часть этой задачи обрабатывается регистратором, который выполняется внутри `NSApplication.Init ()` метода. Это одна из причин того, что любое использование API-интерфейсов Cocoa в `NSApplication.Init` Xamarin. Mac необходимо вызывать первыми.

Задание регистратора состоит в том, чтобы сообщить среде выполнения цели-C C# о существовании классов приложения, производных от классов, таких как `NSApplicationDelegate`, `NSView` `NSWindow`, и `NSObject`. Для этого необходимо проверить все типы в приложении, чтобы определить, какие требования необходимо зарегистрировать и какие элементы каждого типа следует сообщить.

Эту проверку можно выполнить **динамически**, при запуске приложения с помощью отражения или **статически**, как шаг времени сборки. При выборе типа регистрации разработчик должен учитывать следующее:

- Статическая регистрация может радикально сократить время запуска, но может значительно замедлить работу сборок (обычно более чем двойная Отладка времени сборки). Это будет значение по умолчанию для сборок конфигурации **выпуска** .
- Динамическая регистрация задерживает эту работу до запуска приложения и пропускает создание кода, но эта дополнительная работа может создать заметную паузу (по крайней мере две секунды) при запуске приложения. Это особенно заметно в отладочных сборках конфигурации, в которых по умолчанию используется динамическая регистрация, а отражение выполняется медленнее.

Частичная статическая регистрация, впервые представленная в Xamarin. iOS 8,13, дает разработчику лучшее из обоих вариантов. Предварительно вычисляя сведения о регистрации каждого элемента в `Xamarin.Mac.dll` и отправляя эту информацию с помощью Xamarin. Mac в статическую библиотеку (которая должна быть связана только во время сборки), корпорация Майкрософт удалила большую часть времени отражения динамического регистратор, не влияющий на время сборки.

### <a name="enabling-the-partial-static-registrar"></a>Включение частичного статического регистратора

Частичный статический регистратор включен в Xamarin. Mac. для этого дважды щелкните **имя проекта** в **Обозреватель решений**, перейдите к **сборке Mac** и добавьте `--registrar:static` в поле **Дополнительные аргументы MMP:** . Например:

![Добавление частичного статического регистратора к дополнительным аргументам MMP](how-it-works-images/psr01.png "Добавление частичного статического регистратора к дополнительным аргументам MMP")

## <a name="additional-resources"></a>Дополнительные ресурсы

Ниже приведены некоторые более подробные объяснения того, как работают внутренние компоненты:

- [Селекторы цели-C](~/ios/internals/objective-c-selectors.md)
- [Регистратор](~/ios/internals/registrar.md)
- [Xamarin Unified API для iOS и OS X](~/cross-platform/macios/unified/index.md)
- [Основы сеадинг](~/ios/app-fundamentals/threading.md)
- [Делегаты, протоколы и события](~/ios/app-fundamentals/delegates-protocols-and-events.md)
- [Скоро`newrefcount`](~/ios/internals/newrefcount.md)
