---
title: Как работает Xamarin.Mac
description: В этом документе описываются внутренние работы Xamarin. Mac. В частности, в нем рассматриваются конструкторы, управление памятью, предварительная компиляция и регистратор.
ms.prod: xamarin
ms.assetid: C2053ABB-6DBF-4233-AEEA-B72FC6A81FE1
ms.technology: xamarin-mac
author: davidortinau
ms.author: daortin
ms.date: 05/25/2017
ms.openlocfilehash: 05bb9a5552022ea1eb5cd92df90659f7ebacb7cc
ms.sourcegitcommit: 93e6358aac2ade44e8b800f066405b8bc8df2510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84571653"
---
# <a name="how-xamarinmac-works"></a>Как работает Xamarin.Mac

В большинстве случаев разработчику никогда не придется беспокоиться о внутренней «волшебности» Xamarin. Mac, однако при возникновении неисправности в работе с этой документацией будут рассмотрены проблемы, связанные с просмотром и отладкой на C#.

В Xamarin. Mac приложение связывает две части: существует среда выполнения на основе цели-C, содержащая экземпляры машинных классов ( `NSString` , и `NSApplication` т. д.), а среда выполнения C# содержит экземпляры управляемых классов ( `System.String` , `HttpClient` и т. д.). Между этими двумя мировыми приложениями Xamarin. Mac создает двусторонний мост, чтобы приложение вызывало методы (селекторы) в цели-C (например, `NSApplication.Init` ) и цель-c, может вызывать методы C# обратно (например, методы в делегате приложения). Как правило, вызовы цели-C обрабатываются прозрачно через **P/Invokes** и в некоторый код среды выполнения Xamarin предоставляется.

<a name="exposing-classes"></a>

## <a name="exposing-c-classes--methods-to-objective-c"></a>Предоставление классов и методов C# для цели-C

Однако для цели-C, чтобы выполнить обратный вызов объектов C# приложения, они должны быть представлены таким образом, что цель-C может понять. Это делается с помощью `Register` атрибутов и `Export` . Рассмотрим следующий пример:

```csharp
[Register ("MyClass")]
public class MyClass : NSObject
{
   [Export ("init")]
   public MyClass ()
   {
   }

   [Export ("run")]
   public void Run ()
   {
   }
}
```

В этом примере среда выполнения цели-C теперь будет иметь представление о классе, который называется `MyClass` с помощью селекторов `init` и `run` .

В большинстве случаев это сведения о реализации, которые разработчик может игнорировать, так как большинство обратных вызовов, получаемых приложением, будет либо через переопределенные методы в `base` классах (например `AppDelegate` ,,), `Delegates` `DataSources` либо на **действия** , передаваемые в интерфейсы API. Во всех этих случаях `Export` атрибуты не нужны в коде C#.

## <a name="constructor-runthrough"></a>Обзор конструктора

Во многих случаях разработчику необходимо предоставить API-интерфейс создания классов C# приложения исполняющей среде с целевой средой, чтобы его можно было создать из таких мест, как при вызове в файлах Storyboard или XIB. Ниже приведены пять наиболее распространенных конструкторов, используемых в приложениях Xamarin. Mac:

```csharp
// Called when created from unmanaged code
public CustomView (IntPtr handle) : base (handle)
{
   Initialize ();
}

// Called when created directly from a XIB file
[Export ("initWithCoder:")]
public CustomView (NSCoder coder) : base (coder)
{
   Initialize ();
}

// Called from C# to instance NSView with a Frame (initWithFrame)
public CustomView (CGRect frame) : base (frame)
{
}

// Called from C# to instance NSView without setting the frame (init)
public CustomView () : base ()
{
}

// This is a special case constructor that you call on a derived class when the derived called has an [Export] constructor.
// For example, if you call init on NSString then you don’t want to call init on NSObject.
public CustomView () : base (NSObjectFlag.Empty)
{
}
```

В общем случае разработчик должен оставить `IntPtr` `NSCoder` конструкторы и, созданные при создании некоторых типов, например, `NSViews` только пользовательских. Если Xamarin. Mac должен вызывать один из этих конструкторов в ответ на запрос выполнения целевой-C, и вы удалили его, приложение аварийно завершит работу внутри машинного кода, и, возможно, будет трудно определить именно эту ошибку.

## <a name="memory-management-and-cycles"></a>Управление памятью и циклы

Управление памятью в Xamarin. Mac во многом похоже на Xamarin. iOS. Это также сложная тема, которая выходит за рамки этого документа. Ознакомьтесь с рекомендациями по [использованию памяти и производительности](~/cross-platform/deploy-test/memory-perf-best-practices.md).

## <a name="ahead-of-time-compilation"></a>Компиляция перед временем

Как правило, приложения .NET не компилируются в машинный код при их построении, а компилируются в промежуточный уровень, именуемый кодом IL, который получает JIT _-_ компиляцию в машинный код при запуске приложения.

Время, которое требуется среде выполнения Mono для JIT-компиляции. Этот машинный код может замедлять запуск приложения Xamarin. Mac до 20%, так как требует времени на создание необходимого кода компьютера.

Из-за ограничений, накладываемых Apple на iOS, JIT-компиляция кода IL недоступна для Xamarin. iOS. В результате все приложение Xamarin. iOS полностью подготовлено к _работе (AOT_ ), скомпилированное в машинный код во время цикла сборки.

Новые возможности Xamarin. Mac — это возможность AOT-кода IL во время цикла сборки приложения, как и в случае с Xamarin. iOS. Xamarin. Mac использует _гибридный_ подход AOT, который компилирует большую часть необходимого машинного кода, но позволяет среде выполнения компилировать необходимые трамполинес и гибкость для поддержки отражения. Emit (и других вариантов использования, которые в настоящее время работают в Xamarin. Mac).

Существует две основные области, в которых AOT может помочь приложению Xamarin. Mac:

- **Более эффективные "собственные" журналы аварийного** восстановления. Если приложение Xamarin. Mac аварийно завершает работу в машинном коде, что является распространенным событием при неправильном вызове API Cocoa (например, при отправке в `null` метод, который не принимает его), нестандартные журналы аварийного завершения с кадрами JIT трудно проанализировать. Так как в кадрах JIT нет отладочной информации, будет несколько строк с шестнадцатеричными смещениями и никакими сведениями о том, что происходит. AOT создает "реальные" Именованные фреймы, и трассировки гораздо легче читать. Это также означает, что приложение Xamarin. Mac будет работать лучше с собственными средствами, такими как **lldb** и **Instruments**.
- **Более высокая производительность во время запуска** . для больших приложений Xamarin. Mac с множественным временем запуска JIT-компиляция всего кода может занять значительное время. AOT выполняет эту работу заранее.

### <a name="enabling-aot-compilation"></a>Включение компиляции AOT

AOT включен в Xamarin. Mac, дважды щелкнув **имя проекта** в **Обозреватель решений**, перейдя к **сборке Mac** и добавив `--aot:[options]` в **Дополнительные аргументы MMP:** (где `[options]` — один или несколько параметров для управления типом AOT, см. ниже). Пример.

![Добавление AOT в дополнительные аргументы MMP](how-it-works-images/aot01.png "Добавление AOT в дополнительные аргументы MMP")

> [!IMPORTANT]
> Включение компиляции AOT значительно увеличивает время сборки, иногда до нескольких минут, но может повысить время запуска приложения в среднем на 20%. В результате компиляция AOT должна быть включена только для сборок **выпуска** приложения Xamarin. Mac.

### <a name="aot-compilation-options"></a>Параметры компиляции AOT

Существует несколько различных параметров, которые можно изменить при включении компиляции AOT в приложении Xamarin. Mac:

- `none`— Без компиляции AOT. Это параметр по умолчанию.
- `all`-AOT компилирует каждую сборку в виде пакета.
- `core`-AOT компилирует `Xamarin.Mac` `System` `mscorlib` сборки и.
- `sdk`-AOT компилирует `Xamarin.Mac` сборки и библиотеки базовых классов (BCL).
- `|hybrid`-Добавление этого параметра к одному из указанных выше параметров позволяет выполнять гибридную AOT, которая позволяет выключать IL, но приводит к более длительному времени компиляции.
- `+`— Включает один файл для компиляции AOT.
- `-`— Удаляет один файл из компиляции AOT.

Например, `--aot:all,-MyAssembly.dll` может включить КОМПИЛЯЦИЮ AOT для всех сборок в пакете, _за исключением того_ , `MyAssembly.dll` что `--aot:core|hybrid,+MyOtherAssembly.dll,-mscorlib.dll` будет использовать гибридную версию, код AOT должен включать и исключать `MyOtherAssembly.dll` `mscorlib.dll` .

## <a name="partial-static-registrar"></a>Частичный статический регистратор

При разработке приложения Xamarin. Mac необходимо свести к минимуму время между выполнением изменений и тестированием, которое может оказаться важным для достижения сроков разработки. Такие стратегии, как модульная архитектура баз кода и модульных тестов, позволяют уменьшить время компиляции, так как они уменьшают количество случаев, когда приложению потребуется дорогостоящее полное перестроение.

Кроме того, и новые возможности Xamarin. Mac, _частичный регистратор_ (как в составе Xamarin. IOS) может значительно сократить время запуска приложения Xamarin. Mac в конфигурации **отладки** . Понимание того, как использование частичного статического регистратора может быть сжато почти 5x усовершенствованием при запуске отладки, повлечет немного опыта работы регистратора, различия между статичными и динамическими, а также то, что делает эта «частичная статическая» версия.

### <a name="about-the-registrar"></a>Сведения о регистраторе

Внутри любого приложения Xamarin. Mac лежит Cocoa Framework от Apple и исполняющей среды цели-C. Создание моста между этим "собственным миром" и "управляемым миром" C# является основной обязанностью Xamarin. Mac. Часть этой задачи обрабатывается регистратором, который выполняется внутри `NSApplication.Init ()` метода. Это одна из причин того, что любое использование API-интерфейсов Cocoa в Xamarin. Mac необходимо `NSApplication.Init` вызывать первыми.

Задание регистратора состоит в том, чтобы сообщить среде выполнения цели-C о существовании классов C# приложения, производных от классов, таких как `NSApplicationDelegate` , `NSView` , `NSWindow` и `NSObject` . Для этого необходимо проверить все типы в приложении, чтобы определить, какие требования необходимо зарегистрировать и какие элементы каждого типа следует сообщить.

Эту проверку можно выполнить **динамически**, при запуске приложения с помощью отражения или **статически**, как шаг времени сборки. При выборе типа регистрации разработчик должен учитывать следующее:

- Статическая регистрация может радикально сократить время запуска, но может значительно замедлить работу сборок (обычно более чем двойная Отладка времени сборки). Это будет значение по умолчанию для сборок конфигурации **выпуска** .
- Динамическая регистрация задерживает эту работу до запуска приложения и пропускает создание кода, но эта дополнительная работа может создать заметную паузу (по крайней мере две секунды) при запуске приложения. Это особенно заметно в отладочных сборках конфигурации, в которых по умолчанию используется динамическая регистрация, а отражение выполняется медленнее.

Частичная статическая регистрация, впервые представленная в Xamarin. iOS 8,13, дает разработчику лучшее из обоих вариантов. Предварительно вычисляя сведения о регистрации каждого элемента в `Xamarin.Mac.dll` и отправляя эту информацию с помощью Xamarin. Mac в статическую библиотеку (которая должна быть связана только во время сборки), корпорация Майкрософт удалила большую часть времени отражения динамического регистратора, не влияя на время сборки.

### <a name="enabling-the-partial-static-registrar"></a>Включение частичного статического регистратора

Частичный статический регистратор включен в Xamarin. Mac. для этого дважды щелкните **имя проекта** в **Обозреватель решений**, перейдите к **сборке Mac** и добавьте `--registrar:static` в поле **Дополнительные аргументы MMP:** . Пример.

![Добавление частичного статического регистратора к дополнительным аргументам MMP](how-it-works-images/psr01.png "Добавление частичного статического регистратора к дополнительным аргументам MMP")

## <a name="additional-resources"></a>Дополнительные ресурсы

Ниже приведены некоторые более подробные объяснения того, как работают внутренние компоненты:

- [Селекторы цели-C](~/ios/internals/objective-c-selectors.md)
- [регистратор](~/ios/internals/registrar.md)
- [Xamarin Unified API для iOS и OS X](~/cross-platform/macios/unified/index.md)
- [Основы сеадинг](~/ios/app-fundamentals/threading.md)
- [Делегаты, протоколы и события](~/ios/app-fundamentals/delegates-protocols-and-events.md)
- [Скоро`newrefcount`](~/ios/internals/newrefcount.md)
