---
title: Производительность Xamarin.Mac
description: В этом документе описываются особенности производительности приложений Xamarin.Mac. Он описывает современную целевую платформу, компоновщик, AOT, делегаты, API-интерфейсы Cocoa для повторного использования представления и асинхронный код.
ms.prod: xamarin
ms.assetid: 54B07DED-FDF2-49B2-A5FB-3A9357E65922
ms.technology: xamarin-mac
author: conceptdev
ms.author: crdun
ms.date: 11/10/2017
ms.openlocfilehash: 48e5e71a9d4435852f72eb9be21f2e80cd124bfd
ms.sourcegitcommit: 933de144d1fbe7d412e49b743839cae4bfcac439
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2019
ms.locfileid: "70291098"
---
# <a name="xamarinmac-performance"></a>Производительность Xamarin.Mac

## <a name="overview"></a>Обзор

Приложения Xamarin.Mac аналогичны приложениям Xamarin.iOS, поэтому к ним применяется множество одних и тех же рекомендаций по повышению производительности:

- [Производительность Xamarin.iOS](~/ios/deploy-test/performance.md)
- [Кроссплатформенная производительность](~/cross-platform/deploy-test/memory-perf-best-practices.md)

Однако есть несколько полезных советов, специально предназначенных для macOS.

## <a name="prefer-modern-target-framework"></a>Предпочтительное использование современной требуемой версии .NET Framework

Существует несколько [целевых платформ](~/mac/platform/target-framework.md) для приложений Xamarin.Mac с различными функциями и характеристиками производительности.

По возможности следует использовать современную (Modern) платформу и работать с зависимыми библиотеками для получения дополнительной поддержки. Только современная платформа располагает возможностями компоновки, позволяющими значительно сокращать размеры сборки. Это особенно важно при включении AOT, так как компиляция AOT полных сборок может приводить к созданию больших окончательных пакетов.

## <a name="enable-the-linker"></a>Включение компоновщика

Время запуска при загрузке и в режиме "Just In Time" (JIT) линейно масштабируется по отношению к размеру окончательных двоичных файлов. Самым простым способом улучшения этого показателя является удаление неиспользуемого кода с помощью [компоновщика](~/mac/deploy-test/linker.md).

Хотя это предложение в первую очередь предназначено для пользователей современной целевой платформы, [компоновка платформы](~/mac/deploy-test/linker.md) также может обеспечить ограниченное повышение производительности.

## <a name="enable-aot-when-appropriate"></a>Включение AOT при необходимости

Другим аспектом производительности при запуске является JIT-компиляция сборок в машинный код. Компиляция АОТ (Ahead of Time) может значительно сократить время запуска, однако она связана с поиском компромиссов, которые рассматриваются в [документации по AOT](~/mac/internals/aot.md).

## <a name="ensure-performant-delegates"></a>Наличие высокопроизводительных делегатов

Основу многих приложений Xamarin.Mac составляют представления Cocoa, такие как `NSCollectionView`, `NSOutlineView` или `NSTableView`. Часто эти представления формируются на базе предоставляемых в Cocoa классов `Delegate` и `DataSource`, назначение которых следует из их имен.

Многие из этих точек входа вызываются довольно часто — иногда несколько раз в секунду во время прокрутки.

Во избежание блокировки пользовательского интерфейса эти функции должны возвращать легко вычисляемые значения или использовать уже кэшированные данные.

## <a name="use-cocoa-provided-apis-for-reusing-views"></a>Использование API-интерфейсов Cocoa для повторного использования представлений

Многие представления Cocoa, содержащие множество дочерних представлений или ячеек (например, `NSCollectionView`, `NSOutlineView` и `NSTableView`) предоставляют API-интерфейсы для создания и повторного использования представлений. Они формируют пулы общих элементов и препятствуют возникновению проблем производительности при быстрой прокрутке представлений.

## <a name="use-async-and-do-not-block-the-ui"></a>Использование async и предупреждение блокировки пользовательского интерфейса

Классические приложения часто обрабатывают большие объемы данных, поэтому поток пользовательского интерфейса, ожидающий синхронную операцию, может быть с легкостью заблокирован.

Чтобы избежать блокировки пользовательского интерфейса, по возможности следует использовать ключевое слово [async](~/cross-platform/platform/async.md) и потоки.

В целях уведомления пользователей при выполнении длительных операций рекомендуется воспользоваться [NSProgressIndicator](https://docs.microsoft.com/samples/xamarin/mac-samples/progressbarexample) или другими возможностями, указанными на странице [рекомендаций по работе с человеческим интерфейсом](https://developer.apple.com/macos/human-interface-guidelines/indicators/progress-indicators/) на веб-сайте Apple.


## <a name="related-links"></a>Связанные ссылки

- [Кроссплатформенная производительность](~/cross-platform/deploy-test/memory-perf-best-practices.md)
- [Производительность Xamarin.iOS](~/ios/deploy-test/performance.md)
