---
title: Работа с элементами раскадровки в Xamarin.Mac
description: В этом документе описывается работа с раскадровками в Xamarin.Mac, изучая, как загрузить их из кода, жизненный цикл контроллера представления, респондент цепочки, переходы, окно контроллеров, средства распознавания жестов и многое другое.
ms.prod: xamarin
ms.assetid: DF4DF7C2-DDD7-4A32-B375-5C5446301EC5
ms.technology: xamarin-mac
author: lobrien
ms.author: laobri
ms.date: 03/14/2017
ms.openlocfilehash: 61d598f90747cf47b613012328f77b4bd8953a41
ms.sourcegitcommit: 849bf6d1c67df943482ebf3c80c456a48eda1e21
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2018
ms.locfileid: "51528462"
---
# <a name="working-with-storyboards-in-xamarinmac"></a>Работа с элементами раскадровки в Xamarin.Mac

Раскадровки определяет все части пользовательского интерфейса для заданного приложения разбить на функциональные обзором его контроллеров представлений. В построителе интерфейса Xcode каждый из этих контроллеров живет в свой собственный сцены.

[![](indepth-images/intro01.png "Раскадровки в Interface Builder в Xcode")](indepth-images/intro01.png#lightbox)

Раскадровка является файлом ресурсов (с расширениями `.storyboard`), которые получает включены в пакет приложения Xamarin.Mac при его компиляции и поставляется. Чтобы определить начальную раскадровки для вашего приложения, изменить его в `Info.plist` файл и выберите **главный интерфейс** из раскрывающегося списка: 

[![](indepth-images/sb01.png "В редакторе Info.plist")](indepth-images/sb01.png#lightbox)

<a name="Loading-from-Code" />

## <a name="loading-from-code"></a>Загрузка из кода

Возможны ситуации, при необходимости загрузить конкретных раскадровки из кода и вручную создать контроллер представления. Для выполнения этого действия можно использовать следующий код:

```csharp
// Get new window
var storyboard = NSStoryboard.FromName ("Main", null);
var controller = storyboard.InstantiateControllerWithIdentifier ("MainWindow") as NSWindowController;

// Display
controller.ShowWindow(this);
```

`FromName` Загружает файл раскадровки с заданным именем, который был включен в пакет приложения. `InstantiateControllerWithIdentifier` Создает экземпляр контроллера представления с заданным идентификатором. Задать удостоверение в Interface Builder в Xcode, при разработке пользовательского интерфейса:

[![](indepth-images/sb02.png "Указание идентификатора раскадровки")](indepth-images/sb02.png#lightbox)

При необходимости можно использовать `InstantiateInitialController` метод для загрузки контроллера представления, которой назначено начальной контроллер в конструктор Interface Builder:

[![](indepth-images/sb03.png "Задание начальной контроллера")](indepth-images/sb03.png#lightbox)

Ограничивается **точки входа раскадровки** и выше стрелку open завершен.

<a name="View-Controllers" />

## <a name="view-controllers"></a>Контроллеры представлений

Контроллеры представлений определяют связи между заданного представления информации в приложение Mac и модели данных, которая обеспечивает такую информацию. Каждая сцена верхнего уровня в раскадровке представляет один контроллер представления в коде приложения Xamarin.Mac.

<a name="The-View-Controller-Lifecycle" />

### <a name="the-view-controller-lifecycle"></a>Жизненный цикл контроллера представления

Были добавлены новые методы `NSViewController` класс для поддержки раскадровки в macOS. Что самое важное, используйте следующие методы для ответа на жизненный цикл представления, управляемых данного контроллера представления:

- `ViewDidLoad` — Этот метод вызывается, когда представление загружается из файла раскадровки.
- `ViewWillAppear` — Этот метод вызывается непосредственно перед отображением представление на экране.
- `ViewDidAppear` — Этот метод вызывается непосредственно после отображения представления на экране.
- `ViewWillDisappear` — Этот метод вызывается непосредственно перед удалением представление на экране.
- `ViewDidDisappear` — Этот метод вызывается непосредственно после удаления представление на экране.
- `UpdateViewConstraints` — Этот метод вызывается в том случае, когда ограничения, которые определяют представление auto макета положение и размер должны быть обновлены.
- `ViewWillLayout` — Этот метод вызывается непосредственно перед вложенные представления этого представления располагаются на экране.
- `ViewDidLayout` — Этот метод вызывается непосредственно после вложенных представлений, представления располагаются на экране.

<a name="The-Responder-Chain" />

### <a name="the-responder-chain"></a>Цепочка сетевого ответчика

Кроме того `NSViewControllers` теперь являются частью окна _цепочки респондент_:

[![](indepth-images/vc01.png "Цепочка сетевого ответчика")](indepth-images/vc01.png#lightbox)

И таким образом они привязав получать и реагировать на события, такие как вырезать, копировать и вставить выбранные пункты меню. Это автоматическое контроллер представления сети доступ к возникает только в приложениях, выполняющихся в macOS Sierra (10.12) и более поздней версии.

<a name="Containment" />

### <a name="containment"></a>Вложение

В раскадровки, контроллеры представления (например, контроллер разделенного представления и контроллера представления вкладки) теперь можно реализовать _вложения_, таким образом, что они могут «содержит» другие sub контроллеров представлений:

[![](indepth-images/vc02.png "Пример включения контроллера представления")](indepth-images/vc02.png#lightbox)

Контроллеры дочерние представления содержат методы и свойства привязка их обратно к контроллеру представление родительского и работать с отображения и удаления представлений на экране.

Все контроллеры представления контейнера, встроенные в macOS имеют определенный макет, который Apple рекомендуем выполнить при создании собственных пользовательских контроллеров представлений контейнера:

[![](indepth-images/vc03.png "Контроллер представления макета")](indepth-images/vc03.png#lightbox)

Контроллер представления коллекции содержит массив элементов представления коллекции, каждая из которых содержит один или несколько контроллеров представлений, содержащих свои собственные представления.

<a name="Segues" />

## <a name="segues"></a>Однако они плохо

Однако они плохо обеспечивают связи между всеми сцены, определения пользовательского интерфейса приложения. Если вы знакомы с работой в раскадровки в iOS, вы знаете, что переходы для операций ввода-вывода обычно определяется переходы между представлениями во весь экран. Это отличается от macOS, обычно определяется Segues "[вложения](#Containment)«, где сцены является дочерним элементом родительского сцены.

В macOS большинство приложений, как правило, чтобы сгруппировать их представления вместе в том же окне, используя элементы пользовательского интерфейса, такие как разделение представления и вкладки. В отличие от операций ввода-вывода, где представления должны переноситься, включения и отключения экрана, из-за ограниченной физической отображает пространство.

<a name="Presentation-Segues" />

### <a name="presentation-segues"></a>Однако они плохо презентации

Учитывая тенденции использования в macOS к вложения, существуют ситуации, где _переходами презентации_ используются, такие как модальное Windows "," лист "и" Popovers. macOS предоставляет segue Встроенные типы.

- **Показать** -отображает объект переход в немодальном окне. Например можно используйте этот тип перехода для представления другой экземпляр окна документа в приложении.
- **Модальное** -представляет цель перехода как модальное окно. Например можно используйте этот тип перехода для представления окно предпочтений для вашего приложения.
- **Лист** -представляет цель перехода, как лист подключен к родительского окна. Например, используйте этот тип перехода представляет найти и заменить лист.
- **Контекстном** -представляет цель перехода, как и в контекстном окна. Например используйте этот тип перехода для представления параметров, при щелчке пользователем элемента пользовательского интерфейса.
- **Пользовательские** -представляет цель перехода, с помощью пользовательского типа перехода, определяемые разработчиком. См. в разделе [Создание пользовательских переходами](#Creating-Custom-Segues) Дополнительные сведения в приведенном ниже разделе.

При использовании переходами презентации, вы можете переопределить `PrepareForSegue` метод контроллера представления родительского элемента для представления для инициализации и переменные и предоставляют все данные на контроллер представления представления.

<a name="Triggered-Segues" />

### <a name="triggered-segues"></a>Активировано переходами

Активированные Segues позволяют пользователю указать именованный Segues (через их **идентификатор** свойства в построителе интерфейса) и их активации, события, например нажатие кнопки пользователем или вызвав `PerformSegue` метод в коде:

```csharp
// Display the Scene defined by the given Segue ID
PerformSegue("MyNamedSegue", this);
``` 

Идентификатор перехода определяется внутри конструктора Interface Builder, при размещении пользовательском Интерфейсе приложения:

[![](indepth-images/sg02.png "Введите имя Segue")](indepth-images/sg02.png#lightbox)

В контроллере представления, выступающего в качестве источника для перехода, следует переопределить `PrepareForSegue` отображается метод и выполните инициализацию требуется перед выполнением перехода и указанный контроллер представления:

```csharp
public override void PrepareForSegue (NSStoryboardSegue segue, NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    // Take action based on Segue ID
    switch (segue.Identifier) {
    case "MyNamedSegue":
        // Prepare for the segue to happen
        ...
        break;
    }
}
```

При необходимости можно переопределить `ShouldPerformSegue` метод и управления ли переход фактически выполняется через C# кода. Вручную представленных контроллеров представлений, вызывать их `DismissController` метод, чтобы удалить их из отображения, когда они больше не требуются.

<a name="Creating-Custom-Segues" />

### <a name="creating-custom-segues"></a>Создание пользовательских переходов

Возможны ситуации, когда вашему приложению требуется типа перехода, не предоставляемые Segues в сборки, определенные в macOS. Если это так, можно создать настраиваемый перехода, которое может быть назначено в Interface Builder в Xcode при размещении в пользовательском Интерфейсе приложения.

Например чтобы создать новый тип перехода, который заменяет текущий контроллер представления внутри окна (вместо открытия целевой сцены в новом окне), мы используем следующий код:

```csharp
using System;
using AppKit;
using Foundation;

namespace OnCardMac
{
    [Register("ReplaceViewSeque")]
    public class ReplaceViewSeque : NSStoryboardSegue
    {
        #region Constructors
        public ReplaceViewSeque() {

        }

        public ReplaceViewSeque (string identifier, NSObject sourceController, NSObject destinationController) : base(identifier,sourceController,destinationController) {

        }

        public ReplaceViewSeque (IntPtr handle) : base(handle) {
        }

        public ReplaceViewSeque (NSObjectFlag x) : base(x) {
        }
        #endregion

        #region Override Methods
        public override void Perform ()
        {
            // Cast the source and destination controllers
            var source = SourceController as NSViewController;
            var destination = DestinationController as NSViewController;

            // Swap the controllers
            source.View.Window.ContentViewController = destination;

            // Release memory
            source.RemoveFromParentViewController ();
        }
        #endregion

    }
        
}
```

Кое-что здесь необходимо обратить внимание:

- Мы используем `Register` атрибут для предоставления этого класса в Objective-C, Mac OS.
- Мы переопределяем `Perform` метод для фактического выполнения действие наш пользовательский переход.
- Вместо окна `ContentViewController` контроллер с той, которая определяется цель перехода (назначение).
- Мы удаляем исходного контроллера представления для освобождения памяти с помощью `RemoveFromParentViewController` метод.

Чтобы использовать этот новый тип перехода в конструктора Interface Builder, нам нужно скомпилировать приложение, во-первых, а затем переключиться в Xcode и добавляет новый переход между двумя сценами. Задайте **стиля** для **пользовательских** и **Segue класс** для `ReplaceViewSegue` (имя нашего пользовательского класса Segue):

[![](indepth-images/sg01.png "Переход-класс параметров")](indepth-images/sg01.png#lightbox)

<a name="Triggered-Segues" />

## <a name="window-controllers"></a>Окно контроллеров

Контроллеры окна содержат и контролировать различные типы окон, которые могут создавать приложения macOS. Для раскадровок они имеют следующие особенности:

1. Они должны предоставить контроллер представления содержимого. Это будет тот же содержимого контроллер представления, имеющего дочерние окна.
2. `Storyboard` Свойство будет содержать раскадровку, контроллер окна был загружен из, в противном случае `null` Если не загружен с раскадровкой.
3. Вы можете вызвать `DismissController` метод закрытие заданного окна и удалить его из представления.

Как и контроллеры представления, контроллеры окно реализовать `PerformSegue`, `PrepareForSegue` и `ShouldPerformSegue` методов и могут использоваться в качестве источника операции перехода.

Контроллер окна отвечают за следующие функции приложение macOS:

- Они управляют отдельного окна.
- Они управляют, заголовок окна и панели инструментов окна (если доступно).
- Они управляют содержимым контроллера представления для отображения содержимого окна.

<a name="Gesture-Recognizers" />

## <a name="gesture-recognizers"></a>Средства распознавания жестов

Средства распознавания жестов для macOS практически идентичны своим аналогам в iOS и позволяют разработчикам легко добавлять жестов (например, щелчок мышью) к элементам в пользовательском Интерфейсе приложения.

Тем не менее, где жестов в iOS определяются при разработке приложения (например, касания экрана с двумя пальцами) наиболее жестов в macOS, определяются оборудования.

С помощью средства распознавания жестов, может значительно снизить объем кода, необходимые для добавления пользовательского взаимодействия для элемента в пользовательском Интерфейсе. Так как они могут автоматически определять между одинарные и двойные щелчки, щелкните и перетащите, события и т. д.

Вместо переопределения `MouseDown` событий в контроллере представления, следует использовать распознаватель жестов для обработки события ввода пользователя при работе с раскадровками.

В macOS, доступны следующие средства распознавания жестов:

- `NSClickGestureRecognizer` -Register мыши, события down и up.
- `NSPanGestureRecognizer` -Регистры кнопки мыши, перетащите и отпустите кнопку событий.
- `NSPressGestureRecognizer` -Регистры, удерживая кнопку мыши в течение заданного времени событий.
- `NSMagnificationGestureRecognizer` — Регистрирует событие увеличения от оборудования, у вас сенсорная панель.
- `NSRotationGestureRecognizer` — Регистрирует событие поворота от оборудования, у вас сенсорная панель.

<a name="Using-Storyboard-References" />

## <a name="using-storyboard-references"></a>С помощью ссылки раскадровки

Ссылки раскадровки позволяет принимать большие и сложные макета раскадровки, разбив его на небольших раскадровки, получение ссылки из исходного, таким образом удаление сложности и упрощение разработки и обслуживания итоговый отдельных раскадровок.

Кроме того, можно предоставить ссылку на раскадровку _привязки_ другой сцену в одной раскадровке или конкретных сцены на другом.

<a name="Referencing-an-External-Storyboard" />

### <a name="referencing-an-external-storyboard"></a>Ссылки на внешние раскадровки

Чтобы добавить ссылку на внешний раскадровки, сделайте следующее:

1. В **обозревателе решений**, щелкните правой кнопкой мыши имя проекта и выберите **добавить** > **новый файл...**   >  **Mac** > **раскадровки**. Введите **имя** новой раскадровки и нажмите кнопку **New** кнопки: 

    [![](indepth-images/ref01.png "Добавление новой раскадровки")](indepth-images/ref01.png#lightbox)
2. В **обозревателе решений**, дважды щелкните имя нового раскадровки, чтобы открыть его для редактирования в Interface Builder в Xcode.
2. Разработка макета новая раскадровка автоматически, как обычно и сохраните изменения: 

    [![](indepth-images/ref02.png "Разработка интерфейса")](indepth-images/ref02.png#lightbox)
3. Переключиться на раскадровку, нужно добавления ссылки в построителе интерфейса.
4. Перетащите **раскадровка ссылку** из **объекта библиотеки** в область конструктора: 

    [![](indepth-images/ref03.png "Выбрав ссылку на раскадровку в библиотеке")](indepth-images/ref03.png#lightbox)
5. В **инспекторе атрибутов**, выберите имя **раскадровки** , созданный выше: 

    [![](indepth-images/ref04.png "Настройка ссылки")](indepth-images/ref04.png#lightbox)
6. Элемент управления, щелкните пользовательский Интерфейс мини-приложения (например, кнопки) на существующий сцены и создайте новый переход к **ссылки раскадровки** , вы только что создали.  Во всплывающем меню выберите **Показать** для завершения перехода: 

    [![](indepth-images/ref06.png "Выбор типа перехода")](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровку.
9. Вернитесь к Visual Studio для Mac синхронизировать изменения.

Будет отображаться при запуске приложения, и пользователь щелкает элемент пользовательского интерфейса, созданного переход от начальной контроллер окна из внешних раскадровки, указанный в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-an-External-Storyboard" />

### <a name="referencing-a-specific-scene-in-an-external-storyboard"></a>Ссылки на определенные сцены в раскадровке внешних

Для добавления ссылки на определенные сцены внешних раскадровки (и не начальной контроллер окна), сделайте следующее:

1. В **обозревателе решений**, дважды щелкните внешних раскадровки, чтобы открыть его для редактирования в Interface Builder в Xcode.
2. Добавьте новую сцену и его макет, как обычно: 

    [![](indepth-images/ref07.png "Разработка макета в Xcode")](indepth-images/ref07.png#lightbox)
3. В **инспектор удостоверений**, введите **идентификатора раскадровки** для новой сцены контроллер окна: 

    [![](indepth-images/ref08.png "Указание идентификатора раскадровки")](indepth-images/ref08.png#lightbox)
3. Откройте раскадровку, нужно добавления ссылки в конструктор Interface Builder.
4. Перетащите **раскадровка ссылку** из **объекта библиотеки** в область конструктора: 

    [![](indepth-images/ref03.png "Выбрав ссылку раскадровки из библиотеки")](indepth-images/ref03.png#lightbox)
5. В **инспектор удостоверений**, выберите имя **раскадровки** и **идентификатор ссылки** (идентификатор раскадровки) сцены, созданный выше: 

    [![](indepth-images/ref09.png "Задание идентификатора ссылки")](indepth-images/ref09.png#lightbox)
6. Элемент управления, щелкните пользовательский Интерфейс мини-приложения (например, кнопки) на существующий сцены и создайте новый переход к **ссылки раскадровки** , вы только что создали. Во всплывающем меню выберите **Показать** для завершения перехода: 

    [![](indepth-images/ref06.png "Выбор типа перехода")](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровку.
9. Вернитесь к Visual Studio для Mac синхронизировать изменения.

Если приложение — выполнения, а пользователь щелкнет элемент пользовательского интерфейса, который вы создали переход из жестких дисков с данной **идентификатора раскадровки** из внешних раскадровки, указанный в ссылке раскадровки будет отображаться.

<a name="Referencing-a-Specific-Scene-in-the-Same-Storyboard" />

### <a name="referencing-a-specific-scene-in-the-same-storyboard"></a>Ссылки на определенные сцены в одной раскадровке

Чтобы добавить ссылку на конкретных сцены же раскадровки, сделайте следующее:

1. В **обозревателе решений**, дважды щелкните файл раскадровки, чтобы открыть его для редактирования.
2. Добавьте новую сцену и его макет, как обычно: 

    [![](indepth-images/ref11.png "Изменение раскадровки в Xcode")](indepth-images/ref11.png#lightbox)
3. В **инспектор удостоверений**, введите **идентификатора раскадровки** для новой сцены контроллер окна: 

    [![](indepth-images/ref12.png "Указание идентификатора раскадровки")](indepth-images/ref12.png#lightbox)
3. Перетащите **раскадровка ссылку** из **элементов** в область конструктора: 

    [![](indepth-images/ref03.png "Выбрав ссылку раскадровки из библиотеки")](indepth-images/ref03.png#lightbox)
5. В **инспекторе атрибутов**выберите **идентификатор ссылки** (идентификатор раскадровки) сцены, созданный выше: 

    [![](indepth-images/ref13.png "Задание идентификатора ссылки")](indepth-images/ref13.png#lightbox)
6. Элемент управления, щелкните пользовательский Интерфейс мини-приложения (например, кнопки) на существующий сцены и создайте новый переход к **ссылки раскадровки** , вы только что создали. Во всплывающем меню выберите **Показать** для завершения перехода: 

    [![](indepth-images/ref06.png "Выбор типа перехода")](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровку.
9. Вернитесь к Visual Studio для Mac синхронизировать изменения.

Если приложение — выполнения, а пользователь щелкнет элемент пользовательского интерфейса, который вы создали переход из жестких дисков с заданной **идентификатора раскадровки** в одной раскадровке, указанный в ссылке раскадровки будет отображаться.

<a name="Complex-Storyboard-Example" />

## <a name="complex-storyboard-example"></a>Пример сложной раскадровки

Сложный пример работы с раскадровками в приложении Xamarin.Mac, см. в разделе [пример приложения SourceWriter](https://developer.xamarin.com/samples/mac/SourceWriter/). SourceWriter — это простой редактор исходного кода, который предоставляет поддержку для автозавершения и выделения простого синтаксиса.

Код SourceWriter полностью закомментирован, и там, где это возможно, предоставлены ссылки из основных технологий и методов на соответствующую информацию в документации по руководствам для Xamarin.Mac.

## <a name="related-links"></a>Связанные ссылки

- [MacStoryboard (пример)](https://developer.xamarin.com/samples/mac/MacStoryboard/)
- [Привет, Mac](~/mac/get-started/hello-mac.md)
- [Работа с Windows](~/mac/user-interface/window.md)
- [Рекомендации по работе с человеческим интерфейсом OS X](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/OSXHIGuidelines/)
- [Введение в Windows](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/WinPanel/Introduction.html#//apple_ref/doc/uid/10000031-SW1)
