---
title: Работа с раскадровками в Xamarin. Mac
description: В этом документе описывается работа с раскадровками в Xamarin. Mac, изучение процесса загрузки из кода, жизненного цикла контроллера представления, цепочки ответчиков, переходов, контроллеров окна, распознавателей жестов и т. д.
ms.prod: xamarin
ms.assetid: DF4DF7C2-DDD7-4A32-B375-5C5446301EC5
ms.technology: xamarin-mac
author: davidortinau
ms.author: daortin
ms.date: 03/14/2017
ms.openlocfilehash: 06774d13cf053b661dd0b2d24b7df0c0b767b4db
ms.sourcegitcommit: eca3b01098dba004d367292c8b0d74b58c4e1206
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/13/2020
ms.locfileid: "79306209"
---
# <a name="working-with-storyboards-in-xamarinmac"></a>Работа с раскадровками в Xamarin. Mac

Раскадровка определяет весь пользовательский интерфейс для данного приложения, разбитый на функциональный обзор контроллеров представления. В Interface Builder Xcode каждый из этих контроллеров находится в собственной сцене.

[![раскадровки в Xcode Interface Builder](indepth-images/intro01.png)](indepth-images/intro01.png#lightbox)

Раскадровка — это файл ресурсов (с расширениями `.storyboard`), который включается в пакет приложения Xamarin. Mac при компиляции и отгрузке. Чтобы определить начальную раскадровку для приложения, измените файл `Info.plist` и выберите **основной интерфейс** из раскрывающегося списка: 

[![редактора info. plist](indepth-images/sb01.png)](indepth-images/sb01.png#lightbox)

<a name="Loading-from-Code" />

## <a name="loading-from-code"></a>Загрузка из кода

Иногда требуется загрузить определенную раскадровку из кода и создать контроллер представления вручную. Для выполнения этого действия можно использовать следующий код:

```csharp
// Get new window
var storyboard = NSStoryboard.FromName ("Main", null);
var controller = storyboard.InstantiateControllerWithIdentifier ("MainWindow") as NSWindowController;

// Display
controller.ShowWindow(this);
```

`FromName` загружает файл раскадровки с заданным именем, включенным в пакет приложения. `InstantiateControllerWithIdentifier` создает экземпляр контроллера представления с заданным удостоверением. Удостоверение задается в Interface Builder Xcode при проектировании пользовательского интерфейса:

[![установки идентификатора раскадровки](indepth-images/sb02.png)](indepth-images/sb02.png#lightbox)

При необходимости можно использовать метод `InstantiateInitialController` для загрузки контроллера представления, которому назначен исходный контроллер, в Interface Builder:

[![установки начального контроллера](indepth-images/sb03.png)](indepth-images/sb03.png#lightbox)

Он помечается **точкой входа раскадровки** и стрелкой открытия завершенного выше.

<a name="View-Controllers" />

## <a name="view-controllers"></a>Контроллеры представления

Контроллеры представления определяют связи между определенным представлением информации в приложении Mac и моделью данных, предоставляющей эти сведения. Каждая сцена верхнего уровня в раскадровке представляет один контроллер представления в коде приложения Xamarin. Mac.

<a name="The-View-Controller-Lifecycle" />

### <a name="the-view-controller-lifecycle"></a>Жизненный цикл контроллера представления

В класс `NSViewController` были добавлены несколько новых методов для поддержки раскадровок в macOS. Самое важное — следующие методы используются для реагирования на жизненный цикл представления, контролируемого данным контроллером представления:

- `ViewDidLoad` — этот метод вызывается, когда представление загружается из файла раскадровки.
- `ViewWillAppear` — этот метод вызывается непосредственно перед отображением представления на экране.
- `ViewDidAppear` — этот метод вызывается непосредственно после отображения представления на экране.
- `ViewWillDisappear` — этот метод вызывается непосредственно перед удалением представления с экрана.
- `ViewDidDisappear` — этот метод вызывается непосредственно после удаления представления с экрана.
- `UpdateViewConstraints` — этот метод вызывается, когда ограничения, определяющие положение и размер автоматического макета представления, необходимо обновить.
- `ViewWillLayout` — этот метод вызывается непосредственно перед тем, как подпредставления этого представления будут размещены на экране.
- `ViewDidLayout` — этот метод вызывается непосредственно после того, как подпредставления представления будут размещены на экране.

<a name="The-Responder-Chain" />

### <a name="the-responder-chain"></a>Цепочка ответчиков

Кроме того, `NSViewControllers` теперь являются частью _цепочки ответчиков_окна:

[![цепочку ответчиков](indepth-images/vc01.png)](indepth-images/vc01.png#lightbox)

И, таким образом, они могут принимать и отвечать на такие события, как вырезание, копирование и вставка элементов меню. Этот контроллер автоматического просмотра выполняется только в приложениях, работающих на macOS Sierra (10,12) и более поздних версиях.

<a name="Containment" />

### <a name="containment"></a>Containment

В раскадровках контроллеры представлений (например, контроллер разделенного представления и контроллер представления вкладок) теперь могут реализовать _Включение_, чтобы они могли "содержать" другие контроллеры подпредставления:

[![пример включения контроллера представления](indepth-images/vc02.png)](indepth-images/vc02.png#lightbox)

Дочерние контроллеры представлений содержат методы и свойства для привязки их к контроллеру родительского представления и для работы с отображением и удалением представлений с экрана.

Все контроллеры представлений контейнеров, встроенные в macOS, имеют определенную структуру, о которой Apple рекомендует при создании собственных пользовательских контроллеров представлений контейнеров.

[![макета контроллера представления](indepth-images/vc03.png)](indepth-images/vc03.png#lightbox)

Контроллер представления коллекции содержит массив элементов представления коллекций, каждый из которых содержит один или несколько контроллеров представления, содержащих собственные представления.

<a name="Segues" />

## <a name="segues"></a>Переходов

Переходов предоставляют связи между всеми сценами, определяющими пользовательский интерфейс приложения. Если вы знакомы с обработкой раскадровок в iOS, то знаете, что переходов для iOS обычно определяет переходы между полноэкранными представлениями. Это отличается от macOS, когда переходов обычно определяет "[вложение](#Containment)", где одна сцена является дочерней для родительской сцены.

В macOS большинство приложений обычно группируют свои представления вместе в одном окне с помощью элементов пользовательского интерфейса, таких как разделенные представления и вкладки. В отличие от iOS, когда представления должны быть переведены на экран и выключаться из-за ограниченного объема физической области отображения.

<a name="Presentation-Segues" />

### <a name="presentation-segues"></a>Переходов представления

Учитывая, что macOS тенденции к вложению, существуют ситуации, где используются _переходов представления_ , например модальные окна, представления листов и поповерс. macOS предоставляет следующие встроенные типы перехода:

- **Показать** — отображает целевой объект перехода как не модальное окно. Например, используйте этот тип перехода для представления другого экземпляра окна документа в приложении.
- **Modal** — представляет целевой объект перехода как модальное окно. Например, используйте этот тип перехода, чтобы показать окно настроек для приложения.
- **Лист** — представляет целевой объект перехода как лист, присоединенный к родительскому окну. Например, используйте этот тип перехода для представления листа поиска и замены.
- **Контекстном меню Action** — представляет целевой объект перехода как в окне контекстном меню Action. Например, используйте этот тип перехода для представления параметров при щелчке пользователем элемента пользовательского интерфейса.
- **Custom** — представляет целевой объект перехода с помощью пользовательского типа перехода, определенного разработчиком. Дополнительные сведения см. в разделе [Создание настраиваемых переходов](#Creating-Custom-Segues) ниже.

При использовании представления переходов можно переопределить метод `PrepareForSegue` контроллера родительского представления для представления на инициализацию и переменные и предоставить любые данные в представляемый контроллер представления.

<a name="Triggered-Segues" />

### <a name="triggered-segues"></a>Активированный переходов

Активированный переходов позволяет указать именованный переходов (с помощью свойства **идентификатора** в Interface Builder) и активировать их событиями, такими как пользователь, нажимая кнопку или вызывая метод `PerformSegue` в коде:

```csharp
// Display the Scene defined by the given Segue ID
PerformSegue("MyNamedSegue", this);
``` 

Идентификатор перехода определяется в Interface Builder Xcode при размещении пользовательского интерфейса приложения.

[![ввода имени перехода](indepth-images/sg02.png)](indepth-images/sg02.png#lightbox)

В контроллере представления, который выступает в качестве источника перехода, следует переопределить метод `PrepareForSegue` и выполнить инициализацию, необходимую перед выполнением перехода и отображения указанного контроллера представления:

```csharp
public override void PrepareForSegue (NSStoryboardSegue segue, NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    // Take action based on Segue ID
    switch (segue.Identifier) {
    case "MyNamedSegue":
        // Prepare for the segue to happen
        ...
        break;
    }
}
```

При необходимости можно переопределить `ShouldPerformSegue` метод и управлять тем, выполняется ли фактический перехода с помощью C# кода. Для контроллеров представлений, представленных вручную, вызовите метод `DismissController`, чтобы удалить их из отображения, когда они больше не нужны.

<a name="Creating-Custom-Segues" />

### <a name="creating-custom-segues"></a>Создание настраиваемых переходов

Возможны случаи, когда приложению требуется тип перехода, не предоставленный сборкой переходов, определенной в macOS. В этом случае можно создать пользовательский перехода, который можно назначить в Interface Builder Xcode при создании макета пользовательского интерфейса приложения.

Например, чтобы создать новый тип перехода, который заменяет текущий контроллер представления внутри окна (вместо того чтобы открывать целевую сцену в новом окне), можно использовать следующий код:

```csharp
using System;
using AppKit;
using Foundation;

namespace OnCardMac
{
    [Register("ReplaceViewSeque")]
    public class ReplaceViewSeque : NSStoryboardSegue
    {
        #region Constructors
        public ReplaceViewSeque() {

        }

        public ReplaceViewSeque (string identifier, NSObject sourceController, NSObject destinationController) : base(identifier,sourceController,destinationController) {

        }

        public ReplaceViewSeque (IntPtr handle) : base(handle) {
        }

        public ReplaceViewSeque (NSObjectFlag x) : base(x) {
        }
        #endregion

        #region Override Methods
        public override void Perform ()
        {
            // Cast the source and destination controllers
            var source = SourceController as NSViewController;
            var destination = DestinationController as NSViewController;

            // Swap the controllers
            source.View.Window.ContentViewController = destination;

            // Release memory
            source.RemoveFromParentViewController ();
        }
        #endregion

    }
        
}
```

Обратите внимание на несколько моментов:

- Мы используем атрибут `Register`, чтобы предоставить этот класс цели-C/macOS.
- Мы переопределяем метод `Perform` для фактического выполнения действия нашего пользовательского перехода.
- Мы заменяем контроллер `ContentViewController` окна на тот, который определен целевым объектом (назначением) перехода.
- Мы удаляем исходный контроллер представления для освобождения памяти с помощью метода `RemoveFromParentViewController`.

Чтобы использовать этот новый тип перехода в Interface Builder Xcode, сначала необходимо скомпилировать приложение, а затем переключиться на Xcode и добавить новый перехода между двумя кадрами. Присвойте **стилю** значение **Custom** , а **класс перехода** — `ReplaceViewSegue` (имя нашего пользовательского класса перехода):

[![установки класса перехода](indepth-images/sg01.png)](indepth-images/sg01.png#lightbox)

<a name="Triggered-Segues" />

## <a name="window-controllers"></a>Контроллеры окна

Windows Controllers содержит и контролирует различные типы окон, которые может создать приложение macOS. Для раскадровки они имеют следующие возможности.

1. Они должны предоставить контроллер представления содержимого. Это будет тот же контроллер представления содержимого, что и у дочернего окна.
2. Свойство `Storyboard` будет содержать раскадровку, из которой был загружен контроллер окна, иначе `null`, если он не был загружен из раскадровки.
3. Можно вызвать метод `DismissController`, чтобы закрыть заданное окно и удалить его из представления.

Как и контроллеры представлений, контроллеры окон реализуют `PerformSegue`, `PrepareForSegue` и методы `ShouldPerformSegue` и могут использоваться в качестве источника операции перехода.

Контроллер окна отвечает за следующие возможности приложения macOS:

- Они управляют конкретным окном.
- Они управляют заголовком окна и панелью инструментов (если она доступна).
- Они управляют контроллером представления содержимого для отображения содержимого окна.

<a name="Gesture-Recognizers" />

## <a name="gesture-recognizers"></a>Распознаватели жестов

Распознаватели жестов для macOS практически идентичны своим аналогам в iOS и позволяют разработчику легко добавлять жесты (например, нажатие кнопки мыши) к элементам пользовательского интерфейса приложения.

Однако, когда жесты в iOS определяются конструкцией приложения (например, при касании экрана двумя пальцами), большинство жестов в macOS определяются оборудованием.

С помощью распознавателей жестов можно значительно сократить объем кода, необходимого для добавления пользовательских взаимодействий в элемент пользовательского интерфейса. Так как они могут автоматически определять двойные и одинарные щелчки, щелкните и перетащите события и т. д.

Вместо переопределения события `MouseDown` в контроллере представления следует использовать распознаватель жестов для работы с событиями пользовательского ввода при работе с раскадровками.

В macOS доступны следующие распознаватели жестов:

- `NSClickGestureRecognizer` регистрировать события нажатия кнопки мыши.
- `NSPanGestureRecognizer` — регистрирует кнопки мыши вниз, события перетаскивания и освобождения.
- `NSPressGestureRecognizer` — регистрирует нажатие кнопки мыши в течение заданного промежутка времени.
- `NSMagnificationGestureRecognizer` — регистрирует событие увеличения на основе оборудования трекпада.
- `NSRotationGestureRecognizer` — регистрирует событие вращения от оборудования трекпада.

<a name="Using-Storyboard-References" />

## <a name="using-storyboard-references"></a>Использование ссылок раскадровки

Ссылка на раскадровку позволяет использовать большую, сложную структуру раскадровки и разбивать ее на более мелкие раскадровки, на которые можно ссылаться из оригинала, тем самым удаляя сложность и делая полученные отдельные раскадровки проще в проектировании и обслуживании.

Кроме того, ссылка раскадровки может предоставлять _привязку_ к другой сцене в той же раскадровке или в определенной сцене на другом.

<a name="Referencing-an-External-Storyboard" />

### <a name="referencing-an-external-storyboard"></a>Ссылка на внешнюю раскадровку

Чтобы добавить ссылку на внешнюю раскадровку, выполните следующие действия.

1. В **Обозреватель решений**щелкните правой кнопкой мыши имя проекта и выберите **Добавить** > **новый файл...**  > **Mac** > **Storyboard**. Введите **имя** новой раскадровки и нажмите кнопку " **создать** ": 

    [![Добавление новой раскадровки](indepth-images/ref01.png)](indepth-images/ref01.png#lightbox)
2. В **Обозреватель решений**дважды щелкните новое имя раскадровки, чтобы открыть его для редактирования в Interface Builder Xcode.
3. Разработайте макет новых сцен раскадровки, как обычно и сохраняйте изменения: 

    [![конструирования интерфейса](indepth-images/ref02.png)](indepth-images/ref02.png#lightbox)
4. Переключитесь на раскадровку, в которую предполагается добавить ссылку, в Interface Builder.
5. Перетащите **ссылку раскадровки** из **библиотеки объектов** на область конструктора: 

    [![выбора ссылки раскадровки в библиотеке](indepth-images/ref03.png)](indepth-images/ref03.png#lightbox)
6. В **инспекторе атрибутов**выберите имя **раскадровки** , созданной ранее: 

    [![Настройка ссылки](indepth-images/ref04.png)](indepth-images/ref04.png#lightbox)
7. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **Ссылки раскадровки** .  В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода: 

    [![установки типа перехода](indepth-images/ref06.png)](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровке.
9. Вернитесь к Visual Studio для Mac, чтобы синхронизировать изменения.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного с помощью перехода, будет отображаться начальный контроллер окна из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-an-External-Storyboard" />

### <a name="referencing-a-specific-scene-in-an-external-storyboard"></a>Ссылка на конкретную сцену во внешней раскадровке

Чтобы добавить ссылку на конкретную сцену, внешняя Раскадровка (а не исходный контроллер окна) выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните внешнюю раскадровку, чтобы открыть ее для редактирования в Interface Builder Xcode.
2. Добавьте новую сцену и разработайте ее макет, как обычно: 

    [![конструирования макета в Xcode](indepth-images/ref07.png)](indepth-images/ref07.png#lightbox)
3. В **инспекторе удостоверений**введите **идентификатор раскадровки** для контроллера окна новой сцены: 

    [![установки идентификатора раскадровки](indepth-images/ref08.png)](indepth-images/ref08.png#lightbox)
4. Откройте раскадровку, в которую вы будете добавлять ссылку, в Interface Builder.
5. Перетащите **ссылку раскадровки** из **библиотеки объектов** на область конструктора: 

    [![выбора ссылки раскадровки из библиотеки](indepth-images/ref03.png)](indepth-images/ref03.png#lightbox)
6. В **инспекторе удостоверений**выберите имя **раскадровки** и **идентификатор ссылки** (идентификатор раскадровки) для сцены, созданной ранее. 

    [![установки идентификатора ссылки](indepth-images/ref09.png)](indepth-images/ref09.png#lightbox)
7. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **Ссылки раскадровки** . В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода: 

    [![установки типа перехода](indepth-images/ref06.png)](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровке.
9. Вернитесь к Visual Studio для Mac, чтобы синхронизировать изменения.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным **идентификатором раскадровки** из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-the-Same-Storyboard" />

### <a name="referencing-a-specific-scene-in-the-same-storyboard"></a>Ссылка на конкретную сцену в той же раскадровке

Чтобы добавить ссылку на определенную сцену в ту же раскадровку, выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните раскадровку, чтобы открыть ее для редактирования.
2. Добавьте новую сцену и разработайте ее макет, как обычно: 

    [![редактирования раскадровки в Xcode](indepth-images/ref11.png)](indepth-images/ref11.png#lightbox)
3. В **инспекторе удостоверений**введите **идентификатор раскадровки** для контроллера окна новой сцены: 

    [![установки идентификатора раскадровки](indepth-images/ref12.png)](indepth-images/ref12.png#lightbox)
4. Перетащите **ссылку раскадровки** из **панели элементов** на область конструктора: 

    [![выбора ссылки раскадровки из библиотеки](indepth-images/ref03.png)](indepth-images/ref03.png#lightbox)
5. В **инспекторе атрибутов**выберите **идентификатор ссылки** (идентификатор раскадровки) для сцены, созданной ранее. 

    [![установки идентификатора ссылки](indepth-images/ref13.png)](indepth-images/ref13.png#lightbox)
6. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **Ссылки раскадровки** . В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода: 

    [![выбора типа перехода](indepth-images/ref06.png)](indepth-images/ref06.png#lightbox) 
7. Сохраните изменения в раскадровке.
8. Вернитесь к Visual Studio для Mac, чтобы синхронизировать изменения.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным **идентификатором** раскадровки в той же раскадровке, которая указана в ссылке раскадровки.

<a name="Complex-Storyboard-Example" />

## <a name="complex-storyboard-example"></a>Пример сложной раскадровки

Сложный пример работы с раскадровками в приложении Xamarin. Mac см. в [примере приложения SourceWriter](https://docs.microsoft.com/samples/xamarin/mac-samples/sourcewriter). SourceWriter — это простой редактор исходного кода, который предоставляет поддержку для автозавершения и выделения простого синтаксиса.

Код SourceWriter полностью закомментирован, и там, где это возможно, предоставлены ссылки из основных технологий и методов на соответствующую информацию в документации по руководствам для Xamarin.Mac.

## <a name="related-links"></a>Связанные ссылки

- [Привет, Mac](~/mac/get-started/hello-mac.md)
- [Работа с Windows](~/mac/user-interface/window.md)
- [Рекомендации по работе с человеческим интерфейсом OS X](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/OSXHIGuidelines/)
- [Введение в Windows](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/WinPanel/Introduction.html#//apple_ref/doc/uid/10000031-SW1)
