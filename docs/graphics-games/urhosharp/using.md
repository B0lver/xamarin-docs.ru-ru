---
title: Создание трехмерной игры с помощью UrhoSharp
description: Этот документ содержит обзор UrhoSharp, описание сцен, компонентов, фигур, камер, действий, вводимых пользователем данных, звука и т. д.
ms.prod: xamarin
ms.assetid: D9BEAD83-1D9E-41C3-AD4B-3D87E13674A0
author: conceptdev
ms.author: crdun
ms.date: 03/29/2017
ms.openlocfilehash: f9ea9c4f6f2c920d903bd6f136dd0b98ddc7bf57
ms.sourcegitcommit: 93e6358aac2ade44e8b800f066405b8bc8df2510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84574331"
---
# <a name="using-urhosharp-to-build-a-3d-game"></a>Создание трехмерной игры с помощью UrhoSharp

Перед написанием первой игры необходимо ознакомиться с основами: как настроить сцену, как загружать ресурсы (в том что она содержит иллюстрацию) и как создавать простые взаимодействия для своей игры.

<a name="scenenodescomponentsandcameras"></a>

## <a name="scenes-nodes-components-and-cameras"></a>Сцены, узлы, компоненты и камеры

Модель сцены может быть описана как граф сцены на основе компонентов. Сцена состоит из иерархии узлов сцены, начиная с корневого узла, который также представляет всю сцену. Каждый `Node` из них имеет трехмерное преобразование (расположение, поворот и масштабирование), имя, идентификатор и произвольное число компонентов.  Компоненты приводят к жизни узла, они могут добавить визуальное представление ( `StaticModel` ), они могут выдавать звук ( `SoundSource` ), они могут предоставить границу конфликтов и т. д.

Вы можете создавать монтажные кадры и узлы установки с помощью [редактора Урхо](#urhoeditor), а также выполнять действия из кода C#.  В этом документе мы рассмотрим настройку на основе кода, так как они иллюстрируют элементы, необходимые для отображения на экране.

В дополнение к настройке сцены необходимо настроить `Camera` . Это определяет, что будет показано пользователю.

### <a name="setting-up-your-scene"></a>Настройка сцены

Обычно этот метод создается в виде метода Start:

```csharp
var scene = new Scene ();
// Create the Octree component to the scene. This is required before
// adding any drawable components, or else nothing will show up. The
// default octree volume will be from -1000, -1000, -1000) to
//(1000, 1000, 1000) in world coordinates; it is also legal to place
// objects outside the volume but their visibility can then not be
// checked in a hierarchically optimizing manner
scene.CreateComponent<Octree> ();
// Create a child scene node (at world origin) and a StaticModel
// component into it. Set the StaticModel to show a simple plane mesh
// with a "stone" material. Note that naming the scene nodes is
// optional. Scale the scene node larger (100 x 100 world units)
var planeNode = scene.CreateChild("Plane");
planeNode.Scale = new Vector3 (100, 1, 100);
var planeObject = planeNode.CreateComponent<StaticModel> ();
planeObject.Model = ResourceCache.GetModel ("Models/Plane.mdl");
planeObject.SetMaterial(ResourceCache.GetMaterial("Materials/StoneTiled.xml"));
```

### <a name="components"></a>Компоненты

Рендеринг трехмерных объектов, воспроизведение звука, физика и обновление логики на основе скриптов включены путем создания различных компонентов в узлах путем вызова `CreateComponent<T>()` .  Например, настройте узел и облегченный компонент следующим образом:

```csharp
// Create a directional light to the world so that we can see something. The
// light scene node's orientation controls the light direction; we will use
// the SetDirection() function which calculates the orientation from a forward
// direction vector.
// The light will use default settings (white light, no shadows)
var lightNode = scene.CreateChild("DirectionalLight");
lightNode.SetDirection (new Vector3(0.6f, -1.0f, 0.8f));
```

Мы создали узел с именем " `DirectionalLight` " и настроили для него направление, но ничего другого нет.  Теперь можно превратить указанный выше узел в облегченный узел, присоединив `Light` к нему компонент, выполнив `CreateComponent` следующие действия.

```csharp
var light = lightNode.CreateComponent<Light>();
```

Компоненты, созданные в `Scene` самом себе, имеют специальную роль: для реализации функциональности на уровне сцены. Они должны быть созданы до всех остальных компонентов и включать следующее:

 `Octree`: реализует пространственные запросы на секционирование и ускоренную видимость. Без этих трехмерных объектов не может быть подготовлен к просмотру.
 `PhysicsWorld`: реализует физическое моделирование. Физические компоненты, такие как `RigidBody` или, `CollisionShape` не могут правильно работать без этого.
 `DebugRenderer`: реализует визуализацию геометрии для отладки.

Обычные компоненты `Light` , например `Camera` или`StaticModel`
не следует создавать непосредственно в, а `Scene` в дочерних узлах.

Библиотека поставляется с широким спектром компонентов, которые можно присоединить к своим узлам, чтобы обеспечить их жизнь: видимые пользователю элементы (модели), звуки, жесткие тексты, конфликты, фигуры, камеры, источники освещения, податчики частиц и многое другое.

### <a name="shapes"></a>Фигуры

Для удобства различные фигуры доступны в виде простых узлов в пространстве имен Урхо. Shapes.  Сюда входят поля, шарик, конес, цилиндры и плоскости.

### <a name="camera-and-viewport"></a>Камера и окно просмотра

Как и освещение, камеры являются компонентами, поэтому необходимо подключить компонент к узлу следующим образом:

```csharp
var CameraNode = scene.CreateChild ("camera");
camera = CameraNode.CreateComponent<Camera>();
CameraNode.Position = new Vector3 (0, 5, 0);
```

После этого вы создали камеру и поместили камеру в трехмерный мир, следующим шагом будет сообщить `Application` , что это камера, которую вы хотите использовать. это делается с помощью следующего кода:

```csharp
Renderer.SetViewPort (0, new Viewport (Context, scene, camera, null))
```

Теперь вы можете увидеть результаты создания.

### <a name="identification-and-scene-hierarchy"></a>Иерархия идентификации и сцены

В отличие от узлов, компоненты не имеют имен; компоненты внутри одного узла идентифицируются только по типу и индексируются в списке компонентов узла, который заполняется в порядке создания, например, можно извлечь компонент из объекта, как показано ниже `Light` `lightNode` .

```csharp
var myLight = lightNode.GetComponent<Light>();
```

Вы также можете получить список всех компонентов, извлекая `Components` свойство, которое возвращает объект `IList<Component>` , который можно использовать.

При создании оба узла и компонента получают глобальные целочисленные идентификаторы сцены. Их можно запрашивать из сцены с помощью функций `GetNode(uint id)` и `GetComponent(uint id)` . Это происходит гораздо быстрее, чем например, при рекурсивных запросах узла сцены на основе имени.

Встроенное понятие сущности или игрового объекта отсутствует. Вместо этого программисту нужно выбрать иерархию узлов, и на каких узлах будет размещаться любая логика скрипта. Как правило, объекты с произвольным перемещением в трехмерном мире создаются как дочерние элементы корневого узла. Узлы можно создавать с именем или без него с помощью `CreateChild` . Уникальность имен узлов не применяется.

Каждый раз, когда существует иерархическая композиция, рекомендуется (и по сути, поскольку компоненты не имеют собственных трехмерных преобразований) для создания дочернего узла.

Например, если символ владеет объектом, объект должен иметь собственный узел, который был бы родительским по отношению к элементу руки символа (а также `Node` ).  Исключением является физика `CollisionShape` , которую можно оффсеттед и поворачивать по отдельности в отношении узла.

Обратите внимание, что `Scene` собственное преобразование намеренно игнорируется как оптимизация при вычислении преобразования, производного от универсальных узлов, поэтому изменение не оказывает никакого влияния, и его следует оставить как есть (положение в источнике, без вращения, без масштабирования).

`Scene`узлы можно свободно переносить в родительский узел. В отличие от компонентов, они всегда принадлежат узлу, к которому они подключены, и не могут перемещаться между узлами. Как узлы, так и компоненты предоставляют `Remove` функцию для выполнения этой задачи без необходимости проходить через родительский элемент. После удаления узла не удается обеспечить безопасность операций на узле или в рассматриваемом компоненте после вызова этой функции.

Кроме того, можно создать объект `Node` , который не принадлежит сцене. Это полезно, например, при перемещении камеры в сцену, которая может быть загружена или сохранена, потому что камера не будет сохранена вместе с фактической сцены и не будет уничтожена при загрузке сцены. Однако обратите внимание, что создание объектов Geometry, физикы или сценария для неприсоединенного узла, а затем перемещение его в сцену позже приведет к неправильной работе этих компонентов.

### <a name="scene-updates"></a>Обновления сцены

Сцена, обновления которой включены (по умолчанию), автоматически обновляются для каждой итерации цикла Main.  `SceneUpdate`На него вызывается обработчик событий приложения.

Узлы и компоненты можно исключить из обновления сцены, отключив их, см `Enabled` . раздел.  Поведение зависит от конкретного компонента, но, например при отключении изображаемого компонента, также делает его невидимым, в то время как отключение компонента источника звука выключает его. Если узел отключен, все его компоненты обрабатываются как отключенные независимо от их состояния включения или отключения.

## <a name="adding-behavior-to-your-components"></a>Добавление поведения в компоненты

Лучшим способом структурировать игру является создание собственного компонента, который инкапсулирует субъект или элемент в игре.  Это делает функцию автономной, из ресурсов, используемых для ее вывода, в поведение.

Самым простым способом добавления поведения в компонент является использование действий, которые являются инструкциями, которые можно поставить в очередь и объединять с асинхронным программированием на C#.  Это позволяет обеспечить очень высокий уровень поведения компонента и упростить понимание того, что происходит.

Кроме того, можно точно контролировать, что происходит с компонентом, обновив свойства компонента в каждом кадре (рассматривается в разделе «поведение на основе кадров»).

### <a name="actions"></a>Действия

Вы можете добавить поведение к узлам с помощью действий.  Действия могут изменять различные свойства узла и выполнять их в течение определенного периода времени или повторять их несколько раз с заданной кривой анимации.

Например, рассмотрим "Облачный" узел на сцене, вы можете повыглядеть следующим образом:

```csharp
await cloud.RunActionsAsync (new FadeOut (duration: 3))
```

Действия являются неизменяемыми объектами, что позволяет повторно использовать действие для различных объектов.

Распространенной идиомой является создание действия, которое выполняет обратную операцию:

```csharp
var gotoExit = new MoveTo (duration: 3, position: exitLocation);
var return = gotoExit.Reverse ();
```

В следующем примере объект переносится в течение трех секунд.  Можно также выполнить одно действие после другого, например, можно сначала переместить облако, а затем скрыть его:

```csharp
await cloud.RunActionsAsync (
    new MoveBy  (duration: 1.5f, position: new Vector3(0, 0, 15),
    new FadeOut (duration: 3));
```

Если требуется, чтобы оба действия были выполнены одновременно, можно использовать параллельное действие и предоставить все действия, которые должны выполняться в параллельном режиме.

```csharp
  await cloud.RunActionsAsync (
    new Parallel (
      new MoveBy  (duration: 3, position: new Vector3(0, 0, 15),
      new FadeOut (duration: 3)));
```

В приведенном выше примере облако будет перемещаться и исчезать в то же время.

Вы заметите, что они используют C# `await` , что позволяет линейно думать о поведении, которое необходимо достичь.

### <a name="basic-actions"></a>Основные действия

Ниже приведены действия, поддерживаемые в UrhoSharp.

- Перемещение узлов: `MoveTo` , `MoveBy` , `Place` , `BezierTo` , `BezierBy` , `JumpTo` ,`JumpBy`
- Вращение узлов: `RotateTo` ,`RotateBy`
- Масштабирование узлов: `ScaleTo` ,`ScaleBy`
- Снижение яркости узлов: `FadeIn` ,, `FadeTo` `FadeOut` , `Hide` ,`Blink`
- Оттенок: `TintTo` ,`TintBy`
- Мгновенные сообщения: `Hide` , `Show` , `Place` , `RemoveSelf` ,`ToggleVisibility`
- Циклическая обработка: `Repeat` , `RepeatForever` ,`ReverseTime`

Другие дополнительные функции включают сочетание `Spawn` `Sequence` действий и.

### <a name="easing---controlling-the-speed-of-your-actions"></a>Плавное управление скоростью действий

Замедление — это способ, которым будет unfold анимация, и она может сделать анимацию гораздо более приятный.  По умолчанию действия будут иметь линейное поведение, например действие будет `MoveTo` иметь очень автоматическую передвижение.  Вы можете заключить действия в действие замедления для изменения поведения, например для медленного запуска перемещения, ускорения и медленного достижения конца ( `EasyInOut` ).

Это делается путем переноса существующего действия в действие плавности, например:

```csharp
await cloud.RunActionAsync (
   new EaseInOut (
     new MoveTo (duration: 3, position: new Vector (0,0,15)), rate:1))
```

Существует много режимов плавности, на следующей диаграмме показаны различные типы замедления и их поведение в отношении значения объекта, за которым они контролируются за определенный период времени, от начала до конца:

![Режимы плавности](using-images/easing.png "На этой диаграмме показаны различные типы замедления и их поведение в отношении значения объекта, за которым они контролируются за определенный период времени.")

### <a name="using-actions-and-async-code"></a>Использование действий и асинхронного кода

В `Component` подклассе следует ввести асинхронный метод, который подготавливает поведение компонента и управляет его функциональностью.
Затем этот метод следует вызывать с помощью `await` ключевого слова C# из другой части программы — либо метода, `Application.Start` либо в ответ на точку пользователя или описания в приложении.

Пример.

```csharp
class Robot : Component {
    public bool IsAlive;
    async void Launch ()
    {
        // Dress up our robot
        var cache = Application.ResourceCache;
        var model = node.CreateComponent<StaticModel>();
        model.Model = cache.GetModel ("robot.mdl"));
        model.SetMaterial (cache.GetMaterial ("robot.xml"));
        Node.SetScale (1);

        // Bring the robot into our scene
        await Node.RunActionsAsync(
            new MoveBy(duration: 0.6f, position: new Vector3(0, -2, 0)));
        // Make him move around to avoid the user fire
        MoveRandomly(minX: 1, maxX: 2, minY: -3, maxY: 3, duration: 1.5f);
        // And simultaneously have him shoot at the user
        StartShooting();
    }

    protected async void MoveRandomly (float minX, float maxX,
                                       float minY, float maxY,
                       float duration)
    {
        while (IsAlive){
            var moveAction = new MoveBy(duration,
                new Vector3(RandomHelper.NextRandom(minX, maxX),
                            RandomHelper.NextRandom(minY, maxY), 0));
            await Node.RunActionsAsync(moveAction, moveAction.Reverse());
        }
    }
    protected async void StartShooting()
    {
        while (IsAlive && Node.Components.Count > 0){
            foreach (var weapon in Node.Components.OfType<Weapon>()){
                await weapon.FireAsync(false);
                if (!IsAlive)
                    return;
            }
            await Node.RunActionsAsync(new DelayTime(0.1f));
        }
    }
}
```

В `Launch` методе выше три действия запускаются: робот поступает в сцену, это действие изменяет расположение узла в течение 0,6 секунд.  Поскольку это параметр async, это происходит параллельно, как и Следующая инструкция, которая является вызовом `MoveRandomly` .  Этот метод будет изменять положение робота в параллельном режиме на случайное расположение.  Это достигается за счет выполнения двух составных действий, перемещения в новое место и возврата к исходному положению и повторения до тех пор, пока робот остается активным.  И, чтобы сделать интерес более интересным, робот будет непрерывно выполнять отдело.  Запуск начнется каждые 0,1 секунд.

### <a name="frame-based-behavior-programming"></a>Программирование поведений на основе кадров

Если требуется управлять поведением компонента на основе отдельных кадров, а не с помощью действий, то нужно переопределить `OnUpdate` метод `Component` подкласса.  Этот метод вызывается один раз для каждого кадра и вызывается, только если для свойства Рецеивесценеупдатес задано значение true.

Ниже показано, как создать `Rotator` компонент, который затем присоединяется к узлу, что приводит к тому, что узел поворачивается:

```csharp
class Rotator : Component {
    public Rotator()
    {
        ReceiveSceneUpdates = true;
    }
    public Vector3 RotationSpeed { get; set; }
    protected override void OnUpdate(float timeStep)
    {
        Node.Rotate(new Quaternion(
            RotationSpeed.X  timeStep,
            RotationSpeed.Y  timeStep,
            RotationSpeed.Z  timeStep),
            TransformSpace.Local);
    }
}
```

И вот как можно присоединить этот компонент к узлу:

```csharp
Node boxNode = new Node();
var rotator = new Rotator() { RotationSpeed = rotationSpeed };
boxNode.AddComponent (rotator);
```

### <a name="combining-styles"></a>Объединение стилей

Модель на основе Async/Action можно использовать для программирования большей части поведения, что отлично подходит для стиля программирования "пожар-и-забыть", но можно также точно настроить поведение компонента, чтобы в каждом кадре также выполнялся код обновления.

Например, в демонстрационной версии Самплигаме, которая используется в `Enemy` классе, кодирует базовое поведение с помощью действий, но также гарантирует, что компоненты указывают на пользователя, задав направление узла с помощью `Node.LookAt` :

```csharp
    protected override void OnUpdate(SceneUpdateEventArgs args)
    {
        Node.LookAt(
            new Vector3(0, -3, 0),
            new Vector3(0, 1, -1),
            TransformSpace.World);
        base.OnUpdate(args);
    }
```

## <a name="loading-and-saving-scenes"></a>Загрузка и сохранение сцен

Сцены можно загружать и сохранять в формате XML. см. раздел функции `LoadXml` и `SaveXML` . При загрузке сцены сначала удаляется все существующее содержимое (дочерние узлы и компоненты). Узлы и компоненты, помеченные как временные со `Temporary` свойством, не будут сохранены. Сериализатор обрабатывает все встроенные компоненты и свойства, но не является достаточно интеллектуальным для обработки пользовательских свойств и полей, определенных в подклассах компонента. Однако он предоставляет два виртуальных метода для этого:

 `OnSerialize`где можно зарегистрировать пользовательские состояния для сериализации

 `OnDeserialized`где можно получить сохраненные пользовательские состояния.

Как правило, пользовательский компонент будет выглядеть следующим образом:

```csharp
class MyComponent : Component {
    // Constructor needed for deserialization
    public MyComponent(IntPtr handle) : base(handle) { }
    public MyComponent() { }
    // user defined properties (managed state):
    public Quaternion MyRotation { get; set; }
    public string MyName { get; set; }

    public override void OnSerialize(IComponentSerializer ser)
    {
        // register our properties with their names as keys using nameof()
        ser.Serialize(nameof(MyRotation), MyRotation);
        ser.Serialize(nameof(MyName), MyName);
    }

    public override void OnDeserialize(IComponentDeserializer des)
    {
        MyRotation = des.Deserialize<Quaternion>(nameof(MyRotation));
        MyName = des.Deserialize<string>(nameof(MyName));
    }
    // called when the component is attached to some node
    public override void OnAttachedToNode()
    {
        var node = this.Node;
    }
}
```

### <a name="object-prefabs"></a>Prefabs объекта

Загрузка или сохранение целых сцен недостаточно гибок для игр, в которых новые объекты должны динамически создаваться. С другой стороны, создание сложных объектов и настройка их свойств в коде также будут утомительными. По этой причине можно также сохранить узел сцены, который будет включать его дочерние узлы, компоненты и атрибуты. Позже их можно будет загрузить как группу.  Такой сохраненный объект часто называется prefab. Это можно сделать тремя способами:

- В коде путем вызова `Node.SaveXml` в узле
- В редакторе, выбрав узел в окне Иерархия и выбрав пункт "сохранить узел как" в меню "файл".
- С помощью команды Node в среде `AssetImporter` , которая сохранит иерархию узлов сцены и все модели, содержащиеся во входном ресурсе-контейнере (например, Файл Collada-файл)

Чтобы создать экземпляр сохраненного узла в сцене, вызовите `InstantiateXml` . Узел будет создан как дочерний для сцены, но после этого он может быть свободно переподчинен. Необходимо указать расположение и поворот для размещения узла. В следующем коде показано, как создать экземпляр prefab `Ninja.xm` для сцены с желаемой позицией и поворотом:

```csharp
var prefabPath = Path.Combine (FileSystem.ProgramDir,"Data/Objects/Ninja.xml");
using (var file = new File(Context, prefabPath, FileMode.Read))
{
    scene.InstantiateXml(file, desiredPos, desiredRotation,
        CreateMode.Replicated);
}
```

## <a name="events"></a>События

Урхубжектс создает ряд событий, они отображаются в виде событий C# для различных классов, создающих их.  Помимо модели событий на основе C#, можно также использовать `SubscribeToXXX` методы, позволяющие подписаться и использовать маркер подписки, который позже можно будет применять для отмены подписки.  Разница заключается в том, что первый допускает подписку многих вызывающих объектов, а вторая — только один, но позволяет использовать лучшеный подход в стиле лямбда-стилей и, тем не более, допускать простое удаление подписки.  Они являются взаимоисключающими.

При оформлении подписки на событие необходимо предоставить метод, принимающий аргумент с соответствующими аргументами события.

Например, вы подписались на событие нажатия кнопки мыши:

```csharp
public void override Start ()
{
    UI.MouseButtonDown += HandleMouseButtonDown;
}

void HandleMouseButtonDown(MouseButtonDownEventArgs args)
{
    Console.WriteLine ("button pressed");
}
```

С лямбда-стилем:

```csharp
public void override Start ()
{
    UI.MouseButtonDown += args => {
        Console.WriteLine ("button pressed");
    };
}
```

Иногда необходимо отменить получение уведомлений для события, в таких случаях сохранить возвращаемое значение из вызова `SubscribeTo` метода и вызвать метод отмены подписки.

```csharp
Subscription mouseSub;

public void override Start ()
{
    mouseSub = UI.SubscribeToMouseButtonDown (args => {
    Console.WriteLine ("button pressed");
      mouseSub.Unsubscribe ();
    };
}
```

Параметр, полученный обработчиком событий, является строго типизированным классом аргументов события, который будет конкретным для каждого события и содержит полезные данные события.

## <a name="responding-to-user-input"></a>Реагирование на ввод данных пользователем

Вы можете подписаться на различные события, например нажатия клавиш, подподписавшись на событие и реагируя на доставку входных данных:

```csharp
Start ()
{
    UI.KeyDown += HandleKeyDown;
}

void HandleKeyDown (KeyDownEventArgs arg)
{
     switch (arg.Key){
     case Key.Esc: Engine.Exit (); return;
}
```

Но во многих случаях необходимо, чтобы обработчики обновлений сцены проверяют текущее состояние ключей при их обновлении и соответствующим образом обновляет код.  Например, можно использовать следующую команду для обновления расположения камеры на основе ввода с клавиатуры:

```csharp
protected override void OnUpdate(float timeStep)
{
    Input input = Input;
    // Movement speed as world units per second
    const float moveSpeed = 4.0f;
    // Read WASD keys and move the camera scene node to the
    // corresponding direction if they are pressed
    if (input.GetKeyDown(Key.W))
        CameraNode.Translate(Vector3.UnitY  moveSpeed  timeStep, TransformSpace.Local);
    if (input.GetKeyDown(Key.S))
        CameraNode.Translate(new Vector3(0.0f, -1.0f, 0.0f)  moveSpeed  timeStep, TransformSpace.Local);
    if (input.GetKeyDown(Key.A))
        CameraNode.Translate(new Vector3(-1.0f, 0.0f, 0.0f)  moveSpeed  timeStep, TransformSpace.Local);
    if (input.GetKeyDown(Key.D))
        CameraNode.Translate(Vector3.UnitX  moveSpeed  timeStep, TransformSpace.Local);
}
```

## <a name="resources-assets"></a>Ресурсы (активы)

Ресурсы включают в себя большинство вещей в UrhoSharp, которые загружаются из массового хранилища во время инициализации или выполнения.

- `Animation`— используется для анимаций скелетообразных
- `Image`— представляет изображения, хранящиеся в различных графических форматах
- `Model`-Трехмерные модели
- `Material`— материалы, используемые для отрисовки моделей.
- `ParticleEffect`- [Описание](https://urho3d.github.io/documentation/1.4/_particles.html) работы передатчика примитивов см. в разделе "[частицы](#particles)" ниже.
- `Shader`— Пользовательские шейдеры
- `Sound`— звук для воспроизведения см. в разделе "[звук](#sound)" ниже.
- `Technique`— приемы отрисовки материалов
- `Texture2D`— Двухмерная текстура
- `Texture3D`— Трехмерная текстура
- `TextureCube`-Текстура Куба
- `XmlFile`

Они управляются и загружаются `ResourceCache` подсистемой (доступна как `Application.ResourceCache` ).

Сами ресурсы определяются по путям к файлам относительно зарегистрированных каталогов ресурсов или файлов пакетов. По умолчанию подсистема регистрирует каталоги ресурсов `Data` `CoreData` , или пакеты `Data.pak` и, `CoreData.pak` если они существуют.

При сбое загрузки ресурса будет записана ошибка, и возвращается пустая ссылка.

В следующем примере показан типичный способ выборки ресурса из кэша ресурсов.  В этом случае текстура для элемента пользовательского интерфейса использует `ResourceCache` свойство из `Application` класса.

```csharp
healthBar.SetTexture(ResourceCache.GetTexture2D("Textures/HealthBarBorder.png"));
```

Ресурсы также можно создать вручную и сохранить в кэше ресурсов так, как будто они были загружены с диска.

Для каждого типа ресурса можно задать бюджеты памяти. Если ресурсы потребляют больше памяти, чем разрешено, самые старые ресурсы будут удалены из кэша, если они больше не используются. По умолчанию для бюджетов памяти задано значение unlimited.

### <a name="bringing-3d-models-and-images"></a>Перенос трехмерных моделей и изображений

Urho3D пытается использовать существующие форматы файлов везде, где это возможно, и определять пользовательские форматы файлов только при крайней необходимости, например для моделей (MDL) и для анимации (ANI). Для этих типов ресурсов Урхо предоставляет конвертер [ассетимпортер](https://urho3d.github.io/documentation/1.4/_tools.html) , который может использовать многие популярные трехмерные форматы, такие как FBX, DAE, 3ds, obj и т. д.

Также существует удобная надстройка для смешения [https://github.com/reattiva/Urho3D-Blender](https://github.com/reattiva/Urho3D-Blender) , которая может экспортировать активы-контейнеры в формате, подходящем для Urho3D.

### <a name="background-loading-of-resources"></a>Фоновая загрузка ресурсов

Обычно при запросе ресурсов с помощью одного из `ResourceCache` `Get` методов они загружаются немедленно в основном потоке, что может занять несколько миллисекунд для выполнения всех необходимых действий (Загрузка файла с диска, анализ данных, передача в GPU при необходимости) и, следовательно, приводит к падению частоты кадров.

Если вы заранее знакомы с тем, какие ресурсы вам нужны, можно запросить их загрузку в фоновом потоке, вызвав `BackgroundLoadResource` . Вы можете подписываться на событие загрузки фонового ресурса с помощью `SubscribeToResourceBackgroundLoaded` метода. она сообщит, действительно ли загрузка была успешной или неудачной. В зависимости от ресурса, только часть процесса загрузки может быть перемещена в фоновый поток, например, шаг завершения загрузки GPU всегда должен выполняться в основном потоке. Обратите внимание, что при вызове одного из методов загрузки ресурсов для ресурса, помещенного в очередь для фоновой загрузки, основной поток будет остановлен до завершения его загрузки.

Функция загрузки асинхронной сцены `LoadAsync` с `LoadAsyncXML` возможностью фоновой загрузки ресурсов перед продолжением загрузки содержимого сцены. Его также можно использовать для загрузки ресурсов без изменения сцены, указав `LoadMode.ResourcesOnly` . Это позволяет подготовить сцену или файл prefab объекта для быстрого создания экземпляров.

Наконец, максимальное время (в миллисекундах), затраченное на обработку каждого кадра при завершении загрузки фоновых ресурсов, можно настроить, задав `FinishBackgroundResourcesMs` свойство в `ResourceCache` .

<a name="sound"></a>

## <a name="sound"></a>Звук

Звук является важной частью игры, и UrhoSharp Framework позволяет воспроизводить звуки в игре.  Вы воспроизводите звуки, присоединяя`SoundSource`
в `Node` , а затем воспроизводить именованный файл из ресурсов.

Вот как это делается:

```csharp
var explosionNode = Scene.CreateChild();
var sound = explosionNode.CreateComponent<SoundSource>();
soundSource.Play(Application.ResourceCache.GetSound("Sounds/ding.wav"));
soundSource.Gain = 0.5f;
soundSource.AutoRemove = true;
```

<a name="particles"></a>

## <a name="particles"></a>Примитивы

Частицы предоставляют простой способ добавления простых и недорогих эффектов в приложение.  Можно использовать частицы, хранящиеся в формате PEX, с помощью таких средств, как [http://onebyonedesign.com/flash/particleeditor/](http://onebyonedesign.com/flash/particleeditor/) .

Частицы — это компоненты, которые можно добавить в узел.  Необходимо вызвать метод узла, `CreateComponent<ParticleEmitter2D>` чтобы создать примитив, а затем настроить его, задав для свойства Effect («результат») плоский результат, который загружается из кэша ресурсов.

Например, этот метод можно вызвать для компонента, чтобы отобразить некоторые частицы, отображаемые в виде развертывания при попадании:

```csharp
public async void Explode (Component target)
{
    // show a small explosion when the missile reaches an aircraft.
    var cache = Application.ResourceCache;
    var explosionNode = Scene.CreateChild();
    explosionNode.Position = target.Node.WorldPosition;
    explosionNode.SetScale(1f);
    var particle = explosionNode.CreateComponent<ParticleEmitter2D>();
    particle.Effect = cache.GetParticleEffect2D("explosion.pex");
    var scaleAction = new ScaleTo(0.5f, 0f);
    await explosionNode.RunActionsAsync(
        scaleAction, new DelayTime(0.5f));
    explosionNode.Remove();
}
```

Приведенный выше код создает узел развертывания, присоединенный к текущему компоненту, внутри этого узла развертывания мы создаем податчик 2D-примитива и настроим его, установив свойство Effect.  Мы выполняем два действия, один из которых увеличивает размер узла и оставляет его в течение 0,5 секунд.  Затем мы удалим развертывание, которое также удаляет результат примитива с экрана.

Приведенная выше часть визуализируется следующим образом при использовании текстуры сферы:

![Частицы с текстурой сферы](using-images/image-1.png "Приведенная выше часть отображается подобным образом при использовании текстуры сферы")

И это выглядит, если используется блочная текстура:

![Частицы с текстурой Box](using-images/image-2.png "И это выглядит при использовании блочной текстуры")

## <a name="multi-threading-support"></a>Поддержка многопоточности

UrhoSharp является единственной многопоточной библиотекой.  Это означает, что не следует пытаться вызывать методы в UrhoSharp из фонового потока, или вы рискуете повредить состояние приложения и, скорее всего, приведет к сбою приложения.

Если вы хотите выполнить некоторый код в фоновом режиме, а затем обновить компоненты Урхо в основном пользовательском интерфейсе, можно использовать`Application.InvokeOnMain(Action)`
метод.  Кроме того, можно использовать функции ожидания C# и API-интерфейсы задач .NET, чтобы обеспечить выполнение кода в правильном потоке.

## <a name="urhoeditor"></a>урхоедитор

Вы можете скачать редактор Урхо для своей платформы с [веб-сайта Урхо](http://urho3d.github.io/), перейдя к разделам Downloads и выберите последнюю версию.

## <a name="copyrights"></a>Авторские права

В этой документации содержится первоначальное содержимое от Xamarin Inc, но оно широко выводится из документации по с открытым исходным кодом для проекта Urho3D и содержит снимки экрана из проекта Cocos2D.
