---
title: Двухмерные математические операции с CocosSharp
description: В этом руководстве описывается 2D математики для разработки игр. Он использует CocosSharp демонстрирует, как выполнять типовые задачи разработки игр и объясняет математически этих задач.
ms.prod: xamarin
ms.assetid: 5C241AB4-F97E-4B61-B93C-F5D307BCD517
author: charlespetzold
ms.author: chape
ms.date: 03/27/2017
ms.openlocfilehash: 63c722b74c7dc7e034475e539f38204aca87763e
ms.sourcegitcommit: b56b3f906d2c05a3f1be219ef41be8b79e519b8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/25/2018
ms.locfileid: "39242057"
---
# <a name="2d-math-with-cocossharp"></a>Двухмерные математические операции с CocosSharp

_В этом руководстве описывается 2D математики для разработки игр. Он использует CocosSharp демонстрирует, как выполнять типовые задачи разработки игр и объясняет математически этих задач._

Для размещения и перемещения объектов с кодом является основной частью разработки игр любого размера. Размещение и перемещение требуется использовать математические, ли игра требующей перемещения объекта вдоль прямой или использование тригонометрических вычислений для поворота. В этом документе рассматриваются следующие темы:

 - Скорость
 - Ускорение
 - Поворот объектов CocosSharp
 - Использование с скорость поворота

Разработчики, не имеющих фона строгого математические или кто давно забытым эти разделы из учебного заведения, не нужно беспокоиться — в этом документе будет разбить основные понятия на оторваться компонентов и все прилагаемые к теоретической объяснений с практическими примерами. Короче говоря, в этой статье будет ответить на вопрос учащегося как мир math: «Когда мне будет фактически нужно для использования подобного?»


## <a name="requirements"></a>Требования

Несмотря на то, что этот документ посвящен главным образом в математических части CocosSharp, образцы кода описывают работе с объектами, наследование формы `CCNode`. Кроме того, с момента `CCNode` не содержат значения для и ускорение, в коде предполагается, работе с сущностями, которые предоставляют значения, такие как VelocityX, VelocityY, AccelerationX и AccelerationY. Дополнительные сведения о сущностях см. в разделе нашим пошаговым руководством на [сущности в CocosSharp](~/graphics-games/cocossharp/entities.md).


## <a name="velocity"></a>Скорость

Разработчики игр используется термин *скорости* для описания того, как объект движется — специально скорость некий объект движется и направление он движется. 

Скорость определяется с помощью два вида единиц: единое позиции и единицу измерения времени. Например скоростью автомобиля определяется как миль в час или километры в час. Разработчики игр, часто используется пикселей в секунду, можно определить как быстро объект перемещается. Например маркер, могут быть перемещены со скоростью 300 пикселей в секунду. То есть если маркера движется в 300 пикселей в секунду, затем его будет были перемещены 600 единиц в две секунды, а 900 единиц в три секунды и т. д. Как правило, значение скорости *добавляет* позиции объекта (как мы увидим ниже).

Несмотря на то, что мы использовали скорость для объяснения единицы скорости, скорость термин обычно ссылается на значение, независимо от направления, пока скорость термин относится к скорости и направление. Таким образом назначение скорости маркера (предполагается, что маркер — это класс, который включает необходимые свойства) может выглядеть следующим образом:


```csharp
// This bullet is not moving horizontally, so set VelocityX to 0:
bulletInstance.VelocityX = 0;
// Positive Y is "up" so move the bullet up 300 units per second:
bulletInstance.VelocityY = 300;
```


### <a name="implementing-velocity"></a>Реализация скорости

CocosSharp не реализует скорости, поэтому объекты, требующие перемещения потребуется реализовывать собственную логику перемещения. Новым разработчикам игр, реализация скорости часто зависеть полагают, что делает их скорости частота кадров. То есть следующие *неверная реализация* будет дает правильные результаты, но будет основываться на частоту кадров для игры:

```csharp
// VelocityX and VelocityY will be added every time this code executes
this.PositionX += this.VelocityX;
this.PositionY += this.VelocityY;
```

Если игра работает на более высокий уровень фрейма (например, 60 кадров в секунду, а не 30 кадров в секунду), объект будет отображаться для перемещения быстрее, чем если работает медленнее частотой кадров. Аналогичным образом Если игры не может обрабатывать кадры в качестве высокой частоты кадров, (который может быть вызвано фоновых процессов, с помощью ресурсов устройства), игра будет отображаться к замедлению работы.

Чтобы это учесть, скорость часто реализуется с помощью значение времени. Например если `seconds` переменная представляет число (или их части), время в секундах с момента последнего скорость времени была применена, то следующий код приведет к объект согласованные перемещения независимо от частоты кадров:

```csharp
// VelocityX and VelocityY will be added every time this code executes
this.PositionX += this.VelocityX * seconds;
this.PositionY += this.VelocityY * seconds;
```

Рассмотрим, что игры, который выполняется с меньшей скоростью кадра обновит положение его объектов меньше часто. Таким образом каждое обновление приведет к дальнейшей, чем это было бы, если игра обновляли чаще перемещение объектов. `seconds` Значение учетные записи для этого службами reporting, сколько времени прошло с момента последнего обновления.

Пример добавления перемещения на основе времени, см. в разделе [Этот рецепт, охватывающие время на основе перемещения](https://github.com/xamarin/recipes/tree/master/Recipes/cross-platform/game_development/time_based_movement).


### <a name="calculating-positions-using-velocity"></a>Вычисление позициями, используя скорость

Скорость может использоваться для создания прогнозов, о котором объект будет после этого некоторое количество времени или для настройки поведения объектов без необходимости запуска игры. Например разработчика, который реализует перемещение активированных маркера необходимо задать скорость маркера после ее создания. Размер экрана можно использовать для создания базы для установки скорости. То есть если разработчик знает, что маркера следует переместить Высота экрана в 2 секунды, а затем скорость должно быть присвоено Высота экрана, поделенную на 2. Если экрана 800 пикселов в высоту, затем скорость маркера устанавливается до 400 (который составляет 800/2).

Аналогичным образом логику игры может потребоваться вычислить, сколько объект перейдете к назначению, учитывая его скорости. Это может быть вычисляется путем деления расстояние, скорость Передвижная объекта. Например, приведенный ниже показано, как назначение текста на метку, которая отображает как долго до ракетной достигает своей цели:


```csharp
// We'll assume only the X axis for this example
float distanceX = target.PositionX - missile.PositionX;

float secondsToReachTarget = distanceX / missile.VelocityX;

label.Text = secondsToReachTarget + " seconds to reach target"; 
```


## <a name="acceleration"></a>Ускорение

*Ускорение* — это понятие, распространенных в разработке игр, и она имеет много общего с скорости. Ускорение содержит количественные ли ускорение или замедление (как значение скорости изменяется со временем) объекта. Ускорение *добавляет* скорости, так же, как скорость добавляет для размещения. Типичные способы применения ускорение включают гравитации, автомобиль, ускоряя и обработки его thrusters пространства корабля. 

Аналогичный скорости, ускорение, определенные в позицию и единицу времени; Тем не менее единицы времени ускорение называется *квадрате* блок, который отражает, как ускорение определяется математически. То есть ускорение игры часто измеряется в *пикселей в секунду в квадрате*.

Если у объекта имеется ускорение X 10 единиц в секунду в квадрате, то это означает, что приведет к увеличению его скорость в 10 раз в секунду. Если начиная с начнут, после одной секунды будет перемещение на 10 единиц в секунду, после двух секунд 20 единиц в, во-вторых, и т. д.

Ускорение в двух направлениях требуется компонент X и Y, поэтому он может быть назначено следующим образом:


```csharp
// No horizontal acceleration:
icicle.AccelerationX = 0;
// Simulate gravity with Y acceleration. Negative Y is down, so assign a negative value:
icicle.AccelerationY = -50; 
```


### <a name="acceleration-vs-deceleration"></a>Ускорение и замедление

Несмотря на то, что ускорение и замедление, иногда различаются в ежедневным речи, нет технические различия между ними. Гравитация это сила, что приводит к ускорение. Если объект создается вверх затем тяжести будет замедлять работу (значения), но после того как объект был остановлен экстремума и снижается в направлении тяжести затем тяжести ускорение его (ускорение). Как показано ниже, приложение ускорение, совпадает ли он применяется в том же направлении или обратное направление перемещения. 


### <a name="implementing-acceleration"></a>Реализация ускорение

Ускорение, аналогичный скорости, при реализации — она не реализуется автоматически CocosSharp и ускорение на основе времени является необходимого внедрения (в отличие от ускорение на основе кадров). Поэтому реализация простой ускорение (а также скорости) может выглядеть так:

```csharp
this.VelocityX += this.AccelerationX * seconds;
this.VelocityY += this.AccelerationY * seconds;
this.PositionX += this.VelocityX * seconds;
this.PositionY += this.VelocityY * seconds;
```

Приведенный выше код является то, что называется *линейной аппроксимации* для ускорения реализации. Фактически он реализует ускорение достаточно тесная степень точности, но это не вполне точной модели ускорения. Он включается выше чтобы лучше объяснить понятие реализации ускорение.

Следующая реализация является математически точные приложением ускорения, скорость:


```csharp
float halfSecondsSquared = (seconds * seconds) / 2.0f;

this.PositionX += 
    this.Velocity.X * seconds + this.AccelerationX * halfSecondsSquared;
this.PositionY += 
    this.Velocity.Y * seconds + this.AccelerationY * halfSecondsSquared;

this.VelocityX += this.AccelerationX * seconds;
this.VelocityY += this.AccelerationY * seconds; 
```

Самым очевидным отличием в приведенный выше код является `halfSecondsSquared` переменную и их использование для применения ускорение для размещения. Математические причина выходит за рамки данного руководства, но разработчиков, заинтересованных в расчеты за этим можно найти дополнительные сведения в [данного обсуждения об интеграции ускорение.](http://www.cliffsnotes.com/math/calculus/calculus/integration/distance-velocity-and-acceleration)

Практическое влияние закона `halfSecondSquare` — что ускорение будет вести себя математически точно и предсказуемое независимо от частоты кадров. Линейной аппроксимации ускорения подчиняется частота кадров — чем меньше значение частоты кадров опускается, тем менее точным становится приблизительное значение. С помощью `halfSecondsSquared` гарантии, что код будет функционировать так же, независимо от частоты кадров.


## <a name="angles-and-rotation"></a>Углы и поворот

Визуальные объекты, такие как `CCSprite` поддерживают поворот через `Rotation` переменной. Это можно назначить значение для задания вращения в градусах. Например, приведенный ниже демонстрируется поворот `CCSprite` экземпляр:


```csharp
CCSprite unrotatedSprite = new CCSprite("star.png");
unrotatedSprite.IsAntialiased = false;
unrotatedSprite.PositionX = 100;
unrotatedSprite.PositionY = 100;
this.AddChild (unrotatedSprite);

CCSprite rotatedSprite = new CCSprite("star.png");
rotatedSprite.IsAntialiased = false;
// This sprite is moved to the right so it doesn’t overlap the first
rotatedSprite.PositionX = 130;
rotatedSprite.PositionY = 100;
rotatedSprite.Rotation = 45;
this.AddChild (rotatedSprite); 
```

Эти действия произведут следующий результат:

![](math-images/image1.png "Это приводит к на этом снимке экрана")

Обратите внимание, что поворот на 45 градусов по часовой стрелке (которые по историческим причинам является противоположностью как математически применяется поворот):

![](math-images/image2.png "Обратите внимание, что угол поворота по часовой стрелке на 45 градусов по историческим причинам это противоположность как математически применяется поворот")

В целом поворота CocosSharp, а также математика регулярных можно представить следующим образом:

![](math-images/image3.png "В целом можно визуализировать поворота CocosSharp, а также математика регулярных следующим образом")

![](math-images/image4.png "В целом можно визуализировать поворота CocosSharp, а также математика регулярных следующим образом")

Это различие важно, так как `System.Math` класс использует поворот против часовой стрелки, поэтому разработчики, знакомые с этим классом необходимо обратить углы при работе с `CCNode` экземпляров.

Следует отметить, что выше схемы отображать поворота в градусах; Тем не менее некоторые математические функции (такие как функции в `System.Math` пространства имен) ожидать и возвращать значения в *радианах* вместо того чтобы градусов. Мы рассмотрим способ преобразования между типами два модульных немного позже в этом руководстве.


### <a name="rotating-to-face-a-direction"></a>Поворот на лицевой стороной в направлении

Как показано выше, `CCSprite` повернутый с использованием `Rotation` свойство. `Rotation` Предоставляется свойство `CCNode` (базовый класс для `CCSprite`), что означает, что поворот может применяться к сущности, которые наследуют от `CCNode` также. 

Некоторые играм требуются объекты смене, поэтому перед лицом целевого объекта. Примеры включают управляемые компьютером злоумышленником, устранении неполадок в целевой объект проигрывателя или в движении к точке, где пользователь касается экрана пространства корабля. Тем не менее значение поворота должен сначала вычислить на основе расположение объекта, подлежащего смене и целевого лиц.

Этот процесс требует несколько этапов:

 - Определение *смещение* целевого объекта. Смещение относится к X и Y расстояние между поворота сущностью и целевой сущности.
 - Вычисление угол от смещения, используя функцию тригонометрические арктангенс (подробно ниже).
 - Настройка для разницы между на право и направление, в котором указывает поворота сущности при отмене повернутый 0 градусов.
 - Настройка для разницы между математические поворот (против часовой стрелки) и CocosSharp поворота (по часовой стрелке).

Следующая функция (предполагается, что для записи в сущности) поворачивает сущность сталкиваются целевого объекта:


```csharp
// This function assumes that it is contained in a CCNode-inheriting object
public void FacePoint(float targetX, float targetY)
{
    // Calculate the offset - the target's position relative to "this"
    float xOffset = targetX - this.PositionX;
    float yOffset = targetY - this.PositionY;

    // Make sure the target isn't the same point as "this". If so,
    // then rotation cannot be calculated.
    if (targetX != this.PositionX || targetY != this.Position.Y)
    {

        // Call Atan2 to get the radians representing the angle from 
        // "this" to the target
        float radiansToTarget = (float)System.Math.Atan2 (yOffset, xOffset);

        // Since CCNode uses degrees for its rotation, we need to convert
        // from radians
        float degreesToTarget = CCMathHelper.ToDegrees (radiansToTarget);

        // The direction that the entity faces when unrotated. In this case
        // the entity is facing "up", which is 90 degrees 
        const float forwardAngle = 90;

        // Adjust the angle we want to rotate by subtracting the
        // forward angle.
        float adjustedForDirecitonFacing = degreesToTarget - forwardAngle;

        // Invert the angle since CocosSharp uses clockwise rotation
        float cocosSharpAngle = adjustedForDirecitonFacing * -1;

        // Finally assign the rotation
        this.Rotation = rotation = cocosSharpAngle;
    }
} 
```

Приведенный выше код может использоваться для поворота сущности, чтобы она была направлена в точке, где пользователь касается экрана, следующим образом:


```csharp
private void HandleInput(System.Collections.Generic.List<CCTouch> touches, CCEvent touchEvent)
{
    if(touches.Count > 0)
    {
        CCTouch firstTouch = touches[0];
        FacePoint (firstTouch.Location.X, firstTouch.Location.Y);
    }
} 
```

Этот код вызывает следующее поведение:

![](math-images/image5.gif "Этот код приводит к такое поведение")

#### <a name="using-atan2-to-convert-offsets-to-angles"></a>Преобразование с помощью Atan2 смещений в углов

`System.Math.Atan2` можно использовать для преобразования смещение углом. Имя функции `Atan2` поступает из арктангенс тригонометрической функции. «2» суффикс отличает эту функцию из стандарта `Atan` функции, строго удовлетворяющий математические поведение арктангенс. Арктангенс — это функция, которая возвращает значение в диапазоне от -90 и 90 градусов (или его эквивалента в радианах). Во многих областях компьютерные игры, часто требуют полного 360 градусов из значений, поэтому `Math` класс включает `Atan2` для удовлетворения этой потребности.

Обратите внимание на то, что приведенный выше код передает параметр Y во-первых, затем параметр X, при вызове `Atan2` метод. Это обратной из обычного X, Y упорядочение положение координаты. Дополнительные сведения [см. в разделе Документация Atan2](https://msdn.microsoft.com/library/system.math.atan2(v=vs.110).aspx).

Стоит также отметить, что возвращаемое значение из `Atan2` — в радианах, который является еще одну единицу, используются для измерения углов. В этом руководстве не рассматриваются угол в радианах, но имейте в виду, все тригонометрические функции в `System.Math` пространства имен принимающие радианы, поэтому все значения должны преобразовываться в градусы перед использованием объектов CocosSharp. Можно найти дополнительные сведения о радианах [в радианах страница](http://en.wikipedia.org/wiki/Radian).

#### <a name="forward-angle"></a>Прямой угол

Один раз `FacePoint` метод преобразует угол в радианах, он определяет `forwardAngle` значение. Это значение представляет угол, в которой направлена сущности, если его значение поворота равно 0. В этом примере мы предполагаем, что сущности направлена вверх, который является 90 градусов, при использовании математических поворота (в отличие от поворота CocosSharp). Здесь мы использовать математические поворот так, как мы еще не обращена поворота для CocosSharp.

Далее показано, какие сущности с `forwardAngle` 90 градусов может выглядеть так:

![](math-images/image6.png "Это показывает, как может выглядеть сущность с forwardAngle 90 градусов")


### <a name="angled-velocity"></a>Угловая скорость

Пока мы рассмотрели, как преобразовать смещения в угол. В этом разделе идет другим способом — получает значение угла и преобразует его в X и значений Y. Распространенные примеры включают перемещение в направление, в котором лицевой или неполадок маркера, который перемещается в направлении, возник корабль пространства корабля автомобиля. 

По существу скорость может рассчитываться путем сначала определить нужный скорость при отмене повернутый, а затем поворот, скорость на угол, возник сущности. Чтобы объяснить эту концепцию (и ускорение) можно представить в виде 2-мерной *вектор* (который обычно отображенный в виде стрелки). Вектор для значения скорости с X = 100, а Y = 0 можно представить следующим образом:

![](math-images/image7.png "Вектор для значения скорости с X = 100, а Y = 0 можно представить следующим образом")

Этот вектор можно поворачивать с последующим получением нового скорости. Например поворот на 45 градусов (с помощью повороту против часовой стрелки) вектор приведет к следующему:

![](math-images/image8.png "Поворот на 45 градусов с помощью результатов повороту против часовой стрелки в этом вектора")

К счастью скорости, ускорение и даже положение всех повернуть можно с тем же кодом, независимо от того, как применяются значения. Следующая функция общего назначения может использоваться для поворота вектор по значению CocosSharp поворота:


```csharp
// Rotates the argument vector by degrees specified by
// cocosSharpDegrees. In other words, the rotation
// value is expected to be clockwise.
// The vector parameter is modified, so it is both an in and out value
void RotateVector(ref CCVector2 vector, float cocosSharpDegrees)
{
    // Invert the rotation to get degrees as is normally
    // used in math (counterclockwise)
    float mathDegrees = -cocosSharpDegrees;

    // Convert the degrees to radians, as the System.Math
    // object expects arguments in radians
    float radians = CCMathHelper.ToRadians (mathDegrees);

    // Calculate the "up" and "right" vectors. This is essentially
    // a 2x2 matrix that we'll use to rotate the vector
    float xAxisXComponent = (float)System.Math.Cos (radians);
    float xAxisYComponent = (float)System.Math.Sin (radians);
    float yAxisXComponent = (float)System.Math.Cos (radians + CCMathHelper.Pi / 2.0f);
    float yAxisYComponent = (float)System.Math.Sin (radians + CCMathHelper.Pi / 2.0f);

    // Store the original vector values which will be used
    // below to perform the final operation of rotation.
    float originalX = vector.X;
    float originalY = vector.Y;

    // Use the axis values calculated above (the matrix values)
    // to rotate and assign the vector.
    vector.X = originalX * xAxisXComponent + originalY * yAxisXComponent;
    vector.Y = originalX * xAxisYComponent + originalY * yAxisYComponent;
} 
```

Полное понимание доступных `RotateVector` метод требует знакомства с косинус и синус тригонометрические функции, а также некоторые линейной алгебры, который выходит за рамки этой статьи. Однако после реализации `RotateVector` метод может использоваться для любого объекта vector, включая вектора скорости поворота. Например, следующий код может возникнуть маркера в направление, заданное параметром `rotation` значение:


```csharp
// Create a Bullet instance
Bullet newBullet = new Bullet();

// Define the velocity of the bullet when 
// rotation is 0
CCVector2 velocity = new CCVector2 (0, 100);

// Modify the velocity according to rotation
RotateVector (ref velocity, rotation);

// Assign the newBullet's velocity using the
// rotated vector
newBullet.VelocityX = velocity.X;
newBullet.VelocityY = velocity.Y;

// Set the bullet's rotation so it faces
// the direction that it's flying
newBullet.Rotation = rotation; 
```

Этот код может привести к примерно следующим образом:

![](math-images/image9.png "Этот код может выдать примерно на этом снимке экрана")


## <a name="summary"></a>Сводка

В этом руководстве рассматриваются основные понятия математические 2D разработкой игр. Показано, как назначить и реализации и ускорение и описывается, как поворачивать объекты и векторы для перемещения в любом направлении.
