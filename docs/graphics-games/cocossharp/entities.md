---
title: Сущности в CocosSharp
description: Шаблон сущности является мощным средством для организации кода игры. Он повышает удобочитаемость, делает код проще было обслуживать и использует функции, встроенные родители потомки.
ms.topic: article
ms.prod: xamarin
ms.assetid: 1D3261CE-AC96-4296-8A53-A76A42B927A8
ms.technology: xamarin-cross-platform
author: charlespetzold
ms.author: chape
ms.date: 03/27/2017
ms.openlocfilehash: bb4af0f76f6b266cad4eb969d987a346b7396aa9
ms.sourcegitcommit: 4f1b508caa8e7b6ccf85d167ea700a5d28b0347e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/03/2018
---
# <a name="entities-in-cocossharp"></a>Сущности в CocosSharp

_Шаблон сущности является мощным средством для организации кода игры. Он повышает удобочитаемость, делает код проще было обслуживать и использует функции, встроенные родители потомки._

Шаблон сущности может повысить усилий разработчика с CocosSharp улучшенные код организации. В этом пошаговом руководстве будет практический пример, показывающий, как создать две сущности — отгрузки и сущностью маркера. Эти сущности будут автономными объектами, означающее, что после создания экземпляра они будут автоматически передаваться и выполняет перемещение логики в зависимости от их типа. 

В этом руководстве рассматриваются следующие темы:

 - Общие сведения о сущности игры
 - Общее сравнение типов конкретной сущности
 - Настройка проекта
 - Создание классов сущностей
 - Добавление экземпляров сущностей для `GameLayer`
 - Отклик на логику сущности в `GameLayer`

По завершении игры будет выглядеть следующим образом:

![](entities-images/image1.png "По завершении игры будет выглядеть следующим образом")


## <a name="introduction-to-game-entities"></a>Общие сведения о сущности игры

Игры сущности являются классы, которые определяют объекты, которым требуются логики отрисовки, конфликтов, физических или искусственного аналитики. К счастью присутствует в базе кода игры в сущности часто соответствуют концептуальные объекты в игру. Если это так, идентификации сущностей, необходимо выделить в игру можно проще сделать. 

Например, пробел теме [неисправностей 'em игры](http://en.wikipedia.org/wiki/Shoot_%27em_up) может включать следующие сущности:

 - `PlayerShip`
 - `EnemyShip`
 - `PlayerBullet`
 - `EnemyBullet`
 - `CollectableItem`
 - `HUD`
 - `Environment`

Эти объекты станут свои собственные классы в игре, и каждый экземпляр потребуют установки почти или совсем не после создания экземпляра.


## <a name="general-vs-specific-entity-types"></a>Общее сравнение типов конкретной сущности

Одним из первых вопросов сталкиваются игры разработчиков, использующих систему сущности является объем для подготовки к использованию соответствующие сущности. Конкретных реализаций определить классы для каждого типа сущности, даже если они отличаются по несколько характеристик. Более общие систем объединить в один класс группы сущностей и позволить экземпляры можно настроить.

Например мы представим, места игра, которую определяет следующие классы:

 - `PlayerDogfighter`
 - `PlayerBomber`
 - `EnemyMissileShip`
 - `EnemyLaserShip`

Подход с использованием более обобщенный можно создать один класс для проигрывателя поставляется и один класс для соперника поставляется, которые могут быть настроены для поддержки отгрузки различных типов. Настройки могут содержать изображение, загрузки, какой тип маркера сущностей, создаваемого при устранении неполадок, коэффициенты перемещения и логика AI enemy поставляется. В этом случае список сущностей может быть сокращено до.

 - `PlayerShip`
 - `EnemyShip`

Конечно эти типы сущностей можно обобщить дальнейшей, позволяя настройки каждого экземпляра для управления перемещения. Проигрыватель отгрузки экземпляров читает входных данных во время соперника отгрузки экземпляры могут реализовать логику AI. Это означает, что сущности может быть обобщена даже дальше в один класс:

 - `Ship`

Обобщение можно продолжить еще больше — игра может использовать один базовый класс для всех сущностей. Это один класс, который может быть вызван `GameEntity`, будет класс, используемый для каждого экземпляра сущности в игре целиком, включая сущностей, которые не являются поставляется как маркеры и собираемой элементы (питания ИБП).

Это общие большинство систем часто называют *компонента системы*. В такой системе игры сущности могут иметь отдельные компоненты, такие как физический, AI, или визуализации компонентов добавлен настраивать внешний вид и поведение. Чисто систем на основе компонентов включите Максимальная гибкость и избежать проблем, вызванных наследование, например цепочки наследования сложных. Как и в других обобщения систем действующие компонентов может быть сложно настроить и может уменьшить выразительности кода.

Уровень обобщение использовать, зависит от учесть множество факторов, в том числе:

 - Игры размер — меньше игры можете создавать особые классы, хотя большего игры может быть сложно управлять с большим количеством классов.
 - Разработка — на основе данных игры, которые зависят от данных (изображения, 3D-модели и файлов данных, таких как JSON или XML) может повыситься при обобщенные типы сущностей и настройке особенности на основе данных. Это особенно импорта для игр, которые предполагается добавить новое содержимое во время разработки или после выпуска игры.
 - Игры подсистемы шаблонов — некоторые игры обработчики настоятельно рекомендуем использования компонента системы, а другие разработчики могут решать, как организовать сущности. CocosSharp не требует использования компонента системы, поэтому разработчики могут реализовать любой тип сущности. 

Для простоты мы будем работать с определенной подход на основе класса с одной сущностью отгрузки и маркера для этого учебника.


## <a name="project-setup"></a>Настройка проекта

Перед началом реализации сущностями, нам нужно создать проект. Мы будем работать с использованием шаблонов проекта CocosSharp для упрощения создания проекта. [Проверьте запись](http://forums.xamarin.com/discussion/26822/cocossharp-project-templates-for-xamarin-studio) сведения о создании проекта CocosSharp из Visual Studio для Mac шаблонов. В оставшейся части этого руководства будет использовать имя проекта **EntityProject**.

После создания проекта мы настроим разрешение нашей игры на 480 x 320. Чтобы сделать это, вызовите `CCScene.SetDefaultDesignResolution` в `GameAppDelegate.ApplicationDidFinishLaunching` метод следующим образом:


```csharp
public override void ApplicationDidFinishLaunching (CCApplication application, CCWindow mainWindow)
{
    ...

    // New code for resolution setting:
    CCScene.SetDefaultDesignResolution(480, 320, CCSceneResolutionPolicy.ShowAll);
    
    CCScene scene = new CCScene (mainWindow);
    GameLayer gameLayer = new GameLayer ();

    scene.AddChild (gameLayer);
    mainWindow.RunWithScene (scene);
} 
```

Дополнительные сведения о работе с CocosSharp способы их устранения см. в разделе нашей [руководство по обработке ряд разрешений в CocosSharp](~/graphics-games/cocossharp/resolutions.md).


## <a name="adding-content-to-the-project"></a>Добавление содержимого в проект

После создания проекта мы будем добавлять файлы, содержащиеся в [содержимого в архиве](https://github.com/xamarin/mobile-samples/blob/master/BouncingGame/Resources/Entities.zip?raw=true). Чтобы сделать это, загрузите ZIP-файл и распакуйте его. Добавить оба **ship.png** и **bullet.png** для **содержимого** папки. **Содержимого** папке будут находиться внутри **активы** папку на Android будут в корневой папке проекта на iOS. После добавления, мы должны увидеть обоих файлов в **содержимого** папки:

![](entities-images/image2.png "После добавления в эту папку контента должно быть обоих файлов")


## <a name="creating-the-ship-entity"></a>Создание сущности отгрузки

`Ship` Класс будет первая сущность нашей игры. Чтобы добавить `Ship` класса, сначала создайте папку с именем **сущностей** на корневом уровне проекта. Добавьте новый класс в **сущностей** папку с именем `Ship`:

![](entities-images/image3.png "Добавьте новый класс в папке сущностей отгрузки")

Первое изменение, мы выполним с нашей `Ship` класс является автоматически наследуют от `CCNode` класса. `CCNode` как и служит в качестве базового класса для общих классов CocosSharp `CCSprite` и `CCLayer`и дает следующие возможности:

 - `Position` свойство для перемещения отгрузки по экрану.
 - `Children` свойство для добавления `CCSprite.`
 - `Parent` свойство, которое может использоваться для присоединения `Ship` экземпляров другой `CCNodes`. Мы не будет использовать эту функцию в этом учебнике; больше игр часто пользуются присоединение сущностей в другом `CCNodes`. 
 - `AddEventListener` метод для обработки входных данных для перемещения доставки.
 - `Schedule` метод Устранение маркеры.

Также мы добавим `CCSprite` , чтобы наши отгрузки можно просмотреть на экране:


```csharp
using System;
using CocosSharp;

namespace EntityProject
{
    public class Ship : CCNode
    {
        CCSprite sprite;

        public Ship () : base()
        {
            sprite = new CCSprite ("ship.png");
            // Center the Sprite in this entity to simplify
            // centering the Ship when it is instantiated
            sprite.AnchorPoint = CCPoint.AnchorMiddle;
            this.AddChild(sprite);
        }
    }
}
```

Далее мы добавим отгрузки для наших `GameLayer` он отображается в нашей игры:


```csharp
public class GameLayer : CCLayer
{
    Ship ship;

    public GameLayer ()
    {
        ship = new Ship ();
        ship.PositionX = 240;
        ship.PositionY = 50;
        this.AddChild (ship);
    } 
    ...
```

Если мы запустим нашей игры мы увидим нашей отгрузки сущности:

![](entities-images/image4.png "При запуске игры, будет отображаться сущность отгрузки")


### <a name="why-inherit-from-ccnode-instead-of-ccsprite"></a>Почему наследовать от CCNode вместо CCSprite?

На этом этапе нашей `Ship` класс является оболочкой для простой `CCSprite` экземпляра. Поскольку `CCSprite` наследует от `CCNode`, мы могли унаследованы непосредственно из `CCSprite`, которой будет снижена код в `Ship.cs`. Кроме того, наследующим непосредственно `CCSprite` уменьшает число объектов в памяти и может повысить производительность, уменьшая дерево зависимостей.

Несмотря на этих преимуществ мы наследуется от `CCNode` скрыть некоторые `CCSprite` свойств из каждого экземпляра. Например `Texture` не следует изменять свойство за пределами `Ship` класса и наследование от `CCNode` позволяет скрыть это свойство. Открытые члены сущностями становятся особенно важно при увеличении большего игры и дополнительных разработчики при добавлении команды.


## <a name="adding-input-to-the-ship"></a>Добавление входных данных для доставки

Теперь, когда наши отгрузки отображается на экране будут добавлены входные данные. Наш подход будет аналогичен подходов, использованных [руководство BouncingGame](~/graphics-games/cocossharp/bouncing-game.md), за исключением того, что мы поместив код для перемещения в `Ship` класса, а не в содержащем `CCLayer` или `CCScene`.

Добавьте код в `Ship` для поддержки перемещения всякий раз, когда пользователь касается экрана:


```csharp
public class Ship : CCNode
{
    CCSprite sprite;

    CCEventListenerTouchAllAtOnce touchListener;

    public Ship () : base()
    {
        sprite = new CCSprite ("ship.png");
        // Center the Sprite in this entity to simplify
        // centering the Ship on screen
        sprite.AnchorPoint = CCPoint.AnchorMiddle;
        this.AddChild(sprite);

        touchListener = new CCEventListenerTouchAllAtOnce();
        touchListener.OnTouchesMoved = HandleInput;
        AddEventListener(touchListener, this);

    }

    private void HandleInput(System.Collections.Generic.List<CCTouch> touches, CCEvent touchEvent)
    {
        if(touches.Count > 0)
        {
            CCTouch firstTouch = touches[0];

            this.PositionX = firstTouch.Location.X;
            this.PositionY = firstTouch.Location.Y;
        } 
    }
} 
```

Многие неисправностей 'em копирование реализуйте игры Максимальная скорость, с которой копирует перемещение традиционные на базе контроллера. С другой стороны, мы просто будет реализован немедленного перемещения наш код короче.


## <a name="creating-the-bullet-entity"></a>Создание сущности маркера

Две сущности в нашей простой игры — это сущность для отображения маркеров. Так же, как `Ship` сущности, `Bullet` сущность будет содержать `CCSprite` , чтобы на экране. Логику для перемещения отличается тем, что он не зависит от входных данных пользователя для перемещения; Вместо этого `Bullet` экземпляров будет переместить в виде прямой линии с помощью свойств скорости.

Сначала мы добавим новый файл класса для наших **сущностей** папки и назовите его **маркера**:

![](entities-images/image5.png "Добавьте новый файл класса в папку сущностей и вызовите его маркера")

После добавления мы изменим `Bullet.cs` кода следующим образом:


```csharp
using System;
using CocosSharp;

namespace EntityProject
{
    public class Bullet : CCNode
    {
        CCSprite sprite;

        public float VelocityX
        {
            get;
            set;
        }

        public float VelocityY
        {
            get;
            set;
        }

        public Bullet () : base()
        {
            sprite = new CCSprite ("bullet.png");
            // Making the Sprite be centered makes
            // positioning easier.
            sprite.AnchorPoint = CCPoint.AnchorMiddle;
            this.AddChild(sprite);

            this.Schedule (ApplyVelocity);
        }

        void ApplyVelocity(float time)
        {
            PositionX += VelocityX * time;
            PositionY += VelocityY * time;
        }
    }
} 
```

Помимо изменения файла, используемый для `CCSprite` для `bullet.png`, код в `ApplyVelocity` включает перемещения логику, основанную на двух коэффициенты: `VelocityX` и `VelocityY`.

`Schedule` Метод разрешает Добавление делегатов для вызова каждого кадра. В этом случае мы добавляем `ApplyVelocity` метод, чтобы наши маркер перемещается в соответствии с его значениями. `Schedule` Принимает `Action<float>`, где параметр типа float указывает количество времени (в секундах) с момента последнего кадра, который будет использован для реализации на основе времени перемещения. Со времени значение измеряется в секундах, то нашей значения скорости представляют перемещение в *пикселей в секунду*.


## <a name="adding-bullets-to-gamelayer"></a>Добавление маркеров для GameLayer

Прежде чем добавлять любые `Bullet` экземпляров нашей игру мы выполним контейнер, в частности `List<Bullet>`. Изменить `GameLayer` , включив в него список маркеров:


```csharp
    public class GameLayer : CCLayer
    {
        Ship ship;
        List<Bullet> bullets;

        public GameLayer ()
        {
            ship = new Ship ();
            ship.PositionX = 240;
            ship.PositionY = 50;
            this.AddChild (ship);

            bullets = new List<Bullet> ();
        }
        ... 
```

Далее нам нужно будет заполнить `Bullet` списка. Логику для условий создания `Bullet` должны содержаться в `Ship` сущности, но `GameLayer` отвечает за сохранение списка маркеров. Мы будем использовать шаблон фабрики, чтобы разрешить `Ship` сущности для создания `Bullet` экземпляров. Эта фабрика будет предоставляется доступ к событию, `GameLayer` может обрабатывать. 

Для этого сначала мы добавим папку к нашей проект с именем **фабрик**, а затем добавьте новый класс с именем `BulletFactory`:

![](entities-images/image6.png "Добавление папки в проект с именем фабрики, а затем добавьте новый класс с именем BulletFactory")

Далее мы реализовать `BulletFactory` singleton-класса:


```csharp
using System;

namespace EntityProject
{
    public class BulletFactory
    {
        static Lazy<BulletFactory> self = 
            new Lazy<BulletFactory>(()=>new BulletFactory());

        // simple singleton implementation
        public static BulletFactory Self
        {
            get
            {
                return self.Value;
            }
        }

        public event Action<Bullet> BulletCreated;

        private BulletFactory()
        {

        }

        public Bullet CreateNew()
        {
            Bullet newBullet = new Bullet ();

            if (BulletCreated != null)
            {
                BulletCreated (newBullet);
            }

            return newBullet;
        }
    }
} 
```

`Ship` Сущность будет обрабатывать создание `Bullet` экземпляров — в частности, будут обрабатываться как часто `Bullet` экземпляры должны создаваться (т. е. как часто запускается маркера), их положение и их скорости.

Изменить `Ship` конструктор сущности, чтобы добавить новый `Schedule` вызвать, а затем реализовать этот метод следующим образом:


```csharp
...
public Ship () : base()
{
    sprite = new CCSprite ("ship.png");
    // Center the Sprite in this entity to simplify
    // centering the Ship on screen
    sprite.AnchorPoint = CCPoint.AnchorMiddle;
    this.AddChild(sprite);

    touchListener = new CCEventListenerTouchAllAtOnce();
    touchListener.OnTouchesMoved = HandleInput;
    AddEventListener(touchListener, this);

    Schedule (FireBullet, interval: 0.5f);

}

void FireBullet(float unusedValue)
{
    Bullet newBullet = BulletFactory.Self.CreateNew ();
    newBullet.Position = this.Position;
    newBullet.VelocityY = 100;
} 
...
```

Последний шаг — для обработки создание новых `Bullet` экземпляров в `GameLayer` кода. Добавьте обработчик событий `BulletCreated` событие, которое добавляет только что созданный `Bullet` в соответствующие списки:


```csharp
...
public GameLayer ()
{
    ship = new Ship ();
    ship.PositionX = 240;
    ship.PositionY = 50;
    this.AddChild (ship);

    bullets = new List<Bullet> ();
    BulletFactory.Self.BulletCreated += HandleBulletCreated;
}

void HandleBulletCreated(Bullet newBullet)
{
    AddChild (newBullet);
    bullets.Add (newBullet);
}
... 
```

Теперь можно запустить игру и разделе `Ship` Устранение `Bullet` экземпляров:

![](entities-images/image1.png "Запустить игру и доставки будет Устранение экземпляров маркера")


## <a name="why-gamelayer-has-ship-and-bullets-members"></a>Почему GameLayer имеет отгрузки и маркеры элементов

Наш `GameLayer` класс определяет два поля для хранения ссылок на нашем экземпляров сущности (`ship` и `bullets`), но не выполняет никаких действий с ними. Кроме того объекты отвечают за свои собственные действия, например перемещения и устранении неполадок. Поэтому почему мы добавим `ship` и `bullets` поля `GameLayer`?

Мы добавили эти элементы, так как полные игры реализация потребует логику в `GameLayer` для взаимодействия между разными субъектами. Например эта игра может продолжена для включения враги, которые можно уничтожить проигрыватель. Эти враги будет содержаться в `List` в `GameLayer`и алгоритм для проверки ли `Bullet` экземпляров конфликтуют с враги будет выполнена в `GameLayer` также. Другими словами `GameLayer` является корнем *владельца* все сущности экземпляров, который отвечает за взаимодействия между экземплярами сущностей.


## <a name="bullet-destruction-considerations"></a>Вопросы удаления маркера

Наш игры в настоящее время отсутствует код для уничтожения `Bullet` экземпляров. Каждый `Bullet` экземпляр имеет логики для перемещения на экране, но мы еще не добавили написание кода для уничтожает за пределы экрана `Bullet` экземпляров.

Кроме того уничтожение `Bullet` экземпляры не могут входить в `GameLayer`. Например, вместо того чтобы уничтожении при вне экрана, `Bullet` сущность может иметь логику для уничтожения сам через заданный промежуток времени. В этом случае `Bullet` требуется способ взаимодействия, должен быть уничтожен для `GameLayer`, почти как `Ship` сущности взаимодействуют с `GameLayer` , новый `Bullet` был создан при помощи `BulletFactory`.

Самым простым решением является разверните ответственность за класс фабрики для поддержки уничтожения. Затем экземпляр сущности уничтожении, который может обрабатывать другие объекты, такие как можно получать уведомления о фабрике `GameLayer` удаление экземпляра сущности из его списков. 

## <a name="summary"></a>Сводка

В этом руководстве показано, как создать сущности CocosSharp путем наследования от `CCNode` класса. Эти сущности являются автономными объектами, создавать свои собственные визуальные элементы и пользовательской логики обработки. В этом руководстве обозначает код, который принадлежит внутри сущности (перемещение и создания других сущностей) из кода, который входит в корневом контейнере сущностей (конфликтов и логика взаимодействия другие сущности).

## <a name="related-links"></a>Связанные ссылки

- [Документация по CocosSharp API](https://developer.xamarin.com/api/namespace/CocosSharp/)
- [Содержимого zip](https://github.com/xamarin/mobile-samples/blob/master/BouncingGame/Resources/Entities.zip?raw=true)
