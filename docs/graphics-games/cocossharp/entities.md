---
title: Сущности в CocosSharp
description: Шаблон сущности — это эффективное средство для организации кода игры. Это улучшает читаемость, благодаря этому код проще обслуживать и использует функции, встроенные родители потомки.
ms.prod: xamarin
ms.assetid: 1D3261CE-AC96-4296-8A53-A76A42B927A8
author: conceptdev
ms.author: crdun
ms.date: 03/27/2017
ms.openlocfilehash: 42034261c374183346c8072eb42014f43a4fe22c
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61210407"
---
# <a name="entities-in-cocossharp"></a>Сущности в CocosSharp

_Шаблон сущности — это эффективное средство для организации кода игры. Это улучшает читаемость, благодаря этому код проще обслуживать и использует функции, встроенные родители потомки._

Шаблон сущности может улучшить усилия разработчиков с помощью CocosSharp улучшенный код организации. В этом пошаговом руководстве будет практический пример, показывающий, как создать две сущности — сущностями отгрузки и маркера. Эти сущности будут автономных объектов, которое означает, что после создания экземпляра они будут автоматически передаваться и выполнит логикой перемещения в зависимости от их типа. 

В этом руководстве рассматриваются следующие темы:

 - Общие сведения о сущностей game
 - Общие и типы определенной сущности
 - Настройка проекта
 - Создание классов сущностей
 - Добавление экземпляров сущностей `GameLayer`
 - Реагирование на логику сущности в `GameLayer`

По завершении игры будет выглядеть следующим образом:

![](entities-images/image1.png "По завершении игры выглядит примерно так")


## <a name="introduction-to-game-entities"></a>Общие сведения о сущностей game

Игры сущности являются классы, которые определяют объекты, которым требуются логики отрисовки, конфликтов, физики или искусственного интеллекта. К счастью сущностей, присутствующих в базе кода игры часто соответствуют концептуальные объекты в игре. Если это значение равно true, идентификацию сущностям, требуемым в игре можно легко выполнить. 

Например, пробел тематические [прокрутить ускорения работы игры](https://en.wikipedia.org/wiki/Shoot_%27em_up) может включать следующие сущности:

 - `PlayerShip`
 - `EnemyShip`
 - `PlayerBullet`
 - `EnemyBullet`
 - `CollectableItem`
 - `HUD`
 - `Environment`

Эти сущности бы свои собственные классы в игре, и каждый экземпляр потребует почти или совсем не настройки, кроме создания экземпляра.


## <a name="general-vs-specific-entity-types"></a>Общие и типы определенной сущности

Один из первых вопросов, которыми сталкиваются разработчики игр, с помощью системы сущность сколько для подготовки к использованию их сущности. Наиболее конкретными реализациями бы определить классы для каждого типа сущности, даже если они отличаются по несколько характеристик. Более общие системы будет объединять группы сущностей в один класс и позволить экземпляры для специальной настройки.

Для примера мы Представьте себе игру пространство, которая определяет следующие классы:

 - `PlayerDogfighter`
 - `PlayerBomber`
 - `EnemyMissileShip`
 - `EnemyLaserShip`

Это подход более специализированных будет создавать один класс для проигрывателя поставляется и один класс для выстрелов поставляется, которые могут быть настроены для поддержки различных ship типов. Настройки могут включать какой образ для загрузки, какой тип маркера сущностей, создаваемого при устранении неполадок, коэффициенты перемещения и поставляется логику работы с искусственным Интеллектом для злоумышленником. В этом случае список сущностей может быть сокращен до:

 - `PlayerShip`
 - `EnemyShip`

Само собой эти типы сущностей можно дополнительно обобщить, позволяя настройки каждого экземпляра, для контроля перемещения. Экземпляры ship проигрыватель будет прочесть входных данных, пока выстрелов ship экземпляры могут реализовать логику искусственного Интеллекта. Это означает, что сущности может подготовить к использованию еще дальше, в один класс:

 - `Ship`

Обобщение можно по-прежнему еще дальше — игра может использовать один базовый класс для всех сущностей. Это один класс, который может вызываться `GameEntity`, будет класс, используемый для каждого экземпляра сущности в игре целиком, включая сущности, которые не поставляется как маркеры и собираемой элементов (раздавайте бонусы).

Это общие большинство систем часто называется *компонент системы*. В подобной системе игр сущности могут иметь отдельные компоненты, такие как физики, искусственный Интеллект, или отрисовки компоненты добавить для настройки поведения и внешнего вида. Чистые систем на основе компонента включите обеспечения наибольшей эффективности и избежать проблем, вызванных наследование, таких как наследование, сложные цепочки. Как и в других обобщения систем действующие компонентов может быть сложно настроить и может снизить выразительности кода.

Степень обобщения используется зависит от учесть множество факторов, в том числе:

 - Размер игры — игры меньшего размера может позволить себе создавать особые классы, хотя большего размера игры может быть сложно управлять с большим числом классы.
 - Разработка — на основе данных игры, которые зависят от данных (изображения, трехмерные модели и файлов данных, например JSON или XML) могут получить преимущества от обобщенные типы сущностей и настройке особенности, на основе данных. Это особенно импорта для игр, которые хотят добавлять новое содержимое во время разработки или после выпуска игры.
 - Шаблоны игровое ядро — некоторые игровых движков настоятельно рекомендуем использование систем компонентов во время другие разработчики могут решить, как организовать сущности. CocosSharp не требует использования компонента системы, поэтому разработчики могут реализовать любой тип сущности. 

Для простоты мы будем использовать определенный подход на основе класса с одной сущностью, поставки и маркера в этом руководстве.


## <a name="project-setup"></a>Настройка проекта

Прежде чем начать внедрение сущностями, нам нужно создать проект. Мы будем использовать шаблоны проектов CocosSharp для упрощения создания проекта. [Проверьте блога](http://forums.xamarin.com/discussion/26822/cocossharp-project-templates-for-xamarin-studio) сведения о создании проекта CocosSharp из Visual Studio для Mac шаблонов. Далее в этом руководстве будет использоваться имя проекта **EntityProject**.

После создания проекта мы настроим разрешение нашей игре в 480 x 320 пикселов. Чтобы сделать это, вызовите `CCScene.SetDefaultDesignResolution` в `GameAppDelegate.ApplicationDidFinishLaunching` метод следующим образом:


```csharp
public override void ApplicationDidFinishLaunching (CCApplication application, CCWindow mainWindow)
{
    ...

    // New code for resolution setting:
    CCScene.SetDefaultDesignResolution(480, 320, CCSceneResolutionPolicy.ShowAll);
    
    CCScene scene = new CCScene (mainWindow);
    GameLayer gameLayer = new GameLayer ();

    scene.AddChild (gameLayer);
    mainWindow.RunWithScene (scene);
} 
```

Дополнительные сведения о работе с CocosSharp способы их устранения см. наш [руководство по обработке нескольких разрешений в CocosSharp](~/graphics-games/cocossharp/resolutions.md).


## <a name="adding-content-to-the-project"></a>Добавление содержимого в проект

После создания проекта, мы добавим файлам, содержащимся в [содержимого ZIP-файл](https://github.com/xamarin/mobile-samples/blob/master/BouncingGame/Resources/Entities.zip?raw=true). Чтобы сделать это, скачайте ZIP-файл и распакуйте его. Добавить оба **ship.png** и **bullet.png** для **содержимого** папки. **Содержимого** папке будут находиться внутри **активы** папки на устройстве Android и в корне проекта на iOS. После добавления, мы должны увидеть обоих файлов в **содержимого** папки:

![](entities-images/image2.png "После добавления обоих файлы должны находиться в папке Content")


## <a name="creating-the-ship-entity"></a>Создание сущности отгрузки

`Ship` Класс будет первая сущность нашей игре. Чтобы добавить `Ship` класса, сначала создайте папку с именем **сущностей** на корневом уровне проекта. Добавьте новый класс в **сущностей** папку с именем `Ship`:

![](entities-images/image3.png "Добавьте новый класс в папку сущностей с именем отгрузки")

Первое изменение, мы выполним наших `Ship` класс — это передать ее от `CCNode` класса. `CCNode` служит в качестве базового класса для общих классов CocosSharp, такие как `CCSprite` и `CCLayer`и дает нам следующие функциональные возможности:

 - `Position` свойство для перемещения корабля по экрану.
 - `Children` свойство для добавления `CCSprite.`
 - `Parent` свойство, которое может использоваться для присоединения `Ship` экземпляров другу `CCNodes`. Мы не будем использовать эту функцию в этом руководстве; больше игры часто пользуются присоединение сущностей другу `CCNodes`. 
 - `AddEventListener` метод для обработки входных данных для перемещения корабля.
 - `Schedule` метод для выполнения маркеры.

Также мы добавим `CCSprite` экземпляра, чтобы наши ship можно увидеть на экране:


```csharp
using System;
using CocosSharp;

namespace EntityProject
{
    public class Ship : CCNode
    {
        CCSprite sprite;

        public Ship () : base()
        {
            sprite = new CCSprite ("ship.png");
            // Center the Sprite in this entity to simplify
            // centering the Ship when it is instantiated
            sprite.AnchorPoint = CCPoint.AnchorMiddle;
            this.AddChild(sprite);
        }
    }
}
```

Далее мы добавим корабль для наших `GameLayer` для отобразится в нашей игре:


```csharp
public class GameLayer : CCLayer
{
    Ship ship;

    public GameLayer ()
    {
        ship = new Ship ();
        ship.PositionX = 240;
        ship.PositionY = 50;
        this.AddChild (ship);
    } 
    ...
```

Если мы выполним нашей игре мы увидим наш Ship сущности:

![](entities-images/image4.png "При запуске игры, будет отображаться сущность отгрузки")


### <a name="why-inherit-from-ccnode-instead-of-ccsprite"></a>Почему наследовать от CCNode вместо CCSprite?

На этом этапе наши `Ship` класс — это простая оболочка для `CCSprite` экземпляра. Так как `CCSprite` также наследует от `CCNode`, мы может унаследовано непосредственно из `CCSprite`, который бы позволило сократить код в `Ship.cs`. Кроме того, наследование непосредственно `CCSprite` уменьшает число объектов в памяти и может повысить производительность, уменьшая дерева зависимостей.

Несмотря на эти преимущества, мы наследуется от `CCNode` для скрытия части `CCSprite` свойств из каждого экземпляра. Например `Texture` не следует изменять свойство за пределами `Ship` класса и наследование от `CCNode` позволяет скрыть это свойство. Открытые члены сущностями становятся особенно важно, как игра становится больше и дополнительных разработчиков при добавлении команды.


## <a name="adding-input-to-the-ship"></a>Добавление входных данных для доставки

Теперь, когда наши ship отображается на экране мы добавим входные данные. Наш подход будет выглядеть как подход для использования [руководство по игре BouncingGame](~/graphics-games/cocossharp/bouncing-game.md), за исключением того, что мы будет поместив данный код для перемещения в `Ship` класса, а не в содержащем `CCLayer` или `CCScene`.

Добавьте код, чтобы `Ship` для поддержки перемещения везде, где пользователь касается экрана:


```csharp
public class Ship : CCNode
{
    CCSprite sprite;

    CCEventListenerTouchAllAtOnce touchListener;

    public Ship () : base()
    {
        sprite = new CCSprite ("ship.png");
        // Center the Sprite in this entity to simplify
        // centering the Ship on screen
        sprite.AnchorPoint = CCPoint.AnchorMiddle;
        this.AddChild(sprite);

        touchListener = new CCEventListenerTouchAllAtOnce();
        touchListener.OnTouchesMoved = HandleInput;
        AddEventListener(touchListener, this);

    }

    private void HandleInput(System.Collections.Generic.List<CCTouch> touches, CCEvent touchEvent)
    {
        if(touches.Count > 0)
        {
            CCTouch firstTouch = touches[0];

            this.PositionX = firstTouch.Location.X;
            this.PositionY = firstTouch.Location.Y;
        } 
    }
} 
```

Многие прокрутить ускорения работы до реализации игры Максимальная скорость, копируя традиционных перемещения на основе контроллера. С другой стороны, просто реализуется немедленно перемещения наш код короче.


## <a name="creating-the-bullet-entity"></a>Создание сущности маркера

Второй сущности в наш простой игре — это сущность, для отображения маркеров. Так же, как `Ship` сущности, `Bullet` сущность будет содержать `CCSprite` , чтобы он отображался на экране. Логика перемещения отличается тем, что он не зависит от входных данных пользователя для перемещения; Вместо этого `Bullet` по прямой линии с помощью свойства velocity будет перенос экземпляров.

Сначала мы добавим новый файл класса для наших **сущностей** папки и назовите его **маркера**:

![](entities-images/image5.png "Добавьте новый файл класса в папку сущностей и назовите его маркера")

После добавления, мы изменим `Bullet.cs` кода следующим образом:


```csharp
using System;
using CocosSharp;

namespace EntityProject
{
    public class Bullet : CCNode
    {
        CCSprite sprite;

        public float VelocityX
        {
            get;
            set;
        }

        public float VelocityY
        {
            get;
            set;
        }

        public Bullet () : base()
        {
            sprite = new CCSprite ("bullet.png");
            // Making the Sprite be centered makes
            // positioning easier.
            sprite.AnchorPoint = CCPoint.AnchorMiddle;
            this.AddChild(sprite);

            this.Schedule (ApplyVelocity);
        }

        void ApplyVelocity(float time)
        {
            PositionX += VelocityX * time;
            PositionY += VelocityY * time;
        }
    }
} 
```

Помимо изменения файла, используемый для `CCSprite` для `bullet.png`, код в `ApplyVelocity` включает логику перемещения, основанное на двух коэффициенты: `VelocityX` и `VelocityY`.

`Schedule` Метод позволяет добавлять делегаты для вызова каждого кадра. В этом случае мы добавляем `ApplyVelocity` метод таким образом, чтобы наш маркер перемещается в соответствии с его значения скорости. `Schedule` Альбома `Action<float>`, где параметр float указывает количество времени (в секундах) с момента последнего кадра, который мы используем для реализации перемещения на основе времени. С момента отправки значение измеряется в секундах, а затем наших значения скорости представляют перемещения в *пикселей в секунду*.


## <a name="adding-bullets-to-gamelayer"></a>Добавлять маркеры GameLayer

Прежде чем добавлять любой `Bullet` экземпляров для нашей игре мы сделаем контейнер, в частности `List<Bullet>`. Изменить `GameLayer` включив в него список маркеров:


```csharp
    public class GameLayer : CCLayer
    {
        Ship ship;
        List<Bullet> bullets;

        public GameLayer ()
        {
            ship = new Ship ();
            ship.PositionX = 240;
            ship.PositionY = 50;
            this.AddChild (ship);

            bullets = new List<Bullet> ();
        }
        ... 
```

Далее нам нужно будет заполнить `Bullet` списка. Логику для создания `Bullet` должны содержаться в `Ship` сущности, но `GameLayer` хранит список маркеров. Мы будем использовать шаблон фабрики, чтобы разрешить `Ship` сущности для создания `Bullet` экземпляров. Эта фабрика будет предоставляется доступ к событию, `GameLayer` может обрабатывать. 

Для этого во-первых, мы добавим папку наш проект с именем **фабрик**, а затем добавьте новый класс с именем `BulletFactory`:

![](entities-images/image6.png "Добавление папки в проект с именем фабрики, а затем добавьте новый класс с именем BulletFactory")

Затем мы реализуем `BulletFactory` singleton-класса:


```csharp
using System;

namespace EntityProject
{
    public class BulletFactory
    {
        static Lazy<BulletFactory> self = 
            new Lazy<BulletFactory>(()=>new BulletFactory());

        // simple singleton implementation
        public static BulletFactory Self
        {
            get
            {
                return self.Value;
            }
        }

        public event Action<Bullet> BulletCreated;

        private BulletFactory()
        {

        }

        public Bullet CreateNew()
        {
            Bullet newBullet = new Bullet ();

            if (BulletCreated != null)
            {
                BulletCreated (newBullet);
            }

            return newBullet;
        }
    }
} 
```

`Ship` Сущностей, обрабатывающий создание `Bullet` экземпляров — в частности, он будет обрабатывать как часто `Bullet` экземпляры должны создаваться (т. е. как часто запускается маркера), их положение, а также их скорости.

Изменить `Ship` конструкторе сущности, чтобы добавить новую `Schedule` вызова, а затем Реализуйте этот метод следующим образом:


```csharp
...
public Ship () : base()
{
    sprite = new CCSprite ("ship.png");
    // Center the Sprite in this entity to simplify
    // centering the Ship on screen
    sprite.AnchorPoint = CCPoint.AnchorMiddle;
    this.AddChild(sprite);

    touchListener = new CCEventListenerTouchAllAtOnce();
    touchListener.OnTouchesMoved = HandleInput;
    AddEventListener(touchListener, this);

    Schedule (FireBullet, interval: 0.5f);

}

void FireBullet(float unusedValue)
{
    Bullet newBullet = BulletFactory.Self.CreateNew ();
    newBullet.Position = this.Position;
    newBullet.VelocityY = 100;
} 
...
```

Последний шаг — для обработки создание новых `Bullet` экземпляров в `GameLayer` кода. Добавьте обработчик событий для `BulletCreated` событие, которое добавляет только что созданный `Bullet` в соответствующие списки:


```csharp
...
public GameLayer ()
{
    ship = new Ship ();
    ship.PositionX = 240;
    ship.PositionY = 50;
    this.AddChild (ship);

    bullets = new List<Bullet> ();
    BulletFactory.Self.BulletCreated += HandleBulletCreated;
}

void HandleBulletCreated(Bullet newBullet)
{
    AddChild (newBullet);
    bullets.Add (newBullet);
}
... 
```

Теперь можно запустить игру и см. в разделе `Ship` неполадок `Bullet` экземпляров:

![](entities-images/image1.png "Запустить игру и корабль будет неполадок экземпляров маркера")


## <a name="why-gamelayer-has-ship-and-bullets-members"></a>Почему GameLayer имеет отгрузки и маркированных списков членов

Наши `GameLayer` класс определяет два поля для хранения ссылок на наши экземпляры сущности (`ship` и `bullets`), но не выполняет никаких действий с ними. Кроме того сущности несут ответственность за свои собственные поведения, такие как перемещение и устранении неполадок. Так почему мы добавили `ship` и `bullets` поля `GameLayer`?

Мы добавили этих членов, так как полное игр реализация потребует логику в `GameLayer` для взаимодействия между разными сущностями. Например эта игра может быть дальнейшей разработано для включения врагов, которые могут быть уничтожены проигрывателем. Эти противников будут содержаться в `List` в `GameLayer`и логику для проверки ли `Bullet` экземпляров конфликтуют с враги должно выполняться в `GameLayer` также. Другими словами `GameLayer` является корнем *владельца* все сущности экземпляров и он отвечает за взаимодействие между экземплярами сущностей.


## <a name="bullet-destruction-considerations"></a>Рекомендации по уничтожения маркера

Нашей игре на данный момент отсутствует код для уничтожения `Bullet` экземпляров. Каждый `Bullet` экземпляр имеет логики для перемещения на экране, но мы еще не добавили код для уничтожает вне экрана `Bullet` экземпляров.

Кроме того уничтожение `Bullet` экземпляры не могут принадлежать в `GameLayer`. Например, вместо того чтобы уничтожения при вне экрана, `Bullet` сущность может иметь логику для уничтожения сам через некоторое время. В этом случае `Bullet` необходим способ, позволяющий взаимодействовать, что его следует удалить для `GameLayer`, почти как `Ship` передаваемые сущности `GameLayer` , новый `Bullet` была создана с помощью `BulletFactory`.

Простым решением является разверните ответственность за класс фабрики для поддержки уничтожения. Затем фабрика может получать уведомления о экземпляр сущности уничтожения, которой могут быть обработаны другие объекты, такие как `GameLayer` удаление экземпляра сущности из его списков. 

## <a name="summary"></a>Сводка

В этом руководстве показано, как создать сущности CocosSharp путем наследования от `CCNode` класса. Эти сущности являются автономными объектами, создавать собственные визуальные элементы и пользовательскую логику обработки. В этом руководстве обозначает код, который принадлежит внутри сущности (перемещения и создавать другие сущности) из кода, который принадлежит в корневом контейнере сущностей (конфликтов и логика взаимодействия другие сущности).

## <a name="related-links"></a>Связанные ссылки

- [Документация по API CocosSharp](https://developer.xamarin.com/api/namespace/CocosSharp/)
- [Содержимым zip](https://github.com/xamarin/mobile-samples/blob/master/BouncingGame/Resources/Entities.zip?raw=true)
