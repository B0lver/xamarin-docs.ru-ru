---
title: Кэширование текстуры с помощью CCTextureCache
description: В CocosSharp CCTextureCache класс предоставляет стандартный способ упорядочить, кэш и выгрузки содержимого. Это особенно полезно для больших игр, которые может не поместиться полностью в ОЗУ, упрощая процесс группирования и уничтожения текстур.
ms.prod: xamarin
ms.assetid: 1B5F3F85-9E68-42A7-B516-E90E54BA7102
author: conceptdev
ms.author: crdun
ms.date: 03/28/2017
ms.openlocfilehash: 232363d6ce1cb93499716b2c1247c48403cf6cea
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50117386"
---
# <a name="texture-caching-using-cctexturecache"></a>Кэширование текстуры с помощью CCTextureCache

_В CocosSharp CCTextureCache класс предоставляет стандартный способ упорядочить, кэш и выгрузки содержимого. Это особенно полезно для больших игр, которые может не поместиться полностью в ОЗУ, упрощая процесс группирования и уничтожения текстур._

`CCTextureCache` Класс является важной частью процесса разработки игр CocosSharp. Большинство CocosSharp играми воспользуйтесь `CCTextureCache` объекта, даже если явно не столько методы CocosSharp используется внутренне *общего* текстуры кэша.

В этом руководстве описывается `CCTextureCache` и почему это важно для разработки игр. В частности здесь рассматривается:

 - Почему текстуры кэширования: вопросы и ответы
 - Время существования текстуры
 - С помощью SharedTextureCache
 - Отложенная загрузка и предварительную загрузку с AddImage
 - Удаление текстуры


## <a name="why-texture-caching-matters"></a>Почему текстуры кэширования: вопросы и ответы

Кэширование текстуры — это важно учитывать при разработке игр, как загрузка текстуры является длительной операции и текстуры требуется значительный объем оперативной памяти во время выполнения.

Как и в случае с любой операции файл загрузки текстур с диска может быть дорогостоящей операцией. Загрузка текстуры может занять дополнительное время, если загружаемый файл требует обработки, например распаковать (как в случае для изображений png и jpg). Кэширование текстуры можно уменьшить количество раз, что приложение должно загрузить файлы с диска.

Как упоминалось выше, также текстурами большой объем памяти для среды выполнения. Например фонового изображения, подобранные по разрешение iPhone 6 (1344 x 750) должны занимать 4 мегабайт в оперативной памяти, даже если PNG-файл имеет размер только несколько килобайт. Кэширование текстуры предоставляет способ совместного использования текстуры ссылки внутри приложения, а также легко выгрузить все содержимое во время перехода между различными состояниями игр.


## <a name="texture-lifespan"></a>Время существования текстуры

Текстуры CocosSharp может храниться в памяти для всей продолжительности выполнения приложения, или они могут быть ограниченный срок действия. Чтобы свести к минимуму памяти использования приложения следует освободить текстуры, ставшие ненужными. Само собой это означает, что текстуры может быть удален и повторно загружено на более позднее время, которое может увеличить время загрузки или вызвать снижение производительности во время загрузки. 

Текстуры загрузки часто требуется компромисс между временем использования и нагрузки памяти / производительность во время выполнения. Игры, которые используют небольшой объем памяти текстуры можно хранить все текстуры в памяти, чем требуется, но игры большего размера может потребоваться выгрузить текстуры, чтобы освободить место.

В примере ниже показан простой игры, который загружает текстуры, при необходимости и сохраняет их в памяти для всей продолжительности выполнения:

![](texture-cache-images/image1.png "Эта диаграмма показывает простую игру, которая загружает текстуры, при необходимости и сохраняет их в памяти для всей продолжительности выполнения")

Первые две полосы представляют текстур, которые нужны немедленно после выполнения игры. Следующие три полосы представляют текстуры для каждого уровня, загрузится в требуемом объеме.

Если игра велико достаточно его со временем загружает достаточно текстуры, чтобы заполнить весь объем ОЗУ, предоставляемых устройства и операционной системы. Чтобы решить эту проблему, игры может выгрузить данные текстуры, когда оно больше не нужно. Например в примере ниже показан игры, который выгружает Level1Texture, когда он больше не используется, а затем загружает Level2Texture для следующего уровня. Конечным результатом является то, что только три текстуры, хранятся в памяти в любой момент времени: 

![](texture-cache-images/image2.png "Конечным результатом является то, что только три текстуры, хранятся в памяти в любой момент времени")


Приведенной выше схеме указывает, что использование памяти текстуры можно уменьшить путем выгрузки, а для этого может потребоваться время дополнительной загрузки, если игрок решает воспроизведения уровнем. Также стоит отметить, что текстуры UITexture и MainCharacter загружаются и никогда не выгружается. Это означает, что эти текстуры требуются на всех уровнях, поэтому всегда хранятся в памяти. 


## <a name="using-sharedtexturecache"></a>С помощью SharedTextureCache

CocosSharp автоматически кэширует текстуры, при загрузке их с помощью `CCSprite` конструктор. Например следующий код создает только один экземпляр текстуры:


```csharp
for (int i = 0; i < 100; i++)
{
    CCSprite starSprite = new CCSprite ("star.png");
    starSprite.PositionX = i * 32;
    this.AddChild (starSprite);
} 
```

Автоматически кэширует CocosSharp `star.png` текстуры, чтобы избежать ресурсоемких вместо создания многочисленных идентичные `CCTexture2D` экземпляров. Это достигается путем `AddImage` вызываемой в общем `CCTextureCache` экземпляра, в частности `CCTextureCache.SharedTextureCache.Shared`. Чтобы понять, каким образом `SharedTextureCache` используется взглянуть на следующий код, который функционально идентичен вызову `CCSprite` конструктор с параметром строки:


```

CCSprite starSprite = new CCSprite ();
 starSprite.Texture = CCTextureCache.SharedTextureCache.AddImage ("star.png");
```

`AddImage` проверяет, если аргумент файла (в данном случае `star.png`) уже загружен. Если Да, то возвращается кэшированный экземпляр. Если затем не загружен из файловой системы, а также ссылку на текстура хранится внутренним образом для последующих `AddImage` вызовов. Другими словами `star.png` образ загружается только один раз, а последующие вызовы требуют нет доступа к дополнительный диск или память дополнительных текстур.


## <a name="lazy-loading-vs-pre-loading-with-addimage"></a>Отложенная загрузка и предварительную загрузку с AddImage

`AddImage` позволяет коду для записи же запрошенную текстуру уже загружена ли или нет. Это означает, что это содержимое не будет загружен, если она нужна; Тем не менее могут возникать проблемы с производительностью во время выполнения из-за непредсказуемым содержимое загрузки.

Например, рассмотрим игру, где можно обновить оружия игрока. При обновлении оружия и снаряды визуально изменится, приводит к новой текстуры используется. Если содержимое является отложенной загрузке затем текстуры, связанный с обновленной оружие не будет загружен изначально, а лишь через некоторое время, когда игрок получает обновления. 

Эта загрузка середины игровой процесс может привести к игру, чтобы *pop*, который является коротким, но заметно запрет на выполнение. Чтобы избежать этого, код может предсказать, какие текстуры будет требоваться заранее и предварительно загрузить их. Например ниже может использоваться для предварительной загрузки текстуры:


```csharp
void PreLoadImages()
{
    var cache = CCTextureCache.SharedTextureCache;

    cache.AddImage ("powerup1.png");
    cache.AddImage ("powerup2.png");
    cache.AddImage ("powerup3.png");

    cache.AddImage ("enemy1.png");
    cache.AddImage ("enemy2.png");
    cache.AddImage ("enemy3.png");

    // pre-load any additional content here to 
    // prevent pops at runtime
} 
```

Эта предварительная загрузка может привести к потере памяти и может увеличить время запуска. Например, проигрыватель может получить фактически никогда не питания представленный `powerup3.png` текстуры, поэтому он будет загружаться без необходимости. Само собой, это может быть затраты для оплаты во избежание потенциальных pop в игровой процесс, поэтому, как правило, лучше предварительной загрузки содержимого он помещается в оперативной памяти.


## <a name="disposing-textures"></a>Удаление текстуры

Если игры не требует больше памяти текстуры, чем доступно на устройстве минимальное спецификаций текстуры не обязательно должны быть удален. С другой стороны игры большего размера может потребоваться освободить память текстур, чтобы освободить место для нового содержимого. Например, игра может использовать большой объем памяти, хранения текстур для среды. Среды используется только в определенном уровне затем оно должно ли быть выгружено при завершении уровень.


### <a name="disposing-a-single-texture"></a>Удаление одной текстуры

Удалить одну текстуру, сначала необходимо вызова `Dispose` метод, а затем вручную удалить из `CCTextureCache`.

Ниже показано, как полностью удалить спрайт вместе с его текстуры фона:


```csharp
void DisposeBackground()
{
    // Assuming this is called from a CCLayer:
    this.RemoveChild (backgroundSprite);

    CCTextureCache.SharedTextureCache.RemoveTexture (backgroundsprite.Texture);

    backgroundSprite.Texture.Dispose ();
} 
```

Непосредственно disposing текстуры может быть эффективным, при работе с небольшим числом текстур, но это может стать ошибкам при работе с большими наборами текстуры.

Текстуры могут быть сгруппированы в настраиваемый (без общего доступа) `CCTextureCache` экземпляров для упрощения очистки текстуры.

Например, рассмотрим пример там, где содержимое предварительно загружается с помощью определенного уровня `CCTextureCache` экземпляра. `CCTextureCache` Экземпляр может быть определено в класс, определяющий уровень (который может быть `CCLayer` или `CCScene`):


```csharp
CCTextureCache levelTextures; 
```

`levelTextures` Экземпляр затем может использоваться для предварительной загрузки текстуры соответствующие уровню: 


```

void PreloadLevelTextures(CCApplication application)
{
    levelTextures = new CCTextureCache (application);

    levelTextures.AddImage ("Background.png");
    levelTextures.AddImage ("Foreground.png");
    levelTextures.AddImage ("Enemy1.png");
    levelTextures.AddImage ("Enemy2.png");
    levelTextures.AddImage ("Enemy3.png");

    levelTextures.AddImage ("Powerups.png");
    levelTextures.AddImage ("Particles.png");
} 
```

Наконец по окончании уровень текстуры может быть все удален за один раз через `CCTextureCache`:


```csharp
void EndLevel()
{
    levelTextures.Dispose ();
    // Perform any other end-level cleanup
} 
```

Метод Dispose будет dispose всех внутренних текстур, очищая память, занятая эти текстуры. Объединение `CCTextureCache.Shared` с уровня или игровой режим определенного `CCTextureCache` экземпляра приводит некоторые текстуры, сохранение через весь игры, а также некоторые выгружается, как завершить уровни, аналогичную схему, представленного в начале этого руководства: 

![](texture-cache-images/image2.png "Объединение CCTextureCache.Shared игр или уровня относящиеся к режиму CCTextureCache экземпляра приводит к получению некоторых текстуры, сохранение через весь игры, а также некоторые выгружается, как завершить уровни, аналогичную схему, представленного в начале этого руководства")




## <a name="summary"></a>Сводка

В этом руководстве показано, как использовать `CCTextureCache` класс баланс производительности памяти использования и среды выполнения. `CCTexturCache.SharedTextureCache` можно явно или неявно используется для загрузки и кэширования текстуры в течение жизненного цикла приложения, а `CCTextureCache` экземпляры можно использовать для выгрузки текстуры, чтобы сократить объем памяти.

## <a name="related-links"></a>Связанные ссылки

- [https://github.com/mono/CocosSharp](https://github.com/mono/CocosSharp)
- [/api/type/CocosSharp.CCTextureCache/](https://developer.xamarin.com/api/type/CocosSharp.CCTextureCache/)
