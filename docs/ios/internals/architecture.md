---
title: Архитектура приложения iOS
description: В этом документе описывается низкий уровень Xamarin. iOS, обсуждаются взаимодействие машинного и управляемого кода, компиляция AOT, селекторы, регистраторы, запуск приложения и генератор.
ms.prod: xamarin
ms.assetid: F40F2275-17DA-4B4D-9678-618FF25C6803
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/21/2017
ms.openlocfilehash: 2bb682dcd2218291c8a6332cf0c1ad548c0aa3e2
ms.sourcegitcommit: c9651cad80c2865bc628349d30e82721c01ddb4a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/03/2019
ms.locfileid: "70225981"
---
# <a name="ios-app-architecture"></a>Архитектура приложения iOS

Приложения Xamarin. iOS выполняются в среде выполнения Mono и используют компиляцию с полным временем (AOT) для компиляции C# кода на языке ассемблера ARM. Это выполняется параллельно с исполняющей средой [цели-C](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/). Обе среды выполнения работают поверх ядра, похожего на UNIX, в частности [ксну](https://en.wikipedia.org/wiki/XNU), и предоставляют доступ к различным интерфейсам API для пользовательского кода, что позволяет разработчикам обращаться к базовой машинной или управляемой системе.

На схеме ниже показан базовый обзор этой архитектуры.

[![](architecture-images/ios-arch-small.png "На этой схеме показан базовый обзор архитектуры компиляции перед временем (AOT)")](architecture-images/ios-arch.png#lightbox)

## <a name="native-and-managed-code-an-explanation"></a>Машинный и управляемый код: Объяснение

При разработке для Xamarin термины *машинный и управляемый* код часто используются. [Управляемый код](https://blogs.msdn.microsoft.com/brada/2004/01/09/what-is-managed-code/) — это код, выполнение которого осуществляется с помощью [.NET Framework среды CLR](https://msdn.microsoft.com/library/8bs2ecf4(v=vs.110).aspx)или в случае Xamarin: среда выполнения Mono. Именно так мы вызываем промежуточный язык.

Машинный код — это код, который будет выполняться в собственном коде на конкретной платформе (например, в коде цели-C или даже скомпилированного кода AOT в микросхеме ARM). В этом руководство рассказывается о том, как AOT компилирует управляемый код в машинный код и объясняет, как работает приложение Xamarin. iOS, что обеспечивает полное использование интерфейсов API iOS Apple с помощью привязок, а также доступа к. BCL и сложный язык, например C#.

## <a name="aot"></a>AOT

При компиляции любого приложения платформы Xamarin (или) выполняется C# компилятор Mono F#(или), который компилирует код C# и F# в промежуточный язык Майкрософт (MSIL). Если вы используете Xamarin. Android, приложение Xamarin. Mac или даже приложение Xamarin. iOS в симуляторе, [Среда CLR .NET](https://msdn.microsoft.com/library/8bs2ecf4(v=vs.110).aspx) компилирует код MSIL, используя JIT-компилятор. Во время выполнения эта компиляция компилируется в машинный код, который может работать в правильной архитектуре приложения.

Однако в iOS имеется ограничение безопасности, заданное Apple, которое запрещает выполнение динамически созданного кода на устройстве.
Чтобы обеспечить соблюдение этих протоколов безопасности, Xamarin. iOS вместо этого использует компилятор предварительного времени (AOT) для компиляции управляемого кода. При этом создается собственный двоичный файл iOS, который можно оптимизировать с помощью LLVM для устройств, который может быть развернут на процессоре Apple ARM. Ниже показана грубая схема совместного использования.

[![](architecture-images/aot.png "Грубая схема совместного использования")](architecture-images/aot-large.png#lightbox)

Использование AOT имеет ряд ограничений, которые подробно описаны в разделе " [ограничения](~/ios/internals/limitations.md) ". Он также предоставляет ряд усовершенствований по сравнению с JIT за счет сокращения времени запуска и различных способов оптимизации производительности.

Теперь, когда мы проучили, как код компилируется из исходного кода в машинный код, давайте посмотрим, как Xamarin. iOS позволяет писать полностью собственные приложения iOS.

## <a name="selectors"></a>Селекторы

С помощью Xamarin у нас есть две отдельные экосистемы — .NET и Apple, которые нам нужно объединить, чтобы обеспечить плавность работы пользователей. Мы видели в разделе выше, как взаимодействуют две среды выполнения, и вы можете очень хорошо слышать термин "привязки", который позволяет использовать собственные API iOS в Xamarin. Привязки описаны подробно в нашей документации по привязке " [Цель-C](~/cross-platform/macios/binding/overview.md) ". Теперь давайте посмотрим, как работает iOS.

Во-первых, должен существовать способ предоставления цели-C в C#, что делается с помощью селекторов. Селектор — это сообщение, которое отправляется объекту или классу. С помощью цели-C это осуществляется с помощью функций [objc_msgSend](~/cross-platform/macios/binding/overview.md) .
Дополнительные сведения об использовании селекторов см. в руководстве по [селекторам цели-C](~/ios/internals/objective-c-selectors.md) . Также должен быть способ предоставления управляемому коду цели-C, что усложняется из-за того, что цель-C не знает ничего о управляемом коде. Чтобы обойти это, мы будемиспользовать регистраторы. Эти сведения более подробно описаны в следующем разделе.

## <a name="registrars"></a>Регистраторов

Как упоминалось выше, регистратор — это код, который предоставляет управляемому коду цель-C. Для этого создается список всех управляемых классов, производных от Нсобжект:

- Для всех классов, которые не упаковывают существующий класс цели-c, он создает новый класс цели-c с элементами цели-c, которые отражают все управляемые члены, имеющие атрибут [`Export`].

- В реализациях для каждого члена цели – C код добавляется автоматически для вызова зеркального управляемого члена.

В псевдокоде ниже приведен пример того, как это делается.

**C#(Управляемый код)**

```csharp
 class MyViewController : UIViewController{
     [Export ("myFunc")]
     public void MyFunc ()
     {
     }
 }
```

**Цель-C:**

```objectivec
@interface MyViewController : UIViewController { }

    -(void)myFunc;
@end

@implementation MyViewController {}

    -(void) myFunc
    {
        /* code to call the managed MyViewController.MyFunc method */
    }
@end

```

Управляемый код может содержать атрибуты `[Register]` и `[Export]`, которые регистратор использует для того, чтобы убедиться, что объект должен быть предоставлен для цели-C.
`[Register]` Атрибут используется для указания имени созданного класса цели-C в случае, если созданное по умолчанию имя не подходит. Все классы, производные от Нсобжект, автоматически регистрируются с помощью цели-C.
Обязательный `[Export]` атрибут содержит строку, которая является селектором, используемым в созданном классе цели-C.

Существует два типа регистраторов, используемых в Xamarin. iOS — Dynamic и static:


- **Динамические регистраторы** — динамический регистратор выполняет регистрацию всех типов в сборке во время выполнения. Для этого используются функции, предоставляемые [API среды выполнения цели-C](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/). Таким образом, динамический регистратор имеет медленный запуск, но более быстрое время сборки. Это значение по умолчанию для симулятора iOS. Собственные функции (обычно в C), называемые трамполинес, используются в качестве реализаций методов при использовании динамических регистраторов. Они отличаются в разных архитектурах.

- **Статические регистраторы** — статический регистратор создает код цели-C во время сборки, который затем компилируется в статическую библиотеку и связывается с исполняемым файлом. Это обеспечивает более быстрый запуск, но во время сборки занимает больше времени. Этот параметр используется по умолчанию для сборок устройств. Статический регистратор также можно использовать с симулятором iOS, передав `--registrar:static` в `mtouch` качестве атрибута в параметры сборки проекта, как показано ниже:

    [![](architecture-images/image1.png "Установка дополнительных аргументов mtouch")](architecture-images/image1.png#lightbox)

Дополнительные сведения об особенностях системы регистрации типов iOS, используемой Xamarin. iOS, см. в руководстве по [типу регистратора](~/ios/internals/registrar.md) .

## <a name="application-launch"></a>Запуск приложения

Точка входа всех исполняемых файлов Xamarin. iOS предоставляется функцией `xamarin_main`, которая инициализирует Mono.

В зависимости от типа проекта выполняются следующие действия.

- Для обычных приложений iOS и tvOS вызывается управляемый метод Main, предоставляемый приложением Xamarin. Затем этот управляемый метод Main `UIApplication.Main`вызывает, который является точкой входа для цели-C. UIApplication. Main — это привязка для `UIApplicationMain` метода цели-C.
- Для расширений используется собственная функция — `NSExtensionMain` или (`NSExtensionmain` для расширений WatchOS), предоставляемая библиотеками Apple. Так как эти проекты являются библиотеками классов, а не исполняемыми проектами, нет управляемых методов для выполнения.

Все эти последовательности запуска компилируются в статическую библиотеку, которая затем связывается с окончательным исполняемым файлом, чтобы ваше приложение знало, как приступить к работе.

На этом этапе приложение запущено, моно работает, мы работаем в управляемом коде, и мы понимаем, как вызывать машинный код и вызывать его обратно. Далее нам нужно сначала добавить элементы управления и сделать приложение интерактивным.


## <a name="generator"></a>Generator

Xamarin. iOS содержит определения для каждого отдельного API iOS. Их можно просмотреть в [репозитории GitHub маЦиос](https://github.com/xamarin/xamarin-macios/tree/master/src). Эти определения содержат интерфейсы с атрибутами, а также все необходимые методы и свойства. Например, следующий код используется для определения Уитулбар в [пространстве имен](https://github.com/xamarin/xamarin-macios/blob/master/src/uikit.cs#L11277-L11327)UIKit. Обратите внимание, что это интерфейс с несколькими методами и свойствами:

```csharp
[BaseType (typeof (UIView))]
public interface UIToolbar : UIBarPositioning {
    [Export ("initWithFrame:")]
    IntPtr Constructor (CGRect frame);

    [Export ("barStyle")]
    UIBarStyle BarStyle { get; set; }

    [Export ("items", ArgumentSemantic.Copy)][NullAllowed]
    UIBarButtonItem [] Items { get; set; }

    [Export ("translucent", ArgumentSemantic.Assign)]
    bool Translucent { [Bind ("isTranslucent")] get; set; }

    // done manually so we can keep this "in sync" with 'Items' property
    //[Export ("setItems:animated:")][PostGet ("Items")]
    //void SetItems (UIBarButtonItem [] items, bool animated);

    [Since (5,0)]
    [Export ("setBackgroundImage:forToolbarPosition:barMetrics:")]
    [Appearance]
    void SetBackgroundImage ([NullAllowed] UIImage backgroundImage, UIToolbarPosition position, UIBarMetrics barMetrics);

    [Since (5,0)]
    [Export ("backgroundImageForToolbarPosition:barMetrics:")]
    [Appearance]
    UIImage GetBackgroundImage (UIToolbarPosition position, UIBarMetrics barMetrics);

    ...
}
```

Генератор, вызываемый [`btouch`](https://github.com/xamarin/xamarin-macios/blob/master/src/btouch.cs) в Xamarin. iOS, принимает эти файлы определения и использует средства .NET для [их компиляции во временную сборку](https://github.com/xamarin/xamarin-macios/blob/master/src/btouch.cs#L318). Однако эта временная сборка непригодна для вызова кода цели-C. Затем генератор считывает временную сборку и создает C# код, который можно использовать во время выполнения.
Вот почему, например, при добавлении случайного атрибута в файл Definition. CS он не будет отображаться в выводимом коде. Генератор не знает о нем и, следовательно `btouch` , не знает, что он ищет его во временной сборке для вывода.

После создания Xamarin. iOS. dll mtouch будет объединять все компоненты вместе.

На высоком уровне он достигает этого, выполняя следующие задачи:

- Создайте структуру пакета приложений.
- Скопируйте в управляемые сборки.
- Если связывание включено, запустите управляемый компоновщик для оптимизации сборок путем копирования неиспользуемых частей.
- Компиляция AOT.
- Создайте собственный исполняемый файл, который выводит ряд статических библиотек (по одному для каждой сборки), которые связаны с собственным исполняемым файлом, чтобы собственный исполняемый файл состоит из кода запуска, кода регистратора (если он статический) и всех выходных данных из AOT. компилятора


Более подробные сведения о компоновщике и способах его использования см. в руководстве по [компоновщику](~/ios/deploy-test/linker.md) .

## <a name="summary"></a>Сводка

В этом разделе рассматривается компиляция AOT приложений Xamarin. iOS и изучение Xamarin. iOS и его отношения к цели-C в глубину.

## <a name="related-links"></a>Связанные ссылки

- [Ограничения](~/ios/internals/limitations.md)
- [Привязка Objective-C](~/cross-platform/macios/binding/overview.md)
- [Селекторы цели-C](~/ios/internals/objective-c-selectors.md)
- [Регистратор типов](~/ios/internals/registrar.md)
- [Компоновщик](~/ios/deploy-test/linker.md)
