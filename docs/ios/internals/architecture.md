---
title: Архитектура приложения iOS
description: В этом документе приводится описание взаимодействия низкого уровня, обсуждения как машинного и управляемого кода, компиляция AOT, селекторы, регистраторов, запуска приложений и генератор Xamarin.iOS.
ms.prod: xamarin
ms.assetid: F40F2275-17DA-4B4D-9678-618FF25C6803
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/21/2017
ms.openlocfilehash: 426c5ef5cc32877546ebb88cb485a81723816e6e
ms.sourcegitcommit: 58d8bbc19ead3eb535fb8248710d93ba0892e05d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/09/2019
ms.locfileid: "67675065"
---
# <a name="ios-app-architecture"></a>Архитектура приложения iOS

Приложений Xamarin.iOS запуск в среде выполнения Mono и использование полной компиляции Ahead из времени (AOT) компиляции C# код на языке ассемблера ARM. Эта команда запускает side-by-side с [среде выполнения Objective-c.](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/). Обе эти среды выполнения выполняются на основе UNIX-подобных ядро, в частности [XNU](https://en.wikipedia.org/wiki/XNU)и предоставлять различные интерфейсы API для пользовательского кода, что позволяет разработчикам получать доступ к базовой системы машинного или управляемого.

На следующей схеме показан общий обзор этой архитектуры:

[![](architecture-images/ios-arch-small.png "На этой схеме показан общий обзор архитектуры вперед от времени (AOT) компиляции")](architecture-images/ios-arch.png#lightbox)

## <a name="native-and-managed-code-an-explanation"></a>Машинного и управляемого кода: Объяснение

При разработке для Xamarin условия *машинного и управляемого* кода часто используются. [Управляемый код](https://blogs.msdn.microsoft.com/brada/2004/01/09/what-is-managed-code/) приведен код, который имеет свое выполнение, управляет [.NET Framework Common Language Runtime](https://msdn.microsoft.com/library/8bs2ecf4(v=vs.110).aspx), или в случае Xamarin: среда выполнения Mono. Это так называемый промежуточный язык.

Машинный код приведен код, который будет выполняться в собственном коде на конкретную платформу (например, Objective-C или даже код компиляции AOT, в микросхеме ARM). В этом руководстве рассматриваются как AOT компилирует управляемого кода в машинный код, а также объясняется, как работает приложение Xamarin.iOS, интенсивно использовать API для iOS компании Apple при помощи привязок, сохранив доступ к. NET BCL и сложный язык, такой как C#.

## <a name="aot"></a>AOT

При компиляции любого приложения Xamarin платформы Mono C# (или F#) компилятор будет выполняться и будет компилироваться в C# и F# код в промежуточный язык MSIL (Microsoft). Если вы используете Xamarin.Android приложения Xamarin.Mac и даже приложения Xamarin.iOS в симуляторе, [.NET Common Language Runtime (CLR)](https://msdn.microsoft.com/library/8bs2ecf4(v=vs.110).aspx) компилирует код MSIL, используя только в компиляторе Time (JIT). Во время выполнения, это компилируется в машинный код, который можно запустить на правильной архитектуры для вашего приложения.

Однако есть ограничение безопасности в компании Apple, который запрещает выполнение динамически созданный код на устройстве iOS.
Чтобы убедиться, что мы Соблюдаем эти протоколы безопасности, Xamarin.iOS вместо этого использует вперед от времени (AOT) компилятор для компиляции управляемого кода. В результате получается машинном коде iOS двоичных данных, при необходимости оптимизирован с LLVM для устройств, которые могут быть развернуты на процессоре ARM под управлением Apple. Приблизительная схема как это сочетается друг с другом как показано ниже:

[![](architecture-images/aot.png "Приблизительная схема как это сочетается друг с другом")](architecture-images/aot-large.png#lightbox)

С помощью AOT имеет ряд ограничений, которые подробно описаны в [ограничения](~/ios/internals/limitations.md) руководства. Он также предоставляет ряд улучшений по JIT через уменьшение времени запуска, а также различные оптимизации производительности

Теперь, когда мы изучили, как код компилируется из источника в машинный код, давайте Заглянем под капот, чтобы увидеть, как Xamarin.iOS позволяет нам создать полностью собственные приложения iOS

## <a name="selectors"></a>Селекторы

С помощью Xamarin, у нас есть два отдельных экосистемы .NET и Apple, которую нам нужно перевести вместе, чтобы показаться как упрощенная, как можно точнее, чтобы убедиться, что конечная цель — для удобства пользователей. Мы видели в разделе выше взаимодействие две среды выполнения, и вы очень хорошо выдающимся физиком того термин «привязки», который разрешает собственного API-интерфейсов для использования в Xamarin iOS. Привязки рассматриваются подробно в наших [привязки Objective-C](~/cross-platform/macios/binding/overview.md) документации, поэтому сейчас рассмотрим принцип iOS взгляд изнутри.

Во-первых, есть ли способ предоставления Objective-C, чтобы C#, который делается с помощью селекторов. Селектор — это сообщение, отправляемое объект или класс. С помощью Objective-C это делается с помощью [objc_msgSend](~/cross-platform/macios/binding/overview.md) функции.
Дополнительные сведения об использовании селекторы см [селекторы Objective-C](~/ios/internals/objective-c-selectors.md) руководства. Также должен быть способ предоставления управляемого кода Objective-C, который более сложен, тем, что Objective-C не знает ничего о управляемого кода. Чтобы обойти эту проблему, мы используем *регистраторов*. Это описано более подробно в следующем разделе.

## <a name="registrars"></a>Регистраторы

Как упоминалось выше, регистратор кода, предоставляет доступ к управляемому коду Objective-C. Это достигается путем создания списка каждый управляемый класс, производный от NSObject:

- Для всех классов, которые не создается программа-оболочка существующего класса Objective-C, он создает новый класс Objective-C с Objective-C участниками зеркального отображения все управляемые элементы с суффиксом [`Export`] атрибут.

- В реализациях для каждого члена Objective-C код для вызова зеркальных управляемого элемента добавляется автоматически.

В приведенном ниже коде псевдо является примером этого является:

**C#(Управляемый код)**

```csharp
 class MyViewController : UIViewController{
     [Export ("myFunc")]
     public void MyFunc ()
     {
     }
 }
```

**Цель — C:**

```objectivec
@interface MyViewController : UIViewController { }

    -(void)myFunc;
@end

@implementation MyViewController {}

    -(void) myFunc
    {
        /* code to call the managed MyViewController.MyFunc method */
    }
@end

```

Управляемый код может содержать атрибуты `[Register]` и `[Export]`, который использует регистратор, чтобы знать, что объект должен предоставляться Objective-C.
`[Register]` Атрибут используется для указания имени создаваемого класса Objective-C, если созданное по умолчанию имя не подходит. Все классы, производные от NSObject автоматически регистрируются с Objective-C.
Необходимая `[Export]` атрибут содержит строку, которая является селектор, используемый в созданном классе ему Objective-C.

Существует два типа регистраторов, используемых в Xamarin.iOS — динамический и статический.


- **Динамические регистраторов** – динамические регистратор регистрацию всех типов в сборку во время выполнения. Это делается с помощью функций, предоставляемых [API среды выполнения Objective-C](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/). Таким образом, динамические регистратор имеет медленнее запуска, но более быстрой во время сборки. Это значение по умолчанию для симулятора iOS. Неуправляемые функции (обычно в C), вызванные trampolines, используются в качестве реализации метода, при использовании динамического регистраторов. Они отличаются в разных архитектур.

- **Статические регистраторов** — статический регистратор создает код Objective-C во время сборки, который затем компилируется в статическую библиотеку и связанные в исполняемый файл. Это позволяет для быстрого запуска, но занимает больше времени, во время сборки. Используется по умолчанию для сборок устройств. Статический регистратора можно также использовать с симулятором iOS путем передачи `--registrar:static` как `mtouch` атрибут в параметрах сборки проекта, как показано ниже:

    [![](architecture-images/image1.png "Параметр Дополнительные аргументы mtouch")](architecture-images/image1.png#lightbox)

Дополнительные сведения об особенностях iOS регистрация типа системы, используемой Xamarin.iOS см [тип регистратора](~/ios/internals/registrar.md) руководства.

## <a name="application-launch"></a>Запуск приложения

Точка входа все исполняемые файлы Xamarin.iOS, предоставляемые функции с именем `xamarin_main`, которое инициализирует mono.

В зависимости от типа проекта выполняется следующее:

- Для регулярного iOS и tvOS приложений называется управляемого метода Main, предоставленный приложением Xamarin. Это управляемый метод Main вызывает `UIApplication.Main`, который является точкой входа для Objective-C. Привязка Objective-C является UIApplication.Main `UIApplicationMain` метод.
- Для расширений, функция в машинном коде — `NSExtensionMain` или (`NSExtensionmain` для расширения WatchOS) — предоставляемых компанией Apple называется библиотеки. Так как эти проекты библиотеки классов и проектов не исполняемых файлов, существуют нет управляемых методов Main для выполнения.

Все это последовательность запуска компилируется в статическую библиотеку, которая затем связана в окончательный исполняемый файл, приложение знает, как приступить к работе.

На этом этапе наше приложение запуска, Mono работает, мы в управляемом коде и мы знаем, как вызывать машинный код и обеспечить возможность обратного вызова. Следующее, что нам нужно сделать — фактически начать добавлять элементы управления и обеспечить интерактивные приложения.


## <a name="generator"></a>Generator

Xamarin.iOS содержит определения для каждого единый API iOS. Можно выполнять поиск любого из этих на [репозиторий github MaciOS](https://github.com/xamarin/xamarin-macios/tree/master/src). Эти определения содержат интерфейсы с атрибутами, а также все необходимые методы и свойства. Например, следующий код используется для определения UIToolbar в UIKit [пространства имен](https://github.com/xamarin/xamarin-macios/blob/master/src/uikit.cs#L11277-L11327). Обратите внимание на то, что он является интерфейсом ряд методов и свойств:

```csharp
[BaseType (typeof (UIView))]
public interface UIToolbar : UIBarPositioning {
    [Export ("initWithFrame:")]
    IntPtr Constructor (CGRect frame);

    [Export ("barStyle")]
    UIBarStyle BarStyle { get; set; }

    [Export ("items", ArgumentSemantic.Copy)][NullAllowed]
    UIBarButtonItem [] Items { get; set; }

    [Export ("translucent", ArgumentSemantic.Assign)]
    bool Translucent { [Bind ("isTranslucent")] get; set; }

    // done manually so we can keep this "in sync" with 'Items' property
    //[Export ("setItems:animated:")][PostGet ("Items")]
    //void SetItems (UIBarButtonItem [] items, bool animated);

    [Since (5,0)]
    [Export ("setBackgroundImage:forToolbarPosition:barMetrics:")]
    [Appearance]
    void SetBackgroundImage ([NullAllowed] UIImage backgroundImage, UIToolbarPosition position, UIBarMetrics barMetrics);

    [Since (5,0)]
    [Export ("backgroundImageForToolbarPosition:barMetrics:")]
    [Appearance]
    UIImage GetBackgroundImage (UIToolbarPosition position, UIBarMetrics barMetrics);

    ...
}
```

Генератор, вызывается [ `btouch` ](https://github.com/xamarin/xamarin-macios/blob/master/src/btouch.cs) в Xamarin.iOS, принимает эти файлы определения и использует средства .NET для [скомпилировать их во временную сборку](https://github.com/xamarin/xamarin-macios/blob/master/src/btouch.cs#L318). Тем не менее это временная сборка непригоден для вызова кода Objective-C. Генератор, затем считывает временную сборку и создает C# код, который может использоваться во время выполнения.
Это, почему, например, при добавлении случайных атрибут для определения CS-файле, оно не будет отображаться в outputted коде. Генератор не знает о нем и поэтому `btouch` не знает, искать его в временную сборку, чтобы вывести его.

После создания Xamarin.iOS.dll mtouch будут объединены все компоненты.

На высоком уровне это достигается путем выполнения следующих задач:

-   Создайте структуру пакета приложения.
-   Копирование управляемых сборок.
-   Если связывание включено, то запустите управляемых компоновщик для оптимизации сборок путем копирования в неиспользуемых частей.
-   Компиляция AOT.
-   Создайте исполняемый файл машинного кода, который выводит ряд статических библиотек (по одному для каждой сборки), связанных с исполняемый файл машинного кода, таким образом, чтобы исполняемый файл машинного кода состоит из средства запуска кода на код регистратора (если статический) и все выходные данные из AOT компилятор


Более подробные сведения о компоновщик и способах ее использования, описаны в [компоновщика](~/ios/deploy-test/linker.md) руководства.

## <a name="summary"></a>Сводка

В этом руководстве рассмотрены компиляция AOT приложений Xamarin.iOS и изучать Xamarin.iOS и его связь с Objective-C в глубину.

## <a name="related-links"></a>Связанные ссылки

- [Ограничения](~/ios/internals/limitations.md)
- [Привязка Objective-C](~/cross-platform/macios/binding/overview.md)
- [Селекторы Objective-C](~/ios/internals/objective-c-selectors.md)
- [Тип регистратора](~/ios/internals/registrar.md)
- [Компоновщик](~/ios/deploy-test/linker.md)
