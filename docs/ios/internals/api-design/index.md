---
title: Разработка API Xamarin. iOS
description: Принципы, которые использовались для проектирования интерфейсов API Xamarin. iOS и их отношение к цели-C.
ms.prod: xamarin
ms.assetid: 322D2724-AF27-6FFE-BD21-AA1CFE8C0545
ms.technology: xamarin-ios
author: conceptdev
ms.author: crdun
ms.date: 03/21/2017
ms.openlocfilehash: 843aeda14ad8c47014b577bdce8004872b12865d
ms.sourcegitcommit: 57f815bf0024b1afe9754c0e28054fc0a53ce302
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70753455"
---
# <a name="xamarinios-api-design"></a>Разработка API Xamarin. iOS

В дополнение к основным библиотекам базовых классов, которые являются частью Mono, [Xamarin. iOS](http://www.xamarin.com/iOS) поставляется с привязками для различных интерфейсов API iOS, позволяя разработчикам создавать собственные приложения iOS с Mono.

В ядре Xamarin. iOS существует механизм взаимодействия, связывающий C# мир с миром цели-C, а также привязки для интерфейсов API на основе iOS c, таких как Кореграфикс и [OpenGL ES](#opengles).

Среда выполнения нижнего уровня для взаимодействия с кодом цели-C находится в [Односенсорном. обжкрунтиме](#objcruntime). Поверх этого, предоставляются привязки для [Foundation](#foundation), Корефаундатион и [UIKit](#uikit) .

## <a name="design-principles"></a>Принципы разработки

Это некоторые принципы разработки для привязок Xamarin. iOS (они также применяются к Xamarin. Mac, привязки Mono для цели-C на macOS):

- Следуйте [рекомендациям по проектированию платформы](https://docs.microsoft.com/dotnet/standard/design-guidelines)
- Разрешить разработчикам подклассировать классы цели-C:

  - Наследование от существующего класса
  - Вызов базового конструктора для создания цепочки
  - Переопределяющие методы должны выполняться с C#помощью системы переопределения
  - Подклассы должны работать со C# стандартными конструкциями

- Не предоставляйте разработчикам доступ к селекторам цели-C
- Предоставление механизма вызова произвольных библиотек цели-C
- Простое и сложное назначение задач с заданием на c
- Предоставление свойств цели-C в C# качестве свойств
- Предоставление строго типизированного API:

  - Повышение безопасности типов
  - Уменьшение ошибок времени выполнения
  - Получение IntelliSense интегрированной среды разработки для возвращаемых типов
  - Разрешает всплывающую документацию интегрированной среды разработки

- Рекомендуем исследовать API в интегрированной среде разработки:

  - Например, вместо предоставления слабо типизированного массива следующим образом:

    ```objc
    NSArray *getViews
    ```

    Предоставьте строгий тип следующим образом:

    ```csharp
    NSView [] Views { get; set; }
    ```

    Это дает Visual Studio для Mac возможность автоматического завершения при просмотре API, делает все `System.Array` операции доступными для возвращенного значения и позволяет возвращаемому значению участвовать в LINQ.

- Собственные C# типы:

  - [`NSString`обретает`string`](~/ios/internals/api-design/nsstring.md)
  - Turn `int` C# и C# `[Flags]` параметры, которые должны быть перечислены в перечисления и перечисления с атрибутами `uint`
  - Вместо нейтральных `NSArray` к типу объектов предоставляйте массивы как строго типизированные массивы.
  - Для событий и уведомлений Предоставьте пользователям возможность выбора между:

    - Строго типизированная версия по умолчанию
    - Слабо типизированная версия для расширенных вариантов использования

- Поддержка шаблона делегата цели-C:

  - C#Система событий
  - Предоставление C# делегатам (лямбда-выражения, анонимные `System.Delegate`методы и) в API цели на языке C в качестве блоков

### <a name="assemblies"></a>Сборки

Xamarin. iOS включает несколько сборок, образующих *профиль Xamarin. iOS*. Дополнительные сведения см. на странице [сборок](~/cross-platform/internals/available-assemblies.md) .

### <a name="major-namespaces"></a>Основные пространства имен

#### <a name="objcruntime"></a>обжкрунтиме

Пространство имен [обжкрунтиме](xref:ObjCRuntime) позволяет разработчикам связывать мировые соединения C# и цели-C.
Это новая привязка, разработанная специально для iOS, на основе опыта Cocoa # и GTK #.

#### <a name="foundation"></a>Базовый

Пространство имен [Foundation](xref:Foundation) предоставляет базовые типы данных, предназначенные для взаимодействия с платформой объектив-c Foundation, которая является частью iOS и является основой объектно-ориентированного программирования в целевом C.

Зеркала Xamarin. iOS в C# иерархии классов из цели-C. Например, базовый класс цели-C [нсобжект](https://developer.apple.com/iphone/library/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html) можно использовать из C# Via [Foundation. нсобжект](xref:Foundation.NSObject).

Хотя это пространство имен предоставляет привязки для базовых типов цели-C, в некоторых случаях мы сопоставили базовые типы с типами .NET. Например:

- Вместо того чтобы работать с [NSString](https://developer.apple.com/iphone/library/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/Reference/NSString.html) и [нсаррай](https://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/NSArray.html), среда выполнения предоставляет их C#в виде [строк](xref:System.String)и строго типизированных [массивов](xref:System.Array)по всему API.

- Здесь представлены различные вспомогательные API, позволяющие разработчикам привязывать сторонние API-интерфейсы цели, другие API iOS или API, которые в настоящее время не привязаны к Xamarin. iOS.

Дополнительные сведения о привязках API см. в разделе [генератор привязок Xamarin. iOS](~/cross-platform/macios/binding/binding-types-reference.md) .

##### <a name="nsobject"></a>нсобжект

Тип [нсобжект](xref:Foundation.NSObject) является основой для всех привязок цели-C. Типы Xamarin. iOS отражают два класса типов из интерфейсов API Кокоатауч для iOS: типы C (обычно называются типами Корефаундатион) и типы цели-C (все они являются производными от класса Нсобжект).

Для каждого типа, который отражает неуправляемый тип, можно получить собственный объект через свойство [Handle](xref:Foundation.NSObject.Handle) .

Пока моно предоставляет сборку мусора для всех объектов, `Foundation.NSObject` реализует интерфейс [System. IDisposable](xref:System.IDisposable) . Это означает, что можно явным образом освободить ресурсы любых заданных Нсобжект, не дожидаясь запуска сборщика мусора. Это важно при использовании интенсивного Нсобжектс, например Уиимажес, который может содержать указатели на большие блоки данных.

Если тип должен выполнять детерминированное завершение, переопределите [метод нсобжект. Dispose (bool)](xref:Foundation.NSObject.Dispose(System.Boolean)) , чтобы параметр Dispose был "bool disposing", а если задано значение "true", это означает, что метод Dispose вызывается, так как пользователь явно вызывает Dispose () для объекта. Если значение равно false, это означает, что метод Dispose (bool disposing) вызывается из метода завершения в потоке метода завершения.

##### <a name="categories"></a>Категории

Начиная с Xamarin. iOS 8,10 можно создавать категории цели-C из C#.

Это делается с помощью `Category` атрибута, указывая тип для расширения в качестве аргумента атрибута. В следующем примере показано, как экземпляр расширяет NSString.

```csharp
[Category (typeof (NSString))]
```

Каждый метод категории использует нормальный механизм экспорта методов в цель-C с помощью `Export` атрибута:

```csharp
[Export ("today")]
public static string Today ()
{
    return "Today";
}
```

Все управляемые методы расширения должны быть статическими, но можно создать методы экземпляра цели-C с помощью стандартного синтаксиса для методов расширения в C#:

```csharp
[Export ("toUpper")]
public static string ToUpper (this NSString self)
{
    return self.ToString ().ToUpper ();
}
```

первым аргументом метода расширения будет экземпляр, на котором был вызван метод.

Полный пример:

```csharp
[Category (typeof (NSString))]
public static class MyStringCategory
{
    [Export ("toUpper")]
    static string ToUpper (this NSString self)
    {
        return self.ToString ().ToUpper ();
    }
}
```

В этом примере будет добавлен собственный метод экземпляра toUpper в класс NSString, который можно вызвать из цели-C.

```csharp
[Category (typeof (UIViewController))]
public static class MyViewControllerCategory
{
    [Export ("shouldAutoRotate")]
    static bool GlobalRotate ()
    {
        return true;
    }
}
```

Одним из сценариев, в которых это полезно, является Добавление метода ко всему набору классов в базе кода, например при этом все `UIViewController` экземпляры сообщают о том, что их можно повернуть:

```csharp
[Category (typeof (UINavigationController))]
class Rotation_IOS6 {
      [Export ("shouldAutorotate:")]
      static bool ShouldAutoRotate (this UINavigationController self)
      {
          return true;
      }
}
```

##### <a name="preserveattribute"></a>пресервеаттрибуте

Пресервеаттрибуте — это настраиваемый атрибут, который используется для указания mtouch — средства развертывания Xamarin. iOS — для сохранения типа или члена типа на этапе, когда приложение обрабатывается для уменьшения его размера.

Все члены, которые не имеют статических ссылок из приложения, подлежат удалению. Таким образом, этот атрибут используется для маркировки элементов, на которые нет статических ссылок, но которые по-прежнему нужны приложению.

Например, если вы динамически создаете экземпляры типов, для них нужно сохранять в коде конструктор по умолчанию. Если используется XML-сериализация, нужно сохранять свойства типов.

Этот атрибут можно применить для любого члена типа или для типа в целом. Если необходимо сохранить весь тип, можно использовать синтаксис [preserve (AllMembers = true)] для типа.

#### <a name="uikit"></a>UIKit

Пространство имен [UIKit](xref:UIKit) содержит сопоставление "один к одному" всем КОМПОНЕНТАМ пользовательского интерфейса, которые составляют кокоатауч в форме C# классов. API был изменен для соблюдения соглашений, используемых в C# языке.

C#для распространенных операций предоставляются делегаты. Дополнительные сведения см. в разделе [делегаты](#delegates) .

#### <a name="opengles"></a>Приложение OpenGLes

Для OpenGL мы распространяем [измененную версию](xref:OpenTK) API [опентк](http://www.opentk.com/) , объектно-ориентированную привязку к OpenGL, которая была изменена для использования типов данных и структур кореграфикс, а также предоставляет доступ только к функциональным возможностям, доступным в iOS.

Функции OpenGL 1,1 доступны через [тип ES11.GL](xref:OpenTK.Graphics.ES11.GL).

Функции OpenGL 2,0 доступны через [тип ES20.GL](xref:OpenTK.Graphics.ES20.GL).

Функции OpenGL 3,0 доступны через [тип ES30.GL](xref:OpenTK.Graphics.ES30.GL).

### <a name="binding-design"></a>Разработка привязки

Xamarin. iOS не просто является привязкой к базовой платформе цели-C. Она расширяет систему типов .NET и систему диспетчеризации, чтобы улучшить смешивание C# и цель-C.

Так же, как P/Invoke — это удобное средство для вызова собственных библиотек в Windows и Linux или как поддержку IJW для COM-взаимодействия в Windows, Xamarin. iOS расширяет среду выполнения для поддержки привязки C# объектов к объектам цели-C.

Обсуждение в следующих нескольких разделах не является обязательным для пользователей, создающих приложения Xamarin. iOS, но поможет разработчикам понять, как выполняются вещи и поможет им при создании более сложных приложений.

#### <a name="types"></a>Типы

Там, где это было C# понятно, для C# Вселенной предоставляются типы, а не низкоуровневые типы.  Это означает, что [API использует C# тип String вместо NSString](~/ios/internals/api-design/nsstring.md) и использует строго типизированные C# массивы вместо предоставления нсаррай.

Как правило, в структуре Xamarin. iOS и Xamarin. Mac базовый `NSArray` объект не предоставляется. Вместо этого среда выполнения автоматически преобразует `NSArray`s в строго типизированные массивы `NSObject` некоторого класса. Таким образом, Xamarin. iOS не предоставляет слабо типизированный метод, такой как "аналитические", для возврата Нсаррай:

```csharp
NSArray GetViews ();
```

Вместо этого привязка предоставляет строго типизированное возвращаемое значение следующим образом:

```csharp
UIView [] GetViews ();
```

Существует несколько методов, доступных в `NSArray`, для угловых случаев, где может потребоваться `NSArray` использовать напрямую, но их использование не рекомендуется в привязке API.

Кроме того, в **Classic API** вместо `CGRect`предоставления `CGPoint` и `CGSize` использования `System.Drawing` `RectangleF`APIкореграфиксмы заменили их реализациями и `PointF` `SizeF`так как они помогут разработчикам сохранить существующий код OpenGL, использующий опентк. При использовании нового 64-разрядного **Unified API**следует использовать API кореграфикс.

#### <a name="inheritance"></a>Наследование

Структура API Xamarin. iOS позволяет разработчикам расширять собственные типы "цель-C" точно так же, как они расширяют C# тип, используя ключевое слово "override" в производном классе, а также привязывать к базовой реализации с помощью "Base" C# This.

Такая схема позволяет разработчикам избегать использования селекторов цели-C в рамках процесса разработки, так как вся система цели-C уже заключена в библиотеки Xamarin. iOS.

#### <a name="types-and-interface-builder"></a>Типы и Interface Builder

При создании классов .NET, являющихся экземплярами типов, созданных Interface Builder, необходимо предоставить конструктор, принимающий один `IntPtr` параметр.
Это необходимо для привязки экземпляра управляемого объекта к неуправляемому объекту.
Код состоит из одной строки, как показано ниже.

```csharp
public partial class void MyView : UIView {
   // This is the constructor that you need to add.
   public MyView (IntPtr handle) : base (handle) {}
}
```

#### <a name="delegates"></a>Делегаты

Цель-C и C# разные значения для делегата слова на каждом языке.

В мире цели-C и в документации, где вы найдете в Интернете сведения о Кокоатауч, делегат обычно является экземпляром класса, который будет отвечать на набор методов. Это очень похоже на C# интерфейс, в отличие от того, что методы не всегда являются обязательными.

Эти делегаты играют важную роль в UIKit и других интерфейсах API Кокоатауч. Они используются для выполнения различных задач:

- Для предоставления уведомлений коду (аналогично доставке событий в C# или GTK +).
- Для реализации моделей для элементов управления визуализации данных.
- Чтобы обеспечить поведение элемента управления.

Шаблон программирования предназначен для того, чтобы было максимально сокращать создание производных классов для изменения поведения элемента управления. Это решение аналогично тому, что было сделано с другими наборами средств графического пользовательского интерфейса в течение нескольких лет. Сигналы GTK, слоты Qt, события WinForms, события WPF/Silverlight и т. д. Чтобы избежать использования сотен интерфейсов (по одному для каждого действия) или необходимости разработчиков реализовывать слишком много ненужных методов, цель-C поддерживает необязательные определения методов. Это отличается от C# интерфейсов, требующих реализации всех методов.

В классах цели-C вы увидите, что классы, использующие этот шаблон программирования, предоставляют свойство, обычно называемое `delegate`, которое требуется для реализации обязательных частей интерфейса, а также нуль или более необязательных частей.

В Xamarin. iOS три взаимоисключающих механизма привязки к этим делегатам:

1. [События Via](#via-events).
2. [Строго типизировано через `Delegate` свойство](#strongly-typed-via-a-delegate-property)
3. [Слабо типизировано с `WeakDelegate` помощью свойства](#loosely-typed-via-the-weakdelegate-property)

Например, рассмотрим класс [уивебвиев](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebView_Class/Reference/Reference.html) . Он отправляется в экземпляр [уивебвиевделегате](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebViewDelegate_Protocol/Reference/Reference.html) , который назначается свойству [делегата](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebView_Class/Reference/Reference.html#//apple_ref/occ/instp/UIWebView/delegate) .

##### <a name="via-events"></a>События Via

Для многих типов Xamarin. IOS автоматически создает соответствующий делегат, который будет перенаправлять вызовы в `UIWebViewDelegate` C# события. Для `UIWebView`:

- Метод [вебвиевдидстартлоад](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebViewDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIWebViewDelegate/webViewDidStartLoad:) сопоставлен с событием [уивебвиев. лоадстартед](xref:UIKit.UIWebView.LoadStarted) .
- Метод [вебвиевдидфинишлоад](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebViewDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIWebViewDelegate/webViewDidFinishLoad:) сопоставлен с событием [уивебвиев. лоадфинишед](xref:UIKit.UIWebView.LoadFinished) .
- Метод [webView: дидфаиллоадвисеррор](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebViewDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIWebViewDelegate/webView:didFailLoadWithError:) сопоставлен с событием [уивебвиев. лоадеррор](xref:UIKit.UIWebView.LoadError) .

Например, эта простая программа записывает время начала и окончания при загрузке веб-представления:

```csharp
DateTime startTime, endTime;
var web = new UIWebView (new CGRect (0, 0, 200, 200));
web.LoadStarted += (o, e) => startTime = DateTime.Now;
web.LoadFinished += (o, e) => endTime = DateTime.Now;
```

##### <a name="via-properties"></a>Свойства Via

События полезны при наличии нескольких подписчиков на одно событие. Кроме того, события ограничиваются только тем случаям, когда в коде нет возвращаемого значения.

Для случаев, когда предполагается, что код возвращает значение, мы выбрали вместо него свойства. Это означает, что в объекте можно задать только один метод в определенный момент времени.

Например, этот механизм можно использовать для закрытия клавиатуры на экране обработчика для `UITextField`:

```csharp
void SetupTextField (UITextField tf)
{
    tf.ShouldReturn = delegate (textfield) {
        textfield.ResignFirstResponder ();
        return true;
    }
}
```

`UITextField` Свойствовэтомслучаепринимаетвкачествеаргументаделегат,возвращающийлогическоезначение,иопределяет,должнолиполеTextFieldвыполнятьдействиес`ShouldReturn` нажатой кнопкой возврата. В нашем методе возвращается *значение true* для вызывающего, но мы также удалим клавиатуру с экрана (это происходит при вызове `ResignFirstResponder`TextField).

##### <a name="strongly-typed-via-a-delegate-property"></a>Строго типизировано через свойство делегата

Если вы предпочитаете не использовать события, можно предоставить собственный подкласс [уивебвиевделегате](xref:UIKit.UIWebViewDelegate) и назначить его свойству [уивебвиев. Delegate](xref:UIKit.UIWebView.Delegate) . После назначения Уивебвиев. Delegate механизм диспетчеризации событий Уивебвиев больше не будет работать, а методы Уивебвиевделегате будут вызываться при возникновении соответствующих событий.

Например, этот простой тип записывает время, затрачиваемое на загрузку веб-представления:

```csharp
class Notifier : UIWebViewDelegate  {
    DateTime startTime, endTime;

    public override LoadStarted (UIWebView webview)
    {
        startTime = DateTime.Now;
    }

    public override LoadingFinished (UIWebView webView)
    {
        endTime= DateTime.Now;
    }
}
```

Приведенный выше код используется в коде следующим образом:

```csharp
var web = new UIWebView (new CGRect (0, 0, 200, 200));
web.Delegate = new Notifier ();
```

Приведенный выше компонент создаст Уивебвиевер и сообщит ему отправить сообщение экземпляру уведомления, классу, который мы создали для реагирования на сообщения.

Этот шаблон также используется для управления поведением определенных элементов управления, например в уивебвиев случае свойство [уивебвиев. шаулдстартлоад](xref:UIKit.UIWebView.ShouldStartLoad) позволяет `UIWebView` экземпляру управлять тем `UIWebView` , будет ли загружаться страница.

Шаблон также используется для предоставления данных по запросу для нескольких элементов управления. Например, элемент управления [уитаблевиев](xref:UIKit.UITableView) является мощным элементом управления для отрисовки таблиц, и как внешний вид, так и содержимое управляются экземпляром [уитаблевиевдатасаурце](xref:UIKit.UITableViewDataSource)

### <a name="loosely-typed-via-the-weakdelegate-property"></a>Слабо типизировано с помощью свойства Веакделегате

Помимо строго типизированного свойства, существует также ненадежный типизированный делегат, позволяющий разработчику при необходимости привязывать вещи по-разному.
Везде, где строго `Delegate` типизированное свойство предоставляется в привязке Xamarin. iOS, также `WeakDelegate` предоставляется соответствующее свойство.

При использовании `WeakDelegate`, вы несете ответственность за правильное определение класса с помощью атрибута [Export](xref:Foundation.ExportAttribute) для указания селектора. Например:

```csharp
class Notifier : NSObject  {
    DateTime startTime, endTime;

    [Export ("webViewDidStartLoad:")]
    public void LoadStarted (UIWebView webview)
    {
        startTime = DateTime.Now;
    }

    [Export ("webViewDidFinishLoad:")]
    public void LoadingFinished (UIWebView webView)
    {
        endTime= DateTime.Now;
    }
}

[...]

var web = new UIWebView (new CGRect (0, 0, 200, 200));
web.WeakDelegate = new Notifier ();
```

Обратите внимание, `WeakDelegate` что после присвоения `Delegate` свойства свойство не будет использоваться. Кроме того, при реализации метода в унаследованном базовом классе, который вы хотите применить к [Export], необходимо сделать его открытым методом.

## <a name="mapping-of-the-objective-c-delegate-pattern-to-c"></a>Сопоставление шаблона делегата цели-C с C\#

При просмотре образцов цели-C, которые выглядят следующим образом:

```objc
foo.delegate = [[SomethingDelegate] alloc] init]
```

Это указывает языку создать и сконструировать экземпляр класса "Сомесингделегате" и присвоить значение свойству делегата в переменной foo. Этот механизм поддерживается Xamarin. iOS и C# имеет следующий синтаксис:

```csharp
foo.Delegate = new SomethingDelegate ();
```

В Xamarin. iOS мы предоставили строго типизированные классы, соответствующие классам делегата цели-C. Чтобы использовать их, нужно будет подклассировать и переопределять методы, определенные в реализации Xamarin. iOS. Дополнительные сведения о том, как они работают, см. в разделе "модели" ниже.

### <a name="mapping-delegates-to-c"></a>Сопоставление делегатов с\#

UIKit в целом использует делегаты цели-C в двух формах.

Первая форма предоставляет интерфейс модели компонента. Например, в качестве механизма предоставления данных по запросу для представления, например средства хранения данных для представления списка.  В таких случаях следует всегда создавать экземпляр соответствующего класса и присваивать ему переменную.

В следующем примере мы предоставляем `UIPickerView` реализацию для модели, которая использует строки:

```csharp
public class SampleTitleModel : UIPickerViewTitleModel {

    public override string TitleForRow (UIPickerView picker, nint row, nint component)
    {
        return String.Format ("At {0} {1}", row, component);
    }
}

[...]

pickerView.Model = new MyPickerModel ();
```

Вторая форма — предоставление уведомлений о событиях. В таких случаях, несмотря на то, что мы по-прежнему предоставляем API в форме, описанной выше C# , мы также предоставляем события, которые проще всего использовать для быстрых операций и интегрированы с анонимными C#делегатами и лямбда-выражениями в.

Например, можно подписываться на `UIAccelerometer` события:

```csharp
UIAccelerometer.SharedAccelerometer.Acceleration += (sender, args) => {
   UIAcceleration acc = args.Acceleration;
   Console.WriteLine ("Time={0} at {1},{2},{3}", acc.Time, acc.X, acc.Y, acc.Z);
}
```

Доступны два варианта, где они имеют смысл, но в качестве программиста необходимо выбрать одно или другое. Если вы создаете собственный экземпляр строго типизированного ответчика или делегата и назначаете его C# , события не будут работать. При использовании C# событий методы в классе ответчика или делегата никогда не вызываются.

Предыдущий пример, который использовался `UIWebView` , можно записать с помощью C# 3,0 лямбда-выражений следующим образом:

```csharp
var web = new UIWebView (new CGRect (0, 0, 200, 200));
web.LoadStarted += () => { startTime = DateTime.Now; }
web.LoadFinished += () => { endTime = DateTime.Now; }
```

#### <a name="responding-to-events"></a>Реагирование на события

В коде цели-C иногда обработчики событий для нескольких элементов управления и поставщиков информации для нескольких элементов управления будут размещаться в одном и том же классе. Это возможно, поскольку классы реагируют на сообщения, и пока классы реагируют на сообщения, можно связывать объекты друг с другом.

Как уже было сказано выше, Xamarin. iOS поддерживает C# как модель программирования на основе событий, так и шаблон делегата цели-C, где можно создать новый класс, реализующий делегат, и переопределить нужные методы.

Кроме того, можно реализовать шаблон цели-C, когда отвечающие на несколько различных операций размещаются в одном экземпляре класса. Для этого вам потребуется использовать низкоуровневые функции привязки Xamarin. iOS.

Например, если вы хотите, чтобы ваш класс отвечал как на Message `UITextFieldDelegate.textFieldShouldClear`, так и на `UIWebViewDelegate.webViewDidStartLoad`: в том же экземпляре класса, необходимо использовать объявление атрибута [Export]:

```csharp
public class MyCallbacks : NSObject {
    [Export ("textFieldShouldClear:"]
    public bool should_we_clear (UITextField tf)
    {
        return true;
    }

    [Export ("webViewDidStartLoad:")]
    public void OnWebViewStart (UIWebView view)
    {
        Console.WriteLine ("Loading started");
    }
}
```

C# Имена методов не важны; все, что имеет значение, — это строки, передаваемые в атрибут [Export].

При использовании этого стиля программирования убедитесь, что C# параметры соответствуют реальным типам, которые будет передавать ядро среды выполнения.

#### <a name="models"></a>Модели

В средствах хранения UIKit или в ответчиках, реализованных с помощью вспомогательных классов, они обычно упоминаются в коде цели-C как делегаты и реализуются как протоколы.

Протоколы цели-C подобны интерфейсам, но поддерживают необязательные методы, то есть не все методы должны быть реализованы, чтобы протокол работал.

Существует два способа реализации модели. Можно либо реализовать его вручную, либо использовать существующие строго типизированные определения.

Механизм вручную необходим при попытке реализовать класс, который не привязан к Xamarin. iOS. Это очень просто:

- Пометка класса для регистрации в среде выполнения
- Примените атрибут [Export] с фактическим именем селектора для каждого метода, который требуется переопределить.
- Создайте экземпляр класса и передайте его.

Например, в следующем примере реализуется только один из необязательных методов в определении протокола Уиаппликатионделегате:

```csharp
public class MyAppController : NSObject {
        [Export ("applicationDidFinishLaunching:")]
        public void FinishedLaunching (UIApplication app)
        {
                SetupWindow ();
        }
}
```

Имя селектора цели-C ("аппликатиондидфинишлаунчинг:") объявляется с атрибутом экспорта, а класс регистрируется с `[Register]` помощью атрибута.

Xamarin. iOS предоставляет строго типизированные объявления, готовые к использованию, которые не нуждаются в ручной привязке. Для поддержки этой модели программирования среда выполнения Xamarin. iOS поддерживает атрибут [Model] в объявлении класса. Это информирует среду выполнения о том, что не следует подключать все методы класса, если только методы не реализованы явным образом.

Это означает, что в UIKit классы, представляющие протокол с дополнительными методами, пишутся следующим образом:

```csharp
[Model]
public class SomeViewModel : NSObject {
    [Export ("someMethod:")]
    public virtual int SomeMethod (TheView view) {
       throw new ModelNotImplementedException ();
    }
    ...
}
```

Если необходимо реализовать модель, которая реализует лишь некоторые из методов, достаточно переопределять интересующие вас методы и игнорировать другие методы. Среда выполнения будет подключать только перезаписанные методы, а не исходные методы в мир цели-C.

Эквивалентом предыдущего образца вручную является:

```csharp
public class AppController : UIApplicationDelegate {
    public override void FinishedLaunching (UIApplication uia)
    {
     ...
    }
}
```

Преимущество заключается в том, что нет необходимости изучать файлы заголовков цели-C, чтобы найти селектор, типы аргументов или сопоставление с C#, а также получить intellisense из Visual Studio для Mac и строгих типов.

#### <a name="xib-outlets-and-c"></a>XIBные розетки и C\#

> [!IMPORTANT]
> В этом разделе объясняется интеграция интегрированной среды разработки с средами при использовании файлов XIB. При использовании Xamarin Designer для iOS все это заменяется путем ввода имени в разделе **Identity > Name** в разделе Properties в интегрированной среде разработки, как показано ниже.
>
> [![](images/designeroutlet.png "Ввод имени элемента в конструкторе iOS")](images/designeroutlet.png#lightbox)
>
>Дополнительные сведения о конструкторе iOS см. в документе [Введение в конструктор iOS](~/ios/user-interface/designer/introduction.md#how-it-works) .

Это небольшое описание того, как можно интегрировать возможности C# и предоставляется для опытных пользователей Xamarin. iOS. При использовании Visual Studio для Mac сопоставление выполняется автоматически в фоновом режиме с помощью созданного кода в полете.

При проектировании пользовательского интерфейса с помощью Interface Builder вы разрабатываете только внешний вид приложения и устанавливаете некоторые подключения по умолчанию. Если требуется программная выборка информации, изменение поведения элемента управления во время выполнения или изменение элемента управления во время выполнения, необходимо привязать некоторые элементы управления к управляемому коду.

Это выполняется в несколько шагов.

1. Добавьте **объявление розетки** в **владельца файла**.
1. Подключите свой элемент управления к **владельцу файла**.
1. Сохраните пользовательский интерфейс и подключения в файле XIB/NIB.
1. Загрузите файл NIB во время выполнения.
1. Доступ к переменной розетки.

Шаги (от 1) до (3) описаны в документации Apple по созданию интерфейсов с помощью Interface Builder.

При использовании Xamarin. iOS приложению потребуется создать класс, производный от UIViewController. Он реализуется следующим образом:

```csharp
public class MyViewController : UIViewController {
    public MyViewController (string nibName, NSBundle bundle) : base (nibName, bundle)
    {
        // You can have as many arguments as you want, but you need to call
        // the base constructor with the provided nibName and bundle.
    }
}
```

Затем, чтобы загрузить ViewController из файла NIB, сделайте следующее:

```csharp
var controller = new MyViewController ("HelloWorld", NSBundle.MainBundle, this);
```

При этом пользовательский интерфейс загружается из NIB. Теперь, чтобы получить доступ к розеткам, необходимо сообщить среде выполнения о необходимости доступа к ним. Для этого `UIViewController` подкласс должен объявить свойства и добавить к нему атрибут [Connect]. Пример:

```csharp
[Connect]
UITextField UserName {
    get {
        return (UITextField) GetNativeField ("UserName");
    }
    set {
        SetNativeField ("UserName", value);
    }
}
```

Реализация свойства — это тот, который фактически извлекает и сохраняет значение для самого собственного типа.

При использовании Visual Studio для Mac и Интерфацебуилдер не нужно беспокоиться об этом. Visual Studio для Mac автоматически отражает все объявленные розетки с кодом в разделяемом классе, который компилируется как часть проекта.

#### <a name="selectors"></a>Селекторы

Основной концепцией программирования на языке C являются селекторы. Часто приходится использовать API, требующие передачи селектора, или предполагает, что ваш код будет отвечать на селектор.

Создание новых селекторов в C# очень просто. просто создайте новый экземпляр `ObjCRuntime.Selector` класса и используйте результат в любом месте API, которому он требуется. Например:

```csharp
var selector_add = new Selector ("add:plus:");
```

Для C# метода, отвечающего на вызов селектора, он должен наследовать `NSObject` от типа, C# а метод должен быть снабжен именем селектора с помощью `[Export]` атрибута. Например:

```csharp
public class MyMath : NSObject {
    [Export ("add:plus:")]
    int Add (int first, int second)
    {
         return first + second;
    }
}
```

Обратите внимание, что имена селекторов **должны** точно совпадать, включая все промежуточные и конечные двоеточия (":"), если они есть.

#### <a name="nsobject-constructors"></a>Конструкторы Нсобжект

Большинство классов в Xamarin. iOS, которые являются производными от `NSObject` , будут предоставлять конструкторы, относящиеся к функциональным возможностям объекта, но они также будут предоставлять различные конструкторы, которые не очевидны сразу.

Конструкторы используются следующим образом:

```csharp
public Foo (IntPtr handle)
```

Этот конструктор используется для создания экземпляра класса, когда среда выполнения должна сопоставлять ваш класс с неуправляемым классом. Это происходит при загрузке файла XIB/NIB.  На этом этапе среда выполнения цели-C создаст объект в неуправляемом мире, и этот конструктор будет вызван для инициализации управляемой стороны.

Как правило, все, что нужно сделать, — это вызвать базовый конструктор с параметром Handle, а в теле — выполнить необходимую инициализацию.

```csharp
public Foo ()
```

Это конструктор по умолчанию для класса, а в классах, предоставляемых Xamarin. iOS, инициализирует класс Foundation. нсобжект и все классы в между, а в конце привязывает его к методу цели-C `init` в классе.

```csharp
public Foo (NSObjectFlag x)
```

Этот конструктор используется для инициализации экземпляра, но запрещает коду вызывать метод цели-C "Init" в конце. Обычно этот параметр используется, если вы уже зарегистрировались для инициализации (при использовании `[Export]` в конструкторе) или если вы уже выполнили инициализацию с помощью другого среднего значения.

```csharp
public Foo (NSCoder coder)
```

Этот конструктор предоставляется для случаев, когда объект инициализируется из экземпляра Нскодинг. Дополнительные сведения см. в статье [по программированию архивов и сериализации](https://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/Archiving/index.html#//apple_ref/doc/uid/10000047i) для Apple.

#### <a name="exceptions"></a>Исключения

Структура API Xamarin. iOS не вызывает исключения цели-C как C# исключения. Проект применяет, что ни одна из них не будет отправлена в мир цели-C на первом месте и что все исключения, которые должны быть созданы, создаются привязкой, прежде чем недопустимые данные будут переданы в мир цели-C.

#### <a name="notifications"></a>Уведомления

В iOS и OS X разработчики могут подписываться на уведомления, которые рассылаются базовой платформой. Это делается с помощью `NSNotificationCenter.DefaultCenter.AddObserver` метода. Этот `AddObserver` метод принимает два параметра: одно — уведомление, на которое вы хотите подписываться; второй — метод, который вызывается при возникновении уведомления.

В Xamarin. iOS и Xamarin. Mac ключи для различных уведомлений размещаются в классе, который запускает уведомления. Например, уведомления, вызываемые, `UIMenuController` размещаются в `static NSString` виде свойств в `UIMenuController` классах, заканчивающихся именем Notification.

### <a name="memory-management"></a>Управление памятью

Xamarin. iOS имеет сборщик мусора, который потребует освобождения ресурсов, когда они больше не используются. Помимо сборщика мусора все объекты, производные от `NSObject` , `System.IDisposable` реализуют интерфейс.

#### <a name="nsobject-and-idisposable"></a>Нсобжект и IDisposable

Предоставление интерфейса — это удобный способ помочь разработчикам в освобождении объектов, которые могут инкапсулировать большие блоки памяти (например `UIImage` , может выглядеть как указатель безобидным, но можно указать на изображение размером 2 МБ). `IDisposable` ) и другие важные и ограниченные ресурсы (например, буфер декодирования видео).

Нсобжект реализует интерфейс IDisposable, а также [шаблон удаления .NET](https://msdn.microsoft.com/library/fs2xkftw.aspx). Это позволяет разработчикам, Нсобжект подкласс, переопределять поведение Dispose и освобождать свои ресурсы по запросу. Например, рассмотрим этот контроллер представления, который поддерживает несколько образов:

```csharp
class MenuViewController : UIViewController {
    UIImage breakfast, lunch, dinner;
    [...]
    public override void Dispose (bool disposing)
    {
        if (disposing){
             if (breakfast != null) breakfast.Dispose (); breakfast = null;
             if (lunch != null) lunch.Dispose (); lunch = null;
             if (dinner != null) dinner.Dispose (); dinner = null;
        }
        base.Dispose (disposing)
    }
}
```

Когда управляемый объект удаляется, он больше не используется. Возможно, у вас по-прежнему есть ссылка на объекты, но объект предназначен для всех целей и недопустимы в этой точке. Некоторые API-интерфейсы .NET гарантируют это, вызывая ObjectDisposedException при попытке получить доступ к любым методам удаленного объекта, например:

```csharp
var image = UIImage.FromFile ("demo.png");
image.Dispose ();
image.XXX = false;  // this at this point is an invalid operation
```

Даже если вы по-прежнему можете получить доступ к переменной "Image", она действительно является недопустимой ссылкой и больше не указывает на объект цели-C, который удерживал изображение.

Но удаление объекта в C# не означает, что объект будет обязательно уничтожен. Все, что C# вы сделаете, — освободить ссылку на объект. Возможно, среда Cocoa сохранила ссылку для использования в качестве собственной. Например, если задать изображение для свойства изображения Уиимажевиев, а затем удалить образ, базовый Уиимажевиев получил собственную ссылку и сохранит ссылку на этот объект, пока не завершит его использование.

#### <a name="when-to-call-dispose"></a>Когда следует вызывать Dispose

Метод Dispose следует вызывать, если требуется Mono при получении объекта. Возможный вариант использования заключается в том, что Mono не знает о том, что Нсобжект на самом деле содержит ссылку на важный ресурс, например память, или информационный пул. В таких случаях следует вызывать Dispose для немедленного освобождения ссылки на память вместо того, чтобы ждать, пока Mono выполняет цикл сборки мусора.

На внутреннем уровне, когда Mono создает [ссылки C# NSString из строк](~/ios/internals/api-design/nsstring.md), они немедленно удалят их, чтобы сократить объем работы, которую должен выполнить сборщик мусора. Чем меньше объектов для работы с ними работать, тем быстрее будет выполняться сборщик мусора.

#### <a name="when-to-keep-references-to-objects"></a>Когда следует размещать ссылки на объекты

Одним из побочных эффектов автоматического управления памятью является то, что сборщик мусора будет избавиться от неиспользуемых объектов, если на них нет ссылок. Это иногда может иметь неудивительное побочные эффекты, например, если вы создаете локальную переменную для размещения контроллера представления верхнего уровня или окна верхнего уровня, а затем помещаете эти данные в начало.

Если вы не сохраняете ссылку в статических переменных или переменные экземпляра для объектов, моно будет вызывать для них метод Dispose (), и они будут освобождать ссылку на объект. Так как это может быть единственная необработанная ссылка, среда выполнения цели-C уничтожает объект.

## <a name="related-links"></a>Связанные ссылки

- [Привязка полей](~/cross-platform/macios/binding/objective-c-libraries.md#Binding_Fields)
