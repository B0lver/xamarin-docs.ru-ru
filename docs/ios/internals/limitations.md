---
title: Ограничения Xamarin. iOS
description: В этом документе описаны ограничения для Xamarin. iOS, обсуждаются универсальные шаблоны, универсальные подклассы Нсобжектс, P/Invoke в универсальных объектах и многое другое.
ms.prod: xamarin
ms.assetid: 5AC28F21-4567-278C-7F63-9C2142C6E06A
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 04/09/2018
ms.openlocfilehash: 003ea31c765bd2610e93e0f85fe995606d55022f
ms.sourcegitcommit: 93e6358aac2ade44e8b800f066405b8bc8df2510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84567402"
---
# <a name="limitations-of-xamarinios"></a>Ограничения Xamarin. iOS

Так как приложения, использующие Xamarin. iOS, компилируются в статический код, невозможно использовать какие-либо средства, требующие создания кода во время выполнения.

Это ограничения Xamarin. iOS по сравнению с рабочим столом Mono:

 <a name="Limited_Generics_Support"></a>

## <a name="limited-generics-support"></a>Поддержка ограниченных универсальных шаблонов

В отличие от традиционных Mono/. NET, код на iPhone статически компилируется заранее, а не по требованию JIT-компилятором.

У [полной технологии AOT](https://www.mono-project.com/docs/advanced/aot/#full-aot) Mono есть несколько ограничений по отношению к универсальным шаблонам. Это обусловлено тем, что не все возможные универсальные экземпляры могут быть определены перед компиляцией во время компиляции. Это не является проблемой для обычных сред выполнения .NET или Mono, так как код всегда компилируется во время выполнения с помощью JIT-компилятора. Но это создает задачу для статического компилятора, такого как Xamarin. iOS.

Некоторые распространенные проблемы, с которыми работают разработчики, включают:

 <a name="Generic_Subclasses_of_NSObjects_are_limited"></a>

### <a name="generic-subclasses-of-nsobjects-are-limited"></a>Универсальные подклассы Нсобжектс ограничены

В настоящее время Xamarin. iOS поддерживает ограниченную поддержку создания универсальных подклассов класса Нсобжект, например без поддержки универсальных методов. Начиная с 7.2.1, можно использовать универсальные подклассы Нсобжектс, например:

```csharp
class Foo<T> : UIView {
    [..]
}
```

> [!NOTE]
> Хотя универсальные подклассы Нсобжектс возможны, существует ряд ограничений. Дополнительные сведения см. в [универсальных подклассах документа нсобжект](~/ios/internals/api-design/nsobject-generics.md) .

 <a name="No_Dynamic_Code_Generation"></a>

## <a name="no-dynamic-code-generation"></a>Без динамического создания кода

Так как ядро iOS предотвращает динамическое создание кода приложением, Xamarin. iOS не поддерживает никакие формы динамического создания кода. Сюда входит следующее.

- System. Reflection. Emit недоступен.
- Отсутствует поддержка System. Runtime. Remoting.
- Не поддерживается динамическое создание типов (без Type. GetType ("MyType ' 1")), хотя Поиск существующих типов (Type. GetType ("System. String"), например, работает прекрасно).
- Обратные обратные вызовы должны быть зарегистрированы в среде выполнения во время компиляции.

 <a name="System.Reflection.Emit"></a>

### <a name="systemreflectionemit"></a>System.Reflection.Emit

Отсутствие System. Reflection. **Выдача** означает, что код, зависящий от создания кода среды выполнения, не будет работать. Это включает в себя следующие вещи:

- Среда выполнения динамического языка.
- Все языки, созданные на основе среды динамического языка.
- Транспарентпрокси удаленного взаимодействия или любое другое, которое привело бы к динамическому созданию кода средой выполнения.

  > [!IMPORTANT]
  > Не путайте **отражение. Emit** с **отражением**. Отражение. Emit — это динамическое создание кода и его JIT и компиляция в машинный код. Из-за ограничений на iOS (без JIT-компиляции) это не поддерживается.

Но весь API отражения, включая Type. GetType ("Сомекласс"), список методов, список свойств, получение атрибутов и значений прекрасно работает.

### <a name="using-delegates-to-call-native-functions"></a>Использование делегатов для вызова собственных функций

Чтобы вызвать собственную функцию через делегат C#, объявление делегата должно быть дополнено одним из следующих атрибутов:

- [Унманажедфунктионпоинтераттрибуте](xref:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute) (предпочтительно, так как оно работает на разных платформах и совместимо с .NET Standard 1.1 +)
- [мононативефунктионврапператтрибуте](xref:ObjCRuntime.MonoNativeFunctionWrapperAttribute)

Если не предоставить один из этих атрибутов, будет вызвана ошибка времени выполнения, например:

```
System.ExecutionEngineException: Attempting to JIT compile method '(wrapper managed-to-native) YourClass/YourDelegate:wrapper_aot_native(object,intptr,intptr)' while running in aot-only mode.
```

 <a name="Reverse_Callbacks"></a>

### <a name="reverse-callbacks"></a>Обратные обратные вызовы

В стандартном моно можно передать экземпляры делегата C# в неуправляемый код вместо указателя на функцию. Среда выполнения обычно преобразует эти указатели функций в небольшой преобразователь, который позволяет неуправляемому коду осуществлять обратный вызов управляемого кода.

В Mono эти мосты реализуются JIT-компилятором. При использовании предварительного компилятора, необходимого для iPhone, на этом этапе есть два важных ограничения:

- Необходимо отметить все методы обратного вызова с помощью [монопинвокекаллбаккаттрибуте](xref:ObjCRuntime.MonoPInvokeCallbackAttribute)
- Методы должны быть статическими методами, но не поддерживаются методы экземпляров.

<a name="No_Remoting"></a>

## <a name="no-remoting"></a>Без удаленного взаимодействия

Стек удаленного взаимодействия недоступен в Xamarin. iOS.

 <a name="Runtime_Disabled_Features"></a>

## <a name="runtime-disabled-features"></a>Функции, отключенные в среде выполнения

Следующие функции отключены в среде выполнения iOS Mono:

- Profiler
- Отражение. Emit
- Функция Reflection. Emit. Save
- Привязки COM
- JIT-механизм
- Средство проверки метаданных (так как отсутствует JIT-компилятор)

 <a name=".NET_API_Limitations"></a>

## <a name="net-api-limitations"></a>Ограничения API .NET

Предоставляемый API .NET является подмножеством полной платформы, как не все доступно в iOS. [Список сборок, поддерживаемых в настоящее время](~/cross-platform/internals/available-assemblies.md), см. в разделе часто задаваемых вопросов.

В частности, профиль API, используемый Xamarin. iOS, не включает System. Configuration, поэтому невозможно использовать внешние XML-файлы для настройки поведения среды выполнения.
