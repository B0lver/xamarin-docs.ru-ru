---
title: "Новая система подсчета ссылок"
ms.topic: article
ms.prod: xamarin
ms.assetid: 0221ED8C-5382-4C1C-B182-6C3F3AA47DB1
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.openlocfilehash: dd4aff683b0cfb797147d32f282be1aab4c30667
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="new-reference-counting-system"></a>Новая система подсчета ссылок

Xamarin.iOS 9.2.1 появилась Улучшенная подсчета системы для всех приложений по умолчанию ссылок. Его можно использовать, чтобы устранить многие проблемы памяти, которые были трудно отслеживать и исправлять в более ранних версиях Xamarin.iOS.

## <a name="enabling-the-new-reference-counting-system"></a>Включение новой ссылки инвентаризации системы

Начиная с Xamarin 9.2.1 включен новый ref инвентаризации системы для **все** приложений по умолчанию.

Если вы разрабатываете приложение, можно проверить в CSPROJ-файл, чтобы убедиться, что все вхождения `MtouchUseRefCounting` присваиваются `true`, таких как ниже:

```xml
<MtouchUseRefCounting>true</MtouchUseRefCounting>
```

Если задано значение `false` приложения не будут использовать новое оборудование.

### <a name="using-older-versions-of-xamarin"></a>С помощью старых версий Xamarin

Xamarin.iOS 7.2.1 и выше возможности расширенного просмотра нашей новой ссылки инвентаризации системы.

**Классический API:**

Чтобы включить этот новый эталонной инвентаризации системы, проверьте **использовать расширение подсчетом ссылок** флажок найден в **Дополнительно** вкладке проекта **iOS параметры построения** , как показано ниже: 

[ ![](newrefcount-images/image1.png "Включить систему подсчета ссылок")](newrefcount-images/image1.png)

Обратите внимание, что эти параметры были удалены в более новых версиях Visual Studio для Mac.

 **[Универсальный интерфейс API:](~/cross-platform/macios/unified/index.md)**

 Новая ссылка подсчета расширения требуется для API единой и должен быть включен по умолчанию. Более старые версии интегрированная СРЕДА не возможно, это значение автоматически и возможно, установите флажок, его самостоятельно.

    
> [!IMPORTANT]
> **Примечание:** более раннюю версию этой функции с момента вокруг MonoTouch 5.2 но было доступно только для **sgen** экспериментальный предварительной версии. Этот новый улучшенную версию также доступна для **Боэм** сборщиком мусора.


Исторически были два вида объектов, управляемых Xamarin.iOS: те, которые были простое создание оболочки для собственного объекта (одноранговые объекты) и те, которые расширенные или добавлены новые функциональные возможности (производных объектов) — обычно за счет дополнительного в оперативной памяти. Ранее было возможно, что может дополнять объект одноранговых узлов с состоянием (например, путем добавления обработчика событий C#), но, мы сообщим объекта без ссылки и затем собрать. Это может вызвать сбой позже (например если среда выполнения C цель обратного вызова в управляемый объект).

Новая система автоматически обновит объектов одноранговых узлов в объекты, которые управляются средой выполнения, когда они хранят любой дополнительной информации.

Это позволяет решить различных сбоев, которые произошли в ситуациях, подобные следующему:

```csharp
class MyTableSource : UITableViewSource {
   public override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath) {
        var cell = tableView.DequeueReusableCell ("myId");
        if (cell != null)
                return cell;

        cell = new UITableViewCell (UITableViewCellStyle.Default, "myId");
        var txt = new UITextField ();
        txt.TouchDown += delegate { Console.WriteLine ("...."); };
        cell.ContentView.AddSubview (txt);
        return cell;
   }
}
```

Без расширения счетчик ссылок этот код может завершиться со сбоем из-за `cell` становится собираемой и поэтому его `TouchDown` делегировать, который будет преобразована в висящего указателя.

Расширение счетчик ссылок обеспечивает управляемый объект остается активным и блокирует его коллекции, предоставляемых собственный объект хранится в машинный код.

Новая система также избавляет от необходимости *большинство* закрытого резервного поля, используемые в привязках - которых является стандартным подходом для сохранения экземпляра. Управляемый компоновщика smart удалить все элементы *ненужные* расширения количество полей из приложений с помощью новой ссылки.

Это означает, что каждого экземпляра управляемого объекта потреблять меньше памяти, чем до. Она также позволяет решать связанная с этим проблема, где некоторые резервные поля будет содержать ссылки на которые больше не нужны средой выполнения Objective-C, что усложняет освободить некоторый объем памяти.
