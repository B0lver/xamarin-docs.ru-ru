---
title: Создание потоков в Xamarin. iOS
description: В этом документе описывается использование API-интерфейсов System. Threading в приложении Xamarin. iOS. В нем обсуждается Библиотека параллельных задач, создание приложений, реагирующих на запросы, и сборка мусора.
ms.prod: xamarin
ms.assetid: 50BCAF3B-1020-DDC1-0339-7028985AAC72
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 06/05/2017
ms.openlocfilehash: 30709b9b75c18f954135e950b95094f9ee2d71ac
ms.sourcegitcommit: 00e6a61eb82ad5b0dd323d48d483a74bedd814f2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/29/2020
ms.locfileid: "91435275"
---
# <a name="threading-in-xamarinios"></a>Создание потоков в Xamarin. iOS

Среда выполнения Xamarin. iOS предоставляет разработчикам доступ к API-интерфейсам потоков .NET, как явно, при использовании потоков (), так `System.Threading.Thread, System.Threading.ThreadPool` и неявно при использовании шаблонов асинхронных делегатов или методов BeginXXX, а также полный спектр интерфейсов API, поддерживающих библиотеку параллельных задач.

Xamarin настоятельно рекомендует использовать [библиотеку параллельных задач](/dotnet/standard/parallel-programming/task-parallel-library-tpl) (TPL) для создания приложений по нескольким причинам:

- Планировщик TPL по умолчанию делегирует выполнение задачи пулу потоков, который, в свою очередь, динамически увеличит количество потоков, необходимых для выполнения процесса, а также избежать ситуации, когда слишком много потоков приконкурирует к бесконечному времени ЦП. 
- Проще подумать об операциях с точки зрения задач TPL. Вы можете легко управлять ими, запланировать их, выполнять сериализацию выполнения или запускать множество параллельно с обширным набором интерфейсов API. 
- Это основа для программирования с использованием новых расширений языка C# Async. 

Пул потоков будет медленно увеличивать количество потоков по мере необходимости в зависимости от количества ядер ЦП, доступных в системе, загрузки системы и требований приложения. Этот пул потоков можно использовать либо путем вызова методов в или с `System.Threading.ThreadPool` помощью значения по умолчанию `System.Threading.Tasks.TaskScheduler` (части *параллельных платформ*).

Обычно разработчики используют потоки, когда им нужно создавать реагирующие приложения, и им не нужно блокировать основной цикл выполнения пользовательского интерфейса.

 <a name="Developing_Responsive_Applications"></a>

## <a name="developing-responsive-applications"></a>Разработка приложений для реагирования

Доступ к элементам пользовательского интерфейса должен быть ограничен тем же потоком, который выполняет основной цикл для вашего приложения. Если вы хотите внести изменения в основной пользовательский интерфейс из потока, следует поставить код в очередь с помощью [нсобжект. инвокеонмаинсреад](xref:Foundation.NSObject)следующим образом:

```csharp
MyThreadedRoutine ()  
{  
    var result = DoComputation ();  

    // we want to update an object that is managed by the main
    // thread; To do so, we need to ensure that we only access
    // this from the main thread:

    InvokeOnMainThread (delegate {  
        label.Text = "The result is: " + result;  
    });
}
```

Приведенный выше код вызывается внутри делегата в контексте основного потока, не вызывая каких либо состояний гонки, которые могут привести к сбою приложения.

 <a name="Threading_and_Garbage_Collection"></a>

## <a name="threading-and-garbage-collection"></a>Работа с потоками и сборка мусора

В процессе выполнения среда выполнения цели-C создаст и освободит объекты. Если объекты помечены для "автоматического выпуска", среда выполнения цели-C освобождает эти объекты в текущем потоке `NSAutoReleasePool` . Xamarin. iOS создает один `NSAutoRelease` пул для каждого потока из `System.Threading.ThreadPool` и для основного потока. Это расширение охватывает все потоки, созданные с помощью TaskScheduler по умолчанию в System. Threading. Tasks.

При создании собственных потоков с помощью `System.Threading` необходимо предоставить собственный `NSAutoRelease` пул, чтобы предотвратить утечку данных. Для этого просто заключите поток в следующую часть кода:

```csharp
void MyThreadStart (object arg)
{
   using (var ns = new NSAutoReleasePool ()){
      // Your code goes here.
   }
}
```

Примечание. Поскольку Xamarin. iOS 5,2 вам больше не нужно предоставлять свой собственный `NSAutoReleasePool` , так как он будет предоставляться автоматически.

## <a name="related-links"></a>Связанные ссылки

- [Работа с потоком пользовательского интерфейса](~/ios/user-interface/ios-ui/ui-thread.md)