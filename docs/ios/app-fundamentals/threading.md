---
title: Создание потоков в Xamarin. iOS
description: В этом документе описывается использование API-интерфейсов System. Threading в приложении Xamarin. iOS. В нем обсуждается Библиотека параллельных задач, создание приложений, реагирующих на запросы, и сборка мусора.
ms.prod: xamarin
ms.assetid: 50BCAF3B-1020-DDC1-0339-7028985AAC72
ms.technology: xamarin-ios
author: conceptdev
ms.author: crdun
ms.date: 06/05/2017
ms.openlocfilehash: 9de12f234bb4d18cb7a78f84f72f5e431409dac1
ms.sourcegitcommit: 933de144d1fbe7d412e49b743839cae4bfcac439
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2019
ms.locfileid: "70283044"
---
# <a name="threading-in-xamarinios"></a>Создание потоков в Xamarin. iOS

Среда выполнения Xamarin. iOS предоставляет разработчикам доступ к API-интерфейсам потоков .NET, как явно, при`System.Threading.Thread, System.Threading.ThreadPool`использовании потоков (), так и неявно при использовании шаблонов асинхронных делегатов или методов BeginXXX, а также полный спектр интерфейсов API, поддерживающих Библиотека параллельных задач.



Xamarin настоятельно рекомендует использовать [библиотеку параллельных задач](https://msdn.microsoft.com/library/dd460717.aspx) (TPL) для создания приложений по нескольким причинам:
- Планировщик TPL по умолчанию делегирует выполнение задачи пулу потоков, который, в свою очередь, динамически увеличит количество потоков, необходимых для выполнения процесса, а также избежать ситуации, когда слишком много потоков приконкурирует к бесконечному времени ЦП. 
- Проще подумать об операциях с точки зрения задач TPL. Вы можете легко управлять ими, запланировать их, выполнять сериализацию выполнения или запускать множество параллельно с обширным набором интерфейсов API. 
- Это основа для программирования с использованием новых C# расширений языка Async. 


Пул потоков будет медленно увеличивать количество потоков по мере необходимости в зависимости от количества ядер ЦП, доступных в системе, загрузки системы и требований приложения. Этот пул потоков можно использовать либо путем вызова методов в `System.Threading.ThreadPool` или с помощью значения по умолчанию `System.Threading.Tasks.TaskScheduler` (части *параллельных платформ*).

Обычно разработчики используют потоки, когда им нужно создавать реагирующие приложения, и им не нужно блокировать основной цикл выполнения пользовательского интерфейса.

 <a name="Developing_Responsive_Applications" />


## <a name="developing-responsive-applications"></a>Разработка приложений для реагирования

Доступ к элементам пользовательского интерфейса должен быть ограничен тем же потоком, который выполняет основной цикл для вашего приложения. Если вы хотите внести изменения в основной пользовательский интерфейс из потока, следует поставить код в очередь с помощью [нсобжект. инвокеонмаинсреад](xref:Foundation.NSObject)следующим образом:

```csharp
MyThreadedRoutine ()  
{  
    var result = DoComputation ();  

    // we want to update an object that is managed by the main
    // thread; To do so, we need to ensure that we only access
    // this from the main thread:

    InvokeOnMainThread (delegate {  
        label.Text = "The result is: " + result;  
    });
}
```

Приведенный выше код вызывается внутри делегата в контексте основного потока, не вызывая каких либо состояний гонки, которые могут привести к сбою приложения.

 <a name="Threading_and_Garbage_Collection" />


## <a name="threading-and-garbage-collection"></a>Работа с потоками и сборка мусора

В процессе выполнения среда выполнения цели-C создаст и освободит объекты. Если объекты помечены для "автоматического выпуска", среда выполнения цели-C освобождает эти объекты в текущем `NSAutoReleasePool`потоке. Xamarin. iOS создает один `NSAutoRelease` пул для каждого потока `System.Threading.ThreadPool` из и для основного потока. Это расширение охватывает все потоки, созданные с помощью TaskScheduler по умолчанию в System. Threading. Tasks.

При создании собственных потоков с помощью `System.Threading` необходимо предоставить собственный `NSAutoRelease` пул, чтобы предотвратить утечку данных. Для этого просто заключите поток в следующую часть кода:

```csharp
void MyThreadStart (object arg)
{
   using (var ns = new NSAutoReleasePool ()){
      // Your code goes here.
   }
}
```

Примечание. Так как Xamarin. iOS 5,2 вам `NSAutoReleasePool` больше не нужно предоставлять, так как он будет предоставляться автоматически.


## <a name="related-links"></a>Связанные ссылки

- [Работа с потоком пользовательского интерфейса](~/ios/user-interface/ios-ui/ui-thread.md)
