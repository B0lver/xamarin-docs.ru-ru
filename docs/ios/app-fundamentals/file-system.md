---
title: Работа с файловой системой
description: Xamarin.iOS можно использовать те же классы System.IO для работы с файлами и каталогами в iOS, который нужно использовать в любом приложении .NET. Тем не менее несмотря на знакомые классы и методы, iOS реализует некоторые ограничения для файлов, можно создать или получить доступ к и также предоставляет специальные средства для определенных каталогов. В этой статье описаны эти ограничения и возможности и показана работа приложения Xamarin.iOS доступ к файлам.
ms.prod: xamarin
ms.assetid: 37DF2F38-901E-8F8E-269A-5EE0CCD28C08
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/18/2017
ms.openlocfilehash: 0706e416861e5636413577d38bf524ce9184bc4d
ms.sourcegitcommit: dc882e9631b4ed52596b944a6fbbdde309346943
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2018
---
# <a name="working-with-the-file-system"></a>Работа с файловой системой

_Xamarin.iOS можно использовать те же классы System.IO для работы с файлами и каталогами в iOS, который нужно использовать в любом приложении .NET. Тем не менее несмотря на знакомые классы и методы, iOS реализует некоторые ограничения для файлов, можно создать или получить доступ к и также предоставляет специальные средства для определенных каталогов. В этой статье описаны эти ограничения и возможности и показана работа приложения Xamarin.iOS доступ к файлам._

Можно использовать Xamarin.iOS и `System.IO` классы в *библиотеки базовых классов (BCL) .NET* для доступа к файловой системе iOS. `File` Класс позволяет создавать, удалять и читать файлы и `Directory` класс позволяет создание, удаление или перечисление содержимого папки. Можно также использовать `Stream` подклассов, которые может обеспечить большую степень контроля над операции с файлами (например, сжатие или позицию поиска в файле).

iOS накладывает некоторые ограничения на приложение можно сделать с помощью файловой системы для защиты данных приложения и защитить пользователей от malignant приложений. Эти ограничения являются частью *изолированного приложения* — набор правил, который ограничивает доступ приложения к файлам, параметры, сетевым ресурсам, оборудования, и т. д. Приложения только для чтения и записи файлов в пределах своего домашнего каталога (расположение установки); он нет доступа к файлам другим приложением.

операций ввода-вывода также содержит некоторые функции системной файла: некоторые каталоги требуют специальной обработки в отношении резервного копирования и обновления и приложения также могут совместно использовать файлы через iTunes.

В этой статье обсуждаются возможности и ограничения iOS файловая система подробные и приводится пример приложения, демонстрирующий использование Xamarin.iOS для выполнения некоторых операций простой файловой системы:

 [![](file-system-images/05-sampleapp.png "Образец операций ввода-вывода при выполнении некоторых операций простой файловой системы")](file-system-images/05-sampleapp.png#lightbox)

 <a name="General_File_Access" />


## <a name="general-file-access"></a>Общий доступ к файлам

Xamarin.iOS позволяет использовать .NET `System.IO` классы для операций файловой системы в iOS.

В следующих фрагментах кода показаны некоторые распространенные операции с файлами. Вы найдете их все ниже в `SampleCode.cs` файла, в примере приложения для этой статьи.

 <a name="Working_with_directories" />


### <a name="working-with-directories"></a>Работа с каталогами

Этот код перечисляет подкаталоги текущего каталога (заданные «. /» параметра), — расположение исполняемый файл приложения.
Выходными данными будет список всех файлов и папок, которые развертываются с приложением (отображается в окне консоли при отладке).

```csharp
var directories = Directory.EnumerateDirectories("./");
foreach (var directory in directories) {
      Console.WriteLine(directory);
}
```

 <a name="Reading_files" />


### <a name="reading-files"></a>Чтение файлов

Чтобы прочитать текстовый файл, требуется только одна строка кода. В этом примере содержимое текстового файла будет отображаться в окне выходных данных приложения.

```csharp
var text = File.ReadAllText("TestData/ReadMe.txt");
Console.WriteLine(text);
```

 <a name="XML_Serialization" />


### <a name="xml-serialization"></a>XML-сериализация

Несмотря на то, что работа с полный `System.Xml` имен выходит за рамки данной статьи, можно легко выполнить десериализацию XML-документа из файловой системы с помощью StreamReader следующим образом:

```csharp
using (TextReader reader = new StreamReader("./TestData/test.xml")) {
      XmlSerializer serializer = new XmlSerializer(typeof(MyObject));
      var xml = (MyObject)serializer.Deserialize(reader);
}
```

Обратитесь к документации MSDN для [System.Xml](http://msdn.microsoft.com/library/system.xml.aspx) пространства имен, Дополнительные сведения о [сериализации](http://msdn.microsoft.com/library/system.xml.serialization.aspx). Следует также просмотреть [документации Xamarin.iOS](~/ios/deploy-test/linker.md) в строке компоновщика — обычно требуется добавить `[Preserve]` атрибут классы для сериализации.

 <a name="Creating_Files_and_Directories" />


### <a name="creating-files-and-directories"></a>Создание файлов и каталогов

В этом примере показано, как использовать `Environment` для доступа к папке «документы», где можно создать файлы и каталоги.

```csharp
var documents =
 Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments); 
var filename = Path.Combine (documents, "Write.txt");
File.WriteAllText(filename, "Write this text into a file");
```

Создание каталога — процесс очень похож.

```csharp
var documents =
 Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var directoryname = Path.Combine (documents, "NewDirectory");
Directory.CreateDirectory(directoryname);
```

Дополнительные сведения о пространстве имен System.IO см. в разделе [документации MSDN](http://msdn.microsoft.com/library/system.io.aspx).


### <a name="serializing-json"></a>Сериализация Json

Работа с Json данных в приложении Xamarin.iOS очень просто с помощью [Json.NET](http://www.newtonsoft.com/json) framework JSON высокой производительности для пакета NuGet .NET. Просто добавьте пакет NuGet для проекта приложения: 

[![](file-system-images/json01.png "Добавление пакета NuGet в проект приложения")](file-system-images/json01.png#lightbox)

Добавьте класс в качестве модели для сериализации и десериализации данных (в данном случае `Account.cs`):

```csharp
using System;
using System.Collections.Generic;
using Foundation; // for Preserve attribute, which helps serialization with Linking enabled

namespace FileSystem
{
    [Preserve]
    public class Account
    {
        #region Computed Properties
        public string Email { get; set; }
        public bool Active { get; set; }
        public DateTime CreatedDate { get; set; }
        public List<string> Roles { get; set; }
        #endregion

        #region Constructors
        public Account() {

        }
        #endregion
    }
}
```

Наконец, создайте экземпляр класса `Account` класса, выполнить его сериализацию в json-данных и записи в файл:

```csharp
// Create a new record
var account = new Account(){
    Email = "monkey@xamarin.com",
    Active = true,
    CreatedDate = new DateTime(2015, 5, 27, 0, 0, 0, DateTimeKind.Utc),
    Roles = new List<string> {"User", "Admin"}
};

// Serialize object
var json = JsonConvert.SerializeObject(account, Newtonsoft.Json.Formatting.Indented);

// Save to file
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var filename = Path.Combine (documents, "account.json");
File.WriteAllText(filename, json);
```
См. в Json .NET [документации](http://www.newtonsoft.com/json/help) Дополнительные сведения о работе с данными json в приложении .NET.

<a name="Special_Considerations" />

## <a name="special-considerations"></a>Специальные условия

Несмотря на сходство Xamarin.iOS и .NET операций с файлами, iOS и Xamarin.iOS отличаются от .NET, в некоторых важных аспектах.

 <a name="runtimeaccessible" />


### <a name="making-project-files-accessible-at-runtime"></a>Доступности файлов проекта во время выполнения

По умолчанию при добавлении файла в проект, он не будут включены в окончательную сборку и таким образом, не будут доступны для приложения. Для включения файла в сборку, необходимо отметить его с действием особой сборкой «содержимое».

Чтобы пометить файл для включения, щелкните правой кнопкой мыши на файле и выберите **действие при построении &gt; содержимого** в Visual Studio для Mac. Можно также изменить **действие при построении** в файле **свойства** листа.

 <a name="Case_Sensitivity" />


### <a name="case-sensitivity"></a>Учет регистра

Важно понимать, что файловая система iOS *регистра*. Это означает, что в имена файлов и каталогов должны точно совпадать — README.txt и readme.txt будет считаться разные имена файлов.

Это может привести к сбоям для разработчиков .NET, знакомых с файловой системой Windows, который является более *без учета регистра*— «Файлы», «Файлы» и «файлы» ссылаетесь на том же каталоге.

Таким образом несмотря на то, что устройства iOS чувствительны к регистру и кода должны записываться, помните, — симулятор iOS не учитывается регистра по умолчанию. Это означает, что если ваш регистр имени файла отличается от самого файла и ссылки на него в коде, программный код по-прежнему может работать в имитаторе, но что произойдет сбой на физическом устройстве. Это одна из причин, почему важно для развертывания на фактическом устройстве раннее и часто во время разработки iOS.

 <a name="Path_Separator" />


### <a name="path-separator"></a>Разделитель пути

операций ввода-вывода использует косой черты «/» в качестве разделителя пути (который отличается от Windows, в которых используется обратная косая черта "\").

Из-за этого отличия путаницу, поэтому рекомендуется использовать `System.IO.Path.Combine` метод, который настраивается в соответствии с текущей платформы, а не следует жестко кодировать разделителя конкретного пути. Это простой шаг, который делает код более мобильным на другие платформы.

 <a name="Application_Sandbox" />


## <a name="application-sandbox"></a>Приложение "песочницы"

Приложения доступ к файловой системе (и другие ресурсы, например, функции с сетью и оборудованием) ограничен по соображениям безопасности. Это ограничение, называется *изолированного приложения*. С точки зрения файловой системы приложения ограничено Создание и удаление файлов и каталогов в свой домашний каталог.

Корневой каталог — отдельную папку в файловой системе, где хранятся приложения и все ее данные. Невозможно выбрать (или изменить) расположение основной каталог для приложения; Однако iOS и Xamarin.iOS предоставляют свойства и методы для управления файлами и каталогами внутри.

 <a name="The_Application_Bundle" />


## <a name="the-application-bundle"></a>Пакет приложения

*Пакета приложения* — папка, которая содержит приложение.
Он отличается от других папок, задав .app суффикс, добавляемый к имени каталога. Ваш пакет приложения содержит исполняемый файл, а также все содержимое (файлы, изображения, т. д.) для проекта.

При просмотре вашего пакета приложения в Mac OS, он отображается с помощью разных значков не появиться в других каталогах (и суффикс .app скрыт); Тем не менее это просто регулярного каталога, который по-разному отображая операционной системы.

Для просмотра набора приложений, в образце кода, щелкните правой кнопкой мыши проект в Visual Studio для Mac и выберите **открыть папку, содержащую**. Перейдите к **bin/Debug/** где необходимо найти значка приложения (как на снимке экрана ниже).

 [![](file-system-images/40-bundle.png "Перейдите к bin/Debug, чтобы найти аналогичные на следующий снимок экрана значка приложения")](file-system-images/40-bundle.png#lightbox)

Щелкните правой кнопкой мыши на этот значок и кнопку **Просмотр содержимого пакета** для просмотра содержимого каталога пакета приложения. Содержимое отображается так же, как содержимое регулярного каталога, как показано ниже:

 [![](file-system-images/45-bundle.png "Содержимое пакета приложения")](file-system-images/45-bundle.png#lightbox)

Пакет приложения установленных в симуляторе или на устройстве во время тестирования, который в конечном итоге его отправке в Apple для включения в магазине приложений.

 <a name="Application_Directories" />


## <a name="application-directories"></a>Каталоги приложений

При установке приложения на устройстве, создает свой домашний каталог операционной системы и помещает вашего пакета приложения внутри. Код может обращаться к пакет приложения для чтения данных, но ничего не должен быть записан, корневой каталог, как он подписан и любых изменений будет недействительным приложения и препятствовать запуску.

Поэтому, несмотря на то, что ничего не должен быть записан в корневом каталоге <b>в iOS 7 и более ранних</b> создает несколько каталогов в корневой папке приложения, доступные для использования. <b>В iOS 8, недоступны для пользователей каталоги <a href="https://developer.apple.com/library/ios/technotes/tn2406/_index.html" target="_blank">находятся</a> в корневой папке приложения</b>.

Ниже перечислены эти каталоги и их назначение.

&nbsp;

|Каталог|Описание|
|---|---|
|[ApplicationName] .app /|**В iOS 7 и более ранних** это `ApplicationBundle` каталог, где хранятся исполняемый файл приложения. Структура каталогов, создаются в приложении существует в этом каталоге (например, изображения и другие типы файлов, которые помечены как ресурсы в Visual Studio для Mac проекта).<br /><br />Если требуется доступ к файлам содержимого внутри вашего приложения пакета, путь к этому каталогу доступен через `NSBundle.MainBundle.BundlePath` свойство.|
|Документы и|Используйте этот каталог для хранения пользовательские документы и файлы данных приложения.<br /><br />Содержимое этого каталога можно обеспечить пользователю файлам iTunes (хотя это отключено по умолчанию). Добавить `UIFileSharingEnabled` логическое ключ в файле Info.plist, чтобы разрешить пользователям доступ к этим файлам.<br /><br />Даже если приложение не сразу же включить общий доступ к файлам, следует избегать размещения файлов, которые должны быть скрыты от пользователей в этом каталоге (такие как файлы базы данных, если не требуется использовать их совместно). При условии, что файлы с конфиденциальной информацией остаются скрытыми, эти файлы будут не предоставляется (и потенциально перемещен, изменении или удалении с iTunes) Если включено совместное использование файлов в будущих версиях.<br /><br /> Можно использовать `Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments)` метод для получения пути к каталогу документов для вашего приложения.<br /><br />Содержимое этого каталога архивировались iTunes.|
|Библиотеки и|Каталог библиотеки удобно использовать для хранения файлов, которые не создаются непосредственно пользователем, таких как базы данных или другие файлы, создаваемые приложением. Содержимое этого каталога никогда не предоставляются пользователю через iTunes.<br /><br />Можно создать собственные подкаталоги в библиотеке. Однако уже есть некоторые созданные системой каталоги здесь, следует иметь в виду объекта, включая параметры и кэши.<br /><br />Содержимое этого каталога (за исключением подкаталог кэши) архивировались iTunes. Настраиваемые каталоги, созданные в библиотеке будут создаваться резервные копии.|
|Параметры библиотеки / /|Предпочтения конкретного приложения файлы хранятся в этом каталоге. Не создаются непосредственно эти файлы. Вместо этого используйте `NSUserDefaults` класса.<br /><br />Содержимое этого каталога архивировались iTunes.|
|Библиотеки и кэши /|Каталог кэша является оптимальным местом для хранения файлов данных, которые могут помочь приложения запустите, но, может быть легко восстановлен, если это необходимо. Приложение должно создать и удалить эти файлы по мере необходимости и иметь возможность повторного создания этих файлов, при необходимости. iOS 5 также может удалить эти файлы (в ситуациях очень низкие хранилища), однако он не будет выполнено во время выполнения приложения.<br /><br />Содержимое этого каталога не резервное копирование в iTunes, это означает, что они не будут перенесены в том случае, если пользователь восстанавливает с устройства, и они не могут находиться после установки обновленную версию приложения.<br /><br />Например в случае, если приложение не удается подключиться к сети, можно использовать каталог кэша для хранения данных или файлы для обеспечения эффективной работы вне сети. Приложения можно сохранить и быстро получать эти данные во время ожидания ответов сети, но он не требуется для резервного копирования и можно легко восстановить или восстановлены после восстановления или версию обновления.|
|TMP /|Приложения можно хранить временные файлы, которые требуются только на короткий промежуток времени, в этом каталоге. Чтобы сэкономить место, файлы должны быть удалены, если они больше не требуются. Если приложение не выполняется операционная система может удалить файлы из этого каталога.<br /><br />Содержимое этого каталога не резервное копирование в iTunes.<br /><br />Например каталог tmp может использоваться для хранения временных файлов, загружаются для отображения пользователю (например аватары Twitter или вложений электронной почты), но который может быть удалена, когда они были просмотреть (и при необходимости в будущем будут загружаться снова ).|

На этом снимке экрана показана структура каталогов в окне поиска.

 [![](file-system-images/08-library-directory.png "На этом снимке экрана показана структура каталогов в окне поиска")](file-system-images/08-library-directory.png#lightbox)

 <a name="Accessing_Other_Directories_Programmatically" />

### <a name="accessing-other-directories-programmatically"></a>Программный доступ к другим каталогам

Предыдущих примерах каталогов и файлов доступ к `Documents` каталога. Для записи в другой каталог, следует создать пути с помощью «..» синтаксис, как показано ниже:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var library = Path.Combine (documents, "..", "Library");
var filename = Path.Combine (library, "WriteToLibrary.txt");
File.WriteAllText(filename, "Write this text into a file in Library");
```

Создание каталога очень похож:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var library = Path.Combine (documents, "..", "Library");
var directoryname = Path.Combine (library, "NewLibraryDirectory");
Directory.CreateDirectory(directoryname);
```

Пути к `Caches` и `tmp` каталоги могут создаваться следующим образом:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var cache = Path.Combine (documents, "..", "Library", "Caches");
var tmp = Path.Combine (documents, "..", "tmp");
```

 <a name="Sharing_Files_with_the_User_through_iTunes" />


## <a name="sharing-files-with-the-user-through-itunes"></a>Совместное использование файлов с пользователем с помощью iTunes

Пользователям доступны файлы в каталоге приложения документы, изменив `Info.plist` и создание **поддерживает приложение управления доступом iTunes** (`UIFileSharingEnabled`) запись в **источника** представления, как показан ниже:

 [![](file-system-images/09-uifilesharingenabled-plist.png "Добавление приложения поддерживает общий доступ к свойству iTunes")](file-system-images/09-uifilesharingenabled-plist.png#lightbox)

Эти файлы можно получить в iTunes, когда устройство подключено, а пользователь выбирает `Apps` вкладки. Например на следующем рисунке показан файлы в общих через iTunes выбранного приложения:

 [![](file-system-images/10-itunes-file-sharing.png "На этом снимке экрана показаны файлы в общих через iTunes выбранного приложения")](file-system-images/10-itunes-file-sharing.png#lightbox)

Пользователям доступны только элементы верхнего уровня в этом каталоге через iTunes. Они не могут видеть содержимое всех его подкаталогах (хотя их можно скопировать их на свой компьютер и удалить их). Например с GoodReader, PDF и EPUB файлы можно использовать совместно с приложение, чтобы пользователи могут читать их на устройствах iOS.

Пользователям, которые изменяют содержимое своих папок документов может вызвать проблемы, если не соблюдать осторожность. Приложения должны учитывать это и быть устойчивыми к разрушительных обновления папки «документы».

В образце кода для данной статьи создает файл и папку в папке "документы" (в **SampleCode.cs**) и обеспечивает общий доступ к файлам в **Info.plist** файла. На этом снимке экрана показано, как они отображаются в iTunes:

 [![](file-system-images/15-itunes-file-sharing-example.png "На этом снимке экрана показано, как отображаются файлы в iTunes")](file-system-images/15-itunes-file-sharing-example.png#lightbox)

Ссылаться на [работа с образами](~/ios/app-fundamentals/images-icons/index.md) статьи для получения сведений о том, как определение значков для приложения и для любых типов настраиваемого документа создается.

Если `UIFileSharingEnabled` ключ — значение false или не существует, то общий доступ к файлам, по умолчанию отключена и пользователи не смогут взаимодействовать с вашей Documentsdirectory.

 <a name="Backup_and_Restore" />

## <a name="backup-and-restore"></a>Архивация и восстановление

Когда устройство резервной копии, созданной iTunes, все каталоги, созданные в корневом каталоге приложения будет сохранен, за исключением следующих:

-   **[ApplicationName] .app** — пакет приложения *does* создаваться резервные копии, но только при изменении пакета (если обновления приложения установлена, например). Не следует изменить этот каталог в любом случае, так как он подписан и поэтому должны оставаться неизменными после установки. 
-   **Библиотеки и кэши** — каталог кэша предназначен для рабочих файлов, которые не обязательно для резервного копирования. 
-   **TMP** — этот каталог используется для временных файлов, которые создаются и удаляются, когда больше не нужны, или для файлов, операций ввода-вывода при удаляет необходимое пространство. 


Резервное копирование большой объем данных может занять много времени. Если вы решите, нужно выполнить резервное копирование данных или определенного документа, в приложении следует использовать только документы и библиотеки папок для этого. Для временных данных или файлов, которые можно легко извлечь из сети используйте кэши или каталог tmp.

Имейте в виду, что iOS будет «очистить» файловая система запускаемый устройства критически мало свободного места на диске. Этот процесс приведет к удалению всех файлов из библиотеки и кэши и tmp папки приложений, которые в данный момент не выполняются.

 <a name="Complying_with_iOS5_iCloud_Backup_Restrictions" />

## <a name="complying-with-ios5-icloud-backup-restrictions"></a>Ответственность за соблюдение iOS5 iCloud ограничения резервного копирования

Apple появился *резервного копирования iCloud* функциональные возможности с iOS 5. При включении резервного копирования iCloud, все файлы в корневом каталоге приложения (за исключением каталоги, которые обычно не резервного копирования, например, набор приложений, `Caches` и `tmp`) сохраненный в резервной копии на серверы iCloud. Эта функция предоставляет пользователю полную резервную копию в случае их утери, кражи или устройств повреждена.

Поскольку iCloud предоставляет только 5 ГБ пространства «» для каждого пользователя, но чтобы избежать без необходимости использования пропускной способности, Apple ожидает приложениям только резервное копирование важных созданное пользователем данных. В соответствии с iOS правила хранения данных следует ограничить объем данных, резервного копирования, придерживаясь следующих элементов:

-  Храните только данные, созданные пользователем, или данные, не может быть создана повторно в каталоге "документы" (это резервных копий). 
-  Остальные данные, можно легко повторно создана или повторно загрузить в `Library/Caches` или `tmp` (который не является резервной копии и удалось «очистить»). 
-  При наличии файлов, которые можно применять к `Library/Caches` или `tmp` папки, но не требуется «очистить», сохранять их в другом месте (например `Library/YourData` ) и применить "не вверх" атрибута для предотвращения файлов с помощью стрелок вверх ba резервное копирование в iCloud ndwidth и место на диске. Эти данные по-прежнему использует пространство на устройстве, поэтому следует внимательное управление и удалите его, если это возможно. 

"Не создавать резервную копию" атрибут задается с помощью `NSFileManager` класса. Убедитесь, класс `using Foundation` и вызвать `SetSkipBackupAttribute` следующим образом:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var filename = Path.Combine (documents, "LocalOnly.txt");
File.WriteAllText(filename, "This file will never get backed-up. It would need to be re-created after a restore or re-install");
NSFileManager.SetSkipBackupAttribute (filename, true); // backup will be skipped for this file
```

Когда `SetSkipBackupAttribute` — `true` файл не будет резервной копии, независимо от того, хранится в каталог (даже `Documents` каталога). В запросах можно использовать атрибут `GetSkipBackupAttribute` метод и можно сбросить, вызвав `SetSkipBackupAttribute` метод с `false`, следующим образом:

```csharp
NSFileManager.SetSkipBackupAttribute (filename, false); // file will be backed-up
```

## <a name="sharing-data-between-ios-apps-and-app-extensions"></a>Данные от операций ввода-вывода приложения и расширения приложения для управления доступом

Расширения приложение выполняется как часть ведущего приложения (в отличие от содержащего приложения), общий доступ к данным не является автоматической включены, поэтому дополнительные действия не требуются. Группы приложений — это механизм iOS использует, чтобы разрешить различные приложения для обмена данными. Если приложения правильно настроены правильные права и подготовки, получить доступ к общему каталогу за пределами песочнице обычных операций ввода-вывода.

### <a name="configure-an-app-group"></a>Настройка группы приложений

Общее расположение настраивается с помощью [группы приложения](https://developer.apple.com/library/ios/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW19), настроенной в **сертификатов, профили & идентификаторы** статьи на [центра разработки iOS](https://developer.apple.com/devcenter/ios/). Это значение также должна иметься ссылка в каждом проекте **Entitlements.plist**.

Сведения о создании и настройке группы приложений [возможности группами приложений](~/ios/deploy-test/provisioning/capabilities/app-groups-capabilities.md) руководства.

### <a name="files"></a>Файлы

Приложения iOS и расширение также можно совместно использовать файлы, используя общий путь к файлу (учитывая их должным образом настроены правильные права и подготовки):

```csharp
var FileManager = new NSFileManager ();
var appGroupContainer =FileManager.GetContainerUrl ("group.com.xamarin.WatchSettings");
var appGroupContainerPath = appGroupContainer.Path

Console.WriteLine ("Group Path: " + appGroupContainerPath);

// use the path to create and update files
...
```
> [!IMPORTANT]
> Если путь к группы возвращается `null`, проверьте конфигурацию прав и подготовительный профиль и убедитесь, что они верны.


<a name="Application_Version_Updates" />

## <a name="application-version-updates"></a>Обновления приложений

После загрузки новой версии приложения iOS создается новый основной каталог и сохраняет новый пакет приложения в нем. затем iOS перемещает следующие папки из предыдущей версии соответствующего набора приложений в домашнем каталоге:

-  **Документы**
-  **Библиотека**


Другие каталоги могут также можно копировать между и поместить в домашнем каталоге, но они не гарантирует копировать, поэтому приложения не следует полагаться на это поведение системы.

<a name="Summary" />

## <a name="summary"></a>Сводка

В этой статье показали, что операции файловой системы являются простым с Xamarin.iOS как и в случае с другими приложениями .NET. Также появилась изолированного приложения и проанализировать проблемы безопасности, которые она вызывает. Затем он изучена концепцию комплект приложения. Наконец перечислены специальные каталоги, доступные для приложения и описано их роли во время обновления приложения и резервные копии.


## <a name="related-links"></a>Связанные ссылки

- [FileSystemSampleCode](https://developer.xamarin.com/samples/FileSystemSampleCode/)
- [Руководство по программированию системных файлов](http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/Introduction/Introduction.html)
- [Файл регистрации типов поддерживается данным приложения](http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/DocumentInteraction_TopicsForIOS/Articles/RegisteringtheFileTypesYourAppSupports.html#/apple_ref/doc/uid/TP40010411-SW1)
