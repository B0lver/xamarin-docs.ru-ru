---
title: Работа с файловой системой в Xamarin.iOS
description: В этом документе описывается работа с файловой системой в Xamarin.iOS. Здесь рассматриваются каталоги, чтение файлов, сериализации XML и JSON, "песочница" приложений, совместное использование файлов с помощью iTunes и многое другое.
ms.prod: xamarin
ms.assetid: 37DF2F38-901E-8F8E-269A-5EE0CCD28C08
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/18/2017
ms.openlocfilehash: cf595b57906cf1c47acdcdbcddf04bfbdc963393
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50113434"
---
# <a name="working-with-the-file-system-in-xamarinios"></a>Работа с файловой системой в Xamarin.iOS

Можно использовать Xamarin.iOS и `System.IO` классы в *библиотеки базовых классов (BCL) .NET* для доступа к файловой системе iOS. `File` Класс позволяет создавать, удалять и читать файлы и `Directory` класс позволяет создавать, удалять или перечислять содержимое каталогов. Можно также использовать `Stream` подклассов, которые может предоставить большую степень контроля над операции с файлами (например, сжатие или позицию поиска в файле).

iOS накладывает некоторые ограничения на приложения можно сделать с помощью файловой системы для обеспечения безопасности данных приложения и для защиты пользователей от malignant приложений. Эти ограничения являются частью *приложения "песочницы"* — набор правил доступа приложения к файлы, настройки, сетевые ресурсы, оборудования, и т.д. Приложение ограничено чтение и запись файлов в пределах его домашний каталог (расположения); он нет доступа к файлам других приложений.

iOS также есть некоторые возможности конкретной системы файл: некоторые каталоги требуют специальной обработки по отношению к резервное копирование и обновление, и приложения также могут совместно использовать файлы через iTunes.

В этой статье рассматриваются функции и ограничения из iOS файловая система подробно и приводится пример приложения, демонстрирующий использование Xamarin.iOS для выполнения некоторых операций простой файловой системы:

 [![](file-system-images/05-sampleapp.png "Пример выполнения некоторых операций простой файловой системы iOS")](file-system-images/05-sampleapp.png#lightbox)

 <a name="General_File_Access" />

## <a name="general-file-access"></a>Общий доступ к файлам

Xamarin.iOS позволяет использовать .NET `System.IO` классы для операций файловой системы на устройствах iOS.

В следующих фрагментах кода показаны некоторые общие файловые операции. Вы найдете их все ниже в `SampleCode.cs` файла, в примере приложения для этой статьи.

<a name="Working_with_directories" />

### <a name="working-with-directories"></a>Работа с каталогами

Этот код перечисляет подкаталоги в текущем каталоге (указанного по «. /» параметр), — расположение исполняемого файла приложения.
Выходные данные будут представлять собой список все файлы и папки, которые развертываются с приложением (отображается в окне консоли при отладке).

```csharp
var directories = Directory.EnumerateDirectories("./");
foreach (var directory in directories) {
      Console.WriteLine(directory);
}
```

 <a name="Reading_files" />


### <a name="reading-files"></a>Чтение файлов

Чтобы прочитать текстовый файл, требуется только одной строки кода. В этом примере содержимое текстового файла будет отображаться в окне выходных данных приложения.

```csharp
var text = File.ReadAllText("TestData/ReadMe.txt");
Console.WriteLine(text);
```

 <a name="XML_Serialization" />


### <a name="xml-serialization"></a>XML-сериализация

Несмотря на то, что работа с полный `System.Xml` пространство имен выходит за рамки данной статьи, их можно легко десериализовать XML-документа из файловой системы с помощью StreamReader следующим образом:

```csharp
using (TextReader reader = new StreamReader("./TestData/test.xml")) {
      XmlSerializer serializer = new XmlSerializer(typeof(MyObject));
      var xml = (MyObject)serializer.Deserialize(reader);
}
```

См. в документации MSDN [System.Xml](http://msdn.microsoft.com/library/system.xml.aspx) пространства имен Дополнительные сведения о [сериализации](http://msdn.microsoft.com/library/system.xml.serialization.aspx). Следует также просмотреть [документация по Xamarin.iOS](~/ios/deploy-test/linker.md) в строке компоновщика — обычно требуется добавить `[Preserve]` атрибут классы для сериализации.

 <a name="Creating_Files_and_Directories" />


### <a name="creating-files-and-directories"></a>Создание файлов и каталогов

В этом примере показано, как использовать `Environment` класс для доступа к папке «документы», где можно создать файлы и каталоги.

```csharp
var documents =
 Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments); 
var filename = Path.Combine (documents, "Write.txt");
File.WriteAllText(filename, "Write this text into a file");
```

Создание каталога — процесс очень похож.

```csharp
var documents =
 Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var directoryname = Path.Combine (documents, "NewDirectory");
Directory.CreateDirectory(directoryname);
```

Дополнительные сведения о пространстве имен System.IO см. в разделе [документации MSDN](http://msdn.microsoft.com/library/system.io.aspx).


### <a name="serializing-json"></a>Сериализация Json

Работа с Json данных в приложении Xamarin.iOS очень просто с помощью [Json.NET](http://www.newtonsoft.com/json) JSON платформа высокой производительности для пакета .NET NuGet. Просто добавьте пакет NuGet для проекта приложения: 

[![](file-system-images/json01.png "Добавление пакета NuGet в проект приложения")](file-system-images/json01.png#lightbox)

Добавьте класс в качестве модели данных для сериализации и десериализации (в данном случае `Account.cs`):

```csharp
using System;
using System.Collections.Generic;
using Foundation; // for Preserve attribute, which helps serialization with Linking enabled

namespace FileSystem
{
    [Preserve]
    public class Account
    {
        #region Computed Properties
        public string Email { get; set; }
        public bool Active { get; set; }
        public DateTime CreatedDate { get; set; }
        public List<string> Roles { get; set; }
        #endregion

        #region Constructors
        public Account() {

        }
        #endregion
    }
}
```

Наконец, создайте экземпляр `Account` класса, выполнить его сериализацию в данные json и записать их в файл:

```csharp
// Create a new record
var account = new Account(){
    Email = "monkey@xamarin.com",
    Active = true,
    CreatedDate = new DateTime(2015, 5, 27, 0, 0, 0, DateTimeKind.Utc),
    Roles = new List<string> {"User", "Admin"}
};

// Serialize object
var json = JsonConvert.SerializeObject(account, Newtonsoft.Json.Formatting.Indented);

// Save to file
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var filename = Path.Combine (documents, "account.json");
File.WriteAllText(filename, json);
```
См. в Json .NET [документации](http://www.newtonsoft.com/json/help) Дополнительные сведения о работе с данными json в приложении .NET.

<a name="Special_Considerations" />

## <a name="special-considerations"></a>Особые замечания

Несмотря на схожесть Xamarin.iOS и .NET операций с файлами, iOS и Xamarin.iOS отличаются от .NET, в некоторых важных аспектах.

 <a name="runtimeaccessible" />


### <a name="making-project-files-accessible-at-runtime"></a>Доступности файлов проекта во время выполнения

По умолчанию при добавлении файла в проект, он не будут включены в окончательную сборку и таким образом, не будут доступны для приложения. Чтобы включить файл в сборку, необходимо отметить его с действием особой сборкой, «содержимое».

Чтобы пометить файл для включения, щелкните правой кнопкой мыши, файлов и выберите **действие при построении &gt; содержимого** в Visual Studio для Mac. Можно также изменить **действие при построении** в файле **свойства** таблицы стилей.

 <a name="Case_Sensitivity" />


### <a name="case-sensitivity"></a>Учет регистра

Важно понимать, что файловая система iOS *регистр*. Это означает, что в имена файлов и каталогов должны точно совпадать – файл README.txt и readme.txt будет считаться разные имена файлов.

Это может привести к сбоям для разработчиков .NET, которые знакомы с файловой системой Windows, который является *без учета регистра*– «Файлы», «Файлы» и «файлы» ссылаетесь на том же каталоге.

Таким образом несмотря на то, что устройства iOS чувствительны к регистру и кода должны записываться таким помнить, состоит в симуляторе iOS регистра с учетом символов по умолчанию. Это означает, если регистр в имени файла отличаются от самого файла и ссылки на него в коде, коде по-прежнему может работать в симуляторе, но что произойдет сбой на реальных устройствах. Это одна из причин, почему важно для развертывания на настоящем устройстве более ранней и часто во время разработки iOS.

 <a name="Path_Separator" />


### <a name="path-separator"></a>Разделитель пути

iOS для этого используется знак косой черты «/» как разделитель пути (который отличается от Windows, которая использует обратную косую черту "\").

Из-за этого отличия путаницу, рекомендуется использовать `System.IO.Path.Combine` метод, который настраивает для текущей платформы, а не следует жестко кодировать разделитель конкретного пути. Это простое действие, которое делает код более пригодным для переноса на другие платформы.

 <a name="Application_Sandbox" />


## <a name="application-sandbox"></a>Приложение "песочницы"

Доступ приложения к файловой системе (и другие ресурсы, такие как функции сети и оборудования) ограничена по соображениям безопасности. Это ограничение называется *приложения "песочницы"*. С точки зрения файловой системе приложение ограничено Создание и удаление файлов и каталогов в своем домашнем каталоге.

Корневой каталог — это уникальное расположение в файловой системе, где хранятся ваши приложения и все его данные. Нельзя выбрать (или изменить) расположение домашнего каталога для приложения; Тем не менее iOS и Xamarin.iOS предоставляют свойства и методы для управления файлами и каталогами внутри.

 <a name="The_Application_Bundle" />


## <a name="the-application-bundle"></a>Пакет приложений

*Набор приложений* — папка, которая содержит приложение.
Он отличается от других папках, задав .app суффикс, добавляемый к имени каталога. Ваш пакет приложения содержит исполняемый файл и все содержимое (файлы, изображения, и т.д.) требуется для вашего проекта.

При переходе к вашего пакета приложения в Mac OS, он отображается другим значком не вы видите в других каталогах (и суффикс .app скрыт); Тем не менее это просто регулярных каталога, который отображает ОС по-разному.

Чтобы просмотреть пакет приложений для примера кода, щелкните правой кнопкой мыши проект в Visual Studio для Mac и выберите **открыть содержащую папку**. Затем перейдите к **bin/Debug/** где должны найдешь значка приложения (как на снимке экрана ниже).

 [![](file-system-images/40-bundle.png "Перейдите к bin/Debug, чтобы найти примерно значка приложения")](file-system-images/40-bundle.png#lightbox)

Щелкните этот значок правой кнопкой мыши и выберите **Просмотр содержимого пакета** для просмотра содержимого каталога пакета приложения. Содержимое отображается так же, как содержимое регулярных каталога, как показано ниже:

 [![](file-system-images/45-bundle.png "Содержимое пакета приложения")](file-system-images/45-bundle.png#lightbox)

— Пакет приложений, установленных в симуляторе или на устройстве во время тестирования, и в конечном счете это что отправляется в Apple для включения в App Store.

 <a name="Application_Directories" />


## <a name="application-directories"></a>Каталоги приложения

При установке приложения на устройстве, операционная система создает его домашний каталог и помещает вашего пакета приложения внутри. Ваш код может обращаться к пакет приложений для чтения данных, но ничего не должны записываться в этот корневой каталог, так как она подписана и каких-либо изменений будет недействительным приложения и предотвратить ее запуск.

Да, несмотря на то, что ничего не должны записываться в корневой каталог <b>в iOS 7 и более ранних версий</b> создает несколько каталогов в корневой каталог приложения, которые доступны для использования. <b>В iOS 8, недоступны для пользователей каталогов <a href="https://developer.apple.com/library/ios/technotes/tn2406/_index.html" target="_blank">находятся</a> в корне приложения</b>.

Ниже перечислены эти каталоги и их назначение.

&nbsp;

|Каталог|Описание|
|---|---|
|.App [ApplicationName] /|**В iOS 7 и более ранних версий** это `ApplicationBundle` каталог, где хранится исполняемый файл приложения. Структура каталогов, которая создается в приложении существует в этом каталоге (например, изображений и других типов файлов, которые вы пометили как ресурсы в Visual Studio для Mac проекта).<br /><br />Если вам требуется доступ к файлам содержимого внутри вашего пакета приложения, путь к этому каталогу доступен через `NSBundle.MainBundle.BundlePath` свойство.|
|Документы /|Используйте этот каталог для хранения пользовательские документы и файлы данных приложения.<br /><br />Содержимое этого каталога может предоставляться пользователю через iTunes файлам (несмотря на то, что эта функция отключена по умолчанию). Добавление `UIFileSharingEnabled` логический ключ в файле Info.plist, чтобы разрешить пользователям доступ к этим файлам.<br /><br />Даже если приложение не позволяет сразу же использовать общий доступ к файлам, следует избегать размещения файлов, которые должны быть скрыты от пользователей в этом каталоге (такие как файлы базы данных, если не требуется использовать их совместно). До тех пор, пока конфиденциальные файлы остаются скрытыми, эти файлы будут не доступны (и потенциально перемещен, измененные или удаленные, iTunes) при включении общего доступа к файлам в будущей версии.<br /><br /> Можно использовать `Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments)` метод, чтобы получить путь к каталогу документов для вашего приложения.<br /><br />Содержимое этого каталога резервное копирование по iTunes.|
|Библиотека /|Каталог библиотеки хорошо подходит для хранения файлов, которые не создаются непосредственно пользователем, например баз данных или другие файлы, создаваемые приложением. Содержимое этого каталога никогда не предоставляются пользователю через iTunes.<br /><br />Можно создать собственные подкаталоги в библиотеке. Тем не менее уже имеются некоторые созданные системой каталоги здесь, которые следует учитывать, включая предпочтения и кэши.<br /><br />Содержимое этого каталога (за исключением подкаталог кэшей) резервное копирование по iTunes. Пользовательские папки, создаваемые в библиотеке будут заархивированы.|
|Library/Preferences /|Файлы настройки конкретного приложения хранятся в этом каталоге. Не следует создавать эти файлы напрямую. Вместо этого используйте `NSUserDefaults` класса.<br /><br />Содержимое этого каталога резервное копирование по iTunes.|
|Библиотека/кэши /|Каталог кэша находится отлично подходит для хранения файлов данных, которые могут помочь вашему приложению выполнения, но, можно было легко воссоздать, при необходимости. Приложение необходимо создать и удалить эти файлы по мере необходимости и иметь возможность повторного создания этих файлов, при необходимости. iOS 5 также может удалить эти файлы (в ситуациях чрезвычайно объема хранилища), однако он не будет выполнено во время работы приложения.<br /><br />Содержимое этого каталога не резервное копирование по iTunes, это означает, что они не будут присутствовать в том случае, если пользователь восстанавливает на устройстве, и они могут не присутствовать после установки обновленной версии приложения.<br /><br />Например в случае, если приложение не удается подключиться к сети, можно использовать каталог кэша для хранения данных или файлов для обеспечения эффективной работы вне сети. Приложения можно сохранить и быстро получать эти данные во время ожидания ответов сети, но его не нужно создавать резервные копии и можно легко восстановить или повторно создать после восстановления или версии обновления.|
|TMP /|Приложения могут хранить временные файлы, которые необходимы только в течение короткого периода в этом каталоге. Чтобы сэкономить место, следует ли удалять файлы, если они больше не требуются. Операционная система может также удалить файлы из этого каталога, когда приложение не выполняется.<br /><br />Содержимое этого каталога не резервное копирование по iTunes.<br /><br />Например каталог tmp может использоваться для хранения временных файлов, загружаются для отображения пользователю (например аватары Twitter или вложений электронной почты), но который может быть удален, как только они были просмотреть (и если это требуется в будущем будут загружаться снова ).|

На этом снимке экрана показана структура каталогов в окне поиска:

 [![](file-system-images/08-library-directory.png "На этом снимке экрана показана структура каталогов в окне поиска")](file-system-images/08-library-directory.png#lightbox)

 <a name="Accessing_Other_Directories_Programmatically" />

### <a name="accessing-other-directories-programmatically"></a>Программный доступ к другим каталогам

В более ранних каталогов и файлов примерах доступ `Documents` каталога. Для записи в другой каталог, то необходимо создать пути с помощью «..» синтаксис, как показано ниже:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var library = Path.Combine (documents, "..", "Library");
var filename = Path.Combine (library, "WriteToLibrary.txt");
File.WriteAllText(filename, "Write this text into a file in Library");
```

Создание каталога во многом схожа:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var library = Path.Combine (documents, "..", "Library");
var directoryname = Path.Combine (library, "NewLibraryDirectory");
Directory.CreateDirectory(directoryname);
```

Пути к `Caches` и `tmp` каталоги могут создаваться следующим образом:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var cache = Path.Combine (documents, "..", "Library", "Caches");
var tmp = Path.Combine (documents, "..", "tmp");
```

 <a name="Sharing_Files_with_the_User_through_iTunes" />


## <a name="sharing-files-with-the-user-through-itunes"></a>Совместное использование файлов с пользователем с помощью iTunes

Пользователям файлов в каталоге документов приложения путем редактирования `Info.plist` и создание **приложение поддерживает общий доступ к iTunes** (`UIFileSharingEnabled`) запись в **источника** представление, как Вот как:

 [![](file-system-images/09-uifilesharingenabled-plist.png "Добавление приложения поддерживает iTunes, общий доступ к свойству")](file-system-images/09-uifilesharingenabled-plist.png#lightbox)

Эти файлы можно получить в iTunes, когда устройство подключено и пользователь нажимает `Apps` вкладки. Например на следующем рисунке показан файлы в общих через iTunes выбранного приложения:

 [![](file-system-images/10-itunes-file-sharing.png "На этом снимке экрана показаны файлы в выбранное приложение, совместно с помощью iTunes")](file-system-images/10-itunes-file-sharing.png#lightbox)

Пользователям доступны только элементы верхнего уровня в этом каталоге через iTunes. Они не могут видеть содержимое всех подкаталогах (хотя их можно скопировать их на свой компьютер или удалить их). Например с GoodReader, файлы PDF и EPUB может использоваться вместе с приложением, чтобы пользователи могут читать их на устройствах iOS.

Пользователям, которые изменяют содержимое своих папок документов может вызвать проблемы, если не соблюдать осторожность. Приложения должны учитывать это и быть устойчивым к разрушающее обновления папки «документы».

В примере кода, в этой статье создается файл и папку в папке документы (в **SampleCode.cs**) и обеспечивает совместное использование файлов в **Info.plist** файла. На этом снимке экрана показано, как они отображаются в iTunes:

 [![](file-system-images/15-itunes-file-sharing-example.png "На этом снимке экрана показано, как отображаются файлы в iTunes")](file-system-images/15-itunes-file-sharing-example.png#lightbox)

Ссылаться на [работа с образами](~/ios/app-fundamentals/images-icons/index.md) статье сведения о настройке значков для приложения и для любых типов настраиваемого документа создается.

Если `UIFileSharingEnabled` ключ имеет значение false или не существует, а затем общий доступ к файлам является, по умолчанию отключена и пользователи не смогут взаимодействовать с вашей Documentsdirectory.

 <a name="Backup_and_Restore" />

## <a name="backup-and-restore"></a>Архивация и восстановление

Когда устройство архивируется iTunes, все каталоги, созданные в домашнем каталоге вашего приложения будет сохранен за исключением следующих:

-   **[ApplicationName] .app** — набор приложений *does* создаваться резервные копии, но только если пакет был изменен (когда приложение установлено обновление, например). Не следует изменить этот каталог в любом случае, так как она была подписана и поэтому должны оставаться неизменными после установки. 
-   **Библиотека/кэши** — каталог кэша предназначен для рабочих файлов, которые не нужно создавать резервные копии. 
-   **TMP** — этот каталог используется для временных файлов, которые создаются и удаляются, когда не нужно, или для файлов удаляет, iOS, когда ему пространства. 


Резервное копирование большой объем данных может занять много времени. Если вы решите, необходимо создать резервную копию любого конкретного документа или данных, приложения следует использовать только в том случае, документы и библиотеки папок для этого. Для хранения временных данных или файлы, которые можно легко извлечь из сети используйте кэши или каталог tmp.

Имейте в виду, что iOS будет «clean» файловой системы. Если устройство критически хватает места на диске. Этот процесс будут удалены все файлы из библиотеки/кэши и tmp папку приложений, которые в данный момент не выполняются.

 <a name="Complying_with_iOS5_iCloud_Backup_Restrictions" />

## <a name="complying-with-ios5-icloud-backup-restrictions"></a>Соблюдение iOS5 iCloud ограничения резервного копирования

Компания Apple представила *резервной копии в iCloud* функциональных возможностей с помощью iOS 5. Если включено iCloud резервного копирования, все файлы в домашний каталог приложения (за исключением каталогов, которые не архивируются обычным образом, например, набор приложений, `Caches` и `tmp`) сохраненный в резервной копии iCloud серверам. Эта функция предоставляет пользователю полного резервного копирования, если устройство потерян, украден или поврежден.

Так, как iCloud предоставляет только 5 ГБ пространства на «free» для каждого пользователя и избегать без необходимости использования пропускной способности, Apple ожидает, что приложения, чтобы только резервное копирование важные данные пользователей. В соответствии с iOS правила хранения данных следует ограничить объем данных, резервного копирования, выполняет следующие элементы:

-  Сохранять только пользовательские данные или данные, которые в противном случае не может быть создан повторно в каталоге документы (который является резервных копий). 
-  Все остальные данные, можно легко повторно создать или повторно загрузить в Store `Library/Caches` или `tmp` (который не является резервных копий и может быть «Очистить»). 
-  Если у вас есть файлы, которые могут подходить для `Library/Caches` или `tmp` папке, но вы не хотите для «очистки», хранить их в другом месте (такие как `Library/YourData` ) и применить "не вверх" атрибут, чтобы файлы использования ba резервной копии iCloud ndwidth и место на диске. Эти данные все равно используется пространство на устройстве, поэтому следует тщательно управлять им и удалите его, если это возможно. 

"Не создавать резервные копии" атрибут задается с помощью `NSFileManager` класса. Обеспечивает класс `using Foundation` и вызвать `SetSkipBackupAttribute` следующим образом:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var filename = Path.Combine (documents, "LocalOnly.txt");
File.WriteAllText(filename, "This file will never get backed-up. It would need to be re-created after a restore or re-install");
NSFileManager.SetSkipBackupAttribute (filename, true); // backup will be skipped for this file
```

Когда `SetSkipBackupAttribute` — `true` файл не будет резервные копии, независимо от того, он хранится в каталоге (даже `Documents` directory). Можно запросить атрибута с помощью `GetSkipBackupAttribute` метод и можно сбросить путем вызова `SetSkipBackupAttribute` метод с `false`, следующим образом:

```csharp
NSFileManager.SetSkipBackupAttribute (filename, false); // file will be backed-up
```

## <a name="sharing-data-between-ios-apps-and-app-extensions"></a>Совместное использование данных между iOS, приложения и расширения приложений

Расширения приложений выполняется как часть ведущего приложения (в отличие от содержащего приложения), общий доступ к данным не выполняется автоматически включены, поэтому не требуется дополнительной работы. Группы приложений — это механизм iOS использует, чтобы разрешить различные приложения для обмена данными. Если приложения были правильно настроены с правильные права доступа и подготовки, получения доступа к общей папке за пределами их обычного iOS "песочницы".

### <a name="configure-an-app-group"></a>Настройка группы приложений

Общее расположение настраивается с помощью [групп приложений](https://developer.apple.com/library/ios/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW19), настроенный в **сертификаты, идентификаторы и профили** разделе [Центр разработчиков iOS](https://developer.apple.com/devcenter/ios/). Это значение также должно быть указано в каждом проекте **Entitlements.plist**.

Сведения о создании и настройке группы приложений, см. [возможностей групп приложений](~/ios/deploy-test/provisioning/capabilities/app-groups-capabilities.md) руководства.

### <a name="files"></a>Файлы

Приложения iOS и расширения могут также совместно использовать файлы, используя общий путь к файлу (учитывая их должным образом настроены правильные права доступа и подготовки):

```csharp
var FileManager = new NSFileManager ();
var appGroupContainer =FileManager.GetContainerUrl ("group.com.xamarin.WatchSettings");
var appGroupContainerPath = appGroupContainer.Path

Console.WriteLine ("Group Path: " + appGroupContainerPath);

// use the path to create and update files
...
```
> [!IMPORTANT]
> Если возвращается пути группы `null`, проверьте конфигурацию назначениях и профиль подготовки и убедитесь, что они верны.


<a name="Application_Version_Updates" />

## <a name="application-version-updates"></a>Обновления версий приложения

После загрузки новой версии приложения iOS создает домашний каталог и сохраняет новый пакет приложений в нем. iOS затем перемещает следующие папки из предыдущей версии вашего пакета приложения в новый корневой каталог:

-  **Документы**
-  **Библиотека**


Другие каталоги могут также копирование и поместить в новый домашнем каталоге, но они гарантированы не копируются, поэтому приложение не следует полагаться на поведение этой системы.

<a name="Summary" />

## <a name="summary"></a>Сводка

В этой статье объясняется, что операции файловой системы так же просты, с помощью Xamarin.iOS как и в случае с любым другим приложением .NET. Также появился "песочницы" приложения и просмотреть последствия для безопасности, которые она вызывает. Далее его изучения концепцию пакета приложения. Наконец перечислены специальные каталоги, доступные для приложения и описано их роли во время обновления приложения и резервные копии.


## <a name="related-links"></a>Связанные ссылки

- [FileSystemSampleCode](https://developer.xamarin.com/samples/FileSystemSampleCode/)
- [Руководство по программированию в системе файл](http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/Introduction/Introduction.html)
- [Регистрация файла типы поддерживает ваше приложение](http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/DocumentInteraction_TopicsForIOS/Articles/RegisteringtheFileTypesYourAppSupports.html#/apple_ref/doc/uid/TP40010411-SW1)
