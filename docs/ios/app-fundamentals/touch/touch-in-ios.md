---
title: События касания и жестов в Xamarin.iOS
description: В этом документе описывается работа с событиями касания, мультисенсорного, жесты, нескольких жестов и пользовательских жестов в приложениях Xamarin.iOS.
ms.prod: xamarin
ms.assetid: DA666DC9-446E-4CD1-B5A0-C6FFBC7E53AD
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/18/2017
ms.openlocfilehash: f7160c48e1b1ac85f4aa0173c0eb9f42b8fefca2
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50114773"
---
# <a name="touch-events-and-gestures-in-xamarinios"></a>События касания и жестов в Xamarin.iOS

Важно понимать события касания и touch API-интерфейсы в приложение iOS, так как они являются основой всех физических взаимодействий с устройством. Включают в себя все сенсорного взаимодействия `UITouch` объекта. В этой статье мы сведения об использовании `UITouch` класс и его интерфейсы API для поддержки сенсорного ввода. Позже мы расширим наших знаний, чтобы узнать, как поддержка жестов.

## <a name="enabling-touch"></a>Включение сенсорного ввода

Элементы управления в `UIKit` — этих производных от UIControl — зависят от так взаимодействия с пользователем, которые для них жесты, встроенной в UIKit, и поэтому не нужно включить касания. Он уже включен.

Тем не менее многие представления в `UIKit` не имеют сенсорного ввода включено по умолчанию. Существует два способа включить сенсорного ввода на элемент управления. Первый способ — установите флажок "Включить взаимодействие пользователя" на панели "Свойства" iOS Designer, как показано на следующем снимке экрана:

 [![](touch-in-ios-images/image1.png "Установите флажок \"Включить взаимодействия пользователя\" на панели свойств в конструкторе iOS")](touch-in-ios-images/image1.png#lightbox)

Мы также можно использовать контроллер для задания `UserInteractionEnabled` присвоено значение true, если `UIView` класса. Это необходимо, если пользовательский Интерфейс создается в коде.

Следующий код является примером:

```csharp
imgTouchMe.UserInteractionEnabled = true;
```

## <a name="touch-events"></a>События касания

Существует три этапа точки касания, возникающие, когда пользователь касается экрана, перемещает пальцев или удаляет пальцев. Эти методы определяются в `UIResponder`, который является базовым классом для UIView. iOS будет переопределить соответствующие методы для `UIView` и `UIViewController` для обработки сенсорного ввода:

-  `TouchesBegan` — Это называется при первом касании экрана.
-  `TouchesMoved` — Вызывается, если расположение изменения сенсорного ввода имени пользователя скользит пальцами по экрану.
-  `TouchesEnded` или `TouchesCancelled` — `TouchesEnded` вызывается, когда пальцы пользователя поднимаются на экране.  `TouchesCancelled` Получает вызывается, если iOS отменяет touch — например, если пользователь слайды свой пальцем от отменять нажатие кнопки.


Touch рекурсивно события перемещения по стеку UIViews, чтобы проверить, если событие сенсорного ввода находится в границах объекта представления. Часто это называется _попадания_. Сначала вызываются на самый верхний `UIView` или `UIViewController` и затем будут вызываться в `UIView` и `UIViewControllers` под ними в иерархии представлений.

Объект `UITouch` объект будет создаваться каждый раз, когда пользователь касается экрана. `UITouch` Объект включает в себя данные о сенсорного ввода, например сенсорный возникновения, где оно произошло, в случае касания пальцем и т. д. События касания передаваемые свойства штрихи — `NSSet` содержащий один или несколько штрихов. Что это свойство используется для получения ссылки на сенсорном и определения ответа приложения.

Классы, которые переопределяют одно из событий сенсорного ввода следует сначала вызвать базовую реализацию, а затем получить `UITouch` объект, связанный с событием. Чтобы получить ссылку на первый сенсорное устройство, вызовите `AnyObject` свойство и приведите его как `UITouch` как показано в следующем примере:

```csharp
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    base.TouchesBegan (touches, evt);
    UITouch touch = touches.AnyObject as UITouch;
    if (touch != null)
    {
        //code here to handle touch
    }
}
```

iOS автоматически распознает последовательных быстрый касается на экране и собрать их все как одним касанием в одном `UITouch` объекта. В результате проверки для двойного касания, так же просто, как проверка `TapCount` свойства, как показано в следующем коде:

```csharp
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    base.TouchesBegan (touches, evt);
    UITouch touch = touches.AnyObject as UITouch;
    if (touch != null)
    {
        if (touch.TapCount == 2)
        {
            // do something with the double touch.
        }
    }
}
```

## <a name="multi-touch"></a>Мультисенсорные

Мультисенсорные не включена по умолчанию для элементов управления. Мультисенсорные можно включить в конструкторе, iOS, как показано на следующем снимке экрана:

 [![](touch-in-ios-images/image2.png "Мультисенсорные включена в конструкторе iOS")](touch-in-ios-images/image2.png#lightbox)

Можно также задать мультисенсорные программным способом, задав `MultipleTouchEnabled` свойства, как показано в следующей строке кода:

```csharp
imgTouchMe.MultipleTouchEnabled = true;
```

Чтобы определить, сколько пальцами затронутых экрана, используйте `Count` свойство `UITouch` свойство:

```csharp
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    base.TouchesBegan (touches, evt);
    lblNumberOfFingers.Text = "Number of fingers: " + touches.Count.ToString();
}
```

## <a name="determining-touch-location"></a>Определение расположения сенсорного ввода

Метод `UITouch.LocationInView` возвращает объект CGPoint, содержащий координаты точки касания в заданном представлении. Кроме того, можно проверить для просмотра, если она находится внутри элемента управления путем вызова метода `Frame.Contains`. В следующем фрагменте кода показан пример этого:

```csharp
if (this.imgTouchMe.Frame.Contains (touch.LocationInView (this.View)))
{
    // the touch event happened inside the UIView imgTouchMe.
}
```

Теперь, когда у нас есть представление о события касания в iOS, давайте познакомимся с распознавателей жестов.

## <a name="gesture-recognizers"></a>Средства распознавания жестов

Средства распознавания жестов можно значительно упростить и усилия при программировании для поддержки сенсорного ввода в приложении. распознавателей жестов iOS объединить ряд событий сенсорного ввода в события одного касания.

Xamarin.iOS предоставляет класс `UIGestureRecognizer` как базовый класс для следующих встроенных жест распознавателей:

-  *UITapGestureRecognizer* — это один или несколько касания.
-  *UIPinchGestureRecognizer* — Pinching и распространение пальцы друг от друга.
-  *UIPanGestureRecognizer* — панорамирования или перетаскивания.
-  *UISwipeGestureRecognizer* — проведение пальцем по экрану в любом направлении.
-  *UIRotationGestureRecognizer* — поворот двумя пальцами в по часовой стрелке или против часовой стрелки перемещения.
-  *UILongPressGestureRecognizer* — нажмите и удерживайте клавишу, иногда называют press долго или щелчком долго.


Базовый шаблон с помощью распознавателя жестов выглядит следующим образом:

1.  **Создать экземпляр средства распознавания жестов** — во-первых, создать экземпляр `UIGestureRecognizer` подкласс. Объект, экземпляр которого создается будет связан с представлением и будет собирать как мусор при удалении представления. Чтобы создать это представление как переменную уровня класса необязательно.
1.  **Настройте параметры жест** — следующим шагом является настройка распознавания. Обратитесь к документации по Xamarin на `UIGestureRecognizer` и его подклассов для списка свойств, которые могут устанавливаться для управления поведением `UIGestureRecognizer` экземпляра.
1.  **Настройка целевого объекта** — из-за его наследия Objective-C Xamarin.iOS не вызывают события, когда жест соответствует распознавателя жестов.  `UIGestureRecognizer` метод — `AddTarget` —, которые могут принимать анонимного делегата или селектор Objective-C с помощью кода для выполнения, когда распознаватель жестов делает совпадение.
1.  **Включение распознавания** — так же, как с события касания, жесты воспринимаются только если включены сенсорного взаимодействия.
1.  **Добавление средства распознавания жестов в представление** — последним шагом является добавление жест в представление, вызвав `View.AddGestureRecognizer` и передается объект распознаватель жестов.

Ссылаться на [примеры распознаватель жестов](~/ios/app-fundamentals/touch/ios-touch-walkthrough.md#Gesture_Recognizer_Samples) Дополнительные сведения о том, как реализовать их в коде.

При вызове целевого жеста, он будет передан ссылку на жест произошла. Это позволяет жест целевой объект для получения сведений о возникшей жест. Объем информации, доступной зависит от типа распознавателя жестов, который был использован. См. Дополнительные сведения о данных, доступных для каждого документация для Xamarin `UIGestureRecognizer` подкласс.

Это важно помнить, что после добавления в представление распознаватель жестов представления (и все представления под ним) не получит все события касания. Чтобы разрешить события касания одновременно с жестами, `CancelsTouchesInView` свойству должно быть присвоено значение false, как показано в следующем примере кода:

```csharp
_tapGesture.Recognizer.CancelsTouchesInView = false;
```

Каждый `UIGestureRecognizer` имеет свойство State, предоставляет важные сведения о состоянии распознавания. Каждый раз при изменении значения этого свойства, iOS будет вызывать метод подписки, предоставляя ему обновления. Если пользовательского распознавателя никогда не обновляет свойство State, подписчика никогда не вызывается, Подготовка к просмотру распознавания бесполезными.

Жесты можно представить как один из двух типов.

1.  *Дискретные* — эти жесты единственный fire первый случай, когда они распознаются.
1.  *Непрерывная* — эти жесты по-прежнему срабатывают до тех пор, пока они распознаются.


Средства распознавания жестов находится в одном из следующих состояний:

-  *Возможные* – это начальное состояние распознавателей жестов. Это значение по умолчанию свойство State.
-  *Began* — после распознавания непрерывной жест Began присваивается состояние. Это позволяет подписывается различать при запуске распознавания жестов и при его изменении.
-  *Changed* — после непрерывной жест было начато, но еще не завершено, состояние будет указано значение Changed каждый раз при сенсорном перемещается или изменяется, при условии, что он является по-прежнему в ожидаемом жеста.
-  *Отменено* — это состояние устанавливается, если распознаватель учились Began Changed, а затем штрихи, изменены таким образом, как для больше не относятся к закономерности жеста.
-  *Распознан* — состояние будет установлено, если распознаватель жестов соответствует набору штрихи и сообщит подписчика о том, что жест закончился.
-  *Завершено* — это как псевдоним для состояния распознаны.
-  *Сбой* — когда распознаватель жестов больше не может соответствовать штрихи, он прослушивает, состояние будет изменено на сбой.


Xamarin.iOS предоставляет эти значения в `UIGestureRecognizerState` перечисления.

## <a name="working-with-multiple-gestures"></a>Работа с жестами, несколько

По умолчанию iOS не поддерживает по умолчанию жесты одновременно. Вместо этого каждый распознаватель будет получать события касания недетерминированным образом. В следующем фрагменте кода показано, как осуществлять одновременно запускать распознавателя жестов:

```csharp
gesture.ShouldRecognizeSimultaneously += (UIGestureRecognizer r) => { return true; };
```

Можно также отключить жестов в iOS. Существуют два делегата свойства, позволяющие распознаватель жестов для изучения состояния приложения и текущего события касания, для облегчения принятия решений о том, как и если должны распознаваться жест. Ниже приведены два события.

1.  *ShouldReceiveTouch* — этот делегат вызывается непосредственно перед распознавания передается событие сенсорного ввода, а также предоставляет возможность проверить штрихи и решить, какие штрихи, которые будут обрабатываться объектом распознавания.
1.  *ShouldBegin* — вызывается, когда распознаватель пытается изменить состояние из потенциальных на другое состояние. Возвращает значение false, приведет к состояние средства распознавания жестов, необходимо изменить на сбой.


Можно переопределить эти методы с строго типизированным `UIGestureRecognizerDelegate`, слабый делегат или привязку через синтаксис обработчика событий, как показано в следующем фрагменте кода:

```csharp
gesture.ShouldReceiveTouch += (UIGestureRecognizer r, UITouch t) => { return true; };
```

Наконец можно поставить в очередь распознаватель жестов, чтобы он будет успешной, только если другой распознаватель жестов завершается ошибкой. К примеру распознавателя жестов одним касанием должен завершиться успешно только при сбое распознавателя жестов двойного касания. В следующем фрагменте кода приведен пример этого.

```csharp
singleTapGesture.RequireGestureRecognizerToFail(doubleTapGesture);
```

## <a name="creating-a-custom-gesture"></a>Создание пользовательских жестов

Несмотря на то, что iOS предоставляет некоторые по умолчанию распознавателей жестов, может потребоваться создать пользовательский жест распознавателей в определенных случаях. Создание пользовательского распознавателя включает в себя следующие действия:

1.  Подкласс `UIGestureRecognizer` .
1.  Переопределите методы событий соответствующий сенсорного ввода.
1.  Всплывать распознавания состояния с помощью свойства State базового класса.


Практический пример это будет рассматриваться в [с помощью сенсорные технологии в iOS](ios-touch-walkthrough.md) Пошаговое руководство.
