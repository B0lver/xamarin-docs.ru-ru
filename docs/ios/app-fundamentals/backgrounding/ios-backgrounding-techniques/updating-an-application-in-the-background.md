---
title: "Обновление приложения в фоновом режиме"
ms.topic: article
ms.prod: xamarin
ms.assetid: A2B2231A-C045-4C11-8176-F9966485197A
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/18/2017
ms.openlocfilehash: f4a18bf8f35d1a6c615c819ea90433d1eb123422
ms.sourcegitcommit: 30055c534d9caf5dffcfdeafd6f08e666fb870a8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/09/2018
---
# <a name="updating-an-application-in-the-background"></a>Обновление приложения в фоновом режиме

Обновления в фоновом режиме — это процесс пробуждение приложение, которое приостанавливается или не запущен и обновление его с новым содержимым. операций ввода-вывода обеспечивает три варианта обновление содержимого в фоновом режиме.

1.  *Мониторинг области* и *значительные службы изменения расположения* -фонового триггера привязанный к местонахождению API-интерфейсы обновлений на основе изменений в расположения пользователя. Эти API можно использовать с осторожностью обновить содержимое в приложениях не место под управлением iOS 6, где другие параметры недоступны.
1.  *Фон выборки (iOS 7 +)* -temporal подход к обновление *некритические* содержимое, которое обновляет *часто* .
1.  *Удаленный уведомлений (iOS 7 +)* -приложения, которые получают push-уведомлений можно использовать уведомления для запуска фоновое обновление содержимого. Этот метод можно использовать для обновления с *важно, зависящих от времени* содержимое, которое обновляет *время от времени* .


В следующих разделах описываются основные принципы эти параметры.

## <a name="region-monitoring-and-significant-location-changes"></a>Область мониторинга и расположение значительные изменения

iOS предоставляет два расположения API с backgrounding возможности:

1.  *Мониторинг области* — это процесс установки областей с границами и пробуждение устройства, когда пользователь вводит или выходит из области. Регионы, циклические и могут быть разных размеров. Если пользователь пересечет границы области, устройство будет спящего режима для обработки события, обычно путем вызова уведомление или в самом начале задачи. Мониторинг области требует GPS и увеличивает батареи и использование данных.
1.  *Значительные службы изменения расположения* доступен простой и экономии питания параметр для устройств с радио сотовой связи. Приложения, прослушивающие изменения значительное место будет уведомлен о устройство переключается towers ячейки. Эта служба может использоваться для пробуждения приостановлена или завершенных приложений и предоставляет возможность проверить наличие нового содержимого в фоновом режиме. Фоновая обработка ограничен около 10 секунд, пока не будут связаны с [фоновой задачи](~/ios/app-fundamentals/backgrounding/ios-backgrounding-techniques/ios-backgrounding-with-tasks.md) .


Приложение не нуждается в расположение `UIBackgroundMode` эти расположения API. Поскольку операций ввода-вывода не отслеживает типы задач, выполняемых при пробуждении устройства изменяется в расположения пользователя, эти API обеспечивают обхода обновление содержимого в фоновом режиме в iOS 6. *Следует помнить, активируя обновления в фоновом режиме с интерфейсами API на основе расположения прорисовывает на ресурсы устройства что может запутать пользователей, не понять, почему приложению требуется доступ к их расположение*. Проявляйте осторожность при реализации области мониторинга или значительные изменения расположения для фоновой обработки в приложениях, которые еще не используется местоположение API-интерфейсы.

Приложения, с помощью отслеживания расположения для фоновой обработки предоставлять дефект iOS 6: Если нужд приложения не помещаются в категорию необходимости фона, она имеет ограниченный backgrounding параметры. С появлением два новых API *выборки фона* и *удаленного уведомления*, iOS 7 (и более поздней версии) предоставляет backgrounding возможности для нескольких приложений. В следующих двух разделах описаны эти новые интерфейсы API.

<a name="background_fetch" />

## <a name="background-fetch-ios-7-and-greater"></a>Выборку в фоновом режиме (iOS 7 и более поздней версии)

В iOS 6 приложение, введя на переднем плане требуется время для загрузки нового содержимого, содержимое, которое уже видели короткое время предоставляя пользователям. Выборку в фоновом режиме позволяет приложениям для загрузки новых данных *перед* пользователь запускает приложение и предоставить пользователю наиболее актуальные материалы.

Чтобы реализовать выборку в фоновом режиме, измените *Info.plist* и проверьте **Включение фоновых режимов** и **выборку в фоновом режиме** флажки:

 [![](updating-an-application-in-the-background-images/fetch.png "Изменить Info.plist и проверьте флажки Включение фоновых режимов и Fetch фона")](updating-an-application-in-the-background-images/fetch.png#lightbox)

Затем в `AppDelegate`, переопределите `FinishedLaunching` метод, чтобы задать интервал выборки минимальное. В этом примере мы позволяют решить, как часто для получения нового содержимого операционной системы:

```csharp
public override bool FinishedLaunching (UIApplication application, NSDictionary launchOptions)
{
  UIApplication.SharedApplication.SetMinimumBackgroundFetchInterval (UIApplication.BackgroundFetchIntervalMinimum);
  return true;
}
```

Наконец, выполните инструкции fetch, переопределив `PerformFetch` метод в `AppDelegate`и передача в *обработчик завершения*. Обработчик завершения является делегатом, который принимает `UIBackgroundFetchResult`:

```csharp
public override void PerformFetch (UIApplication application, Action<UIBackgroundFetchResult> completionHandler)
{
  // Check for new data, and display it
  ...
  
  // Inform system of fetch results
  completionHandler (UIBackgroundFetchResult.NewData);
}
```

При обновлении содержимого Готово, мы рекомендуем позволить знать, вызывая обработчик завершения соответствующее состояние операционной системы. iOS предоставляет три режима для состояния обработчик завершения.

1.  `UIBackgroundFetchResult.NewData` — Вызывается, когда получило новое содержимое, и приложение было обновлено.
1.  `UIBackgroundFetchResult.NoData` — Вызывается, когда проходит выборки для нового содержимого, но содержимое не доступна.
1.  `UIBackgroundFetchResult.Failed` -Полезны для обработки ошибок, вызывается, если выборка не удалось пройти.


Приложений с помощью выборки фона можно вызывать для обновления пользовательского интерфейса в фоновом режиме. Когда пользователь открывает приложение, пользовательский Интерфейс будет устарела и отображение нового содержимого. Снимок переключателя приложения приложения, также обновляются, пользователь может видеть, если приложение имеет новое содержимое.

> [!IMPORTANT]
> **Примечание**: один раз `PerformFetch` является именем, приложение должно приблизительно 30 секунд начнем загрузки нового содержимого и блока обработчика завершения вызова. Если это занимает слишком много времени, приложение будет прерван. Рассмотрите возможность использования фона выборки с _фоновая служба передачи_ при загрузке мультимедиа и других больших файлов.


### <a name="backgroundfetchinterval"></a>BackgroundFetchInterval

В приведенном выше примере, мы сообщим ОС решить, как часто следует извлечь новое содержимое, задав интервал выборки минимальное значение `BackgroundFetchIntervalMinimum`. iOS предоставляет три режима для интервала выборки.

1.  `BackgroundFetchIntervalNever` -Укажите системе никогда не выбирать новое содержимое. Используется для отключения доставки данных в определенных ситуациях, например, если пользователь не выполнил вход. Это значение по умолчанию для интервала выборки. 
1.  `BackgroundFetchIntervalMinimum` -Позволить системе решать, как часто выборки на основе шаблонов пользователя, времени работы батареи, использование данных и потребности других приложений.
1.  `BackgroundFetchIntervalCustom` — Если вы знаете, как часто получает обновления содержимого приложения, можно указать интервал «sleep» после каждой инструкции fetch, во время которой приложение будет запрещено выборка новое содержимое. После этого интервала, система будет определить, когда для получения содержимого.


Оба `BackgroundFetchIntervalMinimum` и `BackgroundFetchIntervalCustom` в системе, чтобы запланировать выборки. Этот интервал динамической адаптации к требованиям устройства, а также привычки отдельного пользователя. Например если один пользователь проверяет каждое утро приложения, а другой проверяет каждый час iOS обеспечит содержимое актуален для обоих пользователей каждый раз при открытии приложения.

Для приложений, часто обновляемые некритические содержимым можно использовать выборку в фоновом режиме. Для приложений с критическими обновлениями следует использовать удаленный уведомления. Удаленный уведомления основаны на фон выборки и совместно использовать один и тот же обработчик завершения. Мы будем подробно удаленного уведомления рядом.

 <a name="remote_notifications" />


## <a name="remote-notifications-ios-7-and-greater"></a>Удаленный уведомлений (iOS 7 и более поздней версии)

Push-уведомления отправляются JSON из поставщика с устройством посредством *службы Push-уведомлений Apple (APN)*.

В iOS 6 входящие push-уведомлений сообщает системе, чтобы предупредить пользователя, что происходит в приложении. Щелкнуть уведомление извлекает приложения из состояния приостановки или прерван, и приложение может начать обновление содержимого. iOS 7 (и более поздней версии) расширяет обычный push-уведомлений, давая возможность обновления содержимого в фоновом режиме приложения *перед* уведомления пользователя, чтобы пользователь может открыть приложение и будет предложена новое содержимое немедленно.

Для реализации удаленного уведомлений, изменить *Info.plist* и проверьте **Включение фоновых режимов** и **удаленного уведомления** флажки:

 [![](updating-an-application-in-the-background-images/remote.png "Фоновый режим Включение фоновых режимов и удаленных уведомления")](updating-an-application-in-the-background-images/remote.png#lightbox)

Затем задайте `content-available` флаг push-уведомлений сам 1. Это позволяет приложению знать, чтобы получить новое содержимое перед выводом оповещения:

```csharp
'aps' {
  'content-available': 1,
  'alert': 'Something new has happened in your app!''
}
```

В *AppDelegate*, переопределите `DidReceiveRemoteNotification` метод для проверки полезные данные уведомления для доступного содержимого и блока обработчика завершения вызова:

```csharp
public override void DidReceiveRemoteNotification (UIApplication application, NSDictionary userInfo, Action<UIBackgroundFetchResult> completionHandler)
{
  if([content-available]) {
    // fetch content
    completionHandler (UIBackgroundFetchResult.NewData);
  }
}
```

Для нечастых обновления с содержимым, которое является ключевым для функциональных возможностей приложения следует использовать удаленного уведомления. Дополнительные сведения об удаленных уведомления см. в разделе Xamarin [Push-уведомления в iOS](~/ios/platform/user-notifications/deprecated/remote-notifications-in-ios.md) руководства.

> [!IMPORTANT]
> **Примечание**: так как механизм обновления в удаленной уведомления основан на фон выборки, приложение должно начнем загрузки нового содержимого и вызвать блока обработчика завершения в течение 30 секунд для получения уведомления или iOS будет завершить работу приложения. Рассмотреть возможность объединения удаленного уведомления с _фоновая служба передачи_ при загрузке мультимедиа и других больших файлов в фоновом режиме.


### <a name="silent-remote-notifications"></a>Автоматическая удаленного уведомления

Удаленный уведомления — это простой способ уведомления приложений, обновлений и начнем выборка новое содержимое, но бывают ситуации, где не требуется уведомлять пользователя, что нечто изменилось. Например если пользователь помечает файл для синхронизации, не требуется уведомить их каждый раз, обновляет файл. Синхронизация файлов не неожиданным событий и требуют немедленного вмешательства пользователя. Пользователи ожидают, что так же будут обновленными, при открытии файла.

Для случаев, аналогичный приведенному выше операций ввода-вывода позволяет извещающих уведомлений, отправляемых без вмешательства пользователя — то есть, без предупреждения. Чтобы включить в автоматическом один периодические уведомления, просто удалите оповещение из полезные данные уведомления:

```csharp
'aps' {
  'content-available': 1
}
```

#### <a name="rate-limits"></a>Ограничения скорости

Главное различие между обычным и автоматической уведомлений с точки зрения разработчика является автоматической отправлений скорость ограничены. APNs приведет к задержке доставки автоматической Push-уведомлений устройству при слишком сильной скорость push. Это гарантирует, что приложений не расходования ресурсов устройства с уведомлениями слишком много автоматической.

Тем не менее APNs позволит автоматической уведомления «дальше» наряду с обычным удаленного уведомления или keep-alive ответа. Так как регулярные уведомления не ограниченной по скорости, они могут использоваться для принудительной отправки хранимых копии автоматической уведомления APNs устройства, как показано на следующей схеме:

 [![](updating-an-application-in-the-background-images/silent.png "Регулярные уведомления можно использовать для принудительной отправки хранимых автоматической уведомления APNs устройства, как показано на этой диаграмме")](updating-an-application-in-the-background-images/silent.png#lightbox)

> [!IMPORTANT]
> **Примечание**: Apple стимулирует разработчиков для отправки автоматической push-уведомления каждый раз, когда приложению требуется, и позволяют APNs запланировать их доставки.


В этом разделе мы рассмотрели различные параметры для обновления содержимого в фоновом режиме для выполнения задач, которые не помещаются в категорию необходимости фона. Теперь давайте посмотрим, некоторые из этих интерфейсов API в действии.

 [Далее: Часть 4 - iOS Backgrounding пошаговые руководства](~/ios/app-fundamentals/backgrounding/ios-backgrounding-walkthroughs/index.md)
