---
title: iOS Фоновая обработка задач
description: В этом документе описывается использование фоновых задач для выполнения длительных задач, после размещения приложения в фоновом режиме.
ms.prod: xamarin
ms.assetid: 205D230E-C618-4D69-96EE-4B91D7819121
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/18/2017
ms.openlocfilehash: 48859afe2c988c1afe67d5c4350cef734f879fdf
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50121000"
---
# <a name="ios-backgrounding-with-tasks"></a>iOS Фоновая обработка задач

Самый простой способ выполнения фоновой обработки в iOS является разбиение требований backgrounding на задачи и выполнить задачи в фоновом режиме. Задачи находятся в строгом ограничение по времени и обычно получают около 600 секунд (10 минут) время обработки после приложения были перемещены в фоновом режиме в iOS 6 и менее чем за 10 минут в iOS 7 и более поздние.

Фоновые задачи могут быть разбиты на три категории:

1.  **Safe фоновой задачи** — вызывается в любом месте в приложении, где у вас есть задачу вы не хотите прерванной приложения следует вводить фона.
1.  **Задачи DidEnterBackground** — вызывается во время `DidEnterBackground` метод жизненного цикла приложения для очистки и сохранения состояния.
1.  **Фоновая передача (iOS 7 и более поздние)** — это особая разновидность фоновой задачи, используемый для передачи по сети в iOS 7. В отличие от обычных задач фоновой передачи не имеют предопределенного предела времени.


Фон safe и `DidEnterBackground` задачи являются безопасными для использования в iOS 6 и iOS 7, с незначительными различиями. Давайте рассмотрим эти два типа задач, более подробно.

## <a name="creating-background-safe-tasks"></a>Создание безопасной фоновой задачи

Некоторые приложения содержат задачи, которые не должны быть прерваны iOS должен изменить состояние приложения. Для их регистрации в iOS как длительно выполняемых задач является одним из способов защиты от постороннего этих задач. Можно использовать этот шаблон в любом месте в приложении где вы не хотите, что задача выполняется прерывание следует put пользователя приложения в фоновом режиме. Задачи, например отправка сведений о регистрации нового пользователя к серверу, или проверка того, данные для входа было бы отличным кандидатом для этого шаблона.

В следующем фрагменте кода демонстрируется регистрация выполнение в фоновом режиме задачи:

```csharp
nint taskID = UIApplication.SharedApplication.BeginBackgroundTask( () => {});

//runs on main or background thread
FinishLongRunningTask(taskID);

UIApplication.SharedApplication.EndBackgroundTask(taskID);
```

Процесс регистрации пары задачи с помощью уникального идентификатора, `taskID`и затем помещает его в сопоставлении `BeginBackgroundTask` и `EndBackgroundTask` вызовов. Чтобы создать идентификатор, мы сделать вызов к `BeginBackgroundTask` метод `UIApplication` объекта и запустите длительную задачу, обычно в новом потоке. По завершении задачи мы называем `EndBackgroundTask` и передайте тот же идентификатор. Это важно, поскольку iOS будет завершить работу приложения, если `BeginBackgroundTask` вызов не имеет соответствующую `EndBackgroundTask`.

> [!IMPORTANT]
> Safe фоновой задачи могут запускаться на основной поток или фоновом потоке, в зависимости от потребностей приложения.


## <a name="performing-tasks-during-didenterbackground"></a>Выполнение задач во время DidEnterBackground

Кроме того, что фон safe длительную задачу, регистрации можно использовать для запуска задачи как приложения помещается в фоновом режиме. iOS предоставляет метод событий в *AppDelegate* класс с именем `DidEnterBackground` , можно использовать, чтобы сохранить состояние приложения, сохранить данные пользовательской среды и зашифровать конфиденциальное содержимое, прежде чем приложение перейдет в фоновом режиме. Приложение имеет примерно через пять секунд для возврата из этого метода или получение завершается. Таким образом, задачи очистки, выполнение которых занимает более 5 секунд для завершения может вызываться из внутри `DidEnterBackground` метод. Эти задачи должны вызываться в отдельном потоке.

Процесс почти идентичен синтаксису регистрации длительных задач. Это показано в следующем фрагменте кода в действии:

```csharp
public override void DidEnterBackground (UIApplication application) {
  nint taskID = UIApplication.SharedApplication.BeginBackgroundTask( () => {});
  new Task ( () => {
    DoWork();
    UIApplication.SharedApplication.EndBackgroundTask(taskID);
  }).Start();
}
```

Мы начинаем путем переопределения `DidEnterBackground` метод в `AppDelegate`, где мы регистрируем наш задачи через `BeginBackgroundTask` как это делалось в предыдущем примере. Затем мы создать новый поток и выполните наши длительную задачу. Обратите внимание, что `EndBackgroundTask` теперь вызов из внутри длительную задачу, поскольку `DidEnterBackground` метод будет уже возвратили.

> [!IMPORTANT]
> iOS использует [контрольные механизм](http://developer.apple.com/library/ios/qa/qa1693/_index.html) для обеспечения реакции пользовательского интерфейса в приложении. Приложение, которое тратит слишком много времени в `DidEnterBackground` перестает отвечать в пользовательском Интерфейсе. В самом начале задачи для выполнения в фоновом режиме позволяет `DidEnterBackground` для возврата своевременно, сохранение реакции пользовательского интерфейса и предотвращает прерывание приложения наблюдения.


## <a name="handling-background-task-time-limits"></a>Ограничений по времени задач фоновой обработки

iOS устанавливает строгие ограничения о том, как долго фоновую задачу можно запустить и в том случае, если `EndBackgroundTask` вызов не выполняется за отведенное время, приложение будет завершено. Отслеживая остальных время фоновой обработки и с помощью обработчиков истечения срока действия, при необходимости, можно избежать завершения работы приложения iOS.

### <a name="accessing-background-time-remaining"></a>Доступ к оставшееся время в фоновом режиме

Если приложение с зарегистрированные задачи перемещается в фоновом режиме, зарегистрированные задачи получите около 600 секунд для выполнения. Можно проверить сведения о времени работы задачи должен завершить с помощью статического `BackgroundTimeRemaining` свойство `UIApplication` класса. Следующий код даст нам время в секундах покинул наших фоновой задачи:

```csharp
double timeRemaining = UIApplication.SharedApplication.BackgroundTimeRemaining;
```

### <a name="avoiding-app-termination-with-expiration-handlers"></a>Предотвращение завершения приложения с обработчиками истечения срока действия

Кроме того, что доступ к `BackgroundTimeRemaining` свойство, iOS предоставляет удобный способ обработки фона время истечение срока действия через **обработчик истечения срока действия**. Это необязательный блок кода, который будет выполняться при время, выделенное для задачи является с истекающим сроком действия. Код в обработчике истечения срока действия вызывает `EndBackgroundTask` и передает идентификатор задачи, который указывает, что приложение работает хорошо и предотвращает операций ввода-вывода и завершением работы приложения, даже если задача не хватает времени. `EndBackgroundTask` должен вызываться в обработчике истечения срока действия, а также во время обычной работы. 

Обработчик истечения срока действия выражается как анонимная функция, с помощью лямбда-выражения, как показано ниже:

```csharp
Task.Factory.StartNew( () => {

    //expirationHandler only called if background time allowed exceeded
    var taskId = UIApplication.SharedApplication.BeginBackgroundTask(() => {
        Console.WriteLine("Exhausted time");
        UIApplication.SharedApplication.EndBackgroundTask(taskId); 
    });
    while(myFlag == true)
    {
        Console.WriteLine(UIApplication.SharedApplication.TimeRemaining);
        myFlag = SomeCalculationNeedsMoreTime();
    }
    //Only called if loop terminated due to myFlag and not expiration of time
    UIApplication.SharedApplication.EndBackgroundTask(taskId);
});
```

Хотя обработчики истечения срока действия не требуются для работы кода, следует всегда использовать обработчик истечения срока действия с фоновой задачи.

 <a name="background_tasks_in_iOS_7" />

## <a name="background-tasks-in-ios-7"></a>Фоновые задачи в iOS 7 и более поздние

Самое значительное изменение в iOS 7, что касается фоновых задач является не задач реализации, но во время выполнения.

Помните, что до iOS 7, задача, выполняемая в фоновом режиме 600 секунд было завершить проверку. Одной из причин этого ограничения является, задача, выполняемая в фоновом режиме будет хранить устройство переходит в спящий режим на время задачи:

 [![](ios-backgrounding-with-tasks-images/ios6.png "График задачи сохранения приложение переходит в спящий режим до iOS 7")](ios-backgrounding-with-tasks-images/ios6.png#lightbox)

iOS 7 фоновой обработки оптимизирован для батареи. В iOS 7, фоновая обработка становится обусловленная: вместо того чтобы постоянно устройство переходит в спящий режим, учитывают задачи, когда устройство переходит в спящий режим и вместо этого выполните их обработки в виде фрагментов, когда устройство выходит из спящего режима для обработки телефонных звонков, уведомления, входящие сообщения электронной почты и другие распространенные перерывы в работе. На следующей схеме показано представление о том, как задача может работать неправильно до:

 [![](ios-backgrounding-with-tasks-images/ios7.png "График задачи разбивается на фрагменты после iOS 7")](ios-backgrounding-with-tasks-images/ios7.png#lightbox)

Так как время выполнения задачи не больше непрерывно, задач, выполняющих передачу сети должны обрабатываться по-разному в iOS 7. Разработчики могут использовать `NSURlSession` API для обработки передачи по сети. Следующий раздел является обзором фоновой передачи.

 <a name="background-transfers" />

## <a name="background-transfers"></a>Фоновая передача

Основой фоновой передачи в iOS 7 появился `NSURLSession` API. `NSURLSession` позволяет создавать задачи для:

1.  Передавать содержимое через перерывы в работе сети и устройства.
1.  Отправка и загрузка крупных файлов ( *фоновой службы передачи* ).


Давайте рассмотрим более подробно как это работает.

### <a name="nsurlsession-api"></a>NSURLSession API

 `NSURLSession` — Это мощный API для передачи содержимого по сети. Он предоставляет набор средств для обработки передачи данных через перерывы в работе сети и изменения состояния приложения.

`NSURLSession` API создает один или несколько сеансов, которые в свою очередь порождает задачи для выбора блоки связанных данных по сети. Задачи выполняются асинхронно для быстрой и надежной передачи данных. Поскольку `NSURLSession` является асинхронным, каждый сеанс требует блоком обработчика завершения, чтобы позволить системы и приложения о том, когда передача завершена.

Чтобы выполнить передачу по сети, допустимые для предварительной iOS 7 и после iOS 7, проверьте `NSURLSession` доступными для постановки в очередь передачи и использовать регулярные фоновой задачи для выполнения передачи, если это не:

```csharp
if ([NSURLSession class]) {
  // Create a background session and enqueue transfers
}
else {
  // Start a background task and transfer directly
  // Do NOT make calls to update the UI here!
}
```

> [!IMPORTANT]
> Избегайте вызовов для обновления пользовательского интерфейса из фонового в iOS 6-совместимого кода, iOS 6 не поддерживает обновления пользовательского интерфейса в фоновом режиме, а, чтобы закрыть приложение.


`NSURLSession` API-Интерфейс включает широкий набор функций для обработки проверки подлинности, управления неудачных передач и сообщать об ошибках на стороне клиента — но не на сервере -. Он помогает мост, который перерывы в задаче выполнения появился в iOS 7 и также обеспечивает поддержку для передачи больших файлов, быстро и надежно. В следующем разделе рассматривается этой второй функции.

### <a name="background-transfer-service"></a>Фоновая служба передачи

До iOS 7 отправка и загрузка файлов в фоновом режиме были недостоверными. Фоновые задачи получения ограниченного времени для запуска, но время, необходимое для передачи файла зависит от сети и размера файла. В iOS 7, мы используем `NSURLSession` для успешной отправки и загрузки больших файлов. Конкретного `NSURLSession` тип сеанса, который обрабатывает сетевой передачи больших файлов в фоновом режиме называется *фоновой службы передачи*.

Передача, инициировать с помощью фоновой службы передачи управляются операционной системой и предоставляют API для обработки проверки подлинности и ошибок. Так как передача не связаны с произвольной предельное время, они могут использоваться для отправки или загрузки больших файлов, автоматическое обновление содержимого в фоновом режиме и многое другое. Ссылаться на [Пошаговое руководство передачи фона](~/ios/app-fundamentals/backgrounding/ios-backgrounding-walkthroughs/background-transfer-walkthrough.md) Дополнительные сведения о том, как для реализации службы.

В фоновой службе передачи часто сопровождается фоновое получение или удаленных уведомлений для приложений обновить содержимое в фоновом режиме. В следующих двух разделах мы впервые реализована концепция регистрации всего приложения в фоновом режиме в iOS 6 и iOS 7.

