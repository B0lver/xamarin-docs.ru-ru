---
title: Обзор пользовательского интерфейса iOS 7
description: в iOS 7 введено множество изменений пользовательского интерфейса. В этой статье описываются некоторые из больших изменений, как в визуальном представлении элементов управления, так и в интерфейсах API, поддерживающих новый проект.
ms.prod: xamarin
ms.assetid: FADCEA7C-8968-42A1-9E9E-F4BBAB7BCF2C
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/21/2017
ms.openlocfilehash: 4731be58c1fadae0bba6768570ecfd181b071dd2
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73031863"
---
# <a name="ios-7-user-interface-overview"></a>Обзор пользовательского интерфейса iOS 7

_в iOS 7 введено множество изменений пользовательского интерфейса. В этой статье описываются некоторые из больших изменений, как в визуальном представлении элементов управления, так и в интерфейсах API, поддерживающих новый проект._

в iOS 7 основное внимание уделяется содержимому через Chrome. Элементы пользовательского интерфейса в iOS 7 разделяют Хром, удаляя атрибуты, такие как внешние границы, строки состояния и панели навигации, уменьшая объем пространства экрана, используемый представлениями содержимого. В iOS 7 содержимое предназначено для использования всего экрана.

в iOS 7 введено несколько других изменений: цвет используется для различения элементов пользовательского интерфейса, а не для таких атрибутов, как границы кнопок. Многие элементы, такие как панели навигации и строки состояния, теперь являются размытыми, полупрозрачными или прозрачными, с помощью представлений содержимого, которые делают область под ними. Эти представления содержимого отображаются через Размытые линии, что приводит к поразительности глубины в пользовательском интерфейсе.

В этой статье рассматриваются некоторые изменения в элементах пользовательского интерфейса в iOS 7, а также различные интерфейсы API, связанные с новой структурой пользовательского интерфейса.

## <a name="view-and-control-changes"></a>Просмотр и управление изменениями

Все представления в UIKit соответствуют новому внешнему интерфейсу iOS 7. В этом разделе описываются некоторые изменения этих представлений, а также связанные API, которые были изменены для поддержки нового пользовательского интерфейса.

### <a name="uibutton"></a>UIButton

Кнопки, созданные из класса `UIButton`, теперь не имеют границ и не имеют фона по умолчанию, как показано ниже:

 ![](ios7-ui-images/button.png "Sample UIButton")

Стиль `UIButtonType.RoundedRect` не рекомендуется к использованию. При использовании в iOS 7 `UIButtonType.RoundedRect` приведет к тому, что `UIButtonType.System` будет использоваться, что создает стиль кнопки по умолчанию без фона или видимых границ, как показано выше.

### <a name="uibarbuttonitem"></a>уибарбуттонитем

Как и `UIButton`, кнопки на линейчатых диаграммах также не имеют границ, по умолчанию используется новый стиль `UIBarButtonItemStyle.Plain`, как показано ниже:

 ![](ios7-ui-images/barbuttonplain.png "Sample UIBarButtonItem")

Кроме того, стиль `UIBarButtonItemStyle.Bordered` устарел. Установка `UIBarButtonItemStyle.Bordered` в iOS 7 приведет к тому, что используется стиль `UIBarButtonItemStyle.Plain`.

Стиль `UIBarButtonItemStyle.Done` не является устаревшим. Однако он также создает кнопку без рамки, только с полужирным начертанием текста, как показано ниже:

 ![](ios7-ui-images/barbuttondone.png "Sample UIBarButtonItem in the Done style")

### <a name="uialertview"></a>уиалертвиев

Помимо изменения стиля для нового вида iOS 7, представления предупреждений больше не поддерживают настройку через Подпредставление. Несмотря на то, что `UIAlertView` наследует от `UIView`, вызов `AddSubview` в `UIAlertView` не оказывает никакого влияния. Рассмотрим следующий пример кода:

```csharp
UIBarButtonItem button = new UIBarButtonItem ("Bar Button", UIBarButtonItemStyle.Plain, (s,e) =>
{
    UIAlertView alert = new UIAlertView ("Title", "Message", null, "Cancel", "OK");

    alert.AddSubview (new UIView () {
        Frame = new CGRect(50, 50,100, 100),
        BackgroundColor = UIColor.Green
    });

    alert.Show ();
});
```

В результате будет создано стандартное представление предупреждений с проигнорированным вложенным представлением, как показано ниже:

 ![](ios7-ui-images/alert.png "Sample UIAlertView")

 Примечание. Уиалертвиев не рекомендуется использовать в iOS 8. Ознакомьтесь с рецептом [контроллера предупреждений](https://github.com/xamarin/recipes/tree/master/Recipes/ios/standard_controls/alertcontroller) об использовании представления предупреждений в iOS 8 и более поздних версиях.

### <a name="uisegmentedcontrol"></a>уисегментедконтрол

Сегментированные элементы управления в iOS 7 являются прозрачными и поддерживают цвет оттенка. Цвет оттенка используется для цвета текста и границы. При выборе сегмента цвет переключается между фоном и текстом, а цвет оттенка используется для выделения выбранного сегмента, как показано ниже:

 ![](ios7-ui-images/segmentedcontrol.png "Sample UISegmentedControl")

Кроме того, в iOS 7 не рекомендуется использовать `UISegmentedControlStyle`.

### <a name="picker-views"></a>Представления средства выбора

API для представлений средств выбора в основном не изменился; Однако руководства по проектированию iOS 7 теперь должны быть представлены в виде встроенных представлений, а не как представления ввода, анимированные в нижней части экрана, или через новый контроллер, помещенный в стек контроллера навигации, как в предыдущих версиях iOS. Это можно увидеть в приложении системного календаря:

 ![](ios7-ui-images/inlinepicker.png "This can be seen in the system calendar app")

### <a name="uisearchdisplaycontroller"></a>уисеарчдисплайконтроллер

Панель поиска теперь отображается внутри панели навигации, если свойство `UISearchDisplayController.DisplaysSearchBarInNavigationBar` имеет значение true. Если задано значение false (по умолчанию), панель навигации скрывается при отображении контроллера поиска.

На следующем снимке экрана показана панель поиска в `UISearchDisplayController`:

 ![](ios7-ui-images/searchbar.png "Sample UISearchDisplayController")

### <a name="uitableview"></a>UITableView

Интерфейсы API вокруг `UITableView` в основном не меняются; Однако стиль был значительно изменен в соответствии с новой структурой пользовательского интерфейса. Внутренняя иерархия представлений также немного отличается. Это изменение не повлияет на большинство приложений, но его следует учитывать.

#### <a name="grouped-table-style"></a>Стиль сгруппированной таблицы

Измененный стиль группировки обновлен, содержимое теперь расширяется до границ экрана, как показано ниже:

 ![](ios7-ui-images/table1.png "Sample Grouped Table Style")

#### <a name="separatorinset"></a>сепараторинсет

Разделители строк теперь можно сделать отступами, установив свойство `UITableVIewCell.SeparatorInset`. Например, следующий код используется для отступа ячеек от левого края:

```csharp
cell.SeparatorInset = new UIEdgeInsets (0, 50, 0, 0);
```

Это создает в представлении таблицы с отступами ячейки, как показано ниже:

 ![](ios7-ui-images/separatorinset.png "Sample UITableView SeparatorInset")

#### <a name="table-button-styles"></a>Стили кнопок таблицы

Различные кнопки, используемые в табличных представлениях, были изменены. На следующем снимке экрана представлено табличное представление в режиме редактирования:

 ![](ios7-ui-images/table2.png "This screenshot presents a table view in editing mode")

### <a name="additional-control-changes"></a>Дополнительные изменения элементов управления

Другие элементы управления UIKit также изменились, включая ползунки, переключатели и пошаговые инструкции. Эти изменения являются исключительно визуальным. Дополнительные сведения см. в [руководстве по переходу пользовательского интерфейса в iOS 7](https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/TransitionGuide/index.html)для Apple.

## <a name="general-user-interface-changes"></a>Общие изменения пользовательского интерфейса

В дополнение к изменениям в UIKit в iOS 7 появились разнообразные визуальные изменения в пользовательском интерфейсе, включая:

- Содержимое во весь экран
- Внешний вид панели
- Цвет оттенка

<a name="fullscreen" />

### <a name="full-screen-content"></a>Содержимое во весь экран

iOS 7 предназначена для того, чтобы позволить приложениям использовать преимущества всего экрана. Теперь контроллеры представлений перекрываются строкой состояния и панелью навигации, если она существует, а не ниже состояния и панелей навигации.

При подготовке приложения для iOS 7 можно выполнить повторное сопоставление подпросмотров с помощью *Interface Builder* или *конструктора Xamarin iOS*. Можно также использовать один из новых API-интерфейсов для программной поддержки содержимого в полноэкранном режиме. Эти API-интерфейсы представлены ниже.

#### <a name="toplayoutguide-and-bottomlayoutguide"></a>Топлайаутгуиде и Боттомлайаутгуиде

 `TopLayoutGuide` и `BottomLayoutGuide` служат ссылкой для того, где должны начинаться или заканчиваться представления, чтобы содержимое не было перекрыто полупрозрачной `UIKit` полосой, как показано в следующем примере:

 [![](ios7-ui-images/clipped.png "Sample content not overlapped by a translucent UIKit bar")](ios7-ui-images/clipped.png#lightbox)

Эти API-интерфейсы можно использовать для вычисления смещения представления в верхней или нижней части экрана, а также для настройки размещения содержимого соответствующим образом.

```csharp
public override void ViewDidLayoutSubviews ()
{
    base.ViewDidLayoutSubviews ();

    if (UIDevice.CurrentDevice.CheckSystemVersion (7, 0)) { 
        nfloat displacement_y = this.TopLayoutGuide.Length;

        //load subviews with displacement
    }

}
```

Можно использовать значение, вычисленное выше, чтобы задать смещение `ImageView`в верхней части экрана, чтобы было видно всего изображение:

 [![](ios7-ui-images/good2.png "Example ImageViews displacement from the top of the screen")](ios7-ui-images/good2.png#lightbox)

См. [имажевиевер](https://docs.microsoft.com/samples/xamarin/ios-samples/ios7-ui-updates/) для работы с примером.

Значение смещения создается динамически после добавления представления в иерархию, поэтому попытка чтения `TopLayoutGuide` и `BottomLayoutGuide` значений в `ViewDidLoad` возвратит 0. Вычислите значение после загрузки представления, например, в `ViewDidLayoutSubviews`.

> [!IMPORTANT]
> `TopLayoutGuide` и `BottomLayoutGuide` являются устаревшими в iOS 11 в пользу новой защищенной области. Компания Apple объявила о том, что использование защищенной области совместимо с iOS версии более ранней, чем iOS 11. Дополнительные сведения см. в статье [Обновление приложения для iOS 11](~/ios/platform/introduction-to-ios11/updating-your-app/visual-design.md#fullscreen) .

#### <a name="edgesforextendedlayout"></a>еджесфорекстендедлайаут

Этот API указывает, какие края представления должны быть расширены на весь экран, независимо от линейчатой полупрозрачность. В iOS 7 панели навигации и панели инструментов отображаются в виде слоев над представлением контроллера, в отличие от предыдущих версий iOS, где они не занимали одно и то же пространство. Приложение для фото в iOS 7 показывает `UIViewController.EdgesForExtendedLayout` значение по умолчанию `UIRectEdge.All`. Этот параметр заполняет все четыре края в представлении содержимым, создавая перекрывающиеся и полноэкранные эффекты:

 [![](ios7-ui-images/photos.png "Sample EdgesForExtendedLayout")](ios7-ui-images/photos.png#lightbox)

Касание изображения приводит к удалению отрезков и отображению изображения в полноэкранном режиме:

 [![](ios7-ui-images/photos2.png "EdgesForExtendedLayout with the bars removed")](ios7-ui-images/photos2.png#lightbox)

Поскольку содержимое в полноэкранном режиме является значением по умолчанию, приложения, настроенные для iOS 6, будут иметь часть представления, как показано на снимке экрана ниже:

 [![](ios7-ui-images/clipped.png "Apps configured for iOS 6 will have part of the view clipped, as in this screenshot")](ios7-ui-images/clipped.png#lightbox)

Изменение свойства `UIViewController.EdgesForExtendedLayout` регулирует это поведение. Можно указать, что представление не может заполнять границы, поэтому наше представление не будет отображать содержимое в пространстве, занятом навигацией или панелями инструментов (в каждой ориентации):

```csharp
if (UIDevice.CurrentDevice.CheckSystemVersion (7, 0)) { 
    this.EdgesForExtendedLayout = UIRectEdge.None;
}
```

В нашем приложении мы увидим, что представление снова перемещается, поэтому отображается всего изображение:

 [![](ios7-ui-images/good.png "Example with whole image visible")](ios7-ui-images/good.png#lightbox)

Обратите внимание, что хотя эффекты API `TopLayoutGuide/BottomLayoutGuide` и `EdgesForExtendedLayout` похожи, они предназначены для заполнения разных целей. Изменение параметра `EdgesForExtendedLayout` по умолчанию может привести к исправлению обрезанных представлений в приложениях, предназначенных для iOS 6, но хорошая разработка iOS 7 должна поддерживать полноэкранный Aesthetic и обеспечивать полноэкранный просмотр, полагаться на `TopLayoutGuide` и `BottomLayoutGuide` должным образом размещение содержимого, которое должно работать в удобном для пользователя месте.

См. [имажевиевер](https://docs.microsoft.com/samples/xamarin/ios-samples/ios7-ui-updates/) для работы с примером.

### <a name="status-and-navigation-bars"></a>Состояние и панели навигации

Строка состояния и панели навигации отображаются с прозрачностью. Строки состояния прозрачны, тогда как панели инструментов и панели навигации полупрозрачны и размыты, чтобы передать чувство глубины в пользовательском интерфейсе. На следующем снимке экрана показано такое размытие и прозрачность, где синий цвет фона представления коллекции отображается как состояние и панели навигации, давая им светло-синий вид:

 ![](ios7-ui-images/transparent-navbar.png "Sample Status and Navigation Bar blurring")

#### <a name="status-bar-styles"></a>Стили строки состояния

Кроме размытия и прозрачности, передний план строки состояния может быть либо светлым, либо темным (по умолчанию — темным). Стиль строки состояния можно задать из контроллера представления. Контроллер представления также может задавать, отображается ли строка состояния как скрытая или отображаемая.

Например, следующий код переопределяет метод `PreferredStatusBarStyle` контроллера представления, чтобы строка состояния отображала голубой передний план:

```csharp
public override UIStatusBarStyle PreferredStatusBarStyle ()
{
    return UIStatusBarStyle.LightContent;
}
```

В результате строка состояния будет выглядеть следующим образом:

 ![](ios7-ui-images/light-status-bar.png "Sample Status Bar")

Чтобы скрыть строку состояния в коде контроллера представления, переопределите `PrefersStatusBarHidden`, как показано ниже:

```csharp
public override bool PrefersStatusBarHidden ()
{
    return true;
}
```

Это скрывает строку состояния:

 ![](ios7-ui-images/status-bar-hidden.png "Status Bar hidden")

### <a name="tint-color"></a>Цвет оттенка

Кнопки теперь отображаются как текст, меньший цвета. Цвет текста можно контролировать с помощью нового свойства `TintColor` в `UIView`. Установка `TintColor` применяет цвет ко всей иерархии представлений для представления, которое его задает. Чтобы применить `TintColor`по всему приложению, установите его на `Window`. Можно также определить, когда цвет оттенка изменяется с помощью метода `UIView.TintColorDidChange`.

Например, на следующем снимке экрана показан результат изменения цвета оттенка в представлении контроллера навигации на сиреневый:

 ![](ios7-ui-images/tint-color.png "Purple tint color on a navigation controllers view")

Цвет оттенка можно применить к изображениям, если `RenderingMode` установлен в значение `UIImageRenderingMode.AlwaysTemplate`.

> [!IMPORTANT]
> Цвет оттенка не может быть задан с помощью `UIAppearance`.

### <a name="dynamic-type"></a>Динамический тип

В iOS 7 пользователь может указать размер текста в параметрах системы. При использовании динамического типа шрифт изменяется динамически, чтобы выглядеть хорошо, независимо от размера. `UIFont.PreferredFontForTextStyle` следует использовать для получения шрифта, оптимизированного для управляемого пользователем размера.

## <a name="summary"></a>Сводка

В этой статье рассматриваются изменения в элементах пользовательского интерфейса в iOS 7. Он изучает несколько изменений, внесенных в представления и элементы управления в UIKit, выделяя как визуальные изменения, так и изменения связанных API. Наконец, в нем появились новые API-интерфейсы для работы с полноэкранным содержимым, новой поддержкой цвета оттенков и динамического типа.

## <a name="related-links"></a>Связанные ссылки

- [Имажевиевер (пример)](https://docs.microsoft.com/samples/xamarin/ios-samples/ios7-ui-updates)
