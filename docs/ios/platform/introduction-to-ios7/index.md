---
title: Введение в iOS 7
description: В этой статье рассматриваются основные новые интерфейсы API, появившиеся в iOS 7, включая переходы на контроллеры представлений, улучшения UIView анимации, UIKit Dynamics и Text Kit. В нем также рассматриваются некоторые изменения пользовательского интерфейса и новые возможности многозадачности Расширенная.
ms.prod: xamarin
ms.assetid: 2C33018F-D64A-4BAA-A34E-082EF311D162
ms.technology: xamarin-ios
author: conceptdev
ms.author: crdun
ms.date: 03/19/2017
ms.openlocfilehash: d3a3c28e30e38562035b4d0c7c05366865157dd5
ms.sourcegitcommit: 57f815bf0024b1afe9754c0e28054fc0a53ce302
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70752063"
---
# <a name="introduction-to-ios-7"></a>Введение в iOS 7

_В этой статье рассматриваются основные новые интерфейсы API, появившиеся в iOS 7, включая переходы на контроллеры представлений, улучшения UIView анимации, UIKit Dynamics и Text Kit. В нем также рассматриваются некоторые изменения пользовательского интерфейса и новые возможности многозадачности Расширенная._

iOS 7 — это значительное обновление для iOS. В ней представлено совершенно новое Проектирование пользовательского интерфейса, которое помещает фокус на содержимое, а не на хром приложения. Наряду с визуальными изменениями iOS 7 добавляет множество новых интерфейсов API для создания более мощных взаимодействий и возможностей. В этом документе рассматриваются новые технологии, появившиеся в iOS 7, и служит отправной точкой для дальнейшего изучения.

## <a name="uiview-animation-enhancements"></a>Усовершенствования анимации UIView

iOS 7 дополняет поддержку анимации в UIKit, позволяя приложениям выполнять те действия, которые ранее требовали удаления непосредственно в основную платформу анимации. Например, `UIView` теперь может создавать пружинные анимации, а также анимации опорных кадров, которые `CAKeyframeAnimation` ранее были применены к. `CALayer`

### <a name="spring-animations"></a>Пружинные анимации

 `UIView`Теперь поддерживает анимацию изменений свойств с пружинным действием. Чтобы добавить это значение, вызовите `AnimateNotify` метод `AnimateNotifyAsync` или, передав значения для коэффициента затухания и начальной скорости весны, как описано ниже:

- `springWithDampingRatio`— Значение в диапазоне от 0 до 1, где колебаний увеличивается для меньшего значения.
- `initialSpringVelocity`— Начальная пружинная скорость в процентах от общего расстояния анимации в секунду.

Следующий код создает пружинный результат при изменении центра представления изображения:

```csharp
void AnimateWithSpring ()
{
    float springDampingRatio = 0.25f;
    float initialSpringVelocity = 1.0f;

    UIView.AnimateNotify (3.0, 0.0, springDampingRatio, initialSpringVelocity, 0, () => {

        imageView.Center = new CGPoint (imageView.Center.X, 400);

    }, null);
}
```

Этот эффект приведет к тому, что представление изображения будет выглядеть по мере того, как оно завершит свою анимацию до нового центрального расположения, как показано ниже:

 ![](images/spring-animation.png "Эта пружинный эффект приводит к тому, что представление изображения отображается так, как только завершает свою анимацию до нового центрального расположения.")

### <a name="keyframe-animations"></a>Анимация опорных кадров

Класс теперь включает метод для создания анимаций опорных кадров в `UIView`. `AnimateWithKeyframes` `UIView` Этот метод аналогичен другим `UIView` методам анимации, за исключением того, что дополнительный `NSAction` параметр передается в качестве параметра для включения ключевых кадров. Внутри ключевые кадры добавляются путем вызова `UIView.AddKeyframeWithRelativeStartTime`. `NSAction`

Например, следующий фрагмент кода создает анимацию опорного кадра для анимации центра представления, а также для поворота представления.

```csharp
void AnimateViewWithKeyframes ()
{
    var initialTransform = imageView.Transform;
    var initialCeneter = imageView.Center;

    // can now use keyframes directly on UIView without needing to drop directly into Core Animation

    UIView.AnimateKeyframes (2.0, 0, UIViewKeyframeAnimationOptions.Autoreverse, () => {
        UIView.AddKeyframeWithRelativeStartTime (0.0, 0.5, () => {
            imageView.Center = new CGPoint (200, 200);
        });

        UIView.AddKeyframeWithRelativeStartTime (0.5, 0.5, () => {
            imageView.Transform = CGAffineTransform.MakeRotation ((float)Math.PI / 2);
        });
    }, (finished) => {
        imageView.Center = initialCeneter;
        imageView.Transform = initialTransform;

        AnimateWithSpring ();
    });
}
```

Первые два параметра `AddKeyframeWithRelativeStartTime` метода определяют время начала и длительность ключевого кадра соответственно в процентах от общей длины анимации. Приведенный выше пример приводит к анимации представления изображения в новом центре в течение первой секунды, за которым следует поворот на 90 градусов на следующую секунду. Так как анимация указывает `UIViewKeyframeAnimationOptions.Autoreverse` в качестве параметра, оба ключевых кадра также отдаются в обратную анимацию. Наконец, конечные значения задаются в начальном состоянии в обработчике завершения.

На снимках экрана ниже показана комбинированная анимация через ключевые кадры:

 ![](images/keyframes.png "На снимках экрана показана Объединенная анимация через ключевые кадры.")

## <a name="uikit-dynamics"></a>UIKit Dynamics

UIKit Dynamics — это новый набор API-интерфейсов в UIKit, позволяющий приложениям создавать анимированные взаимодействия на основе физикы. UIKit Dynamics инкапсулирует механизм двухмерной физикы, чтобы сделать это возможным.

По сути, API является декларативным. Вы объявляете, как осуществляется взаимодействие по физике, создавая объекты, называемые *поведением* , для выражения физических концепций, таких как сила притяжения, конфликты, пружины и т. д. Затем вы подключаете поведение к другому объекту, называемому *динамическим аниматор*, который инкапсулирует представление. Динамический аниматор заботится о применении объявленного поведения физикы к *динамическим элементам* — элементам, `IUIDynamicItem`которые реализуют `UIView`, например.

Существует несколько различных примитивных вариантов поведения, которые могут вызывать сложные взаимодействия, включая:

- `UIAttachmentBehavior`— Соединяет два динамических элемента таким, что они перемещаются вместе, или присоединяет динамический элемент к точке вложения.
- `UICollisionBehavior`— Позволяет динамическим элементам участвовать в конфликтах.
- `UIDynamicItemBehavior`— Указывает общий набор свойств, применяемых к динамическим элементам, таким как эластичность, плотность и трение.
- `UIGravityBehavior`— Применяет значение тяжести к динамическому элементу, что приводит к ускорению элементов в направлении гравитатионал.
- `UIPushBehavior`— Применение принудительного применения к динамическому элементу.
- `UISnapBehavior`— Позволяет привязывать динамический элемент к позиции с пружинным действием.

Хотя существует много примитивов, общий процесс добавления нефизических взаимодействий в представление с использованием UIKit Dynamics согласовано по поведению:

1. Создайте динамический аниматор.
1. Создание поведений.
1. Добавьте поведения в динамический аниматор.

### <a name="dynamics-example"></a>Пример Dynamics

Рассмотрим пример, который добавляет границу тяжести и конфликт в `UIView`.

#### <a name="uigravitybehavior"></a>уигравитибехавиор

Чтобы добавить в представление изображения значение тяжести, выполните три шага, описанные выше.

В этом примере мы будем `ViewDidLoad` работать в методе. Сначала добавьте `UIImageView` экземпляр, как показано ниже.

```csharp
image = UIImage.FromFile ("monkeys.jpg");

imageView = new UIImageView (new CGRect (new CGPoint (View.Center.X - image.Size.Width / 2, 0), image.Size)) {
                    Image =  image
                }

View.AddSubview (imageView);
```

Это приведет к созданию представления изображений, центрированного по верхнему краю экрана. Чтобы сделать изображение "попадать" с помощью притяжения, создайте экземпляр класса `UIDynamicAnimator`.

```csharp
dynAnimator = new UIDynamicAnimator (this.View);
```

Объект `UIDynamicAnimator` принимает экземпляр ссылки `UIView` или `UICollectionViewLayout`, который содержит элементы, которые будут анимированы в соответствии с присоединенным поведением.

Затем создайте `UIGravityBehavior` экземпляр. Можно передать один или несколько объектов, реализующих `IUIDynamicItem`объект, `UIView`например:

```csharp
var gravity = new UIGravityBehavior (dynItems);
```

Поведение передается массиву, `IUIDynamicItem`который в данном случае содержит один `UIImageView` экземпляр, для которого выполняется анимация.

Наконец, добавьте поведение в динамический аниматор:

```csharp
dynAnimator.AddBehavior (gravity);
```

Это приводит к анимации изображения вниз с помощью притяжения, как показано ниже:

![](images/gravity2.png "")Расположение
начального изображения(images/gravity3.png "с конечным расположением изображения") ![]

Поскольку границы экрана не ограничиваются, представление изображения просто падает снизу. Чтобы ограничить представление таким образом, чтобы изображение конфликтует с краями экрана, можно добавить `UICollisionBehavior`. Это будет рассмотрено в следующем разделе.

#### <a name="uicollisionbehavior"></a>уиколлисионбехавиор

Начнем с создания `UICollisionBehavior` и добавления в динамический аниматор, как и `UIGravityBehavior`для.

Измените код, включив в `UICollisionBehavior`него:

```csharp
using (image = UIImage.FromFile ("monkeys.jpg")) {

    imageView = new UIImageView (new CGRect (new CGPoint (View.Center.X - image.Size.Width / 2, 0), image.Size)) {
        Image =  image
    };

    View.AddSubview (imageView);

    // 1. create the dynamic animator
    dynAnimator = new UIDynamicAnimator (this.View);

    // 2. create behavior(s)
    var gravity = new UIGravityBehavior (imageView);
    var collision = new UICollisionBehavior (imageView) {
        TranslatesReferenceBoundsIntoBoundary = true
    };

    // 3. add behaviors(s) to the dynamic animator
    dynAnimator.AddBehaviors (gravity, collision);
}
```

Объект `UICollisionBehavior` имеет свойство с именем `TranslatesReferenceBoundsIntoBoundry`. Если задать для `true` этого параметра значение, границы ссылочного представления будут использоваться в качестве границы конфликта.

Теперь, когда изображение анимируется вниз с помощью притяжения, оно слегка переводится в нижнюю часть экрана, прежде чем приступать к его нахождении.

<!--, as shown below:

 ![](images/bounce.png "Now, when the image animates downward with gravity, it bounces slightly off the bottom of the screen before settling to rest there")-->

#### <a name="uidynamicitembehavior"></a>уидинамиЦитембехавиор

Можно дополнительно управлять поведением представления «неработающий образ» с помощью дополнительных поведений. Например, можно добавить `UIDynamicItemBehavior` , чтобы увеличить эластичность, в результате чего представление изображения переводится в другое окно, когда оно конфликтует с нижней частью экрана.

Для добавления `UIDynamicItemBehavior` следует выполнить те же действия, что и в других поведений. Сначала создайте поведение:

```csharp
var dynBehavior = new UIDynamicItemBehavior (dynItems) {
    Elasticity = 0.7f
};
```

Затем добавьте поведение в динамический аниматор:

 `dynAnimator.AddBehavior (dynBehavior);`

После такого поведения представление изображения помещается больше, когда оно конфликтует с границей.

## <a name="general-user-interface-changes"></a>Общие изменения пользовательского интерфейса

В дополнение к новым API UIKit, таким как UIKit Dynamics, переходы контроллеров и Улучшенная анимация UIView, описанная выше, iOS 7 предоставляет разнообразные визуальные изменения в пользовательском интерфейсе и связанные изменения API для различных представлений и элементов управления. Дополнительные сведения см. в статье [Общие сведения о пользовательском интерфейсе iOS 7](~/ios/platform/introduction-to-ios7/ios7-ui.md).

## <a name="text-kit"></a>Набор текстов

Набор текстов — это новый интерфейс API, предлагающий мощные функции верстки и отрисовки текста. Она построена на основе основной платформы текста нижнего уровня, но гораздо проще в использовании, чем основной текст.

Дополнительные сведения см. в нашем [тексткит](~/ios/platform/textkit.md)

## <a name="multitasking"></a>Многозадачность

iOS 7 изменяет время и принципы выполнения фоновой работы. Завершение задач в iOS 7 больше не сохраняет приложения в спящем режиме, когда задачи выполняются в фоновом состоянии, а приложения пробуждении для фоновой обработки несмежным образом. в iOS 7 также добавлены три новых API для обновления приложений с новым содержимым в фоновом режиме:

- Фоновая выборка — позволяет приложениям обновлять содержимое в фоновом режиме через регулярные интервалы.
- Удаленные уведомления. позволяет приложениям обновлять содержимое при получении push-уведомления. Уведомления могут быть либо скрыты, либо могут отображаться на экране блокировки.
- Служба фоновой передачи — позволяет отправлять и скачивать данные, например большие файлы, без фиксированного ограничения по времени.

Дополнительные сведения о новых возможностях многозадачности [см. в](~/ios/app-fundamentals/backgrounding/index.md)разделах iOS в этом разделе.

## <a name="summary"></a>Сводка

В этой статье рассматривается несколько новых дополнений к iOS. Сначала показано, как добавить пользовательские переходы к контроллерам представления. Затем показано, как использовать переходы в представлениях коллекции как из контроллера навигации, так и в интерактивном режиме между представлениями коллекции. Теперь в нем представлено несколько улучшений UIView анимации, показывая, как приложения используют UIKit для тех вещей, которые ранее требовалось программировать непосредственно в основной анимации. Наконец, новый API UIKit Dynamics, который переносит физический механизм в UIKit, появился наряду с поддержкой форматированного текста, которая теперь доступна в платформе текстовых Kit.

## <a name="related-links"></a>Связанные ссылки

- [Введение в iOS 7 (пример)](https://docs.microsoft.com/samples/xamarin/ios-samples/introtoios7)
- [Обзор пользовательского интерфейса iOS 7](~/ios/platform/introduction-to-ios7/ios7-ui.md)
- [Фоновая обработка](~/ios/app-fundamentals/backgrounding/index.md)
