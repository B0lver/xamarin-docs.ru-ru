---
title: Введение в iOS 7
description: В этой статье рассматриваются основные новые интерфейсы API, появившиеся в iOS 7, включая переходы на контроллеры представлений, улучшения UIView анимации, UIKit Dynamics и Text Kit. В нем также рассматриваются некоторые изменения пользовательского интерфейса и новые возможности многозадачности Расширенная.
ms.prod: xamarin
ms.assetid: 2C33018F-D64A-4BAA-A34E-082EF311D162
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/19/2017
ms.openlocfilehash: b405643096699e1d965f485bdc590afa178881d6
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73031821"
---
# <a name="introduction-to-ios-7"></a>Введение в iOS 7

_В этой статье рассматриваются основные новые интерфейсы API, появившиеся в iOS 7, включая переходы на контроллеры представлений, улучшения UIView анимации, UIKit Dynamics и Text Kit. В нем также рассматриваются некоторые изменения пользовательского интерфейса и новые возможности многозадачности Расширенная._

iOS 7 — это значительное обновление для iOS. В ней представлено совершенно новое Проектирование пользовательского интерфейса, которое помещает фокус на содержимое, а не на хром приложения. Наряду с визуальными изменениями iOS 7 добавляет множество новых интерфейсов API для создания более мощных взаимодействий и возможностей. В этом документе рассматриваются новые технологии, появившиеся в iOS 7, и служит отправной точкой для дальнейшего изучения.

## <a name="uiview-animation-enhancements"></a>Усовершенствования анимации UIView

iOS 7 дополняет поддержку анимации в UIKit, позволяя приложениям выполнять те действия, которые ранее требовали удаления непосредственно в основную платформу анимации. Например, `UIView` теперь может выполнять анимацию пружины, а также анимацию опорных кадров, которая ранее `CAKeyframeAnimation` применена к `CALayer`.

### <a name="spring-animations"></a>Пружинные анимации

 `UIView` теперь поддерживает анимацию изменений свойств с пружинным действием. Чтобы добавить это значение, вызовите метод `AnimateNotify` или `AnimateNotifyAsync`, передав значения для коэффициента затухания и начальной скорости весны, как описано ниже.

- `springWithDampingRatio` — значение от 0 до 1, где колебаний увеличивается для меньшего значения.
- `initialSpringVelocity` — начальная пружинная скорость в процентах от общего расстояния анимации в секунду.

Следующий код создает пружинный результат при изменении центра представления изображения:

```csharp
void AnimateWithSpring ()
{
    float springDampingRatio = 0.25f;
    float initialSpringVelocity = 1.0f;

    UIView.AnimateNotify (3.0, 0.0, springDampingRatio, initialSpringVelocity, 0, () => {

        imageView.Center = new CGPoint (imageView.Center.X, 400);

    }, null);
}
```

Этот эффект приведет к тому, что представление изображения будет выглядеть по мере того, как оно завершит свою анимацию до нового центрального расположения, как показано ниже:

 ![](images/spring-animation.png "This spring effect causes the image view to appear to bounce as it completes its animation to a new center location")

### <a name="keyframe-animations"></a>Анимация опорных кадров

Класс `UIView` теперь включает метод `AnimateWithKeyframes` для создания анимации опорных кадров на `UIView`. Этот метод аналогичен другим методам анимации `UIView`, за исключением того, что в качестве параметра для включения ключевых кадров передается дополнительный `NSAction`. В `NSAction` опорные кадры добавляются путем вызова `UIView.AddKeyframeWithRelativeStartTime`.

Например, следующий фрагмент кода создает анимацию опорного кадра для анимации центра представления, а также для поворота представления.

```csharp
void AnimateViewWithKeyframes ()
{
    var initialTransform = imageView.Transform;
    var initialCeneter = imageView.Center;

    // can now use keyframes directly on UIView without needing to drop directly into Core Animation

    UIView.AnimateKeyframes (2.0, 0, UIViewKeyframeAnimationOptions.Autoreverse, () => {
        UIView.AddKeyframeWithRelativeStartTime (0.0, 0.5, () => {
            imageView.Center = new CGPoint (200, 200);
        });

        UIView.AddKeyframeWithRelativeStartTime (0.5, 0.5, () => {
            imageView.Transform = CGAffineTransform.MakeRotation ((float)Math.PI / 2);
        });
    }, (finished) => {
        imageView.Center = initialCeneter;
        imageView.Transform = initialTransform;

        AnimateWithSpring ();
    });
}
```

Первые два параметра метода `AddKeyframeWithRelativeStartTime` указывают время начала и длительность опорного кадра соответственно в процентах от общей длины анимации. Приведенный выше пример приводит к анимации представления изображения в новом центре в течение первой секунды, за которым следует поворот на 90 градусов на следующую секунду. Так как анимация указывает `UIViewKeyframeAnimationOptions.Autoreverse` как параметр, оба опорных кадра также отменяют на обратную. Наконец, конечные значения задаются в начальном состоянии в обработчике завершения.

На снимках экрана ниже показана комбинированная анимация через ключевые кадры:

 ![](images/keyframes.png "This screenshots illustrates the combined animation through the keyframes")

## <a name="uikit-dynamics"></a>UIKit Dynamics

UIKit Dynamics — это новый набор API-интерфейсов в UIKit, позволяющий приложениям создавать анимированные взаимодействия на основе физикы. UIKit Dynamics инкапсулирует механизм двухмерной физикы, чтобы сделать это возможным.

По сути, API является декларативным. Вы объявляете, как осуществляется взаимодействие по физике, создавая объекты, называемые *поведением* , для выражения физических концепций, таких как сила притяжения, конфликты, пружины и т. д. Затем вы подключаете поведение к другому объекту, называемому *динамическим аниматор*, который инкапсулирует представление. Динамический аниматор заботится о применении объявленного поведения физикы к *динамическим элементам* — элементам, которые реализуют `IUIDynamicItem`, например `UIView`.

Существует несколько различных примитивных вариантов поведения, которые могут вызывать сложные взаимодействия, включая:

- `UIAttachmentBehavior` — соединяет два динамических элемента таким, что они перемещаются вместе, или присоединяет динамический элемент к точке вложения.
- `UICollisionBehavior` — позволяет динамическим элементам участвовать в конфликтах.
- `UIDynamicItemBehavior` — указывает общий набор свойств, применяемых к динамическим элементам, таким как эластичность, плотность и трение.
- `UIGravityBehavior` — применяет значение тяжести к динамическому элементу, что приводит к ускорению элементов в направлении гравитатионал.
- `UIPushBehavior` — применяет принудительное применение к динамическому элементу.
- `UISnapBehavior` — позволяет привязывать динамический элемент к положению с пружинным действием.

Хотя существует много примитивов, общий процесс добавления нефизических взаимодействий в представление с использованием UIKit Dynamics согласовано по поведению:

1. Создайте динамический аниматор.
1. Создание поведений.
1. Добавьте поведения в динамический аниматор.

### <a name="dynamics-example"></a>Пример Dynamics

Рассмотрим пример, который добавляет границу тяжести и конфликт в `UIView`.

#### <a name="uigravitybehavior"></a>уигравитибехавиор

Чтобы добавить в представление изображения значение тяжести, выполните три шага, описанные выше.

В этом примере мы будем работать в методе `ViewDidLoad`. Сначала добавьте `UIImageView` экземпляр, как показано ниже.

```csharp
image = UIImage.FromFile ("monkeys.jpg");

imageView = new UIImageView (new CGRect (new CGPoint (View.Center.X - image.Size.Width / 2, 0), image.Size)) {
                    Image =  image
                }

View.AddSubview (imageView);
```

Это приведет к созданию представления изображений, центрированного по верхнему краю экрана. Чтобы сделать изображение "попадать" с помощью тяжести, создайте экземпляр `UIDynamicAnimator`:

```csharp
dynAnimator = new UIDynamicAnimator (this.View);
```

`UIDynamicAnimator` принимает экземпляр ссылочного `UIView` или `UICollectionViewLayout`, который содержит элементы, которые будут анимированы в соответствии с присоединенным поведением.

Затем создайте экземпляр `UIGravityBehavior`. Можно передать один или несколько объектов, реализующих `IUIDynamicItem`, например `UIView`:

```csharp
var gravity = new UIGravityBehavior (dynItems);
```

Поведение передается массиву `IUIDynamicItem`, который в данном случае содержит единственный экземпляр `UIImageView`, для которого выполняется анимация.

Наконец, добавьте поведение в динамический аниматор:

```csharp
dynAnimator.AddBehavior (gravity);
```

Это приводит к анимации изображения вниз с помощью притяжения, как показано ниже:

![](images/gravity2.png "The starting image location")
![](images/gravity3.png "The ending image location")

Поскольку границы экрана не ограничиваются, представление изображения просто падает снизу. Чтобы ограничить представление таким образом, чтобы изображение конфликтует с краями экрана, можно добавить `UICollisionBehavior`. Это будет рассмотрено в следующем разделе.

#### <a name="uicollisionbehavior"></a>уиколлисионбехавиор

Начнем с создания `UICollisionBehavior` и добавления его в динамический аниматор, как и для `UIGravityBehavior`.

Измените код, включив в него `UICollisionBehavior`:

```csharp
using (image = UIImage.FromFile ("monkeys.jpg")) {

    imageView = new UIImageView (new CGRect (new CGPoint (View.Center.X - image.Size.Width / 2, 0), image.Size)) {
        Image =  image
    };

    View.AddSubview (imageView);

    // 1. create the dynamic animator
    dynAnimator = new UIDynamicAnimator (this.View);

    // 2. create behavior(s)
    var gravity = new UIGravityBehavior (imageView);
    var collision = new UICollisionBehavior (imageView) {
        TranslatesReferenceBoundsIntoBoundary = true
    };

    // 3. add behaviors(s) to the dynamic animator
    dynAnimator.AddBehaviors (gravity, collision);
}
```

`UICollisionBehavior` имеет свойство с именем `TranslatesReferenceBoundsIntoBoundry`. Присвоение этому параметру значения `true` приводит к тому, что границы ссылочного представления будут использоваться в качестве границы конфликта.

Теперь, когда изображение анимируется вниз с помощью притяжения, оно слегка переводится в нижнюю часть экрана, прежде чем приступать к его нахождении.

<!--, as shown below:

 ![](images/bounce.png "Now, when the image animates downward with gravity, it bounces slightly off the bottom of the screen before settling to rest there")-->

#### <a name="uidynamicitembehavior"></a>уидинамиЦитембехавиор

Можно дополнительно управлять поведением представления «неработающий образ» с помощью дополнительных поведений. Например, можно добавить `UIDynamicItemBehavior`, чтобы увеличить эластичность, что приведет к увеличению представления изображения, когда оно конфликтует с нижней частью экрана.

Добавление `UIDynamicItemBehavior` следует тем же действиям, что и в других поведении. Сначала создайте поведение:

```csharp
var dynBehavior = new UIDynamicItemBehavior (dynItems) {
    Elasticity = 0.7f
};
```

Затем добавьте поведение в динамический аниматор:

 `dynAnimator.AddBehavior (dynBehavior);`

После такого поведения представление изображения помещается больше, когда оно конфликтует с границей.

## <a name="general-user-interface-changes"></a>Общие изменения пользовательского интерфейса

В дополнение к новым API UIKit, таким как UIKit Dynamics, переходы контроллеров и Улучшенная анимация UIView, описанная выше, iOS 7 предоставляет разнообразные визуальные изменения в пользовательском интерфейсе и связанные изменения API для различных представлений и элементов управления. Дополнительные сведения см. в статье [Общие сведения о пользовательском интерфейсе iOS 7](~/ios/platform/introduction-to-ios7/ios7-ui.md).

## <a name="text-kit"></a>Набор текстов

Набор текстов — это новый интерфейс API, предлагающий мощные функции верстки и отрисовки текста. Она построена на основе основной платформы текста нижнего уровня, но гораздо проще в использовании, чем основной текст.

Дополнительные сведения см. в нашем [тексткит](~/ios/platform/textkit.md)

## <a name="multitasking"></a>Многозадачность

iOS 7 изменяет время и принципы выполнения фоновой работы. Завершение задач в iOS 7 больше не сохраняет приложения в спящем режиме, когда задачи выполняются в фоновом состоянии, а приложения пробуждении для фоновой обработки несмежным образом. в iOS 7 также добавлены три новых API для обновления приложений с новым содержимым в фоновом режиме:

- Фоновая выборка — позволяет приложениям обновлять содержимое в фоновом режиме через регулярные интервалы.
- Удаленные уведомления. позволяет приложениям обновлять содержимое при получении push-уведомления. Уведомления могут быть либо скрыты, либо могут отображаться на экране блокировки.
- Служба фоновой передачи — позволяет отправлять и скачивать данные, например большие файлы, без фиксированного ограничения по времени.

Дополнительные сведения о новых возможностях многозадачности [см. в](~/ios/app-fundamentals/backgrounding/index.md)разделах iOS в этом разделе.

## <a name="summary"></a>Сводка

В этой статье рассматривается несколько новых дополнений к iOS. Сначала показано, как добавить пользовательские переходы к контроллерам представления. Затем показано, как использовать переходы в представлениях коллекции как из контроллера навигации, так и в интерактивном режиме между представлениями коллекции. Теперь в нем представлено несколько улучшений UIView анимации, показывая, как приложения используют UIKit для тех вещей, которые ранее требовалось программировать непосредственно в основной анимации. Наконец, новый API UIKit Dynamics, который переносит физический механизм в UIKit, появился наряду с поддержкой форматированного текста, которая теперь доступна в платформе текстовых Kit.

## <a name="related-links"></a>Связанные ссылки

- [Введение в iOS 7 (пример)](https://docs.microsoft.com/samples/xamarin/ios-samples/introtoios7)
- [Обзор пользовательского интерфейса iOS 7](~/ios/platform/introduction-to-ios7/ios7-ui.md)
- [Фоновая обработка](~/ios/app-fundamentals/backgrounding/index.md)
