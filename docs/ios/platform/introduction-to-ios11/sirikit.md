---
title: SiriKit обновлений в iOS 11
description: В этом документе описывается, как работать с SiriKit в iOS 11. В частности рассматривается, как работать с задач и заметок и обеспечить альтернативные имена для приложения.
ms.prod: xamarin
ms.assetid: 8F75300B-B591-42ED-9D17-001992A5C381
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 09/07/2017
ms.openlocfilehash: 7e895dc2865880ec2789a40f8cdf047a20f8693b
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61400332"
---
# <a name="sirikit-updates-in-ios-11"></a>SiriKit обновлений в iOS 11

SiriKit впервые появился в iOS 10, с количеством доменов службы (включая тренировок поездке резервирования и вызовы). Ссылаться на [SiriKit разделе](~/ios/platform/sirikit/index.md) для понятиях SiriKit и реализация SiriKit в вашем приложении.

![Демонстрация списка задач Siri](sirikit-images/sirikit.png)

SiriKit в iOS 11 добавляет эти новые и обновленные намерений домены:

- [**Содержит список и заметки о** ](#listsnotes) — New! Предоставляет API для приложений для обработки задач и заметок.
- **Коды Visual** — New! Siri можно отобразить QR-коды для предоставления контактных данных или участвовать в транзакциях оплаты.
- **Платежи** — добавлен способы поиска и передачи для оплаты взаимодействий.
- **Воспользуйтесь преимуществами нового заказа столиков в ресторане** — добавлены Отмена намерения поездке и обратной связи.

Другие новые возможности:

- [**Имена приложений альтернативные** ](#alternativenames) — предоставляет псевдонимы, которые помогут клиентам определить целевые приложения, предлагая альтернативные имена/произношений Siri.
- **Запуск тренировок** — предоставляет возможность запускать тренировок в фоновом режиме.

Некоторые из этих функций описаны ниже. Дополнительные сведения о других называть [документации Apple SiriKit](https://developer.apple.com/documentation/sirikit).

<a name="listsnotes" />

## <a name="lists-and-notes"></a>Списки и примечания

Списки и заметки о новом домене предоставляет API для приложений для обработки задач и заметок с помощью голосовых запросов Siri.

**Задачи**

- Иметь заголовок и состоянием завершения.
- При необходимости включите, крайнего срока и расположение.

**Примечания**

- Иметь заголовок и содержимого поля.

Задачи и примечания могут быть организованы в группы. В оставшейся части этого раздела описывается, как реализовать этот новый домен с SiriKit, с помощью [TasksNotes SiriKit пример](https://developer.xamarin.com/samples/monotouch/ios11/SiriKitSample/).

### <a name="how-to-process-a-sirikit-request"></a>Способ обработки запроса SiriKit

Обработайте запрос SiriKit, выполнив следующие действия:

1. **Разрешить** — проверки параметров и запрашивать дополнительные сведения от пользователя (при необходимости).
2. **Подтвердите** — финальную проверку и проверку подлинности, что запрос может быть обработан.
3. **Обрабатывать** — выполнить операцию (обновление данных или выполнение сетевых операций).

Первые два шага необязательны (несмотря на то, что рекомендуется), и последний шаг является обязательным.
Более подробные указания в [SiriKit разделе](~/ios/platform/sirikit/index.md).

### <a name="resolve-and-confirm-methods"></a>Устраните и подтвердить методы

Эти необязательные методы позволяют код выполнять проверку, выберите значения по умолчанию и Дополнительные сведения о запросе от пользователя.

Например для `IINCreateTaskListIntent` интерфейс, необходимый метод — `HandleCreateTaskList`. Существует четыре необязательные методы, которые обеспечивают больший контроль над взаимодействием Siri:

- `ResolveTitle` — Проверяет заголовок, задает заголовок по умолчанию (если применимо) и сообщает, что данные не требуется.
- `ResolveTaskTitles` — Проверяет, список задач, произносятся пользователем.
- `ResolveGroupName` — Проверяет имя группы, выбирает группу по умолчанию или сообщает, что данные не требуется.
- `ConfirmCreateTaskList` — Проверяет, что ваш код может выполнить запрошенную операцию, но не выполняет (только `Handle*` методы следует изменять данные).

### <a name="handle-the-intent"></a>Дескриптор намерение

Существует шесть намерения в домене, списки и примечания, три для задач и три для заметки.
Ниже приведены методы, которые необходимо реализовать для обработки эти intents.

- Для выполнения задач:
  - `HandleAddTasks`
  - `HandleCreateTaskList`
  - `HandleSetTaskAttribute`
- Ознакомиться с заметками:
  - `HandleCreateNote`
  - `HandleAppendToNote`
  - `HandleSearchForNotebookItems`

Каждый метод имеет определенного намерений типа переданного ему, который содержит всю информацию, Siri выполнит синтаксический анализ из запроса пользователя (и возможно обновление в `Resolve*` и `Confirm*` методов).
Ваше приложение должно синтаксический анализ данных, а затем выполнить некоторые действия для хранения или иной обработки данных и возвращают результат, Siri выступает с докладами и показывает пользователю.

### <a name="response-codes"></a>Коды ответов

Необходимая `Handle*` и необязательные `Confirm*` методы указывают код ответа, задав значение для объекта, передаваемого обработчику их завершения. Ответы поступают из `INCreateTaskListIntentResponseCode` перечисления:

- `Ready` — Возвращает на этапе подтверждения (т. е. из `Confirm*` метод, но не из `Handle*` метод).
- `InProgress` — Используется для длительно выполняемых задач (например, сети или сервера).
- `Success` — Возвращает сведения об успешной операции (только из `Handle*` метод).
- `Failure` — Означает, что произошла ошибка, а не удалось выполнить операцию.
- `RequiringAppLaunch` — Не может быть обработан намерения, но операция возможна в приложении.
- `Unspecified` — Не используйте: сообщение об ошибке будет отображаться для пользователя.

Дополнительные сведения об этих методах и ответы в Apple [SiriKit перечислены и заметки о документации](https://developer.apple.com/documentation/sirikit/lists_and_notes).

### <a name="implementing-lists-and-notes"></a>Реализация списков и примечания

[TasksNotes SiriKit пример](https://developer.xamarin.com/samples/monotouch/ios11/SiriKitSample/) была создана, выполнив следующие действия для добавления поддержки SiriKit в пустое приложение iOS.

Во-первых Чтобы добавить поддержку SiriKit, выполните следующие действия для приложения iOS.

1. Такт **SiriKit** в **Entitlements.plist**.
2. Добавить **конфиденциальность — Описание использования Siri** ключа **Info.plist**, вместе с сообщением для ваших клиентов.
3. Вызовите `INPreferences.RequestSiriAuthorization` метод в приложении, чтобы предложить пользователю позволяют выполнять взаимодействия по Siri.
4. Добавьте SiriKit в идентификатор приложения на портале разработчика и повторного создания профилей подготовки для включения новых назначением.

Затем добавьте новый проект расширения приложения, чтобы обрабатывать запросы Siri:

1. Щелкните правой кнопкой мыши на своем решении и выберите **Добавить > Добавить новый проект...** .
2. Выберите **iOS > расширения > расширение Intents** шаблона.
3. Будут добавлены два новых проектов: С намерением доступа и IntentUI. Настройки пользовательского интерфейса не является обязательным, поэтому в примере имеются только код в **намерение** проекта.

Проект расширения является, где все SiriKit запросы будут обрабатываться. Как отдельное расширение он не поддерживает автоматически любой способ обмена информацией с основного приложения — это обычно устраняется реализацией хранилища общих файлов с помощью групп приложений.

#### <a name="configure-the-intenthandler"></a>Настройка IntentHandler

`IntentHandler` Класс является точкой входа для Siri запрашивает — каждые намерение передается `GetHandler` метод, который возвращает объект, который может обработать запрос.

В приведенном ниже коде показана простая реализация:

```csharp
[Register("IntentHandler")]
public partial class IntentHandler : INExtension, IINNotebookDomainHandling
{
  protected IntentHandler(IntPtr handle) : base(handle)
  {}
  public override NSObject GetHandler(INIntent intent)
  {
    // This is the default implementation.  If you want different objects to handle different intents,
    // you can override this and return the handler you want for that particular intent.
    return this;
  }
  // add intent handlers here!
}
```

Класс должен наследоваться от `INExtension`, и так как в примере предполагается обработка списки и заметки о намерения, он также реализует `IINNotebookDomainHandling`.

> [!NOTE]
> - В .NET для интерфейсов с заглавной буквы префиксом имеется соглашение `I`, которой соответствует Xamarin при привязке протоколы из пакета SDK для iOS.
> - Xamarin также сохраняет имена типов из iOS и Apple использует первыми двумя символами в имена типов в соответствии с платформой, к которой принадлежит тип.
> - Для `Intents` framework, типы начинаются с префикса `IN*` (например) `INExtension`), но это _не_ интерфейсов.
> - Также следует, что протоколы (который становятся интерфейсов в C#) в итоге с двумя `I`s, такие как `IINAddTasksIntentHandling`.

#### <a name="handling-intents"></a>Способы обработки

Каждый намерение (Добавить задачу, задайте атрибут задачи, и т.д.) реализуется в единственном методе аналогичен показанному ниже. Метод должен выполнить три основные функции:

1. **Обработать цель** — доступность данных, их анализирует Siri в `intent` объекта, зависящие от типа намерение. Приложение может утвердили эти данные с помощью дополнительных `Resolve*` методы.
2. **Проверьте и обновите хранилище данных** , сохраните данные в файловую систему (с помощью групп приложений, таким образом, основное приложение iOS также доступен) или через сетевой запрос.
3. **Предоставления ответа** — использование `completion` обработчик для отправки ответа обратно в Siri для чтения и отображения для пользователя:

```csharp
public void HandleCreateTaskList(INCreateTaskListIntent intent, Action<INCreateTaskListIntentResponse> completion)
{
  var list = TaskList.FromIntent(intent);
  // TODO: have to create the list and tasks... in your app data store
  var response = new INCreateTaskListIntentResponse(INCreateTaskListIntentResponseCode.Success, null)
  {
    CreatedTaskList = list
  };
  completion(response);
}
```

Обратите внимание, что `null` передается как второй параметр в ответ — это параметр действия пользователя, и когда он не задан, будет использоваться значение по умолчанию.
Можно задать тип пользовательского действия до тех пор, пока ваше приложение iOS поддерживает его с помощью `NSUserActivityTypes` в **Info.plist**. Затем можно этот случай при открытии приложения и выполнять определенные операции (например, открыв к контроллеру соответствующего представления и загрузки данных из операции Siri).

Пример также кодируется `Success` результат, но в реальных сценариях отчетов об ошибке должны добавляться.

### <a name="test-phrases"></a>Тестирование фраз

В примере приложения должны работать следующие фразы теста:

- «Обеспечить списком покупок с яблоки bananas и Груши в TasksNotes»
- «Добавить задачу WWDC в TasksNotes»
- «Добавление задач WWDC список учебных в TasksNotes»
- «Mark посетите WWDC как завершенный в TasksNotes»
- «В TasksNotes Напомнить мне надо купить iphone, при получении Главная»
- «Mark покупать iPhone как завершенный в TasksNotes»
- «Напомнить Главная оставить в 8: 00 в TasksNotes»

![Создайте новый пример списка](sirikit-images/createtasklist-sml.png) ![Набор задач, как полный пример](sirikit-images/settaskattribute-sml.png)

> [!NOTE]
> Симулятор iOS 11 поддерживает, тестирование с помощью Siri (в отличие от более ранних версий).
>
> Если тестирование на реальных устройствах, не забудьте настроить идентификатор приложения и профили для поддержки SiriKit подготовки.

<a name="alternativenames" />

## <a name="alternative-names"></a>Альтернативные имена

Эта новая функция iOS 11 означает, что можно настроить альтернативные имена для вашего приложения, чтобы помочь пользователям активировать правильно с Siri. Добавьте следующие разделы для **Info.plist** файл проекта приложения iOS:

![Info.plist, отображающую приложения альтернативное имя ключи и значения](sirikit-images/alternative-names.png)

С набором имен альтернативные приложения, следующие фразы также будет работать для примера приложения (который на самом деле называется **TasksNotes**):

- «Для создания списка продуктового яблоки bananas и Груши в _MonkeyNotes_"
- «Добавление задач WWDC в _MonkeyTodo_"


## <a name="troubleshooting"></a>Устранение неполадок

Некоторые ошибки, возникающие во время выполнения образца на процессор или добавив SiriKit приложения:

### <a name="nsinternalinconsistencyexception"></a>NSInternalInconsistencyException

_Objective-C исключение.  Имя. NSInternalInconsistencyException причина: Использование класса < INPreferences: 0x60400082ff00 > из приложения требует com.apple.developer.siri прав. Включена ли возможность Siri в проекте Xcode?_

- SiriKit установлен в **Entitlements.plist**.
- **Entitlements.plist** настраивается в **параметры проекта > Создать > подписывание пакета iOS**.

  [![Параметры проекта, указывающий, что правильно задано прав](sirikit-images/set-entitlements-sml.png)](sirikit-images/set-entitlements.png#lightbox)

- (для развертывания устройства) Идентификатор приложения имеет SiriKit включен и загружен профиль подготовки.


## <a name="related-links"></a>Связанные ссылки

- [SiriKit (Apple)](https://developer.apple.com/documentation/sirikit)
- [Пример TasksNotes SiriKit](https://developer.xamarin.com/samples/monotouch/ios11/SiriKitSample/)
- [Новые возможности в SiriKit (WWDC) (видео)](https://developer.apple.com/videos/play/wwdc2017/214/)
