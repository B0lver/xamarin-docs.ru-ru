---
title: Сенсорный идентификатор в Xamarin. iOS
description: В этом документе описывается, как использовать сенсорный идентификатор, технологию проверки подлинности пальцев на основе биометрических параметров Apple в приложениях Xamarin. iOS.
ms.prod: xamarin
ms.assetid: 4BC8EFD6-52FC-4793-BA69-D6BFF850FE5F
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/20/2017
ms.openlocfilehash: 0f92dca71f74266e1408cd65c842f729a9a648ce
ms.sourcegitcommit: 3d21bb1a6d9b78b65aa49917b545c39d44aa3e3c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/28/2019
ms.locfileid: "70065665"
---
# <a name="touch-id-in-xamarinios"></a>Сенсорный идентификатор в Xamarin. iOS

Touch ID появился в iOS 7 в качестве средства проверки подлинности пользователя, похожего на секретный код. Однако было ограничено Разблокирование устройства с помощью магазина приложений, использование iTunes и проверка подлинности только для цепочки ключей iCloud.

Сейчас существует два способа использования Touch ID в качестве механизма проверки подлинности в приложении iOS 8 с помощью локального API проверки подлинности. Сейчас невозможно использовать локальную проверку подлинности для удаленного выполнения проверки подлинности.

Чтобы полностью понять сенсорный идентификатор и его стоимость, следует изучить службы цепочки ключей и то, что означают эти новые изменения для данных пользователя. Доступ к цепочке ключей также был расширен в iOS 8 с помощью новых функций списков управления доступом (ACL).

## <a name="keychain--secure-enclave"></a>Цепочка ключей & Secure анклава

Цепочка ключей — это большая база данных, обеспечивающая безопасное хранение паролей, ключей, сертификатов и примечаний для одного отдельного идентификатора Apple ID. В iOS 8 приложение всегда имеет доступ к собственным уникальным элементам цепочки ключей и не может получить доступ к элементам цепочки ключей других приложений. Это отличается от OS X, где цепочка ключей разблокирована одним паролем, позволяя любому приложению, поддерживающему цепочку ключей, использовать цепочку ключей. В этой статье мы рассмотрим, как работает цепочка ключей в iOS 8.

Цепочка ключей — это специализированная база данных, в которой каждая строка называется _элементом цепочки ключей_. Каждый элемент описывается атрибутами цепочки ключей и состоит из зашифрованных значений. Чтобы обеспечить эффективное использование цепочки ключей, она оптимизирована для небольших элементов или _секретов_.
Каждый элемент цепочки ключей защищен секретным кодом пользователя и уникальным секретом устройства. Элементы цепочки ключей должны быть защищены даже в том случае, если пользователи не используют свои устройства. Это реализовано в iOS, разрешая доступ к элементам только после разблокировки устройства — когда устройство заблокировано, оно становится недоступным. Они также могут храниться в зашифрованной резервной копии. Одной из основных функций цепочки ключей является обеспечение контроля доступа. приложение имеет доступ к своей части цепочки ключей, и все другие приложения будут предотвращены. На схеме ниже показано, как приложение взаимодействует с цепочкой ключей.

[![](touchid-images/image1.png "На этой схеме показано, как приложение взаимодействует с цепочкой ключей.")](touchid-images/image1.png#lightbox)

### <a name="secure-enclave"></a>Защита анклава

Цепочка ключей не может расшифровать сам элемент цепочки ключей. Вместо этого он выполняется в *безопасном анклава*. Secure анклава — это сопроцессор в пределах микросхемы A7, который отвечает за определение успешного сопоставления данных отпечатка пальца от датчика сенсорного идентификатора с зарегистрированной печатью. Затем он расшифровывает элемент цепочки ключей и возвращает расшифрованный секрет в цепочку ключей.

### <a name="working-with-keychain"></a>Работа с цепочкой ключей

Сначала приложение должно выполнить запрос к цепочке ключей, чтобы проверить, существует ли пароль. Если он не существует, может потребоваться ввести пароль, чтобы пользователь не запрашивался. Если необходимо обновить пароль, запросите у пользователя новый пароль и передайте ему обновленное значение в цепочку ключей.

> [!NOTE]
> После использования секрета, полученного из цепочки ключей, все ссылки на данные должны быть удалены из памяти. Никогда не присваивайте его глобальной переменной.

## <a name="keychain-acl-and-touch-id"></a>Список ACL цепочки ключей и сенсорный идентификатор

Список управления доступом — это новый атрибут элемента цепочки ключей в iOS 8, описывающий сведения о том, что должно происходить, чтобы обеспечить выполнение определенной операции. Это может быть в виде отображения диалогового окна предупреждения или запроса секретного кода. Список управления доступом позволяет задать специальные возможности и проверку подлинности для элемента цепочки ключей. На схеме ниже показано, как этот новый атрибут связывается с остальной частью элемента цепочки ключей:

[![](touchid-images/image2.png "На этой схеме показано, как этот новый атрибут связывается с остальной частью элемента цепочки ключей.")](touchid-images/image2.png#lightbox)

Начиная с iOS 8, теперь появилась новая политика присутствия пользователя, `SecAccessControl`которая обеспечивается защитой анклава на iPhone 5S и более поздних версиях. В таблице ниже показано, как конфигурация устройства может повлиять на оценку политики.

|Конфигурация устройства|Оценка политики|Механизм резервного копирования|
|--- |--- |--- |
|Устройство без секретного кода|Нет доступа|Отсутствуют|
|Устройство с секретным кодом|Требуется секретный код|Отсутствуют|
|Устройство с сенсорным ИДЕНТИФИКАТОРом|Предпочтение сенсорного идентификатора|Разрешает секретный код|

Все операции в безопасном анклава могут доверять друг другу. Это означает, что мы можем использовать результат проверки подлинности Touch ID, чтобы авторизовать расшифровку элемента цепочки ключей. В Secure анклава также сохраняется счетчик совпадений ИДЕНТИФИКАТОРов сенсорного ввода. в этом случае пользователю придется вернуться к использованию секретного кода.
Новая платформа в iOS 8, называемая _локальной проверкой_подлинности, поддерживает этот процесс проверки подлинности на устройстве. Это будет рассмотрено в следующем разделе.

## <a name="local-authentication"></a>Локальная проверка подлинности

Как было установлено в предыдущем разделе, приложения могут использовать локальную проверку подлинности для проверки подлинности пользователя с соблюдением политики безопасности, настроенной на устройстве.

В настоящее время API предоставляет только две возможности: Во-первых, он помогает использовать существующие службы цепочки ключей с помощью новых списков управления доступом (ACL). Данные цепочки ключей можно разблокировать с помощью успешной проверки подлинности отпечатка пользователя.

Во вторых, LocalAuthentication предоставляет два метода для локальной проверки подлинности приложения. Разработчики должны использовать `CanEvaluatePolicy` , чтобы определить, может ли устройство принимать сенсорный идентификатор, а затем `EvaluatePolicy` начать операцию проверки подлинности.

Хотя обе возможности предлагают локальную проверку подлинности, они не предоставляют механизму приложения или пользователю проверку подлинности на удаленном сервере.
Локальная проверка подлинности предоставляет новый стандартный пользовательский интерфейс для проверки подлинности. В случае сенсорного идентификатора это представление предупреждений с двумя кнопками, как показано ниже. Одну кнопку для отмены и одну для использования резервных средств проверки подлинности — секретный код. Кроме того, необходимо задать пользовательское сообщение. Рекомендуется использовать этот метод, чтобы объяснить пользователю, зачем требуется проверка подлинности с помощью сенсорного кода.

[![](touchid-images/image12.png "Оповещение проверки подлинности Touch ID")](touchid-images/image12.png#lightbox)

### <a name="with-keychain-services"></a>С помощью служб цепочки ключей

Мы Просмотрели несколько предыдущих способов расшифровки элемента цепочки ключей, используя безопасный анклава для проверки секретного кода. В iOS 8 мы можем использовать локальную проверку подлинности для запроса проверки сенсорного ввода в сочетании с функцией списков управления доступом, которая предоставляет реализацию резервного механизма или пароля.
Чтобы использовать ACL, мы будем `SecAccessControl` использовать политику, а затем проверяя состояние устройства с помощью `SecAccessible.WhenPasscodeSetThisDeviceOnly` или `SecAccessible.WhenUnlocked`.

#### <a name="considerations-with-acl"></a>Рекомендации по списку управления доступом

При использовании ACL с цепочкой ключей следует помнить о многих вещах, и некоторые из них перечислены ниже.

- Используйте только с приложением переднего плана — если вы вызываете любую операцию цепочки ключей в фоновом потоке, вызов завершится ошибкой.
- Для добавления и обновления элементов цепочки ключей может потребоваться проверка подлинности.
- Если запрос возвращает несколько совпадающих элементов в цепочке ключей, может потребоваться проверка подлинности.
- Защищенные элементы ACL доступны только для устройств и поэтому не синхронизированы или не архивируются.

### <a name="using-local-authentication-without-keychain-services"></a>Использование локальной проверки подлинности без служб цепочки ключей

Локальная проверка подлинности была создана как способ для получения учетных данных, таких как секретный код или сенсорный идентификатор, а также для работы с безопасным анклава для завершения проверки подлинности пользователя. Его можно рассматривать как мост между приложением и безопасным анклава, который никогда не может взаимодействовать друг с другом напрямую. Его также можно использовать для оценки политики приложения.

Для этого приложение вызывает оценку политики в локальной проверке подлинности, которая запускает операцию внутри Secure анклава. Это можно использовать для проверки подлинности приложения без прямого запроса или доступа к безопасному анклава.

[![](touchid-images/image13a.png "Использование локальной проверки подлинности без служб цепочки ключей")](touchid-images/image13a.png#lightbox)

Использование локальной проверки подлинности в приложении обеспечивает простой способ реализации пользовательской проверки, например, для разблокировки функции только для глаз владельца устройства, например для банковских приложений, или для телеметрическую родительского контроля. приклад. Вы также можете использовать его в качестве способа расширения уже существующей проверки подлинности — пользователи, например сведения о безопасности, должны быть безопасными, но они также могут иметь параметры.

Безопасность локальной проверки подлинности отличается от безопасности цепочки ключей. Например, при использовании цепочки ключей отношение доверия между операционной системой и безопасным анклава. Локальная проверка подлинности — это между приложением и операционной системой. Это означает, что у вас есть доступ только к результатам безопасного анклава, а не к безопасному анклава.

На предмет безопасности также чрезвычайно важно помнить, что **нет доступа** к зарегистрированным пальцам или изображениям отпечатка. Secure анклава — это владелец этой информации, поэтому другие компоненты системы не имеют доступа к нему.

Чтобы использовать сенсорный идентификатор без цепочки ключей, используя локальный API проверки подлинности, можно использовать несколько функций. Ниже приведены подробные сведения.

* `CanEvaluatePolicy`— Проверяет, может ли устройство принимать сенсорный идентификатор.
* `EvaluatePolicy`— Запускает операцию проверки подлинности и отображает пользовательский интерфейс и возвращает `true` ответ или. `false`
* `DeviceOwnerAuthenticationWithBiometrics`— Это политика, которую можно использовать для отображения экрана сенсорного идентификатора. Стоит отметить, что здесь нет механизма отката секретного кода, поэтому следует реализовать этот откат в приложении, чтобы пользователи могли пропустить проверку подлинности с помощью сенсорного кода.

Существует несколько предостережений с использованием локальной проверки подлинности, которые перечислены ниже.

* Как и в случае с цепочкой ключей, ее можно выполнять только на переднем плане. Вызов этого метода в фоновом потоке приведет к сбою.
* Помните, что вычисление политики может завершиться ошибкой. Кнопка секретного кода должна быть реализована в виде обратной связи.
* Необходимо предоставить, `localizedReason` чтобы объяснить, почему требуется проверка подлинности. Это помогает создавать отношения доверия с пользователем.

Далее в разделе ниже мы рассмотрим, как реализовать API, учитывающий эти предостережения.

## <a name="adding-touch-id-to-your-application"></a>Добавление в приложение идентификатора Touch

В предыдущих разделах мы рассматривали теорию доступа и проверки подлинности с помощью цепочки ключей и локальной проверки подлинности. Теперь мы рассмотрим, как можно интегрировать сенсорный идентификатор в приложение.

### <a name="walkthrough"></a>Пошаговое руководство

Давайте рассмотрим добавление в наше приложение проверки подлинности с помощью сенсорного кода. В этом пошаговом руководстве мы собираемся обновить образец [таблицы](https://docs.microsoft.com/samples/xamarin/ios-samples/data/storyboardtable/) раскадровки, добавив локальную проверку подлинности, чтобы она работала как образец раскадровки [— Локальная проверка](https://docs.microsoft.com/samples/xamarin/ios-samples/storyboardtable-localauthentication) подлинности, позволяющая пользователям, прошедшим проверку подлинности, добавлять в список новые дела.

1. Скачайте пример и запустите его в Visual Studio для Mac.
2. Дважды щелкните `MainStoryboard.Storyboard` , чтобы открыть пример в конструкторе iOS. В этом примере мы хотим добавить в наше приложение новый экран, который будет управлять проверкой подлинности. Это произойдет перед текущим `MasterViewController`.
3. Перетащите новый **контроллер представления** из **области элементов** в **область конструктора**. Установите его в качестве **корневого контроллера представлений** , нажав **CTRL + перетаскивание** из **контроллера навигации**:

    [![](touchid-images/image4.png "Задание контроллера корневого представления")](touchid-images/image4.png#lightbox)
4. Назовите новый контроллер `AuthenticationViewController`представления.
5. Затем перетащите кнопку и поместите ее на `AuthenticationViewController`. Вызовите его и присвойте ему текст `Add a Chore`. `AuthenticateButton`
6. Создайте событие для `AuthenticateButton` вызванного `AuthenticateMe`.
7. `AuthenticationViewController` Создайте ручной перехода из, щелкнув черную полосу в нижней части экрана и **удерживая нажатой клавишу CTRL, перетащите** ползунок в область `MasterViewController` и выберите команду **Отправить** (или покажите, если используется класс размера):

    [![](touchid-images/image5.png "Перетащите ползунок в MVC и выберите Отправить или отобразить.")](touchid-images/image6.png#lightbox)
8. Щелкните только что созданный перехода и присвойте ему идентификатор `AuthenticationSegue`, как показано ниже:

    [![](touchid-images/image7.png "Присвойте идентификатору перехода значение Аусентикатионсегуе")](touchid-images/image7.png#lightbox)
9. Добавьте следующий код в файл `AuthenticationViewController`:

    ```csharp
    partial void AuthenticateMe (UIButton sender)
    {
        var context = new LAContext();
        NSError AuthError;
        var myReason = new NSString("To add a new chore");

        if (context.CanEvaluatePolicy(LAPolicy.DeviceOwnerAuthenticationWithBiometrics, out AuthError)){
            var replyHandler = new LAContextReplyHandler((success, error) => {
                this.InvokeOnMainThread(()=> {
                    if(success)
                    {
                        Console.WriteLine("You logged in!");
                        PerformSegue("AuthenticationSegue", this);
                    }
                    else
                    {
                        // Show fallback mechanism here
                    }
                });
            });
            context.EvaluatePolicy(LAPolicy.DeviceOwnerAuthenticationWithBiometrics, myReason, replyHandler);
        };
    }
    ```

Это весь код, необходимый для реализации проверки подлинности с помощью сенсорного кода с использованием локальной проверки подлинности. В выделенных строках на изображении ниже показано использование локальной проверки подлинности.

[![](touchid-images/image8.png "Выделенные строки показывают использование локальной проверки подлинности")](touchid-images/image8.png#lightbox)

Во-первых, необходимо установить, может ли устройство принимать входные данные сенсорного ввода, используя `CanEvaluatePolicy` и передавая политику. `DeviceOwnerAuthenticationWithBiometrics` Если это так, мы можем отобразить пользовательский интерфейс Touch ID с помощью `EvaluatePolicy`. Есть три фрагмента информации, которые необходимо передать `EvaluatePolicy` , — саму политику, строку, объясняющую, зачем необходима проверка подлинности, и обработчик ответов. Обработчик ответов сообщает приложению, что оно должно делать в случае успешной или неудачной проверки подлинности. Давайте подробнее рассмотрим обработчик ответов:

[![](touchid-images/image9.png "Обработчик ответов")](touchid-images/image9.png#lightbox)

Обработчик ответов `LAContextReplyHandler`указан для типа, который принимает параметры Success `bool` (значение) и `NSError` вызывает `error`. Если это успешно, то именно здесь мы будем выполнять проверку подлинности — в этом случае отобразится экран, позволяющий добавить новую рутинную работу. Помните, что одна из предостережений локальной проверки подлинности заключается в том, что ее необходимо запускать на переднем плане `InvokeOnMainThread`, поэтому обязательно используйте:

[![](touchid-images/image10.png "Использовать Инвокеонмаинсреад для локальной проверки подлинности")](touchid-images/image10.png#lightbox)

Наконец, когда проверка подлинности прошла успешно, мы хотим перейти `MasterViewController`на. Для этого можно использовать метод.`PerformSegue`

[![](touchid-images/image11.png "Вызовите метод Перформсегуе, чтобы перейти к MVC")](touchid-images/image11.png#lightbox)

## <a name="summary"></a>Сводка

В этом руководство мы рассмотрели цепочку ключей и принципы ее работы в iOS. Мы также изучили список ACL цепочки ключей и вносимые в него изменения в iOS. Далее мы рассматривали локальную платформу проверки подлинности, которая впервые использовалась в iOS 8, а затем рассмотрела реализацию проверки подлинности Touch ID в нашем приложении.

## <a name="related-links"></a>Связанные ссылки

- [Таблица раскадровки — локальная проверка подлинности](https://docs.microsoft.com/samples/xamarin/ios-samples/storyboardtable-localauthentication)
- [Пример ВВДК цепочки ключей](https://docs.microsoft.com/samples/xamarin/ios-samples/ios8-keychaintouchid/)
- [Цепочка ключей (пример)](https://docs.microsoft.com/samples/xamarin/ios-samples/keychain/)
