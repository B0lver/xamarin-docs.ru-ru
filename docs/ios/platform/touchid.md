---
title: Сенсорный идентификатор в Xamarin. iOS
description: В этом документе описывается, как использовать сенсорный идентификатор, технологию проверки подлинности пальцев на основе биометрических параметров Apple в приложениях Xamarin. iOS.
ms.prod: xamarin
ms.assetid: 4BC8EFD6-52FC-4793-BA69-D6BFF850FE5F
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/20/2017
ms.openlocfilehash: 112a2a038be9f749f37d2d3260d08f2e58b0c597
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73031430"
---
# <a name="touch-id-in-xamarinios"></a>Сенсорный идентификатор в Xamarin. iOS

Touch ID появился в iOS 7 в качестве средства проверки подлинности пользователя, похожего на секретный код. Однако было ограничено Разблокирование устройства с помощью магазина приложений, использование iTunes и проверка подлинности только для цепочки ключей iCloud.

Сейчас существует два способа использования Touch ID в качестве механизма проверки подлинности в приложении iOS 8 с помощью локального API проверки подлинности. Сейчас невозможно использовать локальную проверку подлинности для удаленного выполнения проверки подлинности.

Чтобы полностью понять сенсорный идентификатор и его стоимость, следует изучить службы цепочки ключей и то, что означают эти новые изменения для данных пользователя. Доступ к цепочке ключей также был расширен в iOS 8 с помощью новых функций списков управления доступом (ACL).

## <a name="keychain--secure-enclave"></a>Цепочка ключей & Secure анклава

Цепочка ключей — это большая база данных, обеспечивающая безопасное хранение паролей, ключей, сертификатов и примечаний для одного отдельного идентификатора Apple ID. В iOS 8 приложение всегда имеет доступ к собственным уникальным элементам цепочки ключей и не может получить доступ к элементам цепочки ключей других приложений. Это отличается от OS X, где цепочка ключей разблокирована одним паролем, позволяя любому приложению, поддерживающему цепочку ключей, использовать цепочку ключей. В этой статье мы рассмотрим, как работает цепочка ключей в iOS 8.

Цепочка ключей — это специализированная база данных, в которой каждая строка называется _элементом цепочки ключей_. Каждый элемент описывается атрибутами цепочки ключей и состоит из зашифрованных значений. Чтобы обеспечить эффективное использование цепочки ключей, она оптимизирована для небольших элементов или _секретов_.
Каждый элемент цепочки ключей защищен секретным кодом пользователя и уникальным секретом устройства. Элементы цепочки ключей должны быть защищены даже в том случае, если пользователи не используют свои устройства. Это реализовано в iOS, разрешая доступ к элементам только после разблокировки устройства — когда устройство заблокировано, оно становится недоступным. Они также могут храниться в зашифрованной резервной копии. Одной из основных функций цепочки ключей является обеспечение контроля доступа. приложение имеет доступ к своей части цепочки ключей, и все другие приложения будут предотвращены. На схеме ниже показано, как приложение взаимодействует с цепочкой ключей.

[![](touchid-images/image1.png "This diagram illustrates how an application interacts with the keychain")](touchid-images/image1.png#lightbox)

### <a name="secure-enclave"></a>Защита анклава

Цепочка ключей не может расшифровать сам элемент цепочки ключей. Вместо этого он выполняется в *безопасном анклава*. Secure анклава — это сопроцессор в пределах микросхемы A7, который отвечает за определение успешного сопоставления данных отпечатка пальца от датчика сенсорного идентификатора с зарегистрированной печатью. Затем он расшифровывает элемент цепочки ключей и возвращает расшифрованный секрет в цепочку ключей.

### <a name="working-with-keychain"></a>Работа с цепочкой ключей

Сначала приложение должно выполнить запрос к цепочке ключей, чтобы проверить, существует ли пароль. Если он не существует, может потребоваться ввести пароль, чтобы пользователь не запрашивался. Если необходимо обновить пароль, запросите у пользователя новый пароль и передайте ему обновленное значение в цепочку ключей.

> [!NOTE]
> После использования секрета, полученного из цепочки ключей, все ссылки на данные должны быть удалены из памяти. Никогда не присваивайте его глобальной переменной.

## <a name="keychain-acl-and-touch-id"></a>Список ACL цепочки ключей и сенсорный идентификатор

Список управления доступом — это новый атрибут элемента цепочки ключей в iOS 8, описывающий сведения о том, что должно происходить, чтобы обеспечить выполнение определенной операции. Это может быть в виде отображения диалогового окна предупреждения или запроса секретного кода. Список управления доступом позволяет задать специальные возможности и проверку подлинности для элемента цепочки ключей. На схеме ниже показано, как этот новый атрибут связывается с остальной частью элемента цепочки ключей:

[![](touchid-images/image2.png "This diagram shows how this new attribute ties in with the rest of the keychain item")](touchid-images/image2.png#lightbox)

Начиная с iOS 8, теперь появилась новая политика присутствия пользователя, `SecAccessControl`, которая обеспечивается защитой анклава на iPhone 5S и более поздних версиях. В таблице ниже показано, как конфигурация устройства может повлиять на оценку политики.

|Конфигурация устройства|Оценка политики|Механизм резервного копирования|
|--- |--- |--- |
|Устройство без секретного кода|Нет доступа|Отсутствуют|
|Устройство с секретным кодом|Требуется секретный код|Отсутствуют|
|Устройство с сенсорным ИДЕНТИФИКАТОРом|Предпочтение сенсорного идентификатора|Разрешает секретный код|

Все операции в безопасном анклава могут доверять друг другу. Это означает, что мы можем использовать результат проверки подлинности Touch ID, чтобы авторизовать расшифровку элемента цепочки ключей. В Secure анклава также сохраняется счетчик совпадений ИДЕНТИФИКАТОРов сенсорного ввода. в этом случае пользователю придется вернуться к использованию секретного кода.
Новая платформа в iOS 8, называемая _локальной проверкой подлинности_, поддерживает этот процесс проверки подлинности на устройстве. Это будет рассмотрено в следующем разделе.

## <a name="local-authentication"></a>Локальная проверка подлинности

Как было установлено в предыдущем разделе, приложения могут использовать локальную проверку подлинности для проверки подлинности пользователя с соблюдением политики безопасности, настроенной на устройстве.

В настоящее время API предоставляет только две возможности: сначала он помогает использовать существующие службы цепочки ключей с помощью новых списков управления доступом (ACL). Данные цепочки ключей можно разблокировать с помощью успешной проверки подлинности отпечатка пользователя.

Во вторых, LocalAuthentication предоставляет два метода для локальной проверки подлинности приложения. Разработчики должны использовать `CanEvaluatePolicy`, чтобы определить, может ли устройство принимать сенсорный идентификатор, а затем `EvaluatePolicy` начать операцию проверки подлинности.

Хотя обе возможности предлагают локальную проверку подлинности, они не предоставляют механизму приложения или пользователю проверку подлинности на удаленном сервере.
Локальная проверка подлинности предоставляет новый стандартный пользовательский интерфейс для проверки подлинности. В случае сенсорного идентификатора это представление предупреждений с двумя кнопками, как показано ниже. Одну кнопку для отмены и одну для использования резервных средств проверки подлинности — секретный код. Кроме того, необходимо задать пользовательское сообщение. Рекомендуется использовать этот метод, чтобы объяснить пользователю, зачем требуется проверка подлинности с помощью сенсорного кода.

[![](touchid-images/image12.png "The Touch ID authentication alert")](touchid-images/image12.png#lightbox)

### <a name="with-keychain-services"></a>С помощью служб цепочки ключей

Мы Просмотрели несколько предыдущих способов расшифровки элемента цепочки ключей, используя безопасный анклава для проверки секретного кода. В iOS 8 мы можем использовать локальную проверку подлинности для запроса проверки сенсорного ввода в сочетании с функцией списков управления доступом, которая предоставляет реализацию резервного механизма или пароля.
Для использования ACL следует использовать политику `SecAccessControl`, а затем проверить состояние устройства с помощью `SecAccessible.WhenPasscodeSetThisDeviceOnly` или `SecAccessible.WhenUnlocked`.

#### <a name="considerations-with-acl"></a>Рекомендации по списку управления доступом

При использовании ACL с цепочкой ключей следует помнить о многих вещах, и некоторые из них перечислены ниже.

- Используйте только с приложением переднего плана — если вы вызываете любую операцию цепочки ключей в фоновом потоке, вызов завершится ошибкой.
- Для добавления и обновления элементов цепочки ключей может потребоваться проверка подлинности.
- Если запрос возвращает несколько совпадающих элементов в цепочке ключей, может потребоваться проверка подлинности.
- Защищенные элементы ACL доступны только для устройств и поэтому не синхронизированы или не архивируются.

### <a name="using-local-authentication-without-keychain-services"></a>Использование локальной проверки подлинности без служб цепочки ключей

Локальная проверка подлинности была создана как способ для получения учетных данных, таких как секретный код или сенсорный идентификатор, а также для работы с безопасным анклава для завершения проверки подлинности пользователя. Его можно рассматривать как мост между приложением и безопасным анклава, который никогда не может взаимодействовать друг с другом напрямую. Его также можно использовать для оценки политики приложения.

Для этого приложение вызывает оценку политики в локальной проверке подлинности, которая запускает операцию внутри Secure анклава. Это можно использовать для проверки подлинности приложения без прямого запроса или доступа к безопасному анклава.

[![](touchid-images/image13a.png "Using Local Authentication without Keychain Services")](touchid-images/image13a.png#lightbox)

Использование локальной проверки подлинности в приложении обеспечивает простой способ реализации пользовательской проверки, например, для разблокировки функции только для глаз владельца устройства, например для банковских приложений, или для телеметрическую родительского контроля. приклад. Вы также можете использовать его в качестве способа расширения уже существующей проверки подлинности — пользователи, например сведения о безопасности, должны быть безопасными, но они также могут иметь параметры.

Безопасность локальной проверки подлинности отличается от безопасности цепочки ключей. Например, при использовании цепочки ключей отношение доверия между операционной системой и безопасным анклава. Локальная проверка подлинности — это между приложением и операционной системой. Это означает, что у вас есть доступ только к результатам безопасного анклава, а не к безопасному анклава.

На предмет безопасности также чрезвычайно важно помнить, что **нет доступа** к зарегистрированным пальцам или изображениям отпечатка. Secure анклава — это владелец этой информации, поэтому другие компоненты системы не имеют доступа к нему.

Чтобы использовать сенсорный идентификатор без цепочки ключей, используя локальный API проверки подлинности, можно использовать несколько функций. Ниже приведены подробные сведения.

- `CanEvaluatePolicy` — это просто проверяет, может ли устройство принимать сенсорный идентификатор.
- `EvaluatePolicy` — запускает операцию проверки подлинности и отображает пользовательский интерфейс, а также возвращает `true` или `false` ответ.
- `DeviceOwnerAuthenticationWithBiometrics` — это политика, которую можно использовать для отображения экрана сенсорного идентификатора. Стоит отметить, что здесь нет механизма отката секретного кода, поэтому следует реализовать этот откат в приложении, чтобы пользователи могли пропустить проверку подлинности с помощью сенсорного кода.

Существует несколько предостережений с использованием локальной проверки подлинности, которые перечислены ниже.

- Как и в случае с цепочкой ключей, ее можно выполнять только на переднем плане. Вызов этого метода в фоновом потоке приведет к сбою.
- Помните, что вычисление политики может завершиться ошибкой. Кнопка секретного кода должна быть реализована в виде обратной связи.
- Необходимо указать `localizedReason`, чтобы объяснить, почему требуется проверка подлинности. Это помогает создавать отношения доверия с пользователем.

Далее в разделе ниже мы рассмотрим, как реализовать API, учитывающий эти предостережения.

## <a name="adding-touch-id-to-your-application"></a>Добавление в приложение идентификатора Touch

В предыдущих разделах мы рассматривали теорию доступа и проверки подлинности с помощью цепочки ключей и локальной проверки подлинности. Теперь мы рассмотрим, как можно интегрировать сенсорный идентификатор в приложение.

### <a name="walkthrough"></a>Пошаговое руководство

Давайте рассмотрим добавление в наше приложение проверки подлинности с помощью сенсорного кода. В этом пошаговом руководстве мы собираемся обновить образец [таблицы раскадровки](https://docs.microsoft.com/samples/xamarin/ios-samples/data/storyboardtable/) , добавив локальную проверку подлинности, чтобы она работала как образец [раскадровки — локальная проверка подлинности](https://docs.microsoft.com/samples/xamarin/ios-samples/storyboardtable-localauthentication) , позволяющая пользователям, прошедшим проверку подлинности, добавлять в список новые дела.

1. Скачайте пример и запустите его в Visual Studio для Mac.
2. Дважды щелкните `MainStoryboard.Storyboard`, чтобы открыть пример в конструкторе iOS. В этом примере мы хотим добавить в наше приложение новый экран, который будет управлять проверкой подлинности. Это будет перейдет до текущего `MasterViewController`.
3. Перетащите новый **контроллер представления** из **области элементов** в **область конструктора**. Установите его в качестве **корневого контроллера представлений** , нажав **CTRL + перетаскивание** из **контроллера навигации**:

    [![](touchid-images/image4.png "Set the Root View Controller")](touchid-images/image4.png#lightbox)
4. Назовите новый контроллер представления `AuthenticationViewController`.
5. Затем перетащите кнопку и поместите ее на `AuthenticationViewController`. Вызовите этот `AuthenticateButton`и присвойте ему текст `Add a Chore`.
6. Создайте событие для `AuthenticateButton` с именем `AuthenticateMe`.
7. Создайте вручную перехода из `AuthenticationViewController`, щелкнув черную полосу в нижней части экрана и **удерживая нажатой клавишу CTRL + перетаскивание** в `MasterViewController` и выбрав пункт **Push** (или **Показывать** , если используются классы размера):

    [![](touchid-images/image5.png "Drag from the bar to the MasterViewController and choosing push or show")](touchid-images/image6.png#lightbox)
8. Щелкните только что созданную перехода и присвойте ей идентификатор `AuthenticationSegue`, как показано ниже:

    [![](touchid-images/image7.png "Set the segue identifier to AuthenticationSegue")](touchid-images/image7.png#lightbox)
9. Добавьте следующий код в файл `AuthenticationViewController`:

    ```csharp
    partial void AuthenticateMe (UIButton sender)
    {
        var context = new LAContext();
        NSError AuthError;
        var myReason = new NSString("To add a new chore");

        if (context.CanEvaluatePolicy(LAPolicy.DeviceOwnerAuthenticationWithBiometrics, out AuthError)){
            var replyHandler = new LAContextReplyHandler((success, error) => {
                this.InvokeOnMainThread(()=> {
                    if(success)
                    {
                        Console.WriteLine("You logged in!");
                        PerformSegue("AuthenticationSegue", this);
                    }
                    else
                    {
                        // Show fallback mechanism here
                    }
                });
            });
            context.EvaluatePolicy(LAPolicy.DeviceOwnerAuthenticationWithBiometrics, myReason, replyHandler);
        };
    }
    ```

Это весь код, необходимый для реализации проверки подлинности с помощью сенсорного кода с использованием локальной проверки подлинности. В выделенных строках на изображении ниже показано использование локальной проверки подлинности.

[![](touchid-images/image8.png "The highlighted lines show the use of Local Authentication")](touchid-images/image8.png#lightbox)

Во-первых, необходимо установить, поддерживает ли устройство входные данные Touch ID, используя `CanEvaluatePolicy` и передав `DeviceOwnerAuthenticationWithBiometrics`политики. Если это так, мы можем отобразить пользовательский интерфейс Touch ID с помощью `EvaluatePolicy`. Есть три части информации, которые нужно передать в `EvaluatePolicy` — саму политику, строку, объясняющую, зачем необходима проверка подлинности, и обработчик ответов. Обработчик ответов сообщает приложению, что оно должно делать в случае успешной или неудачной проверки подлинности. Давайте подробнее рассмотрим обработчик ответов:

[![](touchid-images/image9.png "The reply handler")](touchid-images/image9.png#lightbox)

Обработчик ответов указан для типа `LAContextReplyHandler`, который принимает параметры успешно — значение `bool` и `NSError` с именем `error`. Если это успешно, то именно здесь мы будем выполнять проверку подлинности — в этом случае отобразится экран, позволяющий добавить новую рутинную работу. Помните, что одна из предостережений локальной проверки подлинности заключается в том, что она должна выполняться на переднем плане, поэтому используйте `InvokeOnMainThread`:

[![](touchid-images/image10.png "Use InvokeOnMainThread for Local Authentication")](touchid-images/image10.png#lightbox)

Наконец, когда проверка подлинности прошла успешно, мы хотим перейти на `MasterViewController`. Для этого можно использовать метод `PerformSegue`:

[![](touchid-images/image11.png "Call PerformSegue method to transition to the MasterViewController")](touchid-images/image11.png#lightbox)

## <a name="summary"></a>Сводка

В этом руководство мы рассмотрели цепочку ключей и принципы ее работы в iOS. Мы также изучили список ACL цепочки ключей и вносимые в него изменения в iOS. Далее мы рассматривали локальную платформу проверки подлинности, которая впервые использовалась в iOS 8, а затем рассмотрела реализацию проверки подлинности Touch ID в нашем приложении.

## <a name="related-links"></a>Связанные ссылки

- [Таблица раскадровки — локальная проверка подлинности](https://docs.microsoft.com/samples/xamarin/ios-samples/storyboardtable-localauthentication)
- [Пример ВВДК цепочки ключей](https://docs.microsoft.com/samples/xamarin/ios-samples/ios8-keychaintouchid/)
- [Цепочка ключей (пример)](https://docs.microsoft.com/samples/xamarin/ios-samples/keychain/)
