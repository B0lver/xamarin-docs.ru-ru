---
title: Touch ID в Xamarin.iOS
description: В этом документе описывается, как использовать Touch ID, технологии проверки подлинности Apple биометрические отпечатков пальцев, в приложениях Xamarin.iOS.
ms.prod: xamarin
ms.assetid: 4BC8EFD6-52FC-4793-BA69-D6BFF850FE5F
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/20/2017
ms.openlocfilehash: 2d67bc71361e335515cfba8b5a20e157ed6b6b05
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61087887"
---
# <a name="touch-id-in-xamarinios"></a>Touch ID в Xamarin.iOS

Touch ID впервые появился в iOS 7, как средство проверки подлинности пользователя — аналогичен секретный код. Тем не менее он был ограничен разблокировки устройства, с помощью App Store, с помощью iTunes и проверки подлинности только к цепочке ключей iCloud.

Теперь существует два способа использовать Touch ID в качестве механизма проверки подлинности в приложении iOS 8, с помощью API локальной проверки подлинности. Он в настоящее время не поддерживается для использования локальной проверки подлинности для проверки подлинности удаленно.

Чтобы полностью понять Touch ID и его за период, мы рассмотрим цепочки ключей службы и что означают эти изменения для данных пользователя. Доступ к цепочке ключей также были расширены в iOS 8, благодаря использованию новой функции списки управления доступом (ACL).

## <a name="keychain--secure-enclave"></a>Цепочки ключей & безопасным Анклавом

Цепочки ключей является большой базы данных, обеспечение безопасного хранения пароли, ключи, сертификаты и заметок для одного отдельного идентификатора Apple ID. В iOS 8 приложение всегда имеет доступ к элементам свой собственный уникальный цепочки ключей и нет доступа к цепочке ключей записей других приложений. Это отличается от OS X Если цепочки ключей не заблокирована с одним паролем, что любой цепочки ключей службы приложения с поддержкой использования цепочки ключей. В этой статье мы сосредоточимся на принципах цепочку ключей в iOS 8.

Цепочки ключей — это специализированный база данных, где каждая строка называется _элемент цепочки ключей_. Каждый элемент описан атрибутами цепочки ключей и состоит из зашифрованных значений. Чтобы разрешить для эффективного использования цепочки ключей, оно оптимально подходит для небольших элементов или _секреты_.
Каждый элемент в цепочке ключей защищена пользователей секретный код и уникального секрета устройства. Элементы в цепочке ключей должны быть защищены даже в том случае, когда пользователи не используют свои устройства. Этот метод реализован в iOS, разрешая только элементы станут доступны, если устройство разблокируется, когда устройство заблокировано они становятся недоступными. Они также могут храниться в зашифрованной резервной копии. Одним из ключевых особенностей цепочки ключей является для реализации управления доступом; приложение имеет доступ к своей части цепочки ключей, а все другие приложения не будет проверяться. На следующей схеме показано, как приложение взаимодействует с цепочки ключей.

[![](touchid-images/image1.png "Схема иллюстрирует, как приложение взаимодействует с цепочки ключей")](touchid-images/image1.png#lightbox)

### <a name="secure-enclave"></a>Безопасным Анклавом

Цепочки ключей не удается расшифровать элемент цепочки ключей. Вместо этого он выполняется в *Secure Анклава*. Безопасным анклавом — это совместное процессор в микросхемы A7, который отвечает за определение успешного сопоставления на основе отпечатков пальцев данных от датчика Touch ID для зарегистрированных печати. Затем будет расшифровать элемент цепочки ключей и вернуть расшифрованные секрет в цепочку ключей.

### <a name="working-with-keychain"></a>Работа с цепочки ключей

Сначала приложения должны запрашивать в цепочке ключей, существует ли пароль. Если он не существует, может потребоваться предлагается ввести пароль, поэтому запрос пользователя не выводится постоянно. Если пароль должен быть обновлен, приглашение ввести новый пароль и передайте обновленное значение в цепочку ключей.

> [!NOTE]
> После получения из цепочки ключей, с помощью секрета, все ссылки на данные должны удаляться из памяти. Никогда не назначить его в глобальной переменной.

## <a name="keychain-acl-and-touch-id"></a>Идентификатор цепочки ключей ACL и сенсорного ввода

Список управления доступом — это новый атрибут элемента цепочки ключей в iOS 8, описывающий сведения, касающиеся что должны быть выполнены, чтобы разрешить выполнение определенной операции. Это может быть в форме отображается диалоговое окно предупреждения или запроса секретный код. Список ACL позволяет задать специальных возможностей и проверки подлинности для элемента цепочке ключей. На следующей схеме показано, как этот атрибут механизму остальной части цепочки ключей:

[![](touchid-images/image2.png "На этой схеме показано, как этот атрибут механизму остальной части цепочки ключей")](touchid-images/image2.png#lightbox)

Начиная с версии iOS 8, теперь есть политику присутствия пользователя `SecAccessControl`, который обеспечивается безопасным анклавом на iPhone 5s и более поздних версий. Мы видим, в таблице ниже, так же как конфигурация устройства может влиять на оценки политики:

|Конфигурация устройства|Вычисление политики|Механизм резервного копирования|
|--- |--- |--- |
|Устройства без секретного кода|Нет доступа|Нет|
|Устройства с помощью секретного кода|Требуется секретный код|Нет|
|Устройства с помощью Touch ID|Является предпочтительным для Touch ID|Позволяет секретного кода|

Все операции в Анклава защиты можно доверять друг с другом. Это означает, что результат проверки подлинности Touch ID можно использовать для авторизации расшифровки элемента цепочки ключей. Анклава Secure также отслеживает счетчик неуспешным совпадением Touch ID, в которых случай пользователь получит Чтобы возвратиться к использованию секретный код.
Это новая платформа, в iOS 8, вызывается _локальной проверки подлинности_, поддерживает этот процесс проверки подлинности в пределах устройства. Мы рассмотрим в следующем разделе.

## <a name="local-authentication"></a>Локальной проверки подлинности

Как мы описано в предыдущем разделе, приложения могут использовать локальной проверки подлинности для проверки подлинности пользователя в соответствие с политикой безопасности, установленного на устройстве.

В настоящее время API предоставляет только две возможности: Во-первых она также помогает существующих служб цепочки ключей при помощи новых цепочки ключей списки управления доступом (ACL). Данные цепочки ключей можно разблокировать с успешной проверкой подлинности пользователей пальца.

Во-вторых LocalAuthentication предоставляет два метода проверки подлинности приложения локально. Разработчикам следует использовать `CanEvaluatePolicy` для определения того, если устройство будет принимать Touch ID, а затем `EvaluatePolicy` для запуска операции проверки подлинности.

Хотя обе возможности предлагает локальной проверки подлинности, они не предоставляют механизм для приложения или пользователя для проверки подлинности на удаленном сервере.
Локальной проверки подлинности предоставляет новый стандартный пользовательский интерфейс для проверки подлинности. В случае Touch ID это представление "предупреждения" с две кнопки, как показано ниже. Одна кнопка "Отмена", а другая для использования резервной проверки подлинности — секретный код. Имеется также пользовательское сообщение, который должен быть задан. Рекомендуется использовать это чтобы объяснить, почему необходима проверка подлинности Touch ID пользователю.

[![](touchid-images/image12.png "Предупреждение проверки подлинности Touch ID")](touchid-images/image12.png#lightbox)

### <a name="with-keychain-services"></a>Со службами в цепочке ключей

Мы рассмотрели чуть раньше как является элемент цепочки ключей расшифровки, с помощью безопасным анклавом для проверки нашей секретный код. В iOS 8 мы используем локальной проверки подлинности для запроса проверки Touch ID в сочетании с компонентом списки управления доступом, который предоставляет реализацию резервный механизм или пароль.
Чтобы использовать список управления Доступом, следует использовать `SecAccessControl` политики, а затем проверить состояние устройства с помощью `SecAccessible.WhenPasscodeSetThisDeviceOnly` или `SecAccessible.WhenUnlocked`.

#### <a name="considerations-with-acl"></a>Вопросы, связанные с ACL

Есть много вещей, которые мы следует учитывать при использовании списка управления Доступом с помощью цепочки ключей и некоторые из них перечислены ниже:

-   Используйте только с приложением переднего плана — Если вы вызывать любую операцию цепочку ключей в фоновом потоке, вызов завершится ошибкой.
-   Добавление и обновление элементов цепочки ключей могут требовать проверки подлинности.
-   Если запрос возвращает несколько совпадений в цепочке ключей, может потребоваться проверка подлинности.
-   ACL защищенные элементы являются только для устройств и поэтому не синхронизированные или резервных копий.

### <a name="using-local-authentication-without-keychain-services"></a>С помощью локальной проверки подлинности без использования цепочки ключей служб

Локальной проверки подлинности был создан как способ для получения учетных данных, например секретного кода или Touch ID и работать с Анклавом Secure для завершения проверки подлинности пользователя. Его можно рассматривать как мост между приложением и Анклав Secure, который может никогда не напрямую взаимодействовать друг с другом. Он также используется для оценки политики для вашего приложения.

Для этого приложения вызывает оценки политики внутри локальной проверки подлинности, который запускает операцию внутри Secure Анклава. Вы можете использовать это для обеспечения проверки подлинности в приложение без прямой запрос/доступ к Secure Анклава.

[![](touchid-images/image13a.png "С помощью локальной проверки подлинности без использования цепочки ключей служб")](touchid-images/image13a.png#lightbox)

С помощью локальной проверки подлинности в приложении предоставляет простой способ реализации проверки пользователя, например разблокировать компонент исключительно для с точки зрения владельцу устройства, такие как банковские приложения или родительского контроля вспомогательное средство для каждого пользователя приложение. Можно также использовать его как способ расширения проверки подлинности, который уже существует — пользователям, и их сведения для обеспечения безопасности, но они также хотел иметь параметры.

Безопасность локальной проверки подлинности отличается от цепочки ключей. Например при использовании в цепочку ключей, доверие является между операционная система и безопасность Анклава. С помощью локальной проверки подлинности это между приложением и операционной системы, что означает только наличие доступа к результатам Анклава защиты, не Secure Анклава сам.

По этой теме безопасности, это также очень важно знать, что имеется **нет доступа** для зарегистрированных пальцами, рисунков и отпечатков пальцев. Анклава защиты является владельцем этой информации и поэтому ни один другой компонент системы имеет к нему доступ.

Чтобы использовать Touch ID без цепочки ключей за счет использования API локальной проверки подлинности, существует несколько функций, которые можно использовать. Они описаны ниже.

*   `CanEvaluatePolicy` — Это просто проверяет, если устройство будет принимать Touch ID.
*   `EvaluatePolicy` — Это запускает операцию проверки подлинности и отображает пользовательский Интерфейс и возвращает `true` или `false` ответов.
*   `DeviceOwnerAuthenticationWithBiometrics` — Это политика, который может использоваться для отображения на экране Touch ID. Стоит отметить, что отсутствует секретный код резервный механизм здесь, вместо этого следует реализовать этот откат в приложении, чтобы разрешить пользователям пропускать проверку подлинности Touch ID.

Существует несколько моментов, с использованием локальной проверки подлинности, перечисленных ниже.

*   Как и в цепочке ключей, он может запускаться только на переднем плане. Вызов его в фоновом потоке приведет к сбою.
*   Имейте в виду, что может произойти сбой вычисления политики. Секретный код кнопки необходимо реализовать на случай возможного отката обратно.
*   Необходимо указать `localizedReason` объяснить, почему необходима проверка подлинности. Это позволяет создавать отношения доверия с пользователем.

Затем в разделе ниже мы рассмотрим способы реализации API, учитывая эти предупреждения.

## <a name="adding-touch-id-to-your-application"></a>Добавление в приложение Touch ID

В предыдущих разделах мы рассмотрели теория доступ и проверка подлинности с помощью цепочки ключей и локальной проверки подлинности. Теперь мы обратим внимание на как можно интегрировать Touch ID в приложение.

### <a name="walkthrough"></a>Пошаговое руководство

Так что давайте рассмотрим добавление некоторых Touch ID проверки подлинности для нашего приложения. В этом пошаговом руководстве мы собираемся обновить [раскадровки таблицы](https://developer.xamarin.com/samples/StoryboardTable/) образец, добавляя локальной проверки подлинности, таким образом, чтобы он работает в качестве [таблица раскадровки — локальной проверки подлинности](https://developer.xamarin.com/samples/monotouch/StoryboardTable_LocalAuthentication/) образца, который разрешает только Проверка подлинности пользователей для добавления кода в списке.

1. Скачать пример и запустите его в Visual Studio для Mac.
2. Дважды щелкните `MainStoryboard.Storyboard` Открытие образца в конструкторе iOS. В этом примере мы хотим добавить новый экран для нашего приложения, который будет управлять проверки подлинности. Это будет отправлена до текущего `MasterViewController`.
3. Перетащите новый **контроллер представления** из **элементов** для **конструктора**. Задайте его в виде **контроллера корневого представления** по **клавишу Ctrl при перетаскивании** из **контроллер навигации**:

    [![](touchid-images/image4.png "Значение корневого контроллера представления")](touchid-images/image4.png#lightbox)
4.  Назовите новый контроллер представления `AuthenticationViewController`.
5. Затем перетащите кнопку и поместите его на `AuthenticationViewController`. Это называется `AuthenticateButton`и присвойте ей текст `Add a Chore`.
6. Создает событие `AuthenticateButton` вызывается `AuthenticateMe`.
7. Создание ручного перехода от `AuthenticationViewController` , щелкнув черную полосу в нижней и **клавишу Ctrl при перетаскивании** в строке для `MasterViewController` и выбрав **принудительной** (или **Показать** Если с помощью классов размера):

    [![](touchid-images/image5.png "Перетащите с панели MasterViewController и выбрав Push-уведомлений или отображение")](touchid-images/image6.png#lightbox)
8. Щелкните только что созданный перехода и ему присваивается идентификатор `AuthenticationSegue`, как показано ниже:

    [![](touchid-images/image7.png "Задать идентификатор перехода к AuthenticationSegue")](touchid-images/image7.png#lightbox)
9. Добавьте следующий код в файл `AuthenticationViewController`:

    ```csharp
    partial void AuthenticateMe (UIButton sender)
    {
        var context = new LAContext();
        NSError AuthError;
        var myReason = new NSString("To add a new chore");

        if (context.CanEvaluatePolicy(LAPolicy.DeviceOwnerAuthenticationWithBiometrics, out AuthError)){
            var replyHandler = new LAContextReplyHandler((success, error) => {
                this.InvokeOnMainThread(()=> {
                    if(success)
                    {
                        Console.WriteLine("You logged in!");
                        PerformSegue("AuthenticationSegue", this);
                    }
                    else
                    {
                        // Show fallback mechanism here
                    }
                });
            });
            context.EvaluatePolicy(LAPolicy.DeviceOwnerAuthenticationWithBiometrics, myReason, replyHandler);
        };
    }
    ```

Это весь код, необходимый для реализации проверки подлинности Touch ID, с помощью локальной проверки подлинности. В выделенных строках на следующем рисунке показано использование локальной проверки подлинности:

[![](touchid-images/image8.png "Выделенные строки демонстрируют использование локальной проверки подлинности")](touchid-images/image8.png#lightbox)

Во-первых, нам нужно установить, если устройство будет принимать Touch ID, входные данные с помощью `CanEvaluatePolicy` и передачи в политике `DeviceOwnerAuthenticationWithBiometrics`. Если это значение равно true, то можно отобразить с помощью пользовательского интерфейса Touch ID `EvaluatePolicy`. Существует три элемента информации, нам приходится передавать в `EvaluatePolicy` — сама политика, объясняющее, почему проверка подлинности необходима строка и обработчик ответа. Обработчик ответа сообщает приложению о том, что нужно делать в случае успешной или неудачной, проверки подлинности. Давайте рассмотрим обработчик ответа:

[![](touchid-images/image9.png "Обработчик ответа")](touchid-images/image9.png#lightbox)

Обработчик ответа определяется типа `LAContextReplyHandler`, который принимает параметры успех – `bool` значение и `NSError` вызывается `error`. При успешном выполнении, это где мы выполним то, что необходимо для проверки подлинности — в этом случае отображается заставка, сообщите нам будет добавлен новый тяжкий труд. Помните, один из предупреждения локальной проверки подлинности, его необходимо запустить на переднем плане, поэтому убедитесь, что использовать `InvokeOnMainThread`:

[![](touchid-images/image10.png "Использовать InvokeOnMainThread для локальной проверки подлинности")](touchid-images/image10.png#lightbox)

Наконец, при проверке подлинности успешной, мы хотим переход на `MasterViewController`. `PerformSegue` Метод может использоваться для этого:

[![](touchid-images/image11.png "Вызовите метод PerformSegue для перехода в MVC")](touchid-images/image11.png#lightbox)

## <a name="summary"></a>Сводка
В этом руководстве мы рассмотрели цепочки ключей и как это работает в iOS. Мы также изучили цепочки ключей ACL и изменения данного в iOS. Далее мы рассмотрен framework локальной проверки подлинности, который появился в iOS 8 и затем рассмотрели реализацию проверки подлинности Touch ID в нашем приложении.

## <a name="related-links"></a>Связанные ссылки

- [Таблица раскадровки — локальной проверки подлинности](https://developer.xamarin.com/samples/monotouch/StoryboardTable_LocalAuthentication/) 
- [Пример WWDC цепочки ключей](https://developer.xamarin.com/samples/KeychainTouchID/)
- [Цепочки ключей (пример)](https://developer.xamarin.com/samples/Keychain/)
