---
title: HealthKit в Xamarin.iOS
description: В этом документе описывается HealthKit, это платформа, впервые появился в iOS 8, который предоставляет централизованное, скоординированное и безопасное хранилище данных для получения сведений, связанных с работоспособностью. В нем описывается, как подготовить приложение HealthKit и как написать код, который основан на идеологии HealthKit.
ms.prod: xamarin
ms.assetid: E3927A21-507C-43BA-A2AD-957716BA9B52
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/19/2017
ms.openlocfilehash: df0b0e8dd57129917f2d8dab07115551ca675acf
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61163448"
---
# <a name="healthkit-in-xamarinios"></a>HealthKit в Xamarin.iOS

Комплект работоспособности предоставляет безопасное хранилище данных сведений о пользователе, связанных с работоспособностью. Работоспособности комплект приложений с помощью явного разрешения пользователя, чтения и записи в этом хранилище данных и получать уведомления при добавлении данных. Приложения может представлять данные или пользователя можно использовать предоставленный работоспособности приложения Apple для просмотра панели мониторинга всех своих данных.

Из-за связанных с работоспособностью данных таким образом конфиденциальных и критически важным фактором, комплект работоспособности является строго типизированным, с единицами измерения и явную связь с типом данных для записи (к примеру, уровень глюкоза крови или пульс). Кроме того комплект работоспособности приложения должны использовать явные права, необходимо запрашивать доступ к определенной типов данных и пользователь должен явно предоставить приложению доступ к этим типам данных.

В этой статье будут представлены:

- Требования безопасности работоспособности пакета, включая Подготовка приложений и запрашивает разрешение пользователя для доступа к базе данных о работоспособности пакета;
- Система типов работоспособности пакета, что сводит к минимуму вероятность применения неверно или неправильной интерпретации данных;
- Записи в общий, системных хранилище данных о работоспособности пакета.

В этой статье не рассматриваются более сложным темам, например запрос в базу данных, преобразование единиц измерения или получать уведомления о новых данных.

В этой статье мы создадим пример приложения для записи частоты пользователя:

[![](healthkit-images/image01.png "Пример приложения для записи частоты пользователей")](healthkit-images/image01.png#lightbox)

## <a name="requirements"></a>Требования

Ниже перечислены необходимые условия для выполнения действия, описанные в этой статье:

- **Xcode 7 и iOS 8 (или больше)** — последние Xcode и API для iOS компании Apple необходимо установить и настроить на компьютере разработчика.
- **Visual Studio для Mac или Visual Studio** — последнюю версию Visual Studio для Mac должны быть установлены и настроены на компьютере разработчика.
- **iOS 8 (или больше) устройства** — устройства iOS под управлением последней версии iOS 8 или более поздней версии, для тестирования.

> [!IMPORTANT]
> Комплект работоспособности впервые появился в iOS 8. В настоящее время работоспособности пакета не поддерживается в симуляторе iOS и отладки требуется подключение к физическое устройство iOS.




## <a name="creating-and-provisioning-a-health-kit-app"></a>Создание и подготовка В приложении Kit работоспособности
Прежде, чем в 8 приложение Xamarin.IOS можно использовать HealthKit API, его необходимо правильно настроить и подготовить. В этом разделе рассматриваются шаги, необходимые для правильной настройки приложение Xamarin.

Работоспособность пакета приложений требуется:

- Явно **идентификатор приложения**.
- Объект **профиль подготовки** , связанных с явной **идентификатор приложения** и с **Kit работоспособности** разрешения.
- `Entitlements.plist` С `com.apple.developer.healthkit` свойство типа `Boolean` присвоено `Yes`.
- `Info.plist` Которого `UIRequiredDeviceCapabilities` ключ содержит запись с `String` значение `healthkit`.
- `Info.plist` Также должны быть заполнены соответствующие конфиденциальности объяснение: `String` объяснение для ключа `NSHealthUpdateUsageDescription` Если приложение будет записывать данные и `String` объяснение для ключа `NSHealthShareUsageDescription` Если приложение будет считывать Kit работоспособности данные.

Чтобы получить дополнительные сведения о подготовке приложения iOS [подготовки устройств](~/ios/get-started/installation/device-provisioning/index.md) статьи в Xamarin **Приступая к работе** серии описывается связь между разработчика сертификаты, идентификаторы приложений Профили подготовки и прав приложения.

<a name="explicit-appid" />

### <a name="explicit-app-id-and-provisioning-profile"></a>Явный идентификатор приложения и профиль подготовки

Создание явного **идентификатор приложения** и соответствующей **профиль подготовки** можно сделать в Apple [Центр разработчиков iOS](https://developer.apple.com/devcenter/ios/index.action). 

Текущий **идентификаторов приложений** , перечислены в [сертификаты, идентификаторы и профили](https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action) центра разработки. Часто, этот список будет отображаться **идентификатор** значения `*`, означающее, **идентификатор приложения** - **имя** может использоваться с любым количеством суффиксы. Такие *идентификаторов приложений подстановочный знак* нельзя использовать с помощью комплекта работоспособности.
 
Чтобы создать явный **идентификатор приложения**, нажмите кнопку **+** кнопку в верхнем правом углу, чтобы перейти к **регистрации iOS идентификатор приложения** страницы:


[![](healthkit-images/image02.png "Регистрация приложения на портале разработчика Apple")](healthkit-images/image02.png#lightbox)

Как показано на рисунке выше, после создания описание приложения, используйте **явный идентификатор приложения** раздела, чтобы создать идентификатор приложения. В **службы приложений** установите флажок **Kit работоспособности** в **включить службы** раздел.

Когда вы закончите, нажмите клавишу **Продолжить** кнопку, чтобы зарегистрировать **идентификатор приложения** в вашей учетной записи. Вы перейдете обратно **сертификаты, идентификаторы и профили** страницы. Нажмите кнопку **профили подготовки** перейти к списку текущего профилей подготовки, а затем нажмите кнопку **+** кнопки в правом верхнем углу, чтобы перейти на **добавьте iOS Профиль подготовки** страницы. Выберите **разработки приложений iOS** и нажмите кнопку **Продолжить** для получения **выберите идентификатор приложения** страницы. Здесь, выберите явный **идентификатор приложения** , указанное ранее:


[![](healthkit-images/image03.png "Выберите явный идентификатор приложения")](healthkit-images/image03.png#lightbox)

Нажмите кнопку **Продолжить** и поработайте с остальные экраны, можно указать ваш **сертификаты разработчика**, **устройств**и **имя** для данного **профиль подготовки**:

[![](healthkit-images/image04.png "Создание профиля подготовки")](healthkit-images/image04.png#lightbox)

Нажмите кнопку **формирования** и ожидает создания профиля. Загрузите файл и дважды щелкните его, чтобы установить в Xcode. Можно подтвердить его установку с использованием **Xcode > настройки > учетные записи > Просмотр сведений о...** Вы должны увидеть профиле подготовки устройства, должны быть значок работоспособности Kit и другие специальные службы в, и его **прав** строки:

[![](healthkit-images/image05.png "Просмотр профиля в Xcode")](healthkit-images/image05.png#lightbox)

<a name="associating-appid" />

### <a name="associating-the-app-id-and-provisioning-profile-with-your-xamarinios-app"></a>Сопоставления идентификатора приложения и подготовительного профиля с вашим приложением Xamarin.iOS

После создания и установки соответствующей **профиль подготовки** как было сказано, обычно было бы время для создания решения в Visual Studio для Mac или Visual Studio. Предоставляется работоспособности пакета доступ к любой iOS C# или F# проекта.

Вместо рассмотрен процесс создания проекта Xamarin iOS 8 вручную, откройте пример приложения, подключенные к этой статье (которая включает предварительно созданные раскадровки и код). Должен быть сопоставлен свой набор работоспособности, которые включены в пример приложения **профиль подготовки**в **панели решения**, щелкните правой кнопкой мыши на проекте и открыть его **параметры** диалоговое окно. Переключиться в режим **приложение iOS** панели и ввод явный **идентификатор приложения** созданный ранее в качестве приложения **идентификатор пакета**:

[![](healthkit-images/image06.png "Введите явный идентификатор приложения")](healthkit-images/image06.png#lightbox)

Теперь **подписывание пакета iOS** панели. Ваш последний установленный **профиль подготовки**, его связь с явный **идентификатор приложения**, теперь будут доступны как **профиль подготовки**:

[![](healthkit-images/image07.png "Выберите профиль подготовки")](healthkit-images/image07.png#lightbox)

Если **профиль подготовки** недоступен, еще раз проверьте **идентификатор пакета** в **приложение iOS** панели и который указан в **iOS Центр разработчиков** и что **профиль подготовки** устанавливается (**Xcode > настройки > учетные записи > подробности...** ).

Когда работоспособности Kit с поддержкой **профиль подготовки** является, щелкните **ОК** чтобы закрыть диалоговое окно параметров проекта.

### <a name="entitlementsplist-and-infoplist-values"></a>Entitlements.plist и значениями Info.plist

Образец приложения включает `Entitlements.plist` файла (что необходимо для работоспособности Kit с поддержкой приложений) и не включается в каждый шаблон проекта. Если проект не имеет прав, щелкните правой кнопкой мыши проект, выберите **файл > новый файл... > iOS > Entitlements.plist** для добавления одного вручную.

В конечном счете ваш `Entitlements.plist` должен иметь следующие пары ключей и значений:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.developer.HealthKit</key>
    <true/>
</dict>
</plist>

```

Аналогичным образом `Info.plist` для приложение должно иметь значение `healthkit` связанные с `UIRequiredDeviceCapabilities` ключ:

```xml
<key>UIRequiredDeviceCapabilities</key>
<array>
<string>armv7</string>
    <string>healthkit</string>
</array>

```

Образец приложения для этой статьи включает предварительно настроенные `Entitlements.plist` , включает в себя все необходимые ключи.

<a name="programming" />

## <a name="programming-health-kit"></a>Программирование работоспособности Kit

Хранилище данных работоспособности Kit — хранилище данных закрытый, конкретного пользователя, является общим для приложений. Так как сведения о работоспособности чувствительна, положительных действий, чтобы разрешить доступ к данным должен выполнить пользователь. Разделяемыми могут быть этот доступ (записи, но не чтения, доступ для некоторых типов данных, но не другие, и т.д.) и могут быть отозваны в любое время. Работоспособность комплект приложения должны быть написаны очень осторожно, с учетом того, что многие пользователи будут решаться о хранении информации о связанных с работоспособностью.

Работоспособность пакета данные будут храниться Apple определенных типов. Эти типы строго определены: некоторые из них, например тип крови, ограничены определенные значения перечисления предоставленный Apple, пока другие объединить величиной с единицей измерения (например, граммы калорий и литры). Даже данные, которые совместно используют совместимые единица измерения различаются по их `HKObjectType`; например, система типов будет перехватывать ошибочный попытки для хранения `HKQuantityTypeIdentifier.NumberOfTimesFallen` значение для поля Ожидается `HKQuantityTypeIdentifier.FlightsClimbed` несмотря на то, что используют` HKUnit.Count` Единица измерения.

Типы, который можно поместить в хранилище данных о работоспособности пакета, все подклассы `HKObjectType`. `HKCharacteristicType` объекты хранят биологических Пол крови и типа даты из рождения. Чаще используется, являются `HKSampleType` объекты, которые представляют данные, которое дискретизируется в определенное время или через определенный период времени. 

[![](healthkit-images/image08.png "HKSampleType объектов диаграммы")](healthkit-images/image08.png#lightbox)

`HKSampleType` является абстрактным и имеет четыре конкретные подклассы. В настоящее время имеется только один тип `HKCategoryType` данные, которые являются спящий режим анализа. Большую часть данных в пакете работоспособности относятся к типу `HKQuantityType` и хранят свои данные в `HKQuantitySample` объекты, которые создаются с помощью знакомых фабричного конструктивного шаблона:

[![](healthkit-images/image09.png "Большую часть данных в пакете работоспособности относятся к типу HKQuantityType и хранят свои данные в объектах HKQuantitySample")](healthkit-images/image09.png#lightbox)

`HKQuantityType` типы в диапазоне от `HKQuantityTypeIdentifier.ActiveEnergyBurned` для `HKQuantityTypeIdentifier.StepCount`. 

<a name="requesting-permission" />

### <a name="requesting-permission-from-the-user"></a>Запросить разрешение от пользователя

Конечным пользователям необходимо выполнить положительных действий, чтобы разрешить приложению чтение или запись данных о работоспособности пакета. Это делается с помощью работоспособности приложения, который уже предварительно установлен на устройствах iOS 8. При первом запуске приложения работоспособности Kit пользователю предоставляется с контролем системы **доступа работоспособности** диалоговое окно:

[![](healthkit-images/image10.png "Пользователю предоставляется диалоговое окно доступа работоспособности управляемой системы")](healthkit-images/image10.png#lightbox)

Позже, он может изменять разрешения с помощью работоспособности приложения **источников** диалоговое окно:

[![](healthkit-images/image11.png "Пользователь может изменять разрешения с помощью диалоговое окно источников работоспособности приложений")](healthkit-images/image11.png#lightbox)

Так как сведения о работоспособности очень важна, разработчикам приложений следует писать их программ очень осторожно, в предположении, что разрешения будет отказано и изменить во время выполнения приложения. Является наиболее распространенных идиом, чтобы запросить разрешения в `UIApplicationDelegate.OnActivated` метод и внести в пользовательском интерфейсе соответствующим образом.

### <a name="permissions-walkthrough"></a>Пошаговое руководство разрешения

В проекте подготовкой Kit работоспособности откройте `AppDelegate.cs` файл. Обратите внимание, что инструкции, использующей `HealthKit`; в верхней части файла.


Следующий код относится к работоспособности набор разрешений:

```csharp
private HKHealthStore healthKitStore = new HKHealthStore ();

public override void OnActivated (UIApplication application)
{
        ValidateAuthorization ();
}

private void ValidateAuthorization ()
{
        var heartRateId = HKQuantityTypeIdentifierKey.HeartRate;
        var heartRateType = HKObjectType.GetQuantityType (heartRateId);
        var typesToWrite = new NSSet (new [] { heartRateType });
        var typesToRead = new NSSet ();
        healthKitStore.RequestAuthorizationToShare (
                typesToWrite, 
                typesToRead, 
                ReactToHealthCarePermissions);
}

void ReactToHealthCarePermissions (bool success, NSError error)
{
        var access = healthKitStore.GetAuthorizationStatus (HKObjectType.GetQuantityType (HKQuantityTypeIdentifierKey.HeartRate));
        if (access.HasFlag (HKAuthorizationStatus.SharingAuthorized)) {
                HeartRateModel.Instance.Enabled = true;
        } else {
                HeartRateModel.Instance.Enabled = false;
        }
}

```

Весь код в этих методах удалось сделать `OnActivated`, но пример приложения использует отдельные методы, чтобы сделать их понятнее намерением: `ValidateAuthorization()` имеет действия, необходимые для запроса доступа на определенные типы записываемых (и чтения, при необходимости приложение) и `ReactToHealthCarePermissions()` является обратный вызов, который активируется после он взаимодействовал с диалоговым окном разрешения в Health.app.

Задача `ValidateAuthorization()` заключается в создании набора `HKObjectTypes` что написать приложение и запросить авторизацию, чтобы обновить эти данные. В примере приложения `HKObjectType` — для ключа `KHQuantityTypeIdentifierKey.HeartRate`. Этот тип будет добавлен к набору `typesToWrite`, тогда как набор `typesToRead` остается пустой. Эти наборы, а также ссылку на `ReactToHealthCarePermissions()` обратный вызов, передается методу `HKHealthStore.RequestAuthorizationToShare()`.

`ReactToHealthCarePermissions()` Обратного вызова будет вызван после пользователь выполнял действия с диалоговым окном разрешения и передается два фрагмента информации: `bool` , будет `true` если он взаимодействовал с диалоговое окно разрешений и `NSError`, если отличные от null, указывает на ошибку, связанную с представлением диалоговое окно разрешений.

> [!IMPORTANT]
> Чтобы иметь четкое представление о аргументов для этой функции: _успех_ и _ошибка_ параметры не обозначают ли пользователь имеет разрешения на доступ к данным работоспособности Kit! Они только показывают, что пользователь получил возможность разрешать доступ к данным.

Чтобы проверить, имеет ли приложение доступ к данным, `HKHealthStore.GetAuthorizationStatus()` используется, передавая `HKQuantityTypeIdentifierKey.HeartRate`. Приложение, исходя из возвращенный код состояния, включает или отключает возможность ввода данных. Не предусмотрена возможность обычного пользователя для работы с отказом в доступе и множество возможных вариантов. В приложении-примере, имеет состояние `HeartRateModel` одноэлементный экземпляр, который, в свою очередь, вызывает соответствующие события.

## <a name="model-view-and-controller"></a>Модель, представление и контроллер

Чтобы просмотреть `HeartRateModel` одноэлементного объекта, откройте `HeartRateModel.cs` файл:

```csharp
using System;
using HealthKit;
using Foundation;

namespace HKWork
{
        public class GenericEventArgs<T> : EventArgs
        {
                public T Value { get; protected set; }
                public DateTime Time { get; protected set; }

                public GenericEventArgs (T value)
                {
                        this.Value = value;
                        Time = DateTime.Now;
                }
        }

        public delegate void GenericEventHandler<T> (object sender,GenericEventArgs<T> args);

        public sealed class HeartRateModel : NSObject
        {
                private static volatile HeartRateModel singleton;
                private static object syncRoot = new Object ();

                private HeartRateModel ()
                {
                }

                public static HeartRateModel Instance {
                        get {
                                //Double-check lazy initialization
                                if (singleton == null) {
                                        lock (syncRoot) {
                                                if (singleton == null) {
                                                        singleton = new HeartRateModel ();
                                                }
                                        }
                                }

                                return singleton;
                        }
                }

                private bool enabled = false;

                public event GenericEventHandler<bool> EnabledChanged;
                public event GenericEventHandler<String> ErrorMessageChanged;
                public event GenericEventHandler<Double> HeartRateStored;

                public bool Enabled { 
                        get { return enabled; }
                        set {
                                if (enabled != value) {
                                        enabled = value;
                                        InvokeOnMainThread(() => EnabledChanged (this, new GenericEventArgs<bool>(value)));
                                }
                        }
                }

                public void PermissionsError(string msg)
                {
                        Enabled = false;
                        InvokeOnMainThread(() => ErrorMessageChanged (this, new GenericEventArgs<string>(msg)));
                }

                //Converts its argument into a strongly-typed quantity representing the value in beats-per-minute
                public HKQuantity HeartRateInBeatsPerMinute(ushort beatsPerMinute)
                {
                        var heartRateUnitType = HKUnit.Count.UnitDividedBy (HKUnit.Minute);
                        var quantity = HKQuantity.FromQuantity (heartRateUnitType, beatsPerMinute);

                        return quantity;
                }
                        
                public void StoreHeartRate(HKQuantity quantity)
                {
                        var bpm = HKUnit.Count.UnitDividedBy (HKUnit.Minute);
                        //Confirm that the value passed in is of a valid type (can be converted to beats-per-minute)
                        if (! quantity.IsCompatible(bpm))
                        {
                                InvokeOnMainThread(() => ErrorMessageChanged(this, new GenericEventArgs<string> ("Units must be compatible with BPM")));
                        }

                        var heartRateId = HKQuantityTypeIdentifierKey.HeartRate;
                        var heartRateQuantityType = HKQuantityType.GetQuantityType (heartRateId);
                        var heartRateSample = HKQuantitySample.FromType (heartRateQuantityType, quantity, new NSDate (), new NSDate (), new HKMetadata());

                        using (var healthKitStore = new HKHealthStore ()) {
                                healthKitStore.SaveObject (heartRateSample, (success, error) => {
                                        InvokeOnMainThread (() => {
                                                if (success) {
                                                        HeartRateStored(this, new GenericEventArgs<Double>(quantity.GetDoubleValue(bpm)));
                                                } else {
                                                        ErrorMessageChanged(this, new GenericEventArgs<string>("Save failed"));
                                                }
                                                if (error != null) {
                                                        //If there's some kind of error, disable 
                                                        Enabled = false;
                                                        ErrorMessageChanged (this, new GenericEventArgs<string>(error.ToString()));
                                                }
                                        });
                                });
                        }
                }
        }
}

```

Первый раздел — стандартный код для создания универсальные события и обработчики. Начальная часть `HeartRateModel` класс также является шаблона для создания объекта одноэлементного поточно ориентированными.

Затем `HeartRateModel` 3 событиями: 

- `EnabledChanged` — Указывает, что пульс хранилища была включена или отключена (Обратите внимание, что хранилище отключено изначально). 
- `ErrorMessageChanged` — Для этого примера приложения, у нас есть очень простая модель обработки ошибок: строка с последней возникшей ошибки. 
- `HeartRateStored` — Вызывается, когда частота пульса хранится в базе данных о работоспособности пакета.

Обратите внимание, что каждый раз, когда эти события запускаются, это делается с помощью `NSObject.InvokeOnMainThread()`, что позволяет подписчикам обновить пользовательский Интерфейс. Кроме того события может быть описан в документации как возникновение в фоновых потоках, и ответственность за обеспечение совместимости может остаться в обработчики. Поток вопросы важны в комплект работоспособности приложений, так как многие из функций, таких как запрос разрешения, являются асинхронными и выполнить их обратных вызовов в потоках, отличных от main.

Конкретный код Kit состоянием в `HeartRateModel` находится в двух функций `HeartRateInBeatsPerMinute()` и `StoreHeartRate()`. 

`HeartRateInBeatsPerMinute()` Преобразует аргумент в комплект работоспособности со строгой типизацией `HKQuantity`. Тип количества — это указано `HKQuantityTypeIdentifierKey.HeartRate` суммируется количества `HKUnit.Count` деления на `HKUnit.Minute` (другими словами, единица измерения — *ударов в минуту*). 

`StoreHeartRate()` Функция принимает `HKQuantity` (в примере приложения, он создан с `HeartRateInBeatsPerMinute()` ). Чтобы проверить свои данные, он использует `HKQuantity.IsCompatible()` метод, возвращающий `true` Если единиц объекта может быть преобразована в единицы измерения в аргументе. Если при создании количество `HeartRateInBeatsPerMinute()` очевидно, что будет возвращен `true`, но он также будет возвращать `true` Если количество были созданы как, например, *подходит лучше, чем на час*. Но чаще `HKQuantity.IsCompatible()` может использоваться для проверки запоминающих устройств, расстояние и энергии, который пользователь или устройство может ввода или для отображения в одной системы измерения (например, Британская ед.), но который может храниться в другую систему (например, метрические единицы). 

После проверки совместимости количества `HKQuantitySample.FromType()` фабричный метод используется для создания строго типизированного `heartRateSample` объекта. `HKSample` объекты имеют дату начала и окончания; для мгновенного показания эти значения должны быть теми же, как в примере. Образец также не установлен ключ-данные в его `HKMetadata` аргумент, но одна использовать код, как в следующем коде для указания расположения датчика:

```csharp
var hkm = new HKMetadata();
hkm.HeartRateSensorLocation = HKHeartRateSensorLocation.Chest;

```

Один раз `heartRateSample` был создан, код создает новое подключение к базе данных с помощью блока. Внутри этого блока `HKHealthStore.SaveObject()` метод пытается выполнить асинхронную запись в базу данных. Итоговый вызов лямбда-выражение вызывает соответствующие события либо `HeartRateStored` или `ErrorMessageChanged`.

Теперь, когда был запрограммирован модели, пришло время, чтобы увидеть, как контроллер отражает состояние модели. Откройте `HKWorkViewController.cs` файл. Конструктор просто сводит `HeartRateModel` единственного экземпляра методы обработки событий (опять же, это можно сделать с помощью лямбда-выражения, но отдельные методы сделать назначение немного очевиднее):

```csharp
public HKWorkViewController (IntPtr handle) : base (handle)
{
     HeartRateModel.Instance.EnabledChanged += OnEnabledChanged;
     HeartRateModel.Instance.ErrorMessageChanged += OnErrorMessageChanged;
     HeartRateModel.Instance.HeartRateStored += OnHeartBeatStored;
}

```

Ниже приведены соответствующие обработчики.

```csharp
void OnEnabledChanged (object sender, GenericEventArgs<bool> args)
{
        StoreData.Enabled = args.Value;
        PermissionsLabel.Text = args.Value ? "Ready to record" : "Not authorized to store data.";
        PermissionsLabel.SizeToFit ();
}

void OnErrorMessageChanged (object sender, GenericEventArgs<string> args)
{
        PermissionsLabel.Text = args.Value;
}

void OnHeartBeatStored (object sender, GenericEventArgs<double> args)
{
        PermissionsLabel.Text = String.Format ("Stored {0} BPM", args.Value);
}

```

Очевидно, что в приложение с одним контроллером, было бы как можно избежать создания объекта отдельной модели и использование событий для потока управления, но использование объектов модели больше подходит для приложений в реальных условиях.

## <a name="running-the-sample-app"></a>При запуске образца приложения

Симулятор iOS не поддерживает комплект работоспособности. Отладка должны выполняться на физическом устройстве под управлением iOS 8.

Подключите устройства iOS соответствующим образом подготовлено 8 для разработки к системе. Выберите его в качестве целевого объекта развертывания в Visual Studio для Mac и выберите в меню **запуска > Отладка**.

> [!IMPORTANT]
> На этом этапе обнаружатся ошибки, связанные с подготовкой. Чтобы устранить ошибки, просмотрите Создание и подготовка выше раздел работоспособности пакета приложения. Ниже перечислены компоненты. 
>
> - **Центр разработчиков iOS** -явный идентификатор приложения & работоспособности набор включен профиль подготовки. 
> - **Параметры проекта** -идентификатор пакета (явный идентификатор приложения) и профиль подготовки.
> - **Исходный код** -Entitlements.plist & Info.plist

Предположим, что условия заданы правильно, запустится приложение. При переходе в его `OnActivated` метод, он запрашивает Kit работоспособности авторизации. При первом возникает эта ошибка в операционной системе пользователя откроется следующее диалоговое окно:


[![](healthkit-images/image12.png "Это диалоговое окно откроется пользователя")](healthkit-images/image12.png#lightbox)

Предоставление приложению возможности обновления данных пульс, и приложение появится на экране. `ReactToHealthCarePermissions` Обратного вызова активируется асинхронно. Это приведет к `HeartRateModel’s` `Enabled` свойства для изменения, которое будет вызывать `EnabledChanged` событие, которое вызовет `HKPermissionsViewController.OnEnabledChanged()` обработчик событий для запуска, который позволяет `StoreData` кнопки. Следующая диаграмма показывает последовательность.


[![](healthkit-images/image13.png "Эта диаграмма показывает последовательность событий")](healthkit-images/image13.png#lightbox)

Нажмите клавишу **записи** кнопки. Это приведет к `StoreData_TouchUpInside()` обработчик для запуска, как будет предпринята попытка проанализировать значение `heartRate` текстовое поле, преобразовать в `HKQuantity` через уже было сказано `HeartRateModel.HeartRateInBeatsPerMinute()` функции и передать это количество, чтобы `HeartRateModel.StoreHeartRate()`. Как отмечалось ранее, это будет пытаться хранения данных и будет вызывать либо `HeartRateStored` или `ErrorMessageChanged` событий.

Дважды щелкните **Главная** кнопку на устройстве и откройте приложение работоспособности. Нажмите кнопку **источников** вкладку, чтобы просмотреть пример приложения в списке. Выберите его и запретить разрешение на обновление данных пульс. Дважды щелкните **Главная** кнопку и вернитесь к своему приложению. Опять же `ReactToHealthCarePermissions()` будет вызван, но в этот раз, так как доступ запрещен, **StoreData** будет отключена кнопка (Обратите внимание, что это происходит асинхронно, и изменения в пользовательском интерфейсе может отображаться для конечного пользователя).

## <a name="advanced-topics"></a>Дополнительные разделы

Чтение данных из комплекта для работоспособности базы данных очень похожа на запись данных: один определяет типы данных, один пытается получить доступ, запросы авторизации, и если этого авторизация данные доступны, с автоматическим преобразованием совместимый единиц мера.

Существует ряд более сложных функций запроса, на основе предикатов запросов и запросов, выполняющих обновления при обновлении соответствующие данные. 

Разработчикам приложений набор работоспособности следует просмотреть раздел Kit работоспособности из Apple [приложения просмотрите рекомендации](https://developer.apple.com/app-store/review/guidelines/#healthkit).

После понятны по безопасности и система типов модели хранения и чтения данных в базе данных общей работоспособности Kit достаточно прост. Многие из функций в комплект работоспособности работать асинхронно, и разработчики приложений должны писать программы, соответствующим образом.

На момент написания этой статьи, в данный момент нет эквивалента к пакету средств работоспособности в Android или Windows Phone.

## <a name="summary"></a>Сводка

В этой статье мы рассмотрели, как работоспособности. Это средство позволяет приложениям хранить извлекать и работоспособность общего ресурса связанные сведения, а также предоставляет стандартное приложение работоспособности, которое позволяет пользователю доступ и контроль над эти данные. 

Мы также продемонстрировано, как переопределяют проблем, связанных с работоспособностью сведения о конфиденциальности, безопасности и обеспечения целостности данных и приложений с помощью пакета работоспособности приходится иметь дело с увеличение сложности в приложение аспекты управления (Подготовка), работоспособности Kit (тип кодирования система) и пользовательский интерфейс (контроль разрешений с помощью системных диалоговых окон и работоспособности приложения). 

Наконец мы рассмотрим простой реализации комплекта работоспособности, с помощью примера приложения, записывающего данные пульса в хранилище данных о работоспособности пакета и имеет асинхронной поддержкой разработки.

## <a name="related-links"></a>Связанные ссылки

- [HKWork (пример)](https://developer.xamarin.com/samples/monotouch/ios8/IntroToHealthKit/)
- [Введение в iOS 8](~/ios/platform/introduction-to-ios8.md)
