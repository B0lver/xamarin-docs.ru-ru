---
title: Транзакции и проверка в Xamarin. iOS
description: В этом документе описывается, как разрешить восстановление прошлых покупок в приложении Xamarin. iOS. Здесь также обсуждаются способы защиты покупок и серверных продуктов.
ms.prod: xamarin
ms.assetid: 84EDD2B9-3FAA-B3C7-F5E8-C1E5645B7C77
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/18/2017
ms.openlocfilehash: 605f82c90f98bb4b50e5b630a53721d186ff35a1
ms.sourcegitcommit: 008bcbd37b6c96a7be2baf0633d066931d41f61a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/22/2020
ms.locfileid: "86935763"
---
# <a name="transactions-and-verification-in-xamarinios"></a>Транзакции и проверка в Xamarin. iOS

## <a name="restoring-past-transactions"></a>Восстановление прошлых транзакций

Если приложение поддерживает типы продуктов, которые являются restorable, необходимо включить некоторые элементы пользовательского интерфейса, чтобы позволить пользователям восстанавливать эти покупки.
Эта функция позволяет клиенту добавить продукт на дополнительные устройства или восстановить продукт на том же устройстве после очистки или удаления и повторной установки приложения. Restorable следующие типы продуктов:

- Невоспроизводимые продукты
- Автоматические подписки устанавливать возобновляемую
- Бесплатные подписки

Процесс восстановления должен обновить записи, которые вы сохраняете на устройстве для выполнения ваших продуктов. Пользователь может выбрать восстановление в любое время на любом устройстве. Процесс восстановления повторно отправляет все предыдущие транзакции для этого пользователя; код приложения должен затем определить, какое действие следует предпринять с этими сведениями (например, проверить, уже существует ли на устройстве запись о покупке, и если нет, создать запись о покупке и включить продукт для пользователя).

### <a name="implementing-restore"></a>Реализация восстановления

Кнопка **восстановления** пользовательского интерфейса вызывает следующий метод, который активирует ресторекомплетедтрансактионс в `SKPaymentQueue` .

```csharp
public void Restore()
{
   // theObserver will be notified of when the restored transactions start arriving <- AppStore
   SKPaymentQueue.DefaultQueue.RestoreCompletedTransactions();
}
```

StoreKit отправит запрос на восстановление на серверы Apple в асинхронном режиме.   
   
Поскольку `CustomPaymentObserver` регистрируется как наблюдатель транзакций, она будет принимать сообщения при ответе серверов Apple. Ответ будет содержать все транзакции, которые этот пользователь когда-либо выполнял в этом приложении (на всех устройствах). Код выполняет цикл по каждой транзакции, обнаруживает восстановленное состояние и вызывает `UpdatedTransactions` метод для его обработки, как показано ниже:

```csharp
// called when the transaction status is updated
public override void UpdatedTransactions (SKPaymentQueue queue, SKPaymentTransaction[] transactions)
{
   foreach (SKPaymentTransaction transaction in transactions)
   {
       switch (transaction.TransactionState)
       {
       case SKPaymentTransactionState.Purchased:
          theManager.CompleteTransaction(transaction);
           break;
       case SKPaymentTransactionState.Failed:
          theManager.FailedTransaction(transaction);
           break;
       case SKPaymentTransactionState.Restored:
           theManager.RestoreTransaction(transaction);
           break;
default:
           break;
       }
   }
}
```

Если у пользователя нет продуктов restorable, `UpdatedTransactions` он не вызывается.   
   
Самый простой код для восстановления заданной транзакции в примере выполняет те же действия, что и при покупке, за исключением того, что `OriginalTransaction` свойство используется для доступа к идентификатору продукта:

```csharp
public void RestoreTransaction (SKPaymentTransaction transaction)
{
   // Restored Transactions always have an 'original transaction' attached
   var productId = transaction.OriginalTransaction.Payment.ProductIdentifier;
   // Register the purchase, so it is remembered for next time
   PhotoFilterManager.Purchase(productId); // it's as though it was purchased again
   FinishTransaction(transaction, true);
}
```

Более сложная реализация может проверять другие `transaction.OriginalTransaction` свойства, такие как исходная дата и номер чека. Эти сведения будут полезны для некоторых типов продуктов (например, подписок).

#### <a name="restore-completion"></a>Завершение восстановления

В `CustomPaymentObserver` имеется два дополнительных метода, которые будут вызываться StoreKit по завершении процесса восстановления (успешно или с ошибкой), как показано ниже:

```csharp
public override void PaymentQueueRestoreCompletedTransactionsFinished (SKPaymentQueue queue)
{
   Console.WriteLine(" ** RESTORE Finished ");
}
public override void RestoreCompletedTransactionsFailedWithError (SKPaymentQueue queue, NSError error)
{
   Console.WriteLine(" ** RESTORE FailedWithError " + error.LocalizedDescription);
}
```

В этом примере эти методы не выполняют никаких действий, однако реальное приложение может выбрать реализацию сообщения для пользователя или какой-либо другой функциональности.

## <a name="securing-purchases"></a>Обеспечение безопасности покупок

Два примера в этом документе используются `NSUserDefaults` для мониторинга покупок:   
   
 **Расходных материалов** — баланс по кредитным покупкам — это простое `NSUserDefaults` целочисленное значение, увеличивающееся с каждой покупкой.   
   
 **Не-расходных материалов** — каждая покупка фильтра фотографий хранится в виде пары "ключ-значение" в `NSUserDefaults` .

Использование `NSUserDefaults` этого примера кода упрощает, но не предоставляет очень безопасное решение, так как может оказаться, что пользователи с техническими соображениями могут обновлять параметры (минуя механизм оплаты).   
   
Примечание. реальные приложения должны применять безопасный механизм хранения приобретенного содержимого, который не подвергается изменениям пользователей. Это может включать шифрование и (или) другие методы, включая проверку подлинности удаленного сервера.   
   
 Этот механизм также должен быть разработан для использования преимуществ встроенных функций резервного копирования и восстановления в iOS, iTunes и iCloud. Это гарантирует, что после того, как пользователь восстановит резервную копию предыдущих покупок, будет немедленно доступна.   
   
Дополнительные рекомендации для iOS см. в руководстве по безопасному кодированию Apple.

## <a name="receipt-verification-and-server-delivered-products"></a>Проверка поступления и продукты, доставляемые сервером

Примеры в этом документе уже состояли только из приложения, напрямую взаимодействующего с серверами магазина приложений, для проведения транзакций покупки, которые разкрывают функции или возможности, уже закодированные в приложении.   
   
Компания Apple обеспечивает дополнительный уровень безопасности при покупке, разрешая поступление уведомлений о покупках независимо от другого сервера, что может быть полезно для проверки запроса перед доставкой цифрового содержимого в рамках покупки (например, в цифровом бюллетене или журнале).   
   
 **Встроенные продукты** , такие как примеры в этом документе, продукт, который вы приобрели, существует как функция, поставляемая с приложением. Покупка в приложении позволяет пользователю получить доступ к функциональным возможностям.
Идентификаторы продуктов жестко закодированы.   
   
 **Продукты, доставляемые сервером** — продукт состоит из загружаемого содержимого, который хранится на удаленном сервере до тех пор, пока не будет выполнена успешная транзакция, которая приведет к загрузке содержимого.
Примеры могут включать книги или проблемы с журналами. Идентификаторы продуктов обычно помещаются с внешнего сервера (где также размещается содержимое продукта). Приложения должны реализовать надежный способ записи после завершения транзакции, чтобы в случае сбоя загрузки содержимого можно было повторить попытку без путаницы с пользователем.

### <a name="server-delivered-products"></a>Продукты, доставляемые сервером

Некоторые материалы продукта, например книги и журналы (или даже уровень игры), необходимо загрузить с удаленного сервера в процессе приобретения. Это означает, что для хранения и доставки содержимого продукта после его приобретения требуется дополнительный сервер.

#### <a name="getting-prices-for-server-delivered-products"></a>Получение цен на серверные продукты

Так как продукты доставляются удаленно, можно также добавлять дополнительные продукты с течением времени (без обновления кода приложения), например добавлять книги или новые проблемы с журналом. Чтобы приложение могла обнаруживать эти новости и отображать их для пользователя, дополнительный сервер должен хранить и доставлять эти сведения.   
   
[![Получение цен на серверные продукты](transactions-and-verification-images/image38.png)](transactions-and-verification-images/image38.png#lightbox)   
   
1. Сведения о продукте должны храниться в нескольких местах: на сервере и в iTunes Connect. Кроме того, для каждого продукта будут сопоставлены файлы содержимого. Эти файлы будут доставлены после успешной покупки.   
   
2. Когда пользователь хочет купить продукт, приложение должно определить доступные продукты. Эти сведения могут кэшироваться, но должны доставляться с удаленного сервера, на котором хранится главный список продуктов.   
   
3. Сервер возвращает список идентификаторов продуктов для анализируемого приложения.   
   
4. Затем приложение определяет, какой из этих кодов продуктов будет отправлен в StoreKit для получения цен и описаний.   
   
5. StoreKit отправляет список идентификаторов продуктов на серверы Apple.   
   
6. Серверы iTunes реагируют на действительные сведения о продукте (описание и текущая цена).   
   
7. Приложению `SKProductsRequestDelegate` передается информация о продукте для показа пользователю.

#### <a name="purchasing-server-delivered-products"></a>Приобретение продуктов, доставляемых сервером

Поскольку удаленный сервер требует какой-либо проверки того, что запрос содержимого является допустимым (Internet Explorer оплачен для), сведения об уведомлении передаются для проверки подлинности. Удаленный сервер пересылает эти данные в iTunes для проверки и, в случае успеха, включает содержимое продукта в ответ на приложение.   
   
 [![Приобретение продуктов, доставляемых сервером](transactions-and-verification-images/image39.png)](transactions-and-verification-images/image39.png#lightbox)   
   
1. Приложение добавляет объект `SKPayment` в очередь. При необходимости пользователю будет предложено ввести идентификатор Apple ID и появится запрос на подтверждение оплаты.   
   
2. StoreKit отправляет запрос на сервер для обработки.   
   
3. По завершении транзакции сервер отвечает за получение транзакции.   
   
4. `SKPaymentTransactionObserver`Подкласс получает уведомление и обрабатывает его. Поскольку продукт должен быть загружен с сервера, приложение инициирует сетевой запрос к удаленному серверу.   
   
5. Запрос на скачивание сопровождается данными о получении, чтобы удаленный сервер мог проверить, имеет ли он право доступа к содержимому. Сетевой клиент приложения ожидает ответа на этот запрос.   
   
6. Когда сервер получает запрос на содержимое, он анализирует данные о получении и отправляет запрос непосредственно на серверы iTunes, чтобы убедиться, что получено сообщение о допустимой транзакции. Сервер должен использовать определенную логику, чтобы определить, следует ли отправить запрос в рабочий URL-адрес или в песочницу. Компания Apple предлагает всегда использовать рабочий URL-адрес и переключается в песочницу, если получено состояние получения 21007 (уведомление "песочницы" отправлено на рабочий сервер). Дополнительные сведения см. в [руководстве по программированию проверки поступления](https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html) Apple.
   
7. iTunes проверит получение и возвратит нулевое состояние, если оно является допустимым.   
   
8. Сервер ожидает ответа iTunes. Если получен допустимый ответ, код должен узнать связанный с ним файл содержимого продукта, который будет включен в ответ приложения.   
  
9. Приложение получает и анализирует ответ, сохраняя содержимое продукта в файловой системе устройства.   
   
10. Приложение включает продукт, а затем вызывает StoreKit `FinishTransaction` . Приложение может при необходимости отобразить приобретенное содержимое (например, показать первую страницу приобретенной книги или выпуска журнала).

Альтернативная реализация для очень больших файлов содержимого продукта может заключаться в том, что в шаге #9 просто сохраняется уведомление о транзакции, что позволяет быстро завершить транзакцию и предоставить пользователю пользовательский интерфейс для загрузки фактического содержимого продукта. Последующий запрос на загрузку может повторно отправить сохраненное уведомление для доступа к требуемому файлу содержимого продукта.

### <a name="writing-server-side-receipt-verification-code"></a>Написание кода проверки поступления на стороне сервера

Проверка подлинности в коде на стороне сервера может быть выполнена с помощью простого запроса HTTP POST или ответа, который охватывает шаги, #5 с помощью #8 на схеме рабочего процесса.   
   
Извлеките `SKPaymentTansaction.TransactionReceipt` свойство в приложении. Это данные, которые необходимо отправить в iTunes для проверки (шаг #5).

В Base64-кодировке данных о приемке транзакции (на шаге #5 или #6).

Создайте простую полезную нагрузку JSON следующим образом:

```csharp
{
   "receipt-data" : "(base-64 encoded receipt here)"
}
```

HTTP. ОПУБЛИКУЙТЕ JSON в [https://buy.itunes.apple.com/verifyReceipt](https://buy.itunes.apple.com/verifyReceipt) для рабочей среды или [https://sandbox.itunes.apple.com/verifyReceipt](https://sandbox.itunes.apple.com/verifyReceipt) для тестирования.   
   
 Ответ JSON будет содержать следующие ключи:

```csharp
{
   "status" : 0,
   "receipt" : { (receipt repeated here) }
}
```

Нулевое состояние указывает на допустимое получение. Сервер может перейти к выполнению содержимого приобретенного продукта. Ключ получения содержит словарь JSON с теми же свойствами, что и `SKPaymentTransaction` объект, полученный приложением, поэтому серверный код может запрашивать этот словарь для получения таких сведений, как product_id и количества покупок.

Дополнительные сведения см. в статье [руководство по программированию проверки поступления](https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html) Apple.
