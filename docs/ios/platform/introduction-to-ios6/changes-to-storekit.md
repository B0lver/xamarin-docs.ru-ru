---
title: "Изменения в StoreKit"
description: "iOS 6 появились два изменения в набор API хранилища: возможность отображать iTunes (и App Store или iBookstore) приобрести продукты из в ваше приложение и новый в приложении где Apple будет размещаться загружаемые файлы. В этом документе объясняется, как для реализации этих функций с Xamarin.iOS."
ms.topic: article
ms.prod: xamarin
ms.assetid: 253D37D7-44C7-D012-3641-E15DC41C2699
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/19/2017
ms.openlocfilehash: cbaa389e4a115be2face2b72db6108c836676dc7
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="changes-to-storekit"></a>Изменения в StoreKit

_iOS 6 появились два изменения в набор API хранилища: возможность отображать iTunes (и App Store или iBookstore) приобрести продукты из в ваше приложение и новый в приложении где Apple будет размещаться загружаемые файлы. В этом документе объясняется, как для реализации этих функций с Xamarin.iOS._

Эти две новые возможности описаны основные изменения в набор магазина в iOS6:

-   **Отобразить содержимое в приложении & Purchasing** — пользователей можно приобрести и загрузки приложений, музыки, книг и других iTunes содержимого, не выходя из приложения. Можно также связать собственных приложений для повышения приобретения или просто стимулировать рецензии и оценки. 
-   **Содержимое приобрести размещенного в приложении** — для сохранения и доставки содержимого, связанного с вашей продукции Покупка из приложения, который устраняет необходимость использовать отдельный сервер для размещения файлов, автоматически поддерживает загрузку в фоновом режиме и позволяет Apple писать меньше кода. 


Рекомендуется, вместе с существующие Xamarin.iOS прочесть в этом документе [Покупка из приложения](~/ios/platform/in-app-purchasing/index.md) документации.

## <a name="requirements"></a>Требования

Набор магазина возможности, рассматриваемые в этом документе требуется iOS 6 и Xcode 4.5, а также Xamarin.iOS 6.0.


## <a name="in-app-content-display--purchasing"></a>Отображение содержимого в приложении и закупки

В новый компонент покупках в приложении iOS позволяет пользователям просматривать сведения о продукте и приобрести и загрузить продукт с помощью приложения.
Ранее приложений необходимо запустить iTunes, App Store или iBookstore, что привело бы к пользователю, так как исходное приложение. Эта новая функция автоматически возвращает пользователя, приложения, когда они создаются.

 [ ![](changes-to-storekit-images/image1.png "Автоматически возврат к приложению после покупки")](changes-to-storekit-images/image1.png)

Существует ряд сценариев, где это может оказаться полезным, включая (но не ограничиваясь):

-   **Интенсивность приложения пользователям рекомендовать** — страницы магазина приложений можно открыть, чтобы пользователь мог оценить и просмотреть приложения, не покидая его. 
-   **Повышение уровня нескольких приложений** — разрешить пользователю видеть другие приложения, которые публикации возможность купить загрузку немедленно. 
-   **Помощь пользователям находить и загружать содержимое** — помочь пользователям купить содержимое, которое приложение находит, управляет или агрегирует (например) приложения, связанные с музыка удалось предоставляют список воспроизведения песни и позволяют каждой песни приобретать в приложении). 


Один раз `SKStoreProductViewController` было выведено на экран пользователь может взаимодействовать с сведения о продукте, как если бы они были в iTunes App Store и iBookstore. В том числе следующее:

-  Просмотр снимки экрана (для приложений)
-  Выборка песни или видео (Музыка, ТВ-передачи и видео)
-  Просматривает чтения (и записи),
-  Приобретение & загрузки, которое производится целиком в пределах представления контроллера и набор магазина. Приложения не нужно предоставить никакого дополнительного кода для правильной работы. 


Имейте в виду, что некоторые параметры в `SKStoreProductViewController` будет по-прежнему force пользователю оставьте приложение и откройте приложение соответствующем магазине, например на нажатие на **связанные продукты** или приложения **поддержки** ссылку.

### <a name="skstoreproductviewcontroller"></a>SKStoreProductViewController

API-Интерфейс для отображения продукта в любое приложение очень прост: требуется только создание и отображение `SKStoreProductViewController`. Выполните следующие действия для создания и отображения продукта.

1.  Создание `StoreProductParameters` объектов для передачи параметров в представление-контроллер, включая `productId` в конструкторе. 
1.  Создать экземпляр `SKProductViewController` . Назначьте поле уровня класса. 
1.  Назначить обработчик контроллер представление `Finished` событие, которое следует закрыть представление-контроллер. Это событие вызывается, когда пользователь нажимает клавишу отменить ее; или, в противном случае завершает транзакцию внутри представление-контроллер. 
1.  Вызовите `LoadProduct` передачи в метод `StoreProductParameters` и обработчик завершения. Обработчик завершения необходимо проверить запрос продукта успешно и если да, присутствует `SKProductViewController` как модальная. В случае, если не удается получить продукта, следует добавить соответствующую обработку ошибок. 

### <a name="example"></a>Пример

*ProductView* проекта в *StoreKit* реализует образец кода для этой статьи `Buy` метод, который принимает любой продукт Apple идентификатор базы данных и отображает `SKStoreProductViewController`. Следующий код отображает сведения о продукте для любого заданного идентификатора Apple:

```csharp
void Buy (int productId)
{
    var spp = new StoreProductParameters(productId);
    var productViewController = new SKStoreProductViewController ();
    // must set the Finished handler before displaying the view controller
    productViewController.Finished += (sender, err) => {
        // Apple's docs says to use this method to close the view controller
        this.DismissModalViewControllerAnimated (true);
    };
    productViewController.LoadProduct (spp, (ok, err) => { // ASYNC !!!
        if (ok) {
            PresentModalViewController (productViewController, true);
        } else {
            Console.WriteLine (" failed ");
            if (err != null)
                Console.WriteLine (" with error " + err);
        }
    });
}
```

Приложение выглядит следующим образом, при выполнении — закупок или загрузки происходит только в `SKStoreProductViewController`:

 [ ![](changes-to-storekit-images/image2.png "Приложение выглядит следующим образом, при выполнении")](changes-to-storekit-images/image2.png)

### <a name="supporting-older-operating-systems"></a>Поддержка предыдущих версий операционной системы

Образец приложения содержит код, который показывает, как открыть в более ранних версиях iOS App Store и iTunes iBookstore. Используйте `OpenUrl` метод, чтобы открыть правильно сконструированный **itunes.com** URL-адрес.

Можно реализовать проверку версий, чтобы определить, какой код для запуска следующим образом:

```csharp
if (UIDevice.CurrentDevice.CheckSystemVersion (6,0)) {
    // do iOS6+ stuff, using SKStoreProductViewController as shown above
} else {
    // don't do stuff requiring iOS 6.0, use the old syntax 
    // (which will take the user out of your app)
    var nsurl = new NSUrl("http://itunes.apple.com/us/app/angry-birds/id343200656?mt=8");
    UIApplication.SharedApplication.OpenUrl (nsurl);
}
```

### <a name="errors"></a>Ошибки

При этом возникнет следующая ошибка, если недопустимый идентификатор Apple, использовании, что может запутать так как оно означает проблемы с сетью или проверки подлинности определенного рода.

 `Error Domain=SKErrorDomain Code=5 "Cannot connect to iTunes Store"`

### <a name="reading-objective-c-documentation"></a>Чтение документации Objective c.

Разработчики, сведения о хранилище пакета на портале для разработчиков Apple будет отображен протокол — [SKStoreProductViewControllerDelegate](https://developer.apple.com/library/prerelease/ios/#documentation/StoreKit/Reference/SKITunesProductViewControllerDelegate_ProtocolRef/Reference/Reference.html) — отмечалось относительно этой новой функции. Протокол делегат имеет только один метод — productViewControllerDidFinish — предоставила как `Finished` события `SKStoreProductViewController` в Xamarin.iOS.


## <a name="determining-apple-ids"></a>Определение идентификаторов Apple

Идентификатор Apple ID, предусмотренного `SKStoreProductViewController` — *номер* (не следует путать с идентификаторы набора как «com.xamarin.mwc2012»). Существует несколько способов, которые вы можете найти идентификатор Apple ID для продуктов, которые требуется отобразить, перечисленных ниже:

### <a name="itunesconnect"></a>iTunesConnect

Для приложений, публикации, можно легко найти **Apple ID** в iTunes Connect:

 [ ![](changes-to-storekit-images/image3.png "Поиск Apple ID в iTunes Connect")](changes-to-storekit-images/image3.png)

 <a name="Search_API" />


### <a name="search-api"></a>API поиска

Apple предоставляет API, динамический поиска для запроса всех продуктов в магазине приложений iTunes и iBookstore. Сведения о том, как получить доступ к API поиска можно найти в [прикрепить ресурсы компании Apple](http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html), несмотря на то, что API открыт для всех (не только зарегистрированные аффилированных лиц). Полученные данные JSON может быть проанализирован для обнаружения `trackId` , Apple ID для использования с `SKStoreProductViewController`.

Результаты также входят другие метаданные, включая сведения об отображении и иллюстрации URL-адреса, которые могут использоваться для подготовки к просмотру продукта в вашем приложении.

Далее приводятся некоторые примеры.

-   **приложение iBooks*- [http://itunes.apple.com/search?term=ibooks&amp;сущности = программного обеспечения&amp;страны = us](http://itunes.apple.com/search?term=ibooks&amp;entity=software&amp;country=us) 
-   **Точка и днем рождения... iBook*- [http://itunes.apple.com/search?term=dot+and+the+kangaroo&amp;сущности = электронной документации по&amp;страны = us](http://itunes.apple.com/search?term=dot+and+the+kangaroo&amp;entity=ebook&amp;country=us) 


### <a name="enterprise-partner-feed"></a>Веб-канал корпоративного партнера

Apple предоставляет утвержденных партнерам дамп полные данные о продукции в виде плоских файлов для загрузки готовности базы данных. Если подходят для доступа к [Enterprise партнера веб-канал](http://www.apple.com/itunes/affiliates/resources/documentation/itunes-enterprise-partner-feed.html) затем Apple ID для любого продукта можно найти в наборе данных.

Обратите внимание, что веб-канала партнера Enterprise многие пользователи являются членами [партнера программы](http://www.apple.com/itunes/affiliates) , позволяющий комиссии для полученных на продажи продукта. `SKStoreProductViewController` не поддерживает идентификаторы партнера (во время записи; это могут быть добавлены в Apple в будущем).

### <a name="direct-product-links"></a>Прямые ссылки продукт

Идентификатор Apple ID для продукта может быть выведен из его URL-адрес предварительного просмотра ссылки iTunes.
Найдите часть URL-адреса, начиная с в любой iTunes ссылки продукт (для приложений, музыки или книг) `id` и число, которое следует использовать.

Например имеет прямую ссылку на iBooks

```csharp
http://itunes.apple.com/us/app/ibooks/id364709193?mt=8
```

значение идентификатора Apple **364709193**. Аналогичным образом приложения MWC2012 имеет прямую ссылку

```csharp
http://itunes.apple.com/us/app/mwc-2012-unofficial/id496963922?mt=8
```

значение идентификатора Apple **496963922**.

## <a name="in-app-purchase-hosted-content"></a>Покупка из приложения размещенного содержимого

Если покупки из приложений состоят из загружаемое содержимое (например, книги или другой носитель, игры уровня картинок и конфигурации или других больших файлов) затем эти файлы используются для размещения на веб-сервере, и его пришлось внедрить код для безопасной загрузки их после приложений покупки. В iOS 6 Apple был представлен вариант, где будет размещаться файлов на серверах, а также исключает необходимость отдельный сервер. Функция доступна только для продуктов не потребляемых (не может быть использован или подписок). Ниже перечислены преимущества использования службы размещения Apple:

-  Сохраните затраты на размещение и пропускная способность.
-  Вероятно, большую масштабируемость, чем независимо от узла сервера, используемой в текущий момент. 
-  Меньший объем кода для записи, так как не нужно создавать обработки на сервере. 
-  Загрузка фона реализуется автоматически.


Примечание: тестирование размещенного содержимого Покупка из приложения в iOS Simulator не поддерживается, поэтому необходимо тестировать с реального устройства.

### <a name="hosted-content-basics"></a>Основы размещенного содержимого

До iOS 6, было два способа указания продукта (более подробно в [Покупка из приложения Xamarin](~/ios/platform/in-app-purchasing/index.md) документации):

-   **Встроенной продуктами** — функции, являются «разблокировано» после покупки, но при этом встроенные приложением (или как код или внедренные ресурсы). Встроенной продуктами примеры разблокирован фото фильтры или сбоях питания в играх. 
-   **Предоставление сервером продуктов** — после покупки, приложение должно загрузить содержимое с сервера, которыми можно работать. Это содержимое загружается во время покупки, хранящиеся на устройстве и выводятся в виде часть, предоставляющая продукта. Примеры книг, журнал проблем или игры уровней, состоящие из фонового изображения и файлы конфигурации. 


В iOS 6 Apple предоставляет вариант доставки сервера продуктов: они будут размещаться файлы содержимого на их серверах. Это позволяет гораздо проще создавать сервера доставить продукты, так как не требуются для работы на отдельном сервере, а также набор магазина обеспечивает загрузку в фоновом режиме, раньше нужно написать самостоятельно. Чтобы воспользоваться преимуществами размещение Apple, размещения содержимого для новых продуктов Покупка из приложения и изменить код для его преимущества набор магазина. Файлы содержимого продукта затем созданное с помощью Xcode и передан на серверы Apple для ознакомления и выпуска.

 [ ![](changes-to-storekit-images/image4.png "Процесс сборки и доставки")](changes-to-storekit-images/image4.png)

С помощью магазина приложений для предоставления приобретения в приложении *с размещенного содержимого* требует следующих установки и конфигурации:

-   **iTunes Connect** — вы *должен* предоставлять сведения вашей налогов и банковских операций в Apple, поэтому их можно передать средств, собранные от вашего имени. Затем можно настроить продукты на продажу и настройка учетных записей пользователей "песочницы" для проверки приобретения.  *Необходимо также настроить размещенное содержимое**для этих невоспроизводимых продуктов, которые вы хотите разместить на Apple* *.*  
-   **Портал Провизионирования iOS** — создать идентификатор пакета и включение доступа магазина для своего приложения, как и для любого приложения, поддерживающий приобретения в приложении. 
-   **Комплект средств для хранения** — Добавление кода в приложение для отображения продуктов, приобретения продуктов и отмены транзакций.  *В iOS 6 набор магазина также будет управлять загрузкой содержимого продукта, в фоновом режиме, с помощью обновлений хода выполнения.* 
-   **Пользовательский код** — чтобы отслеживать покупки, совершенные клиентов и предоставлять продуктов или служб, которые они приобрели. Использование новых классов набор магазина iOS 6, например `SKDownload` для получения содержимого, размещенного в Apple. 


Ниже описан способ реализации размещенного содержимого на создание и загрузка пакета управления на покупку и загрузить процесса, используя образец кода для этой статьи.


### <a name="sample-code"></a>Пример кода

Пример проекта *HostedNonConsumables* (в StoreKitiOS6.zip) показано, как создать приложение использует размещенного содержимого. Приложение предлагает два «книгах» для продажи, содержимое которой размещается на серверах компании Apple. Содержимое состоит из текстового файла или изображения, несмотря на то, что в реальном приложении может использоваться более сложного содержимого.

До, во время и после покупки, приложение выглядит следующим образом:

 [ ![](changes-to-storekit-images/image5.png "Приложение выглядит следующим образом, до, во время и после покупки")](changes-to-storekit-images/image5.png)

Текстовый файл и изображения загружаются и копируются в каталог приложения документы. В разделе [работа с документацией по файловой системе](~/ios/app-fundamentals/file-system.md) Дополнительные сведения о различных каталоги, доступные для хранения данных приложения.

## <a name="itunes-connect"></a>iTunes Connect

При создании новых продуктов, которые будут использовать Apple содержимого размещение не забудьте установить **не потребляемых** тип продукта. Другие типы продукта не поддерживают размещение содержимого. Кроме того, не следует включать размещения содержимого для *существующие* продукты, продажи; только включить размещение содержимого для новых продуктов.

 [ ![](changes-to-storekit-images/image6.png "Выбор типа потребляемых не продукта")](changes-to-storekit-images/image6.png)

Введите **Product ID**. Это потребуется позднее при создании содержимого для этого продукта.

 [ ![](changes-to-storekit-images/image7.png "Введите код продукта")](changes-to-storekit-images/image7.png)

Размещение содержимого задается в разделе "Сведения". Перед запуском Покупка из приложения просто снимите флажок «Узел содержимого с Apple», если вы хотите отменить (даже если вы отправили тестовое содержимое). Однако размещение содержимого нельзя удалить после покупки из приложений стал динамической.

 [ ![](changes-to-storekit-images/image8.png "Размещение содержимого с Apple.")](changes-to-storekit-images/image8.png)

После включения для размещения содержимого продукта будет ввести **ожидание передачи** состояние и показать это сообщение:

 [ ![](changes-to-storekit-images/image9.png "Продукт будет введите ожидания для отправки состояния и выводить это сообщение")](changes-to-storekit-images/image9.png)

Содержимое, теперь должны создаваться с помощью Xcode и отправки с помощью средства архива. В следующем разделе дается инструкции по созданию пакетов содержимого **создание. Файлы PKG**.

## <a name="creating-pkg-files"></a>Создание. PKG-файлов

Файлы содержимого, которые передаются в Apple должен удовлетворять следующим ограничениям:

-  Размер не может превышать 2 ГБ.
-  Не может содержать исполняемый код (или символических ссылок, которые вне содержимого). 
-  Необходимо правильно отформатировать (включая plist-файл) и иметь расширением pkg. файла. Это будет сделано автоматически, если вы выполните эти инструкции, с помощью Xcode. 


Можно добавить много различных файлов и типов файлов, при условии, что они отвечают эти ограничения. Содержимое ZIP-перед доставкой приложению и распаковываются по набор магазина, прежде чем код обращается к.

После загрузки содержимого пакета, его можно заменить наличие нового содержимого. Новое содержимое должно быть загружено и передан для просмотра и утверждения через обычный процесс. Необходимо увеличить `ContentVersion` в обновленных пакетов содержимого.

### <a name="xcode-in-app-purchase-content-projects"></a>Проекты Xcode в приложении покупки содержимого

В настоящее время создания пакетов содержимого для покупки из приложений продуктов требуется Xcode. Нет нет OBJECTIVE-C написания кода; Xcode имеет новый тип проекта для этих пакетов, содержит только файлы и plist-файл.

Образец приложения имеет книгах для продажи — будет содержать каждый пакет содержимого главы:

-  текстовый файл и
-  изображение для представления в главе.


Выберите **файл > Новый проект** в меню и выбрав **содержимого покупки из приложений**:

 [ ![](changes-to-storekit-images/image10.png "Выберите содержимое Покупка из приложения")](changes-to-storekit-images/image10.png)

Введите **название продукта** и **идентификатор компании** таким образом, что **идентификатор пакета** соответствует **идентификатор продукта** введенное в iTunes Подключение для этого продукта.

 [ ![](changes-to-storekit-images/image11.png "Введите имя и идентификатор")](changes-to-storekit-images/image11.png)

Теперь имеется пустой **содержимого покупки из приложений** проекта. Щелкнуть правой кнопкой мыши и **добавить файлы...** или перетащите их в **навигаторе проекта**. Убедитесь, что **ContentVersion** правильно (он должен начать с 1.0, но при выборе более поздней версии для обновления содержимого, не забудьте увеличить его).

На этом снимке экрана показаны Xcode содержимого файлы, включенные в проект и plist видимых в главном окне.

 [ ![](changes-to-storekit-images/image12.png "На этом снимке экрана показан Xcode с содержимого файлы, включенные в проект и plist видимых в главном окне")](changes-to-storekit-images/image12.png)

После добавления все файлы содержимого можно сохранить этот проект и изменить его позже или начать процесс загрузки.

## <a name="uploading-pkg-files"></a>Отправка. PKG-файлов

Самый простой способ отправки пакетов содержимого — с **Xcode архив средство**. Выберите **продукта > архив** меню, чтобы начать:

 ![](changes-to-storekit-images/image13.png "Выберите Archiven")

Пакет содержимого появится в архив, как показано ниже. Обратите внимание, значок и тип архива Показать это **содержимого архив покупок в приложении**. Нажмите кнопку **проверки...** для нашего пакета содержимого для ошибок проверки без фактического preforming передачи.

 [ ![](changes-to-storekit-images/image14.png "Проверка пакета")](changes-to-storekit-images/image14.png)

Выполните вход с вашей iTunes Connect учетные данные:

 [ ![](changes-to-storekit-images/image15.png "Выполните вход с вашей iTunes Connect учетные данные")](changes-to-storekit-images/image15.png)

Выберите нужного приложения и покупок в приложении для связывания с этого содержимого:

 [ ![](changes-to-storekit-images/image16.png "Выберите правильного приложения и Покупка из приложения, чтобы связать это содержимое с")](changes-to-storekit-images/image16.png)

Вы увидите примерно следующее сообщение:

 ![](changes-to-storekit-images/image17.png "Пример сообщения без проблем")

Теперь проходят через аналогичную процедуру, но щелкнув **распределить...** фактически будет передать это содержимое.

 [ ![](changes-to-storekit-images/image18.png "Распространение приложения")](changes-to-storekit-images/image18.png)

Выберите первый вариант, чтобы передать содержимое:

 ![](changes-to-storekit-images/image19.png "Передать содержимое")

Выполните вход еще раз:

 [ ![](changes-to-storekit-images/image15.png "Имя входа в")](changes-to-storekit-images/image15.png)

Выберите нужного приложения и записи Покупка из приложения для отправки содержимого:

 [ ![](changes-to-storekit-images/image20.png "Выберите запись покупку приложения и в приложении")](changes-to-storekit-images/image20.png)

Подождите, пока файлы будут загружены:

 [ ![](changes-to-storekit-images/image21.png "Диалоговое окно передаче содержимого")](changes-to-storekit-images/image21.png)

После завершения передачи сообщения будут отображаться для уведомления, что содержимое был отправлен в магазине приложений.

 [ ![](changes-to-storekit-images/image22.png "Пример успешную отправку сообщения")](changes-to-storekit-images/image22.png)

Как только что это уже сделано, при возвращении на страницу продукта в iTunes Connect будет показывать сведения о пакете и находиться в **готовы отправить** состояния. После выпуска продукта в это состояние, вы сможете начать тестирование в тестовой среды. Необходимо отправить продукт для тестирования в изолированной среде.

 [ ![](changes-to-storekit-images/image23.png "iTunes Connect будет показывать сведения о пакете и будет готов для отправки состояния")](changes-to-storekit-images/image23.png)

Это может занять некоторое время (например) через несколько минут) между загрузки архива и iTunes Connect состояния обновляется. Можно отправить продукт для проверки отдельно или отправить его в сочетании с двоичным файлом приложения. Только после Apple официально утвердил содержимое будет доступен в рабочей среде App Store для приобретения в вашем приложении.

### <a name="pkg-file-format"></a>Формат файла PKG

С помощью Xcode и средства архива для создания и отправки размещенного содержимого пакета означает, что вы никогда не видеть содержимое самого пакета. Файлы и каталоги в пакеты, созданные для примера приложения выглядеть так, с `plist` файл в корне и файлы продукта в `Contents` подкаталог:

 [ ![](changes-to-storekit-images/image24.png "Файл plist-файл в корне и файлы продукта в подкаталоге содержимое")](changes-to-storekit-images/image24.png)

Обратите внимание, структуру каталогов пакета (особенно расположение файлов в `Contents` подкаталог) так, как будет необходимо понять эту информацию, чтобы извлечь файлы из пакета на устройстве.

### <a name="updating-package-content"></a>Обновление содержимого пакета

Процедура для обновления содержимого после его утверждения.

-  Изменения в приложение покупки содержимого проекта в Xcode.
-  Увеличить номер версии.
-  Повторно отправьте в iTunes Connect. Последующие покупателей автоматически получат последнюю версию, но не получит все уведомления пользователей, имеющих старую версию. 
-  Приложение отвечает за уведомление пользователей и рекомендовать их для получения более новой версии содержимого. Приложения должны создавать функции, которая загружает новую версию. Это необходимо сделать с помощью функции восстановления набор магазина. 
-  Чтобы определить, если существует более новая версия, вы в можно встраивать компонент приложения для выборки SKProducts (например) того же процесса, который используется для получения цены продуктов) и сравнить свойство "ContentVersion". 

## <a name="purchasing-overview"></a>Общие сведения о приобретении

Перед прочтением этого раздела, просмотр существующих [документации Покупка из приложения](~/ios/platform/in-app-purchasing/index.md).

Последовательность событий, которая возникает, когда продукт, размещенное содержимое приобретается и загрузки проиллюстрирован на этой диаграмме:

 [ ![](changes-to-storekit-images/image25.png "Последовательность событий, которая возникает, когда продукт, размещенное содержимое приобретается и загрузки")](changes-to-storekit-images/image25.png)

1.  Новые продукты могут создаваться в iTunes Connect с Hosted Content включена. Фактическое содержимое создается отдельно в Xcode (как просто как перетаскивание файлов в папку) и затем архивировать и отправлены в iTunes (без написания кода не требуется). Каждый продукт, затем отправить на утверждение, после чего он становится доступным для покупки. В образце кода жестко запрограммированы эти коды продуктов, но размещение содержимого в Apple, является более гибким, если хранить список продуктов, доступных на удаленном сервере, чтобы можно было обновить при отправке новых продуктов и содержимого в iTunes Connect. 
1.  Когда пользователь покупает продукт, транзакции помещается в очередь оплаты для обработки. 
1.  Набор магазина отправляет запрос на покупку iTunes серверов для обработки. 
1.  Транзакция завершена на серверах iTunes (например) взимается клиента) и уведомление о возвращается в приложение с присоединенного включая ли загружаемые сведения о продукте (и если да, размер файла и другие метаданные). 
1.  Код должен проверить, если продукт downloadble и в этом случае сделать запрос загрузки содержимого, который помещается в очередь оплаты. Набор магазина отправляет запрос на серверы iTunes. 
1.  Сервер возвращает набор магазина, который обеспечивает обратный вызов для возвращения ход загрузки и время, оставшееся оценки, чтобы код содержимого файла. 
1.  После завершения вы получаете уведомление о том и передать расположение файла в папке кэша. 
1.  Код должен копирования файлов и проверить их, сохраните все состояния, которые необходимо помнить, что продукт был приобретен. Воспользуйтесь этой возможностью, чтобы правильно установить флаг резервного копирования для новых файлов (указание: если они поступают от сервера и никогда не изменена пользователем, необходимо, скорее всего, пропустить резервного копирования, так как пользователь всегда их можно получить от компании Apple серверов в будущем). 
1.  Вызов FinishTransaction. Это важно, поскольку он удаляет транзакцию из очереди оплаты. Также важно не вызывать FinishTransaction до, после копирования содержимого из каталога кэша. После вызова FinishTransaction кэшированных файлов, могут удаляться быстро. 


## <a name="implementing-hosted-content-purchase"></a>Реализация размещаемого Purchase содержимого

Прочитайте следующие сведения в сочетании с полный [документации покупки из приложений](~/ios/platform/in-app-purchasing/index.md). Сведения в этом документе основное внимание на различия между размещенного содержимого и предыдущей реализации.


### <a name="classes"></a>Классы

Следующие классы были добавлены или изменены для поддержки размещенного содержимого в iOS 6:

-   **SKDownload** — новый класс, представляющий загрузкой. API-Интерфейс обеспечивает более одного на продукта, однако изначально единственным был реализован. 
-   **SKProduct** — добавлены новые свойства: `Downloadable` , `ContentVersion` , `ContentLengths` массива. 
-   **SKPaymentTransaction** — добавлено новое свойство: `Downloads` , который содержит коллекцию `SKDownload` объекты, если этот продукт размещается содержимое, доступное для загрузки. 
-   **SKPaymentQueue** — добавлен новый метод: `StartDownloads` . Вызов этого метода с `SKDownload` объекты для выборки их размещенного содержимого. Загрузка может произойти в фоновом режиме. 
-   **SKPaymentTransactionObserver** — новый метод: `UpdateDownloads` . Комплект средств для хранилища вызывает этот метод, сведения о ходе выполнения о текущие операции загрузки. 


Сведения о новой `SKDownload` класса:

-   **Ход выполнения** – значение в диапазоне от 0-1, можно использовать для отображения индикатора выполнения в процентах для пользователя. НЕ используйте выполняется == 1, чтобы определить, загрузка завершена, проверьте состояние == завершен. 
-   **TimeRemaining** — оценка загрузки Осталось времени, в секундах. значение -1 означает, что он еще не завершила оценку. 
-   **Состояние** — Active, ожидающие завершения, не удалось, приостановлен, отменена. 
-   **ContentURL** — расположение, куда было помещать содержимое на диске, в файла `Cache` каталога. Заполняется только после завершения загрузки. 
-   **Ошибка** — проверьте это свойство, если сбой состояния. 


Взаимодействие между классами в примере кода показаны на этой диаграмме (код, предназначенный для размещенного содержимого покупки показаны зеленым цветом):

 [ ![](changes-to-storekit-images/image26.png "Размещенного содержимого покупки отображается зеленым в данной схеме.")](changes-to-storekit-images/image26.png)

В оставшейся части этого раздела показано в образце кода, где использовались эти классы:

### <a name="custompaymentobserver-skpaymenttransactionobserver"></a>CustomPaymentObserver (SKPaymentTransactionObserver)

Изменить существующий `UpdatedTransactions` переопределения для проверки наличия загружаемое содержимое и вызова `StartDownloads` при необходимости:

```csharp
public override void UpdatedTransactions (SKPaymentQueue queue, SKPaymentTransaction[] transactions)
{
    foreach (SKPaymentTransaction transaction in transactions) {
        switch (transaction.TransactionState) {
        case SKPaymentTransactionState.Purchased:
            // UPDATED FOR iOS 6
            if (transaction.Downloads != null && transaction.Downloads.Length > 0) {
                // Purchase complete, and it has downloads... so download them!
                SKPaymentQueue.DefaultQueue.StartDownloads (transaction.Downloads);
                // CompleteTransaction() call has moved after downloads complete
            } else {
                // complete the transaction now
                theManager.CompleteTransaction(transaction);
            }
            break;
        case SKPaymentTransactionState.Failed:
            theManager.FailedTransaction(transaction);
            break;
        case SKPaymentTransactionState.Restored:
            // TODO: you must decide how to handle restored transactions.
            // Triggering all the downloads at once is not advisable.
            theManager.RestoreTransaction(transaction);
            break;
        default:
            break;
        }
    }
}
```

Новый переопределенный метод `UpdatedDownloads` показано ниже. Комплект средств для хранилища вызывает этот метод после `StartDownloads` запускается в `UpdatedTransactions`. Этот метод вызывается *несколько раз* неопределенное интервалы для предоставления вам ход загрузки и затем снова после завершения загрузки. Обратите внимание, метод принимает массив `SKDownload` объектов, каждый вызов метода можно получить состояние скачать несколько файлов в очереди. Как показано в реализация ниже, являются таковыми загрузки проверяется каждый раз и выполнены соответствующие действия.

```csharp
// ENTIRELY NEW METHOD IN iOS6
public override void PaymentQueueUpdatedDownloads (SKPaymentQueue queue, SKDownload[] downloads)
{
    Console.WriteLine (" -- PaymentQueueUpdatedDownloads");
    foreach (SKDownload download in downloads) {
        switch (download.DownloadState) {
        case SKDownloadState.Active:
            // TODO: implement a notification to the UI (progress bar or something?)
            Console.WriteLine ("Download progress:" + download.Progress);
            Console.WriteLine ("Time remaining:   " + download.TimeRemaining); // -1 means 'still calculating'
            break;
        case SKDownloadState.Finished:
            Console.WriteLine ("Finished!!!!");
            Console.WriteLine ("Content URL:" + download.ContentUrl);

            // UNPACK HERE! Calls FinishTransaction when it's done
            theManager.SaveDownload (download);

            break;
        case SKDownloadState.Failed:
            Console.WriteLine ("Failed"); // TODO: UI?
            break;
        case SKDownloadState.Cancelled:
            Console.WriteLine ("Cancelled"); // TODO: UI?
            break;
        case SKDownloadState.Paused:
        case SKDownloadState.Waiting:
            break;
        default:
            break;
        }
    }
}
```

### <a name="inapppurchasemanager-skproductsrequestdelegate"></a>InAppPurchaseManager (SKProductsRequestDelegate)

Этот класс содержит новый метод `SaveDownload` , вызываемый после успешного завершения каждой загрузки.

Размещенное содержимое были успешно загружены и распаковываются в `Cache` каталога. Структура. Файл PKG требуются все файлы должны быть сохранены в `Contents` подкаталог, поэтому приведенный ниже код извлекает файлы из среды `Contents` подкаталог.

Код выполняет итерацию по всем файлам в пакете содержимого и копирует их в `Documents` каталог во вложенную папку с именем `ProductIdentifier`. Наконец он вызывает `CompleteTransaction`, который вызывает `FinishTransaction` для удаления транзакции из очереди оплаты.

```csharp
// ENTIRELY NEW METHOD IN iOS 6
public void SaveDownload (SKDownload download)
{
    var documentsPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal); // Documents folder
    var targetfolder = System.IO.Path.Combine (documentsPath, download.Transaction.Payment.ProductIdentifier);
    // targetfolder will be "/Documents/com.xamarin.storekitdoc.montouchimages/" or something like that
    if (!System.IO.Directory.Exists (targetfolder))
        System.IO.Directory.CreateDirectory (targetfolder);
    foreach (var file in System.IO.Directory.EnumerateFiles 
             (System.IO.Path.Combine(download.ContentUrl.Path, "Contents"))) { // Contents directory is the default in .PKG files
        var fileName = file.Substring (file.LastIndexOf ("/") + 1);
        var newFilePath = System.IO.Path.Combine(targetfolder, fileName);
        if (!System.IO.File.Exists(newFilePath)) // HACK: this won't support new versions...
            System.IO.File.Copy (file, newFilePath);
        else
            Console.WriteLine ("already exists " + newFilePath);
    }
    CompleteTransaction (download.Transaction); // so it gets 'finished'
}
```

Когда `FinishTransaction` вызывается загруженного файлы больше не обязательно будут в `Cache` каталога. Должны быть скопированы все файлы перед вызовом `FinishTransaction`.


## <a name="other-considerations"></a>Другие вопросы

В приведенном выше примере кода показан пример реализации довольно проста приобрести размещенного содержимого. Существуют некоторые дополнительные моменты, которые необходимо учитывать:

### <a name="detecting-updated-content"></a>Обнаружение обновленное содержимое

Хотя и существует возможность обновления размещенного содержимого пакетов, набор магазина не предоставляет механизм для проведения этих обновлений для пользователей, которые уже загрузили и приобретенных продуктов. Для реализации этой функции может проверить новый код `SKProduct.ContentVersion` свойства (если `SKProduct` — `Downloadable`) регулярно и определить, если значение увеличивается. В качестве альтернативы можно построить системы push уведомлений.

### <a name="installing-updated-content-versions"></a>Установка обновленной версии содержимого

Приведенном выше примере пропускает копирование файлов, если файл уже существует. Это не рекомендуется, если вы хотите поддерживать более новых версий загруженное содержимое.

Может быть альтернативы, чтобы скопировать содержимое в папку с именем для версии и отслеживать которого является текущей версии (например) в `NSUserDefaults` или везде, где хранятся записи завершенных покупку).

### <a name="restoring-transactions"></a>Восстановление транзакций

Если `SKPaymentQueue.DefaultQueue.RestoreCompletedTransactions` будет вызван, набор магазина возвращает все предыдущие транзакции для пользователя. Если они приобрели большое количество элементов или каждой покупкой имеет очень больших пакетов содержимого, затем восстановления может привести к большой объем сетевого трафика, все, что возвращает в очередь для загрузки за один раз.

Рассмотрите возможность отслеживания ли продукт приобретенной отдельно от фактической загрузки связанного содержимого пакета.

### <a name="pausing-restarting-and-canceling-downloads"></a>Приостановка, перезапуск и Отмена загрузки

Несмотря на то, что образец кода демонстрирует эту функцию, можно приостановить и перезапустить размещенную загрузки содержимого. `SKPaymentQueue.DefaultQueue` Имеет методы для `PauseDownloads`, `ResumeDownloads` и `CancelDownloads`.

Если код вызывает `FinishTransaction` очередь оплаты до начала выполнения загрузки `Finished` то автоматически отменяется этой загрузки.

### <a name="setting-the-skip-backup-flag-on-the-downloaded-content"></a>Установка флажка, резервное копирование SKIP на загруженное содержимое

Предлагаемые инструкции резервного копирования iCloud Apple, не написанный пользователем содержимое, которое легко восстановить на сервере должен *не* быть резервную копию (так как он будет использоваться без необходимости копирования iCloud хранилища). Ссылаться на [работа с файловой системой](~/ios/app-fundamentals/file-system.md) документации Дополнительные сведения об установке атрибута резервного копирования.

## <a name="summary"></a>Сводка

В этой статье добавлены две новые возможности набор магазина в iOS6: приобрести iTunes и другое содержимое приложения и использование сервера Apple для размещения покупки из приложений. Это введение должны считываться в сочетании с существующим [документации Покупка из приложения](~/ios/platform/in-app-purchasing/index.md) полный обзор реализации функциональности набор магазина.

## <a name="related-links"></a>Связанные ссылки

- [StoreKit (пример)](https://developer.xamarin.com/samples/StoreKit/)
- [Покупки из приложений](~/ios/platform/in-app-purchasing/index.md)
- [Справочник по StoreKit Framework](https://developer.apple.com/library/prerelease/ios/#documentation/StoreKit/Reference/StoreKit_Collection/_index.html)
- [Ссылку на класс SKStoreProductViewController](https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/SKStoreProductViewController.html)
- [Справочник по API поиска iTunes](http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html)
- [SKDownload](https://developer.apple.com/library/prerelease/ios/#documentation/StoreKit/Reference/SKDownload_Ref/Introduction/Introduction.html)
- [SKPaymentQueue](https://developer.apple.com/library/prerelease/ios/documentation/StoreKit/Reference/SKPaymentQueue_Class/Reference/Reference.html#/apple_ref/occ/instm/SKPaymentQueue/cancelDownloads:)
- [SKProduct](https://developer.apple.com/library/prerelease/ios/documentation/StoreKit/Reference/SKProduct_Reference/Reference/Reference.html#/apple_ref/occ/instp/SKProduct/downloadable)
- [Видео WWDC: Продаваемых продуктов с набор магазина](https://developer.apple.com/videos/wwdc/2012/?include=302#302)
