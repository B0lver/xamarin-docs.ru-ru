---
title: Изменения в StoreKit в iOS 6
description: 'в iOS 6 появились два изменения в API комплекта магазина: возможность отображать в приложении программы iTunes (и App Store/эротику) и новый вариант покупки в приложении, где Apple будет размещать загружаемые файлы. В этом документе объясняется, как реализовать эти функции с помощью Xamarin. iOS.'
ms.prod: xamarin
ms.assetid: 253D37D7-44C7-D012-3641-E15DC41C2699
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/19/2017
ms.openlocfilehash: d7491af1ced4e8e0309bb3e22298d33ee5a042be
ms.sourcegitcommit: 93e6358aac2ade44e8b800f066405b8bc8df2510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84571549"
---
# <a name="changes-to-storekit-in-ios-6"></a>Изменения в StoreKit в iOS 6

_в iOS 6 появились два изменения в API комплекта магазина: возможность отображать в приложении программы iTunes (и App Store/эротику) и новый вариант покупки в приложении, где Apple будет размещать загружаемые файлы. В этом документе объясняется, как реализовать эти функции с помощью Xamarin. iOS._

Основные изменения в пакете Store в iOS6 — это две новые функции:

- **Содержимое в приложении отображает & приобретения** — пользователи могут покупать и скачивать приложения, музыку, книги и другое содержимое iTunes, не закрывая приложение. Вы также можете создать ссылку на собственные приложения, чтобы повысить уровень покупок или просто рекомендовать рецензию и оценку.
- **Покупка в приложении размещенное содержимое** — Apple будет хранить и доставлять содержимое, связанное с продуктами, приобретенными в приложении, что устраняет необходимость в отдельном сервере для размещения файлов, автоматически поддерживает фоновую загрузку и позволяет писать меньше кода.

Подробное описание интерфейсов API StoreKit см. в руководствах по [приобретению в приложении](~/ios/platform/in-app-purchasing/index.md) .

## <a name="requirements"></a>Требования

Для функций комплекта магазина, обсуждаемых в этом документе, требуется iOS 6 и Xcode 4,5 вместе с Xamarin. iOS 6,0.

## <a name="in-app-content-display--purchasing"></a>Отображение содержимого в приложении & приобретении

Новая функция покупки в приложении в iOS позволяет пользователям просматривать сведения о продукте и покупать или скачивать продукт в приложении.
Ранее приложениям пришлось бы активировать iTunes, App Store или эротику, что привело бы к выходу пользователя из исходного приложения. Эта новая функция автоматически возвращает пользователя в приложение по завершении работы.

[![](changes-to-storekit-images/image1.png "Automatically returning to an app after purchase")](changes-to-storekit-images/image1.png#lightbox)

Ниже приведены примеры того, как это можно было бы использовать.

- **Поощрение пользователей в оценке приложения** . Вы можете открыть страницу App Store, чтобы пользователи могли оценивать и просматривать приложение, не закрывая его.
- **Перекрестные приложения** — позволяют пользователю видеть другие публикуемые приложения с возможностью немедленной покупки и скачивания.
- Помощь **пользователям в поиске и скачивании содержимого** — Помогите пользователям приобрести содержимое, которое приложение находит, управляет или собирает статистические данные (например, приложение, связанное с музыкой, может предоставить список воспроизведения песен и разрешить приобретать каждую песню в приложении.

После `SKStoreProductViewController` отображения пользователь может взаимодействовать со сведениями о продукте, как будто они были в iTunes, App Store или эротику. Пользователь может:

- Просмотр снимков экрана (для приложений),
- Примеры песен или видео (для музыки, ТЕЛЕПЕРЕДАЧ и фильмов)
- Просмотр (и запись) рецензий,
- Приобретение & скачивания, которое выполняется полностью в пределах контроллера и набора для магазина.

Некоторые параметры в `SKStoreProductViewController` будут по-прежнему требовать от пользователя покинуть приложение и открыть соответствующее приложение магазина, например, щелкнув **связанные продукты** или ссылку на **поддержку** приложения.

### <a name="skstoreproductviewcontroller"></a>сксторепродуктвиевконтроллер

API для отображения продукта в любом приложении прост: требуется только создание и отображение `SKStoreProductViewController` . Чтобы создать и отобразить продукт, выполните следующие действия.

1. Создайте `StoreProductParameters` объект для передачи параметров контроллеру представления, включая `productId` в конструктор.
1. Создание экземпляра `SKProductViewController`. Назначьте его полю уровня класса.
1. Назначьте обработчику событие контроллера представления `Finished` , которое должно отклонить контроллер представления. Это событие вызывается, когда пользователь нажимает кнопку "Отмена"; или, в противном случае, завершает транзакцию внутри контроллера представления.
1. Вызовите `LoadProduct` метод, передав его в `StoreProductParameters` обработчик завершения и. Обработчик завершения должен проверить, успешно ли был выполнен запрос продукта, и, если да, показывать его в `SKProductViewController` модальном режиме. Необходимо добавить соответствующую обработку ошибок в случае, если продукт не может быть извлечен.

### <a name="example"></a>Пример

Проект *продуктвиев* в примере кода *StoreKit* для этой статьи реализует `Buy` метод, который принимает идентификатор Apple ID продукта и отображает `SKStoreProductViewController` . Следующий код отображает сведения о продукте для любого заданного идентификатора Apple ID:

```csharp
void Buy (int productId)
{
    var spp = new StoreProductParameters(productId);
    var productViewController = new SKStoreProductViewController ();
    // must set the Finished handler before displaying the view controller
    productViewController.Finished += (sender, err) => {
        // Apple's docs says to use this method to close the view controller
        this.DismissModalViewControllerAnimated (true);
    };
    productViewController.LoadProduct (spp, (ok, err) => { // ASYNC !!!
        if (ok) {
            PresentModalViewController (productViewController, true);
        } else {
            Console.WriteLine (" failed ");
            if (err != null)
                Console.WriteLine (" with error " + err);
        }
    });
}
```

Приложение выглядит как на следующем снимке экрана при запуске — загрузка или приобретение полностью выполняется в `SKStoreProductViewController` :

[![](changes-to-storekit-images/image2.png "The app looks like this when running")](changes-to-storekit-images/image2.png#lightbox)

### <a name="supporting-older-operating-systems"></a>Поддержка более старых операционных систем

Пример приложения включает в себя код, демонстрирующий, как открыть App Store, iTunes или эротику в более ранних версиях iOS. Используйте `OpenUrl` метод, чтобы открыть правильно созданный URL-адрес **iTunes.com** .

Можно реализовать проверку версии, чтобы определить, какой код следует запустить, как показано ниже:

```csharp
if (UIDevice.CurrentDevice.CheckSystemVersion (6,0)) {
    // do iOS6+ stuff, using SKStoreProductViewController as shown above
} else {
    // don't do stuff requiring iOS 6.0, use the old syntax
    // (which will take the user out of your app)
    var nsurl = new NSUrl("http://itunes.apple.com/us/app/angry-birds/id343200656?mt=8");
    UIApplication.SharedApplication.OpenUrl (nsurl);
}
```

### <a name="errors"></a>ошибки

Если вы используете недопустимый идентификатор Apple ID, произойдет следующая ошибка. это может вызвать путаницу, так как она подразумевает проблему с сетью или проверкой подлинности.

 `Error Domain=SKErrorDomain Code=5 "Cannot connect to iTunes Store"`

### <a name="reading-objective-c-documentation"></a>Чтение документации по цели-C

Для разработчиков, занимающихся чтением комплекта магазина на портале разработчика Apple, будет показан протокол — [сксторепродуктвиевконтроллерделегате](https://developer.apple.com/library/prerelease/ios/#documentation/StoreKit/Reference/SKITunesProductViewControllerDelegate_ProtocolRef/Reference/Reference.html) , который обсуждается в связи с этой новой функцией. Протокол делегата имеет только один метод — Продуктвиевконтроллердидфиниш, который был представлен как событие в `Finished` `SKStoreProductViewController` в Xamarin. iOS.

## <a name="determining-apple-ids"></a>Определение идентификаторов Apple ID

Идентификатор Apple ID, необходимый для, `SKStoreProductViewController` — это *число* (не путать с идентификаторами пакетов, такими как "com. Xamarin. mwc2012"). Существует несколько разных способов узнать идентификатор Apple ID для продуктов, которые вы хотите отобразить, в следующем порядке:

### <a name="itunesconnect"></a>итунесконнект

Для публикуемых приложений можно легко найти **идентификатор Apple ID** в iTunes Connect:

[![](changes-to-storekit-images/image3.png "Finding the Apple ID in iTunes Connect")](changes-to-storekit-images/image3.png#lightbox)

 <a name="Search_API"></a>

### <a name="search-api"></a>Поиск API

Apple предоставляет динамический поисковый API для запроса всех продуктов в магазине приложений, iTunes и эротику. Сведения о том, как получить доступ к API поиска, можно найти в связанных ресурсах Apple, хотя API предоставляется любому пользователю (не только зарегистрированным аффилированным лицам). Полученный JSON можно проанализировать, чтобы обнаружить `trackId` , что является идентификатором Apple ID для использования с `SKStoreProductViewController` .

В результаты также будут включены другие метаданные, включая отображаемые сведения и URL-адреса иллюстраций, которые можно использовать для визуализации продукта в приложении.

Ниже приводится несколько примеров.

- **приложение iBooks** — [ https://itunes.apple.com/search?term=ibooks&amp ; Entity = Software &amp; страна = US](https://itunes.apple.com/search?term=ibooks&amp;entity=software&amp;country=us)
- **DOT и Кангару iBook** – [ https://itunes.apple.com/search?term=dot+and+the+kangaroo&amp ; Entity = книга &amp; страна = US](https://itunes.apple.com/search?term=dot+and+the+kangaroo&amp;entity=ebook&amp;country=us)

### <a name="enterprise-partner-feed"></a>Корпоративный Партнерский веб-канал

Компания Apple предоставляет утвержденным партнерам полный дамп данных всех своих продуктов в виде загружаемых неструктурированных файлов, готовых для базы данных. Если вы предваряти доступ к каналу корпоративного партнера, то идентификатор Apple ID для любого продукта можно найти в этом наборе данных.

Многие пользователи информационного канала предприятия являются участниками [программы](https://www.apple.com/itunes/affiliates) -партнера, которая позволяет получать комиссионные продажи по продуктам. `SKStoreProductViewController`не поддерживает дочерние идентификаторы (во время записи).

### <a name="direct-product-links"></a>Прямые ссылки на продукты

Идентификатор Apple ID для продукта можно вывести из URL-ссылки для предварительного просмотра iTunes.
В любой связи продукта iTunes (для приложений, музыки или книг) найдите часть URL-адреса, начинающуюся с `id` , и используйте следующий номер.

Например, прямая ссылка на iBooks — это

```csharp
http://itunes.apple.com/us/app/ibooks/id364709193?mt=8
```

Идентификатор Apple ID — **364709193**. Аналогичным образом для приложения MWC2012 прямая ссылка

```csharp
http://itunes.apple.com/us/app/mwc-2012-unofficial/id496963922?mt=8
```

Идентификатор Apple ID — **496963922**.

## <a name="in-app-purchase-hosted-content"></a>Размещенное содержимое, приобретенное в приложении

Если покупка в приложении состоит из загружаемого содержимого (например, книг или других носителей, иллюстраций и настроек на уровне игры или других больших файлов), то эти файлы используются для размещения на веб-сервере, и приложениям пришлось бы внедрять код для безопасной загрузки после приобретения. Начиная с iOS 6, Apple будет размещать файлы на своих серверах, устраняя необходимость в отдельном сервере. Эта функция доступна только для невоспроизводимых продуктов (неиспользуемых или подписок). Преимущества использования службы хостинга Apple включают:

- Сохранение расходов на размещение & пропускной способности.
- Возможно, более масштабируемым по сравнению с любым узлом сервера, который сейчас используется.
- Меньше кода для написания, так как вам не нужно создавать обработку на стороне сервера.
- Фоновая загрузка реализована.

Примечание. Тестирование размещенного в приложении содержимого покупки в симуляторе iOS не поддерживается, поэтому необходимо проверить реальное устройство.

### <a name="hosted-content-basics"></a>Основы размещенного содержимого

До выпуска iOS 6 существовало два способа предоставить продукт (подробно см. в документации по [приобретению в приложении Xamarin](~/ios/platform/in-app-purchasing/index.md) ):

- **Встроенные продукты** — функции, которые разблокированы путем приобретения, но встроены в приложение (как код, так и внедренные ресурсы). Примеры встроенных продуктов включают в себя незаблокированные фильтры фотографий или встроенные средства для управления играми.
- **Продукты, доставленные сервером** — после приобретения приложение должно загружать содержимое с сервера, на котором вы работаете. Это содержимое загружается во время приобретения, сохраняется на устройстве и затем подготавливается к просмотру в рамках предоставления продукта. К примерам относятся книги, проблемы с журналами или уровни игры, состоящие из фоновых изображений и файлов конфигурации.

В iOS 6 Apple предлагает разновидность серверных продуктов: они будут размещать файлы содержимого на своих серверах. Это значительно упрощает создание серверных продуктов, поскольку вам не требуется работа с отдельным сервером, а пакет Store предоставляет функции фонового скачивания, которые ранее пришлось написать. Чтобы воспользоваться преимуществами размещения Apple, разрешите размещение содержимого для новых продуктов покупки в приложении и измените код комплекта магазина, чтобы воспользоваться его преимуществами. Затем файлы содержимого продукта создаются с помощью Xcode и передаются на серверы Apple для ознакомления и выпуска.

[![](changes-to-storekit-images/image4.png "The build and deliver process")](changes-to-storekit-images/image4.png#lightbox)

Использование магазина приложений для обеспечения покупки в приложении *с размещенным содержимым* требует выполнения следующих настроек и настройки:

- **iTunes Connect** *— необходимо предоставить* компании Apple сведения о банковских и налоговых данных, чтобы они могли подключаться к фондам, собранным от вашего имени. Затем можно настроить продукты для продажи и настроить учетные записи пользователей песочницы для тестирования приобретения.  _Также необходимо настроить размещенное содержимое для неиспользуемых продуктов, которые вы хотите разместить с помощью Apple_.
- **портал подготовки iOS** — создание идентификатора пакета и включение доступа к магазину приложений для вашего приложения, как и для любого приложения, которое поддерживает приобретение в приложении.
- **Комплект магазина** — Добавление кода в приложение для отображения продуктов, приобретения продуктов и восстановления транзакций.  _В комплекте магазина iOS 6 также будет управлять загрузкой содержимого продукта в фоновом режиме с обновлениями хода выполнения._
- **Пользовательский код** — для учета покупок, производимых клиентами, и предоставления продуктов или услуг, которые они приобрели. Используйте новые классы комплектов для магазина iOS 6, например `SKDownload` для получения содержимого, размещенного в Apple.

В следующих разделах объясняется, как реализовать размещенное содержимое, от создания и отправки пакета до управления процессом покупки и скачивания, используя пример кода для этой статьи.

### <a name="sample-code"></a>Пример кода

В примере проекта *хостеднонконсумаблес* (в StoreKitiOS6. zip) используется размещенное содержимое. Приложение предлагает две главы книги для продажи — содержимое, которое размещается на серверах Apple. Содержимое состоит из текстового файла и изображения, хотя гораздо более сложное содержимое можно использовать в реальных приложениях.

Приложение выглядит следующим образом до, во время и после покупки:

 [![](changes-to-storekit-images/image5.png "The app looks like this before, during and after a purchase")](changes-to-storekit-images/image5.png#lightbox)

Текстовый файл и изображение загружаются и копируются в каталог документов приложения. Дополнительные сведения о различных каталогах, доступных для хранения приложений, см. в [документации по файловой системе](~/ios/app-fundamentals/file-system.md).

## <a name="itunes-connect"></a>iTunes Connect

При создании новых продуктов, которые будут использовать размещение содержимого Apple, обязательно выберите **Тип продукта "** неиспользуемый". Другие типы продуктов не поддерживают размещение содержимого. Кроме того, не следует включать размещение содержимого для *существующих* продуктов, которые продаются. включить размещение содержимого только для новых продуктов.

 [![](changes-to-storekit-images/image6.png "Select the Non-Consumable product type")](changes-to-storekit-images/image6.png#lightbox)

Введите **идентификатор продукта**. Этот идентификатор потребуется позже при создании содержимого для этого продукта.

 [![](changes-to-storekit-images/image7.png "Enter a Product ID")](changes-to-storekit-images/image7.png#lightbox)

Размещение содержимого задается в разделе сведений. Перед покупкой в приложении снимите флажок **содержимое узла с помощью Apple** CheckBox, если вы хотите отменить его (даже если вы отправили часть тестового содержимого). Однако размещение содержимого невозможно удалить после того, как покупка в приложении будет продолжена.

 [![](changes-to-storekit-images/image8.png "Hosting content with Apple")](changes-to-storekit-images/image8.png#lightbox)

После включения содержимого размещения продукт будет вводить состояние **Ожидание отправки** и показывать следующее сообщение:

 [![](changes-to-storekit-images/image9.png "The product will enter Waiting for Upload status and show this message")](changes-to-storekit-images/image9.png#lightbox)

Пакет содержимого должен быть создан с помощью Xcode и отправлен с использованием средства архивации. Инструкции по созданию пакетов содержимого приведены в следующем разделе **Создание. Файлы PKG**.

## <a name="creating-pkg-files"></a>Создание. Файлы PKG

Файлы содержимого, отправляемые в Apple, должны соответствовать следующим ограничениям:

- Размер не может превышать 2 ГБ.
- Не может содержать исполняемый код (или символических ссылок, который находится за пределами содержимого).
- Должен быть правильно отформатирован (включая **plist** -файл) и иметь расширение **pkg** . Это будет сделано автоматически при выполнении этих инструкций с помощью Xcode.

Можно добавить множество различных файлов и типов файлов, если они соответствуют этим ограничениям. Содержимое заархивировано перед доставкой в приложение и расzipо с помощью пакета Store, прежде чем ваш код попытается получить к нему доступ.

После отправки пакета содержимого его можно заменить новым содержимым. Новое содержимое должно быть отправлено и отправлено для просмотра и утверждения с помощью обычного процесса. Увеличьте `ContentVersion` поле в обновленных пакетах содержимого, чтобы указать, что он является более новым.

### <a name="xcode-in-app-purchase-content-projects"></a>Проекты содержимого для покупки в приложении Xcode

Создание пакетов содержимого для продуктов покупки в приложении в настоящее время требует Xcode. КОД цели-C не требуется; Xcode имеет новый тип проекта для этих пакетов, который содержит только файлы и plist.

В нашем примере приложения есть главы книги для продажи — каждый пакет содержимого глав будет содержать следующие сведения:

- текстовый файл и
- изображение, представляющее главу.

Для начала выберите **файл > создать проект** в меню и выберите **содержимое покупки в приложении**:

 [![](changes-to-storekit-images/image10.png "Choose In-App Purchase Content")](changes-to-storekit-images/image10.png#lightbox)

Введите **Название продукта** и **идентификатор компании** , чтобы **идентификатор пакета** совпадал с **идентификатором продукта** , введенным в iTunes Connect для этого продукта.

[![](changes-to-storekit-images/image11.png "Enter the  Name and Identifier")](changes-to-storekit-images/image11.png#lightbox)

Теперь у вас будет пустой проект **содержимого для покупки в приложении** . Можно щелкнуть правой кнопкой мыши и **Добавить файлы...** или перетащите их в **Навигатор по проектам**. Убедитесь в правильности **ContentVersion** (она должна начинаться с 1,0, но если позже вы решите обновить содержимое, не забудьте увеличить его).

На этом снимке экрана показан Xcode с файлами содержимого, входящими в проект, и записями plist, видимыми в главном окне:

[![](changes-to-storekit-images/image12.png "This screenshot shows Xcode with the content files included in the project and the plist entries visible in the main window")](changes-to-storekit-images/image12.png#lightbox)

После добавления всех файлов содержимого можно сохранить этот проект и изменить его позже или начать процесс отправки.

## <a name="uploading-pkg-files"></a>Отправка. Файлы PKG

Самый простой способ отправить пакеты содержимого — с помощью **средства архивирования Xcode**. Выберите **продукт > Архив** в меню, чтобы начать:

![](changes-to-storekit-images/image13.png "Choose Archiven")

Пакет содержимого будет отображаться в архиве, как показано ниже.
Тип архива и значок показывают, что эта строка представляет собой **Архив содержимого для покупки в приложении**. Нажмите кнопку **проверить...** для проверки пакета содержимого на наличие ошибок без фактического выполнения отправки.

[![](changes-to-storekit-images/image14.png "Validate the package")](changes-to-storekit-images/image14.png#lightbox)

Войдите с помощью учетных данных iTunes Connect:

[![](changes-to-storekit-images/image15.png "Login with your iTunes Connect credentials")](changes-to-storekit-images/image15.png#lightbox)

Выберите правильное приложение и покупка в приложении, чтобы связать это содержимое с:

[![](changes-to-storekit-images/image16.png "Choose the correct application and in-app purchase to associate this content with")](changes-to-storekit-images/image16.png#lightbox)

Вы должны увидеть сообщение, как на следующем снимке экрана:

![Пример сообщения без проблем](changes-to-storekit-images/image17.png "Пример сообщения без проблем")

Теперь выполните аналогичный процесс, но нажмите кнопку **распространить...** фактически отправляет содержимое.

[![Распространение приложения](changes-to-storekit-images/image18.png "Распространение приложения")](changes-to-storekit-images/image18.png#lightbox)

Выберите первый вариант, чтобы отправить содержимое:

![Отправка содержимого](changes-to-storekit-images/image19.png "Отправка содержимого")

Выполните вход еще раз:

[![](changes-to-storekit-images/image15.png "Login in")](changes-to-storekit-images/image15.png#lightbox)

Выберите правильное приложение и запись покупки в приложении для отправки содержимого в:

[![](changes-to-storekit-images/image20.png "Choose the application and in-app purchase record")](changes-to-storekit-images/image20.png#lightbox)

Подождите, пока отправляются файлы:

[![](changes-to-storekit-images/image21.png "The content upload dialog")](changes-to-storekit-images/image21.png#lightbox)

После завершения передачи появится сообщение о том, что содержимое отправлено в App Store.

[![](changes-to-storekit-images/image22.png "An example successful upload message")](changes-to-storekit-images/image22.png#lightbox)

После этого при возврате на страницу продукта в iTunes Connect он отобразит сведения о пакете и будет **готов к отправке** состояния. Если продукт находится в этом состоянии, можно начать тестирование в среде "песочницы". НЕ нужно отправлять продукт для тестирования в песочнице.

[![](changes-to-storekit-images/image23.png "iTunes Connect it will show the package details and be in Ready to Submit status")](changes-to-storekit-images/image23.png#lightbox)

Это может занять некоторое время (например, через несколько минут) между отправкой архива и обновлением состояния iTunes Connect. Вы можете отправить продукт для проверки отдельно или отправить его вместе с двоичным файлом приложения. Только после официального одобрения Apple содержимое будет доступно в рабочем магазине приложений для приобретения в вашем приложении.

### <a name="pkg-file-format"></a>Формат файла PKG

Использование Xcode и средства архивации для создания и отправки пакета размещенного содержимого означает, что содержимое самого пакета не отображается. Файлы и каталоги в пакетах, созданных для примера приложения, выглядят как на снимке экрана ниже, где файл **plist** находится в корневом каталоге и файлы продукта в подкаталоге **содержимого** :

[![](changes-to-storekit-images/image24.png "The plist file in the root and the product files in a Contents subdirectory")](changes-to-storekit-images/image24.png#lightbox)

Обратите внимание на структуру каталогов пакета (особенно расположение файлов в `Contents` подкаталоге), так как вам потребуется разобраться с этими сведениями, чтобы извлечь файлы из пакета на устройстве.

### <a name="updating-package-content"></a>Обновление содержимого пакета

Процедура обновления содержимого после утверждения:

- Измените проект содержимого для покупки в приложении в Xcode.
- Создание выпуклого номера версии.
- Отправьте в iTunes Connect еще раз. Последующие покупатели будут автоматически получать последнюю версию, но пользователи, у которых уже есть старая версия, не получат уведомления.
- Приложение отвечает за уведомление пользователей и позволяет им получить более новую версию содержимого. Приложение должно также создавать функцию, которая скачивает новую версию с помощью функции восстановления комплекта Store.
- Чтобы определить, существует ли более новая версия, можно создать в приложении функцию для получения Скпродуктс (например, тот же процесс, который используется для получения цен продуктов) и сравнивает свойство ContentVersion.

## <a name="purchasing-overview"></a>Общие сведения о покупке

Перед чтением этого раздела ознакомьтесь с [документацией по приобретению в приложении](~/ios/platform/in-app-purchasing/index.md).

Последовательность событий, возникающих при приобретении продукта с размещенным содержимым и показанный в этой схеме.

[![](changes-to-storekit-images/image25.png "The sequence of events that occurs when a product with hosted content is purchased and download")](changes-to-storekit-images/image25.png#lightbox)

1. Новые продукты можно создать в iTunes Connect с включенным размещенным содержимым. Реальное содержимое создается отдельно в Xcode (как просто перетаскивание файлов в папку), а затем заархивировано и отправлено в iTunes (код не требуется). После этого каждый продукт отправляется на утверждение, после чего он становится доступным для приобретения. В примере кода эти идентификаторы продуктов жестко, но размещение содержимого с помощью Apple является более гибким, если список доступных продуктов хранится на удаленном сервере, чтобы его можно было обновить при отправке новых продуктов и содержимого в iTunes Connect.
1. Когда пользователь приобретает продукт, транзакция помещается в очередь платежей для обработки.
1. Комплект магазина перенаправляет запрос на покупку на серверы iTunes для обработки.
1. Транзакция выполнена на серверах iTunes (например, клиенту выставляются счета), и в приложение возвращается уведомление, в котором присоединяются сведения о продукте, включая возможность его скачивания (и, если это так, размер файла и другие метаданные).
1. Код должен проверить, является ли продукт загружаемым, и, если да, сделать запрос на скачивание содержимого, который также помещается в очередь платежей. Комплект магазина отправляет этот запрос серверам iTunes.
1. Сервер возвращает файл содержимого в набор для хранения, который предоставляет обратный вызов для возврата сведений о ходе загрузки и времени оставшихся оценок в код.
1. После завершения вы получите уведомления и передали расположение файла в папку кэша.
1. Код должен копировать файлы и проверять их, сохранять любое состояние, которое необходимо помнить о приобретении продукта. Воспользуйтесь этой возможностью для правильной установки флага резервного копирования в новых файлах (указание: если они поступают с сервера и никогда не изменяются пользователем, то, скорее всего, пропустите резервное копирование, так как пользователь всегда может получать их с серверов Apple в будущем).
1. Вызовите Фиништрансактион. Этот шаг важен, так как он удаляет транзакцию из очереди платежей. Также важно не вызывать Фиништрансактион до тех пор, пока содержимое не будет скопировано из каталога кэша. После вызова Фиништрансактион, как правило, кэшированные файлы быстро очищаются.

## <a name="implementing-hosted-content-purchase"></a>Реализация приобретения размещенного содержимого

Приведенные ниже сведения должны быть прочитаны вместе с полной [документацией по покупкам в приложении](~/ios/platform/in-app-purchasing/index.md). Сведения в этом документе посвящены различиям между размещенным содержимым и предыдущей реализацией.

### <a name="classes"></a>Классы

Следующие классы были добавлены или изменены для поддержки размещенного содержимого в iOS 6:

- **Скдовнлоад** — новый класс, представляющий выполняемый процесс скачивания. API поддерживает более одного продукта, однако изначально реализован только один продукт.
- **Скпродукт** — добавлены новые свойства: `Downloadable` , `ContentVersion` , `ContentLengths` Array.
- **Скпайменттрансактион** — Добавлено новое свойство: `Downloads` , которое содержит коллекцию объектов, `SKDownload` Если у этого продукта есть размещенное содержимое, доступное для загрузки.
- **Скпайменткуеуе** — добавлен новый метод: `StartDownloads` . Вызовите этот метод с `SKDownload` объектами для выборки их размещенного содержимого. Загрузка может выполняться в фоновом режиме.
- **Скпайменттрансактионобсервер** — новый метод: `UpdateDownloads` . Комплект магазина вызывает этот метод с информацией о ходе выполнения текущих операций скачивания.

Сведения о новом `SKDownload` классе:

- **Ход выполнения** — значение в диапазоне от 0-1, которое можно использовать для отображения индикатора процента завершения для пользователя. НЕ используйте параметр Progress = = 1, чтобы определить, завершена ли загрузка; Проверьте состояние = = завершено.
- **TimeRemaining** — Оценка оставшегося времени загрузки в секундах. -1 означает, что оценка выполняется по-прежнему.
- **Состояние** : активно, ожидание, завершено, сбой, приостановлено, отменено.
- **Контентурл** — расположение файла, в котором было размещено содержимое на диске, в `Cache` каталоге. Заполняется только после завершения скачивания.
- **Ошибка** — Проверьте это свойство, если состояние не выполнено.

Взаимодействие между классами в образце кода показано на этой схеме (код, относящийся к размещенному содержимому, показан зеленым цветом):

[![](changes-to-storekit-images/image26.png "Hosted content purchases is shown in green in this diagram")](changes-to-storekit-images/image26.png#lightbox)

В оставшейся части этого раздела показан пример кода, в котором используются эти классы.

### <a name="custompaymentobserver-skpaymenttransactionobserver"></a>Кустомпайментобсервер (Скпайменттрансактионобсервер)

Измените существующее `UpdatedTransactions` Переопределение, чтобы проверить наличие загружаемого содержимого, и `StartDownloads` при необходимости выполните вызов:

```csharp
public override void UpdatedTransactions (SKPaymentQueue queue, SKPaymentTransaction[] transactions)
{
    foreach (SKPaymentTransaction transaction in transactions) {
        switch (transaction.TransactionState) {
        case SKPaymentTransactionState.Purchased:
            // UPDATED FOR iOS 6
            if (transaction.Downloads != null && transaction.Downloads.Length > 0) {
                // Purchase complete, and it has downloads... so download them!
                SKPaymentQueue.DefaultQueue.StartDownloads (transaction.Downloads);
                // CompleteTransaction() call has moved after downloads complete
            } else {
                // complete the transaction now
                theManager.CompleteTransaction(transaction);
            }
            break;
        case SKPaymentTransactionState.Failed:
            theManager.FailedTransaction(transaction);
            break;
        case SKPaymentTransactionState.Restored:
            // TODO: you must decide how to handle restored transactions.
            // Triggering all the downloads at once is not advisable.
            theManager.RestoreTransaction(transaction);
            break;
        default:
            break;
        }
    }
}
```

Ниже показан новый переопределенный метод `UpdatedDownloads` . Пакет магазина вызывает этот метод после `StartDownloads` активации в `UpdatedTransactions` . Этот метод вызывается *несколько раз* с неопределенными интервалами, чтобы получить сведения о ходе загрузки, а затем снова после завершения загрузки. Обратите внимание, что метод принимает массив `SKDownload` объектов, поэтому каждый вызов метода может предоставить состояние нескольких Скачиваний в очереди. Как показано в реализации под состоянием загрузки, проверяется каждый раз и выполняются соответствующие действия.

```csharp
// ENTIRELY NEW METHOD IN iOS6
public override void PaymentQueueUpdatedDownloads (SKPaymentQueue queue, SKDownload[] downloads)
{
    Console.WriteLine (" -- PaymentQueueUpdatedDownloads");
    foreach (SKDownload download in downloads) {
        switch (download.DownloadState) {
        case SKDownloadState.Active:
            // TODO: implement a notification to the UI (progress bar or something?)
            Console.WriteLine ("Download progress:" + download.Progress);
            Console.WriteLine ("Time remaining:   " + download.TimeRemaining); // -1 means 'still calculating'
            break;
        case SKDownloadState.Finished:
            Console.WriteLine ("Finished!!!!");
            Console.WriteLine ("Content URL:" + download.ContentUrl);

            // UNPACK HERE! Calls FinishTransaction when it's done
            theManager.SaveDownload (download);

            break;
        case SKDownloadState.Failed:
            Console.WriteLine ("Failed"); // TODO: UI?
            break;
        case SKDownloadState.Cancelled:
            Console.WriteLine ("Canceled"); // TODO: UI?
            break;
        case SKDownloadState.Paused:
        case SKDownloadState.Waiting:
            break;
        default:
            break;
        }
    }
}
```

### <a name="inapppurchasemanager-skproductsrequestdelegate"></a>Инапппурчасеманажер (Скпродуктсрекуестделегате)

Этот класс содержит новый метод `SaveDownload` , который вызывается после успешного завершения каждой загрузки.

Размещенное содержимое успешно загружено и распаковано в `Cache` каталог. Структура. Файл PKG требует, чтобы все файлы сохранялись в `Contents` подкаталоге, поэтому приведенный ниже код извлекает файлы из вложенного `Contents` каталога.

Код выполняет перебор всех файлов в пакете содержимого и копирует их в `Documents` Каталог во вложенной папке с именем для `ProductIdentifier` . Наконец, он вызывает метод `CompleteTransaction` , который вызывает `FinishTransaction` для удаления транзакции из очереди платежей.

```csharp
// ENTIRELY NEW METHOD IN iOS 6
public void SaveDownload (SKDownload download)
{
    var documentsPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal); // Documents folder
    var targetfolder = System.IO.Path.Combine (documentsPath, download.Transaction.Payment.ProductIdentifier);
    // targetfolder will be "/Documents/com.xamarin.storekitdoc.montouchimages/" or something like that
    if (!System.IO.Directory.Exists (targetfolder))
        System.IO.Directory.CreateDirectory (targetfolder);
    foreach (var file in System.IO.Directory.EnumerateFiles
             (System.IO.Path.Combine(download.ContentUrl.Path, "Contents"))) { // Contents directory is the default in .PKG files
        var fileName = file.Substring (file.LastIndexOf ("/") + 1);
        var newFilePath = System.IO.Path.Combine(targetfolder, fileName);
        if (!System.IO.File.Exists(newFilePath)) // HACK: this won't support new versions...
            System.IO.File.Copy (file, newFilePath);
        else
            Console.WriteLine ("already exists " + newFilePath);
    }
    CompleteTransaction (download.Transaction); // so it gets 'finished'
}
```

Когда `FinishTransaction` вызывается метод, загруженные файлы больше не обязательно должны находиться в `Cache` каталоге. Все файлы должны быть скопированы перед вызовом `FinishTransaction` .

## <a name="other-considerations"></a>Другие вопросы

Приведенный выше пример кода демонстрирует довольно простую реализацию приобретения размещенного содержимого. Необходимо учитывать некоторые дополнительные моменты.

### <a name="detecting-updated-content"></a>Обнаружение обновленного содержимого

Хотя вы можете обновить размещенные пакеты содержимого, Комплект магазина не предоставляет никаких механизмов для отправки этих обновлений пользователям, которые уже скачали и приобрели продукт. Для реализации этой функции код может проверить новое `SKProduct.ContentVersion` свойство (если `SKProduct` оно `Downloadable` ) регулярно и определить, увеличивается ли значение. Кроме того, можно создать систему push-уведомлений.

### <a name="installing-updated-content-versions"></a>Установка обновленных версий содержимого

Приведенный выше пример кода пропускает копирование файлов, если файл уже существует. Это не является хорошей идеей, если вы хотите поддерживать более новые версии загружаемого содержимого.

Альтернативой может быть копирование содержимого в папку с именем для версии и отслеживание текущей версии (например, в `NSUserDefaults` или везде, где хранятся завершенные записи о покупках).

### <a name="restoring-transactions"></a>Восстановление транзакций

Когда `SKPaymentQueue.DefaultQueue.RestoreCompletedTransactions` вызывается, Комплект магазина возвращает все предыдущие транзакции для пользователя. Если они приобрели большое количество элементов, или если в каждой покупке имеются пакеты содержимого большого размера, то восстановление может привести к большому объему сетевого трафика, так как все содержимое помещается в очередь для загрузки одновременно.

Рекомендуется отслеживать, приобретен ли продукт отдельно от фактического скачивания соответствующего пакета содержимого.

### <a name="pausing-restarting-and-canceling-downloads"></a>Приостановка, перезапуск и Отмена загрузки

Хотя образец кода не демонстрирует эту функцию, можно приостановить и перезапустить загрузку размещенного содержимого. `SKPaymentQueue.DefaultQueue`Содержит методы для `PauseDownloads` , `ResumeDownloads` и `CancelDownloads` .

Если код вызывает `FinishTransaction` в очереди платежей до загрузки `Finished` , то загрузка отменяется автоматически.

### <a name="setting-the-skip-backup-flag-on-the-downloaded-content"></a>Установка флага пропуска резервного копирования скачанного содержимого

Рекомендации по резервному копированию iCloud Apple предполагают, что непользовательское содержимое, которое легко восстанавливается с сервера, *не* должно быть включено в резервное копирование (так как в этом случае необязательно использовать хранилище iCloud). Дополнительные сведения о настройке атрибута резервного копирования см. в документации по [файловой системе](~/ios/app-fundamentals/file-system.md) .

## <a name="summary"></a>Сводка

В этой статье появились две новые возможности комплекта магазина в iOS6: приобретение iTunes и другого содержимого из приложения и использование сервера Apple для размещения собственных покупок в приложении. Это введение должно быть прочитано вместе с существующей [документацией по покупке в приложении](~/ios/platform/in-app-purchasing/index.md) для полного охвата реализации функций набора магазинов.

## <a name="related-links"></a>Связанные ссылки

- [StoreKit (пример)](https://docs.microsoft.com/samples/xamarin/ios-samples/storekit)
- [Покупки из приложений](~/ios/platform/in-app-purchasing/index.md)
- [Справочник по StoreKit Framework](https://developer.apple.com/library/prerelease/ios/#documentation/StoreKit/Reference/StoreKit_Collection/_index.html)
- [Справочник по классам Сксторепродуктвиевконтроллер](https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/SKStoreProductViewController.html)
- [скдовнлоад](https://developer.apple.com/library/prerelease/ios/#documentation/StoreKit/Reference/SKDownload_Ref/Introduction/Introduction.html)
- [скпайменткуеуе](https://developer.apple.com/library/prerelease/ios/documentation/StoreKit/Reference/SKPaymentQueue_Class/Reference/Reference.html#/apple_ref/occ/instm/SKPaymentQueue/cancelDownloads:)
- [скпродукт](https://developer.apple.com/library/prerelease/ios/documentation/StoreKit/Reference/SKProduct_Reference/Reference/Reference.html#/apple_ref/occ/instp/SKProduct/downloadable)
- [Видео ВВДК: продажи продуктов с помощью Store Kit](https://developer.apple.com/videos/wwdc/2012/?include=302#302)
