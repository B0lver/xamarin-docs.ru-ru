---
title: Ссылки на собственные библиотеки в Xamarin. iOS
description: В этом документе описывается, как связать собственные библиотеки C с приложением Xamarin. iOS. В нем описывается создание универсальных собственных библиотек и доступ к методам C#C из.
ms.prod: xamarin
ms.assetid: 1DA80280-E78A-EC4B-8673-C249C8425CF5
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 07/28/2016
ms.openlocfilehash: eb49be3e52258864d61521bbe1dc388e9f6d1210
ms.sourcegitcommit: 1e3a0d853669dcc57d5dee0894d325d40c7d8009
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/31/2019
ms.locfileid: "70198297"
---
# <a name="referencing-native-libraries-in-xamarinios"></a>Ссылки на собственные библиотеки в Xamarin. iOS

Xamarin. iOS поддерживает связывание с собственными библиотеками C и библиотеками цели-C. В этом документе описывается, как связать собственные библиотеки C с проектом Xamarin. iOS. Сведения о том, как сделать то же самое для библиотек цели-C, см. в нашем документе о [типах привязки-c](~/ios/platform/binding-objective-c/index.md) .

<a name="building_native" />

## <a name="building-universal-native-libraries-i386-armv7-and-arm64"></a>Создание универсальных собственных библиотек (i386, ARMv7 и ARM64)

Часто желательно создавать собственные библиотеки для каждой из поддерживаемых платформ для разработки iOS (i386 для симулятора и ARMv7/ARM64 для самих устройств). Если у вас уже есть проект Xcode для вашей библиотеки, это довольно просто.

Чтобы создать версию i386 собственной библиотеки, выполните следующую команду из терминала:

```bash
/Developer/usr/bin/xcodebuild -project MyProject.xcodeproj -target MyLibrary -sdk iphonesimulator -arch i386 -configuration Release clean build
```

Это приведет к созданию собственной статической библиотеки в `MyProject.xcodeproj/build/Release-iphonesimulator/`. Скопируйте (или переместите) файл архива библиотеки (Либмилибрари. a) в Сейф для последующего использования, указав уникальное имя (например, **либмилибрари-i386. a**), чтобы оно не противопоставлено версиям arm64 и ARMv7 той же библиотеки, которая будет построена далее.

Чтобы создать ARM64 версию собственной библиотеки, выполните следующую команду:

```bash
/Developer/usr/bin/xcodebuild -project MyProject.xcodeproj -target MyLibrary -sdk iphoneos -arch arm64 -configuration Release clean build
```

На этот раз построенная собственная библиотека будет находиться в `MyProject.xcodeproj/build/Release-iphoneos/`папке. Опять же, скопируйте (или переместите) этот файл в надежное расположение и переименуйте его в нечто вроде **либмилибрари-arm64. a** , чтобы оно не противобыло конфликту.

Теперь создайте ARMv7 версию библиотеки:

```bash
/Developer/usr/bin/xcodebuild -project MyProject.xcodeproj -target MyLibrary -sdk iphoneos -arch armv7 -configuration Release clean build
```

Скопируйте (или переместите) результирующий файл библиотеки в то же место, где вы переместили другие 2 версии библиотеки, переименовав ее в нечто вроде **либмилибрари-ARMv7. a**.

Для создания универсального двоичного файла можно воспользоваться `lipo` следующим средством:

```bash
lipo -create -output libMyLibrary.a libMyLibrary-i386.a libMyLibrary-arm64.a libMyLibrary-armv7.a
```

Будет создана `libMyLibrary.a` универсальная библиотека (FAT), которая будет использоваться для всех целевых объектов разработки iOS.


### <a name="missing-required-architecture-i386"></a>Отсутствует требуемая архитектура i386

Если вы получаете `does not implement methodSignatureForSelector` сообщение или `does not implement doesNotRecognizeSelector` в выходных данных среды выполнения при попытке использования библиотеки цели-C в симуляторе iOS, Библиотека, возможно, не была скомпилирована для архитектуры i386 (см. раздел [Создание универсального машинного кода). ](#building_native)См. раздел "библиотеки" выше).

Чтобы проверить архитектуры, поддерживаемые данной библиотекой, используйте следующую команду в окне терминала:

```bash
lipo -info /full/path/to/libraryname.a
```

Где `/full/path/to/` — полный путь к используемой библиотеке и `libraryname.a` является именем рассматриваемой библиотеки.

Если у вас есть источник для библиотеки, вам также потребуется скомпилировать и объединить его с архитектурой i386, если вы хотите протестировать приложение в симуляторе iOS.

### <a name="linking-your-library"></a>Связывание библиотеки

Все используемые сторонние библиотеки должны быть статически связаны с вашим приложением. 

Если требуется статическая компоновка библиотеки "Либмилибрари. a", полученной из Интернета или сборки с помощью Xcode, необходимо выполнить несколько действий:

- Перенесите библиотеку в проект
- Настройка Xamarin. iOS для связи библиотеки
- Получите доступ к методам из библиотеки.


Чтобы **перенести библиотеку в проект**, выберите проект в обозревателе решений и нажмите кнопку **+ параметр + a**. Перейдите к Либмилибрари. a и добавьте его в проект. При появлении запроса укажите Visual Studio для Mac или Visual Studio, чтобы скопировать его в проект. После его добавления найдите Либфу. a в проекте, щелкните его правой кнопкой мыши и задайте для **действия сборки** значение **нет**.

Чтобы **настроить Xamarin. iOS для связывания библиотеки**, в параметрах проекта для последнего исполняемого файла (а не самой библиотеки, но окончательной программе) необходимо добавить дополнительный аргумент **сборки iOS**(это часть параметров проекта) (-gcc_flags). , за которым следует строка в кавычках, содержащая все дополнительные библиотеки, необходимые для программы, например:

```bash
-gcc_flags "-L${ProjectDir} -lMylibrary -force_load ${ProjectDir}/libMyLibrary.a"
```

Приведенный выше пример свяжет **либмилибрари. a**

С помощью `-gcc_flags` можно указать любой набор аргументов командной строки для передачи в компилятор GCC, используемый для выполнения последней ссылки на исполняемый файл. Например, эта командная строка также ссылается на платформу CFNetwork:

```bash
-gcc_flags "-L${ProjectDir} -lMylibrary -lSystemLibrary -framework CFNetwork -force_load ${ProjectDir}/libMyLibrary.a"
```

Если собственная библиотека содержит C++ код, необходимо также передать флаг-CXX в "дополнительные аргументы", чтобы Xamarin. iOS знал использовать правильный компилятор. Для C++ предыдущих параметров будет выглядеть следующим образом:

```bash
-cxx -gcc_flags "-L${ProjectDir} -lMylibrary -lSystemLibrary -framework CFNetwork -force_load ${ProjectDir}/libMyLibrary.a"
```

<a name="Accessing_C_Methods_from_C#" />

## <a name="accessing-c-methods-from-c35"></a>Доступ к методам C из C&#35;

В iOS доступны два вида собственных библиотек:

- Общие библиотеки, являющиеся частью операционной системы.

- Статические библиотеки, поставляемые вместе с приложением.


Для доступа к методам, определенным в одной из них, используется [функция P/Invoke Mono](https://www.mono-project.com/docs/advanced/pinvoke/) , которая является той же технологией, которая используется в .NET, что примерно так:

- Определение функции C, которую требуется вызвать
- Определение сигнатуры
- Определение библиотеки, в которой она находится
- Напишите соответствующее объявление P/Invoke

При использовании P/Invoke необходимо указать путь к библиотеке, с которой выполняется связывание. При использовании общих библиотек iOS можно либо жестко указать путь, либо использовать удобные константы, которые мы определили в нашем примере `Constants`. Эти константы должны охватывать общие библиотеки iOS.

Например, если вы хотите вызвать метод Уиректфрамеусингблендмоде из библиотеки UIKit Apple, которая имеет эту сигнатуру в C:

```csharp
void UIRectFrameUsingBlendMode (CGRect rect, CGBlendMode mode);
```

Объявление P/Invoke будет выглядеть следующим образом:

```csharp
[DllImport (Constants.UIKitLibrary,EntryPoint="UIRectFrameUsingBlendMode")]
public extern static void RectFrameUsingBlendMode (RectangleF rect, CGBlendMode blendMode);
```

Константы. Уикитлибрари — это просто константа, определенная как "/систем/либрари/фрамеворкс/уикит.фрамеворк/уикит", точка входа позволяет указать внешнее имя (Уиректфрамусингблендмоде) при предоставлении другого имени в C#, более короткий Ректфрамеусингблендмоде.

<a name="Accessing_C_Dylibs" />

### <a name="accessing-c-dylibs"></a>Доступ к C Дилибс

Если у вас есть потребность в использовании C dylib в приложении Xamarin. iOS, то перед вызовом `DllImport` атрибута потребуется немного дополнительной настройки.

Например, если у нас есть `Animal.dylib` `Animal_Version` метод, который будет вызываться в нашем приложении, необходимо сообщить Xamarin. iOS о расположении библиотеки, прежде чем пытаться его использовать.

Для этого измените `Main.CS` файл и сделайте его следующим:

```csharp
static void Main (string[] args)
{
    // Load Dylib
    MonoTouch.ObjCRuntime.Dlfcn.dlopen ("/full/path/to/Animal.dylib", 0);

    // Start application
    UIApplication.Main (args, null, "AppDelegate");
}
```

Где `/full/path/to/` — полный путь к используемому dylib. С помощью этого кода можно связать `Animal_Version` метод следующим образом:

```csharp
[DllImport("Animal.dylib", EntryPoint="Animal_Version")]
public static extern double AnimalLibraryVersion();
```

<a name="Static_Libraries" />

### <a name="static-libraries"></a>Статические библиотеки

Поскольку в iOS можно использовать только статические библиотеки, не существует внешней общей библиотеки для компоновки, поэтому параметр path в атрибуте dllimport должен использовать специальное имя `__Internal` (Обратите внимание на символы двойной подчеркивания в начале имени), а не на имя пути.

Это заставляет атрибут DllImport искать символ метода, на который вы ссылаетесь в текущей программе, вместо того, чтобы пытаться загрузить его из общей библиотеки.

