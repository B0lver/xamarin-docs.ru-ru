---
title: Пользовательские элементы управления в Xamarin Designer для iOS
description: Xamarin Designer для iOS поддерживает визуализацию пользовательских элементов управления, созданных в проекте, или ссылок из внешних источников, таких как хранилище компонентов Xamarin.
ms.prod: xamarin
ms.assetid: D8F07D63-B006-4050-9D1B-AC6FCDA71B99
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/22/2017
ms.openlocfilehash: e8c38ec407d13a99e2990a6d4cf39b5a23728b1d
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73003979"
---
# <a name="custom-controls-in-the-xamarin-designer-for-ios"></a>Пользовательские элементы управления в Xamarin Designer для iOS

_Xamarin Designer для iOS поддерживает визуализацию пользовательских элементов управления, созданных в проекте, или ссылок из внешних источников, таких как хранилище компонентов Xamarin._

Xamarin Designer для iOS является мощным средством для визуализации пользовательского интерфейса приложения и обеспечивает поддержку редактирования в режиме WYSIWYG для большинства представлений iOS и контроллеров представлений. Приложение также может содержать пользовательские элементы управления, расширяющие встроенные в iOS. Если эти пользовательские элементы управления написаны с учетом нескольких рекомендаций, они также могут быть отображены в конструкторе iOS, предоставляя даже более широкие возможности редактирования. В этом документе рассматриваются эти рекомендации.

## <a name="requirements"></a>Требования

В области конструктора будут отображены элементы управления, соответствующие следующим требованиям.

1. Это прямой или косвенный подкласс [UIView](xref:UIKit.UIView) или [UIViewController](xref:UIKit.UIViewController). Другие подклассы [нсобжект](xref:Foundation.NSObject) будут отображаться в виде значка в области конструктора.
2. Он имеет [регистераттрибуте](xref:Foundation.RegisterAttribute) , чтобы предоставить его цели — C.
3. У него есть [обязательный конструктор IntPtr](~/ios/internals/api-design/index.md).
4. Он либо реализует интерфейс [IComponent](xref:System.ComponentModel.IComponent) , либо имеет для [десигнтимевисиблеаттрибуте](xref:System.ComponentModel.DesignTimeVisibleAttribute) значение true.

Элементы управления, определенные в коде, отвечающие приведенным выше требованиям, будут отображаться в конструкторе при компиляции содержащего их проекта для симулятора. По умолчанию все пользовательские элементы управления отображаются в разделе **пользовательские компоненты** **области элементов**. Однако [категоряттрибуте](xref:System.ComponentModel.CategoryAttribute) можно применить к классу пользовательского элемента управления, чтобы указать другой раздел.

Конструктор не поддерживает загрузку сторонних библиотек цели-C.

## <a name="custom-properties"></a>Настраиваемые свойства

Свойство, объявленное настраиваемым элементом управления, будет отображаться на панели свойств, если выполняются следующие условия.

1. Свойство имеет открытый метод получения и задания.
1. Свойство имеет [експортаттрибуте](xref:Foundation.ExportAttribute) , а [Бровсаблеаттрибуте](xref:System.ComponentModel.BrowsableAttribute) — значение true.
1. Тип свойства — числовой тип, тип перечисления, String, bool, [SizeF](xref:System.Drawing.SizeF), [уиколор](xref:UIKit.UIColor)или [уиимаже](xref:UIKit.UIImage). Этот список поддерживаемых типов может быть расширен в будущем.

Свойство также можно снабдить [дисплайнамеаттрибуте](xref:System.ComponentModel.DisplayNameAttribute) , чтобы указать метку, которая будет отображаться на панели свойств.

## <a name="initialization"></a>Инициализация

Для `UIViewController` подклассов следует использовать метод [ViewDidLoad](xref:UIKit.UIViewController.ViewDidLoad) для кода, который зависит от представлений, созданных в конструкторе.

Для `UIView` и других подклассов `NSObject` рекомендуется использовать метод [авакефромниб](xref:Foundation.NSObject.AwakeFromNib) , чтобы выполнить инициализацию пользовательского элемента управления после его загрузки из файла макета. Это обусловлено тем, что пользовательские свойства, заданные на панели свойств, не будут заданы при запуске конструктора элемента управления, но будут установлены перед вызовом `AwakeFromNib`:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    public CustomView (IntPtr handle) : base (handle) { }

    public override void AwakeFromNib ()
    {
        // Initialize the view here.
    }
}
```

Если элемент управления также предназначен для создания непосредственно из кода, может потребоваться создать метод, имеющий общий код инициализации, например:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    public CustomView (IntPtr handle) : base (handle) { }

    public CustomView ()
    {
        // Called when created from code.
        Initialize ();
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        Initialize ();
    }

    void Initialize ()
    {
        // Common initialization code here.
    }
}
```

## <a name="property-initialization-and-awakefromnib"></a>Инициализация и Авакефромниб свойств

Следует принять во внимание, когда и где следует инициализировать создаваемые свойства в пользовательском компоненте так, чтобы не перезаписать значения, заданные в конструкторе iOS. В качестве примера рассмотрим следующий код:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    [Export ("Counter"), Browsable (true)]
    public int Counter {get; set;}

    public CustomView (IntPtr handle) : base (handle) { }

    public CustomView ()
    {
        // Called when created from code.
        Initialize ();
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        Initialize ();
    }

    void Initialize ()
    {
        // Common initialization code here.
        Counter = 0;
    }
}
```

Компонент `CustomView` предоставляет свойство `Counter`, которое может быть задано разработчиком в конструкторе iOS. Однако независимо от того, какое значение задается в конструкторе, значение свойства `Counter` всегда будет равно нулю (0). Далее описывается, почему это происходит:

- Экземпляр `CustomControl` расширяется из файла раскадровки.
- Все свойства, измененные в конструкторе iOS, задаются (например, при установке значения `Counter` двум (2)).
- Выполняется метод `AwakeFromNib` и выполняется вызов метода `Initialize` компонента.
- В `Initialize` значение свойства `Counter` сбрасывается в ноль (0).

Чтобы устранить описанную выше ситуацию, либо инициализируйте свойство `Counter` в любом расположении (например, в конструкторе компонента), либо не переопределяйте метод `AwakeFromNib` и вызовите `Initialize`, если компоненту не требуется дальнейшая инициализация за пределами текущего обрабатывается его конструкторами.

## <a name="design-mode"></a>Режим конструктора

В области конструктора пользовательский элемент управления должен соответствовать некоторым ограничениям:

- Ресурсы пакета приложений недоступны в режиме конструктора. Изображения доступны при загрузке с помощью [методов уиимаже](xref:UIKit.UIImage) .
- Асинхронные операции, такие как веб-запросы, не должны выполняться в режиме конструктора. Область конструктора не поддерживает анимацию или другие асинхронные обновления пользовательского интерфейса элемента управления.

Пользовательский элемент управления может реализовать [IComponent](xref:System.ComponentModel.IComponent) и использовать свойство [десигнмоде](xref:System.ComponentModel.ISite.DesignMode) для проверки того, находится ли он в области конструктора. В этом примере метка будет отображать «режим конструктора» в области конструктора и «Runtime» во время выполнения:

```csharp
[Register ("DesignerAwareLabel")]
public class DesignerAwareLabel : UILabel, IComponent {

    #region IComponent implementation

    public ISite Site { get; set; }
    public event EventHandler Disposed;

    #endregion

    public DesignerAwareLabel (IntPtr handle) : base (handle) { }

    public override void AwakeFromNib ()
    {
        if (Site != null && Site.DesignMode)
            Text = "Design Mode";
        else
            Text = "Runtime";
    }
}
```

Прежде чем пытаться получить доступ к любому из его членов, следует всегда проверять свойство `Site` для `null`. Если `Site` `null`, то можно считать, что элемент управления не работает в конструкторе.
В режиме конструктора `Site` задаются после запуска конструктора элемента управления и перед вызовом `AwakeFromNib`.

## <a name="debugging"></a>Отладка

Элемент управления, соответствующий указанным выше требованиям, будет отображаться на панели элементов и отображен на поверхности.
Если элемент управления не отображается, проверьте наличие ошибок в элементе управления или одну из его зависимостей.

Область конструктора часто может перехватывать исключения, создаваемые отдельными элементами управления, продолжая отображать другие элементы управления. Элемент управления, вызвавший сбой, заменяется красным заполнительом, и вы можете просмотреть трассировку исключений, щелкнув значок с восклицательным знаком:

 ![](ios-designable-controls-overview-images/exception-box.png "A faulty control as red placeholder and the exception details")

Если для элемента управления доступны отладочные символы, то трассировка будет содержать имена файлов и номера строк.
Двойной щелчок по строке в трассировке стека приведет к переходу к этой строке в исходном коде.

Если конструктор не может изолировать неисправный элемент управления, в верхней части области конструктора появится предупреждающее сообщение:

 ![](ios-designable-controls-overview-images/info-bar.png "A warning message at the top of the design surface")

Полная визуализация возобновится, когда неисправный элемент управления будет исправлен или удален из области конструктора.

## <a name="summary"></a>Сводка

В этой статье представлено создание и применение пользовательских элементов управления в конструкторе iOS. Сначала в нем описаны требования, которым должны соответствовать элементы управления для подготовки к просмотру в области конструктора и предоставления настраиваемых свойств на панели свойств. Затем он просматривает код программной части для инициализации элемента управления и свойства Десигнмоде. В последний раз было описано, что происходит при возникновении исключений и как устранить эту проблему.
