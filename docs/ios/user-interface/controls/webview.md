---
title: Веб-представления в Xamarin. iOS
description: В этом документе описаны различные способы, с помощью которых приложение Xamarin. iOS может отображать веб-содержимое. В нем обсуждаются Вквебвиев, Сфсафаривиевконтроллер, Safari и безопасность транспорта приложений.
ms.prod: xamarin
ms.assetid: 84886CF4-2B2B-4540-AD92-7F0B791952D1
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/22/2017
ms.openlocfilehash: a9dce962c35e5f9cfdcd674da9ad71cf8935e7d4
ms.sourcegitcommit: 6c60914b380ff679bbffd7790edd4d5e18005d0a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2020
ms.locfileid: "80070319"
---
# <a name="web-views-in-xamarinios"></a>Веб-представления в Xamarin. iOS

В течение времени существования iOS Apple было выпущено несколько способов реализации функциональных возможностей веб-представлений в приложениях для разработчиков приложений. Большинство пользователей использует встроенный веб-браузер Safari на устройстве iOS и, следовательно, предполагаю, что функциональность веб-представлений других приложений согласуется с этим интерфейсом. Они предполагают работу одних и тех же жестов, а также производительность по номиналу и функциональность.

в iOS 11 появились новые изменения как в `WKWebView`, так и в `SFSafariViewController`. Дополнительные сведения см. в статье об [изменениях в Интернете в программе](~/ios/platform/introduction-to-ios11/web.md) "Пошаговое руководством по iOS 11".

## <a name="wkwebview"></a>вквебвиев

`WKWebView` появился в iOS 8, позволяя разработчикам приложений реализовать интерфейс веб-браузера, аналогичный мобильному Safari. Это связано с тем, что `WKWebView` использует подсистему JavaScript нитро, ту же подсистему, которая используется мобильным обозревателем Safari. `WKWebView` всегда следует использовать по Уивебвиев, если это возможно благодаря повышению производительности, встроенным жестам, удобным для пользователя, и простоте взаимодействия между веб-страницей и приложением.

`WKWebView` можно добавить в приложение практически аналогичным образом, так как разработчик имеет гораздо больший контроль над пользовательским интерфейсом, UX и функциональностью. При создании и отображении объекта веб-представления отображается запрошенная страница, однако вы можете управлять представлением представления, тем, как пользователь может перемещаться и как пользователь выходит из представления.  

Приведенный ниже код можно использовать для запуска `WKWebView` в приложении Xamarin. iOS:

```csharp
WKWebView webView = new WKWebView(View.Frame, new WKWebViewConfiguration());
View.AddSubview(webView);

var url = new NSUrl("https://docs.microsoft.com");
var request = new NSUrlRequest(url);
webView.LoadRequest(request);
```

Важно отметить, что `WKWebView` находится в пространстве имен `WebKit`, поэтому вам придется добавить эту директиву using в начало класса.

`WKWebView` также можно использовать в приложениях Xamarin. Mac, и его следует использовать при создании кросс-платформенного приложения Mac/iOS.

В инструкции по [обработке оповещений JavaScript](https://github.com/xamarin/recipes/tree/master/Recipes/ios/content_controls/web_view/handle_javascript_alerts) также содержатся сведения об использовании Вквебвиев с JavaScript.

## <a name="sfsafariviewcontroller"></a>сфсафаривиевконтроллер

 `SFSafariViewController` — это последний способ предоставления веб-содержимого из приложения и доступен в iOS 9 и более поздних версиях. В отличие от `UIWebView` или `WKWebView`, `SFSafariViewController` является контроллером представления и поэтому не может использоваться с другими представлениями. Вы должны представлять `SFSafariViewController` как новый контроллер представления, точно так же, как и любой контроллер представления.

 `SFSafariViewController` по сути является мини-обозревателем Safari, который можно внедрить в приложение. Как и Вквебвиев, он использует тот же механизм JavaScript нитро, но также предоставляет ряд дополнительных функций Safari, таких как автозаполнение, читатель и возможность совместного использования файлов cookie и данных с помощью мобильного обозревателя Safari. Взаимодействие между пользователем и `SFSafariViewController` недоступно для вашего приложения. Приложение не будет иметь доступ к каким бы то ни было функциям Safari по умолчанию.

Кроме того, по умолчанию реализуется кнопка **done (Готово** ), позволяющая пользователю легко вернуться в приложение, а также кнопки перехода и обратно, позволяющие пользователю перемещаться по стеку веб-страниц. Кроме того, он также предоставляет пользователю, которому необходимо предоставить уверенность в том, что они находятся на ожидаемой веб-странице. Адресная строка не разрешает пользователю изменять URL-адрес.

Эти реализации не могут быть изменены, поэтому `SFSafariViewController` идеально подходит для использования в качестве браузера по умолчанию, если приложение хочет предоставить веб-страницу без настройки.

Приведенный ниже код можно использовать для запуска `SFSafariViewController` в приложении Xamarin. iOS:

```csharp
var sfViewController = new SFSafariViewController(url);

PresentViewController(sfViewController, true, null);
```

В результате будет создано следующее веб-представление:

[![пример веб-представления с Сфсафаривиевконтроллер](webview-images/sfsafariviewcontroller.png)](webview-images/sfsafariviewcontroller.png#lightbox)

## <a name="safari"></a>Safari

Вы также можете открыть мобильное приложение Safari в приложении, используя приведенный ниже код.

```csharp
var url = new NSUrl("https://docs.microsoft.com");

UIApplication.SharedApplication.OpenUrl(url);
```

В результате будет создано следующее веб-представление:

[![веб-страницы, представленной в Safari](webview-images/safari.png)](webview-images/safari.png#lightbox)

В большинстве случаев следует избегать переходов пользователей из приложения в Safari. Большинство пользователей не будут получать переходы за пределы приложения, поэтому при переходе от приложения пользователи могут никогда не возвращать его, по сути, выбросить задействование.

улучшения iOS 9 позволяют пользователю легко вернуться в приложение с помощью кнопки назад, представленной в левом верхнем углу страницы Safari.

## <a name="app-transport-security"></a>Защита транспорта приложения

Защита транспорта приложений или *ATS* была введена компанией Apple в iOS 9 для обеспечения соответствия всем Интернет – рекомендациям по обеспечению безопасного подключения.

Дополнительные сведения о ATS, в том числе о том, как ее реализовать в приложении, см. в руководстве по [безопасности транспорта приложений](~/ios/app-fundamentals/ats.md) .

## <a name="uiwebview-deprecation"></a>Устаревшие Уивебвиев

`UIWebView` является устаревшим способом Apple для предоставления веб-содержимого в приложении. Она была выпущена в iOS 2,0 и является устаревшей по отношению к 8,0.

> [!IMPORTANT]
> `UIWebView` не рекомендуется к использованию. Новые приложения, использующие этот элемент управления, [не будут приниматься в магазине приложений по состоянию на апрель 2020, а обновления приложений, использующие этот элемент управления, не будут приниматься за декабрь 2020](https://developer.apple.com/news/?id=12232019b).
>
> [Документация по `UIWebView` Apple](https://developer.apple.com/documentation/uikit/uiwebview) предлагает приложениям использовать вместо них [`WKWebView`](#wkwebview) .
>
> Если при использовании Xamarin.Forms вы ищете ресурсы касательно предупреждения об устаревании `UIWebView`UIWebView (ITMS-90809), ознакомьтесь с документацией по [Xamarin.Forms WebView](~/xamarin-forms/user-interface/webview.md#uiwebview-deprecation-and-app-store-rejection-itms-90809).

Разработчики, которые отправили приложения iOS за последние шесть месяцев (или так далее), могли получить предупреждение из магазина приложений, о `UIWebView` не рекомендуется использовать.

Распространены устаревшие интерфейсы API. Xamarin. iOS использует настраиваемые атрибуты для передачи этих API-интерфейсов (и предлагает замену при их наличии) обратно разработчикам. Что отличается от этого времени и гораздо менее распространено, так как в магазине Apple App Store оно **будет применяться** в процессе отправки.

К сожалению, удаление типа `UIWebView` из `Xamarin.iOS.dll` является [двоичным критическим изменением](https://docs.microsoft.com/dotnet/core/compatibility/categories#binary-compatibility). Это изменение приведет к нарушению существующих сторонних библиотек, включая некоторые из них, которые могут не поддерживаться или даже повторно компилироваться (например, закрытый источник). Это позволит создавать только дополнительные проблемы для разработчиков. Поэтому тип *еще*не удаляется.

Начиная с [Xamarin. iOS 13,16](https://docs.microsoft.com/xamarin/ios/release-notes/13/13.16) новое средство обнаружения и средства можно использовать для перехода с `UIWebView`.

### <a name="detection"></a>Обнаружение

Если вы недавно отправили приложение iOS в Apple App Store, вам может возникнуть вопрос, применима ли эта ситуация к вашим приложениям.

Чтобы узнать это, можно добавить `--warn-on-type-ref=UIKit.UIWebView` к **дополнительным аргументам mtouch проекта.** Будет выведено предупреждение о **любой** ссылке на устаревшую `UIWebView` внутри приложения (и всех его зависимостей). Различные предупреждения используются для отчетов о типах **до** и **после** выполнения управляемого компоновщика.

Предупреждения, как и другие, могут быть включены в ошибки с помощью `-warnaserror:`. Это может быть полезно, если вы хотите убедиться, что новая зависимость от `UIWebView` не добавлена после проверки. Например:

* `-warnaserror:1502` будут сообщать об ошибках, если в предварительно связанных сборках обнаружены какие-либо ссылки.
* `-warnaserror:1503` будут сообщать об ошибках, если в сборках после их обнаружения обнаружены какие-либо ссылки.

Можно также отключить предупреждения, если не будут полезны результаты, предшествующие или отправленные при связывании. Например:

* `-nowarn:1502` **не** будет сообщать о предупреждениях, если в предварительно связанных сборках обнаружены какие-либо ссылки.
* `-nowarn:1503` **не** будет сообщать о предупреждениях, если в сборках, связанных после сборки, обнаружены какие-либо ссылки.

### <a name="removal"></a>Удаление

Каждое приложение является уникальным. Удаление `UIWebView` из приложения может потребовать выполнения различных действий в зависимости от того, как и где оно используется. Ниже перечислены наиболее распространенные сценарии.

- В приложении не используется `UIWebView`. Все правильно. При отправке в AppStore предупреждения **не** должны выдаваться. Никаких других действий от вас не требуется.
- Прямое использование `UIWebView` приложением. Сначала удалите использование `UIWebView`, например замените его новым типом `WKWebView` (iOS 8) или `SFSafariViewController` (iOS 9). После этого управляемый компоновщик не должен видеть ссылку на `UIWebView`, а окончательный двоичный файл приложения не сможет его отслеживать.
- Косвенное использование. `UIWebView` могут присутствовать в некоторых сторонних библиотеках, управляемых или собственных, используемых приложением. Начните с обновления внешних зависимостей до последних версий, так как эта ситуация может уже быть решена в более новом выпуске. В противном случае обратитесь к разработчикам библиотек и запросите их планы обновления.

Кроме того, можно использовать следующие подходы:

1. Если вы используете **Xamarin. Forms**, прочтите эту [запись блога](https://devblogs.microsoft.com/xamarin/uiwebview-deprecation-xamarin-forms/).
1. Включите управляемый компоновщик (для всего проекта или по крайней мере на зависимость, используя `UIWebView`), чтобы он *мог* быть удален, если на него нет ссылок. Это позволит решить проблему, но может потребовать дополнительной работы, чтобы сделать код защищенным компоновщиком.
1. Если не удается изменить параметры управляемого компоновщика, см. следующие особые случаи.

#### <a name="applications-cannot-use-the-linker-or-change-its-settings"></a>Приложения не могут использовать Компоновщик (или изменить его параметры)

Если по какой-либо причине вы **не** используете управляемый компоновщик (например, **не компоновать**), то символ `UIWebView` останется в двоичном приложении, которое вы отправили в Apple, и оно может быть отклонено.

*Принудительное* решение заключается в добавлении `--optimization=force-rejected-types-removal` к **дополнительным аргументам mtouch**проекта. Это приведет к удалению трассировок `UIWebView` из приложения. Однако любой код, ссылающийся на тип, будет **работать неправильно** (предполагается наличие исключений или сбоев). Этот подход следует использовать только в том случае, если вы уверены, что код недоступен во время выполнения (даже если он был доступен через статический анализ).

#### <a name="support-for-ios-7x-or-earlier"></a>Поддержка iOS 7. x (или более ранняя версия)

`UIWebView` входит в состав iOS с момента выпуска версии 2.0. Наиболее распространенными заменами являются `WKWebView` (iOS 8) и `SFSafariViewController` (iOS 9). Если приложение по-прежнему поддерживает более старые версии iOS, следует рассмотреть следующие варианты.

* Создайте минимальную целевую версию iOS 8 (решение времени сборки).
* Используйте только `WKWebView`, если приложение работает в iOS 8 + (решение среды выполнения).

#### <a name="applications-not-submitted-to-apple"></a>Приложения, не отправленные в Apple

Если приложение не отправляется в Apple, следует запланировать переход от устаревшего API, так как он может быть удален в будущих выпусках iOS. Однако этот переход можно выполнить с помощью собственного расписания.

## <a name="related-links"></a>Связанные ссылки

- [Представления (пример)](https://docs.microsoft.com/samples/xamarin/ios-samples/webview)
