---
title: Веб-просмотры в Xamarin.iOS
description: В этом документе описаны различные способы отображения веб-контента приложением Xamarin.iOS. В нем обсуждаются WKWebView, SFSafariViewController, Safari и безопасность на транспорте приложений.
ms.prod: xamarin
ms.assetid: 84886CF4-2B2B-4540-AD92-7F0B791952D1
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/22/2017
ms.openlocfilehash: cc6c87452bf5312d66e33b7c49d3dc216eceb7d6
ms.sourcegitcommit: b93754b220fca3d6e3d131341e3cfbe233d10f84
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/03/2020
ms.locfileid: "80628297"
---
# <a name="web-views-in-xamarinios"></a>Веб-просмотры в Xamarin.iOS

За время существования iOS Apple выпустила несколько способов для разработчиков приложений включить функциональность веб-просмотра в свои приложения. Большинство пользователей используют встроенный веб-браузер Safari на своем устройстве iOS, и поэтому ожидают, что функциональность веб-просмотра из других приложений согласуется с этим опытом. Они ожидают, что те же жесты будут работать, производительность будет на одном уровне, и функциональность то же самое.

iOS 11 внесла `WKWebView` новые изменения в оба и `SFSafariViewController`. Более подробную информацию об этих сведениях можно увидеть [в руководстве по веб-трансляции в руководстве по iOS 11.](~/ios/platform/introduction-to-ios11/web.md)

## <a name="wkwebview"></a>WKWebView

`WKWebView`была введена в iOS 8, что позволяет разработчикам приложений реализовывать интерфейс просмотра веб-страниц, аналогичный интерфейсу мобильного Safari. Отчасти это связано с тем, что `WKWebView` используется двигатель Nitro Javascript, тот же двигатель, используемый мобильным Safari. `WKWebView`всегда следует использовать над UIWebView, где это возможно из-за повышенной производительности, встроенные в удобные жесты, и простота взаимодействия между веб-страницей и вашим приложением.

`WKWebView`может быть добавлен в приложение практически идентичным образом UIWebView, однако, как разработчик у вас есть гораздо больше контроля над UI / UX и функциональности. Создание и отображение объекта веб-представления будет отображать запрашиваемую страницу, однако вы можете контролировать, как представлено представление, как пользователь может перемещаться и как пользователь выходит из представления.  

Приведенный ниже код может `WKWebView` быть использован для запуска приложения Xamarin.iOS:

```csharp
WKWebView webView = new WKWebView(View.Frame, new WKWebViewConfiguration());
View.AddSubview(webView);

var url = new NSUrl("https://docs.microsoft.com");
var request = new NSUrlRequest(url);
webView.LoadRequest(request);
```

Важно отметить, что `WKWebView` находится `WebKit` в пространстве имен, так что вам придется добавить это с помощью директивы в верхней части вашего класса.

`WKWebView`также может быть использован в приложениях Xamarin.Mac, и вы должны использовать его, если вы создаете кросс-платформенный Mac/iOS приложение.

Рецепт [Handle JavaScript Alerts](https://github.com/xamarin/recipes/tree/master/Recipes/ios/content_controls/web_view/handle_javascript_alerts) также содержит информацию об использовании WKWebView с Помощью Javascript.

## <a name="sfsafariviewcontroller"></a>SFSafariViewController

 `SFSafariViewController`это последний способ предоставления веб-контента из вашего приложения и доступен в iOS 9 и позже. В `UIWebView` `WKWebView`отличие `SFSafariViewController` от или , является контроллером представления и поэтому не может быть использован с другими представлениями. Вы должны `SFSafariViewController` представить в качестве нового контроллера представления, так же, как вы бы представить любой контроллер представления.

 `SFSafariViewController`по существу является «мини-сафари», которое может быть встроено в ваше приложение. Как и WKWebView, он использует тот же Nitro Javascript Engine, но также предоставляет ряд дополнительных функций Safari, таких как AutoFill, Reader, а также возможность обмена файлами cookie и данными с помощью мобильного Safari. Взаимодействие между пользователем `SFSafariViewController` и приложением недоступно. Ваше приложение не будет иметь доступа ни к одной из функций Safari по умолчанию.

Кроме того, по умолчанию она реализует кнопку **«Сделано»,** позволяющую пользователю легко возвращаться в ваше приложение, а также кнопки навигации вперед и назад, позволяя пользователю перемещаться по стопке веб-страниц. Кроме того, он также предоставляет пользователю адресбар, дающий ему душевное спокойствие, что они находятся на ожидаемой веб-странице. Адресная панель не позволяет пользователю изменить URL.

Эти реализации не могут `SFSafariViewController` быть изменены, поэтому идеально подходит для использования в качестве браузера по умолчанию, если ваше приложение хочет представить веб-страницу без какой-либо настройки.

Приведенный ниже код может `SFSafariViewController` быть использован для запуска приложения Xamarin.iOS:

```csharp
var sfViewController = new SFSafariViewController(url);

PresentViewController(sfViewController, true, null);
```

Это создает следующий веб-вид:

[![Пример веб-просмотра с SFSafariViewController](webview-images/sfsafariviewcontroller.png)](webview-images/sfsafariviewcontroller.png#lightbox)

## <a name="safari"></a>Safari

Кроме того, можно открыть мобильное приложение Safari из вашего приложения, используя приведенный ниже код:

```csharp
var url = new NSUrl("https://docs.microsoft.com");

UIApplication.SharedApplication.OpenUrl(url);
```

Это создает следующий веб-вид:

[![Веб-страница, представленная в Safari](webview-images/safari.png)](webview-images/safari.png#lightbox)

Как правило, всегда следует избегать перенавки пользователей от приложения к Safari. Большинство пользователей не будут ожидать навигации за пределами приложения, так что если вы переходите от вашего приложения, пользователи могут никогда не вернуть его, по существу убивая участие.

Улучшения iOS 9 позволяют пользователю легко вернуться в ваше приложение через кнопку «Назад», которая предоставляется в верхнем левом углу страницы Safari.

## <a name="app-transport-security"></a>Защита транспорта приложения

App Transport Security, или *ATS,* был представлен Apple в iOS 9, чтобы гарантировать, что все интернет-коммуникации соответствуют передовым методам безопасного подключения.

Для получения дополнительной информации о ATS, в том числе о том, как реализовать ее в приложении, обратитесь к руководству [по безопасности транспорта приложения.](~/ios/app-fundamentals/ats.md)

## <a name="uiwebview-deprecation"></a>UIWebView амортизацию

`UIWebView`это устаревший способ Apple предоставления веб-контента в вашем приложении. Он был выпущен в iOS 2.0, и был унес едек 8.0.

> [!IMPORTANT]
> `UIWebView` не рекомендуется к использованию. Новые приложения, использующие этот элемент управления, [не будут приняты в App Store с апреля 2020 года, а обновления приложений с использованием этого элемента не будут приняты к декабрю 2020 года.](https://developer.apple.com/news/?id=12232019b)
>
> [Документация `UIWebView` Apple](https://developer.apple.com/documentation/uikit/uiwebview) предполагает, [`WKWebView`](#wkwebview) что вместо этого приложения должны использоваться.
>
> Если при использовании Xamarin.Forms вы ищете ресурсы касательно предупреждения об устаревании `UIWebView`UIWebView (ITMS-90809), ознакомьтесь с документацией по [Xamarin.Forms WebView](~/xamarin-forms/user-interface/webview.md#uiwebview-deprecation-and-app-store-rejection-itms-90809).

Разработчики, которые представили приложения для iOS в течение последних шести месяцев `UIWebView` (или около того), возможно, получили предупреждение от App Store, о том, что их утилизют.

Обесценивания AIS являются общими. Xamarin.iOS использует пользовательские атрибуты, чтобы сигнализировать эти AI (и предлагать замены, когда это возможно) обратно к разработчикам. Что отличается на этот раз, и гораздо реже, является то, что износ **будет осуществляться** Apple App Store во время представления.

К сожалению, `UIWebView` удаление `Xamarin.iOS.dll` типа из [двоичного изменения.](https://docs.microsoft.com/dotnet/core/compatibility/categories#binary-compatibility) Это изменение сломает существующие библиотеки сторон, в том числе те, которые могут больше не поддерживаться или даже пересоставлять (например, закрытый источник). Это только создаст дополнительные проблемы для разработчиков. Таким образом, мы не удаляем тип *еще*.

Начиная с [Xamarin.iOS 13.16](https://docs.microsoft.com/xamarin/ios/release-notes/13/13.16) доступны новые обнаружения `UIWebView`и инструменты, чтобы помочь вам мигрировать из .

### <a name="detection"></a>Обнаружение

Если вы недавно отправили заявку на iOS в Apple App Store, вы можете задаться вопросом, применима ли эта ситуация к вашему приложению(ы).

Чтобы узнать это, `--warn-on-type-ref=UIKit.UIWebView` вы можете добавить в **аргументы вашего проекта Дополнительные mtouch.** Это предупредит о **любых** ссылках `UIWebView` на унипраженные внутри приложения (и все его зависимости). Различные предупреждения используются для сообщения типов **до** и **после** выполнения управляемого связующая система.

Предупреждения, как и другие, могут `-warnaserror:`быть превращены в ошибки с помощью. Это может быть полезно, если вы хотите, чтобы новая зависимость не была добавлена `UIWebView` после проверки. Пример:

* `-warnaserror:1502`сообщит об ошибках, если какие-либо ссылки будут найдены в предварительно связанных собраниях.
* `-warnaserror:1503`сообщит об ошибках, если какие-либо ссылки будут найдены в сборках, связанных с ней.

Вы также можете заставить замолчать предупреждения, если либо предварительные / пост ссылки результаты не являются полезными. Пример:

* `-nowarn:1502`**не** будет сообщать о предупреждениях, если какие-либо ссылки обнаружены в предварительно связанных сборках.
* `-nowarn:1503`**не** будет сообщать о предупреждениях, если какие-либо ссылки обнаружены в сборных после ссылки.

### <a name="removal"></a>Удаление

Каждое приложение уникально. Удаление `UIWebView` из приложения может потребовать различных шагов в зависимости от того, как и где оно используется. Наиболее распространенные сценарии:

- Внутри приложения нет `UIWebView` использования. Все в порядке. Вы **не** должны иметь предупреждения при отправке в AppStore. Больше от вас ничего не требуется.
- Прямое `UIWebView` использование приложения. Начните с удаления `UIWebView`использования, например, заменить `WKWebView` его на новые `SFSafariViewController` (iOS 8) или (iOS 9) типов. Как только это будет завершено управляемый `UIWebView` linker не должен видеть какой-либо ссылки на и окончательное приложение двоичный не будет иметь никаких следов его.
- Косвенное использование. `UIWebView`может присутствовать в некоторых библиотеках третьих сторон, управляемых или родных, которые используются вашим приложением. Начните с обновления внешних зависимостей к их последним версиям, так как эта ситуация уже может быть решена в новом выпуске. Если нет, обратитесь к сопровождающему (ы) библиотек и спросите об их планах обновления.

Кроме того, можно попробовать следующие подходы:

1. Если вы используете **Xamarin.Forms**, а затем читать этот [блог](https://devblogs.microsoft.com/xamarin/uiwebview-deprecation-xamarin-forms/).
1. Включите управляемый связующий (по всему проекту или, `UIWebView`по крайней мере, на использование зависимости), чтобы он *мог* быть удален, если не упоминается. Это решит проблему, но может потребовать дополнительной работы, чтобы сделать ваш код linker безопасным.
1. Если вы не можете изменить настройки управляемого связующим звеном, см.

#### <a name="applications-cannot-use-the-linker-or-change-its-settings"></a>Приложения не могут использовать ссылку (или изменить его настройки)

Если по какой-то причине вы **не** используете управляемый связующий (например, не связывайте), то **Don't link** `UIWebView` символ останется в бинарном приложении, вы отправляете его в Apple, и он может быть отклонен.

*Силовое* решение заключается `--optimize=force-rejected-types-removal` в том, чтобы добавить к **дополнительным аргументам mtouch**вашего проекта. Это удалит `UIWebView` следы из приложения. Однако любой код, относящик типа, **не** будет работать должным образом (ожидайте исключения или сбои). Этот подход следует использовать только в том случае, если вы уверены, что код недоступен во время выполнения (даже если он был доступен с помощью статического анализа).

#### <a name="support-for-ios-7x-or-earlier"></a>Поддержка iOS 7.x (или раньше)

`UIWebView`является частью iOS с v2.0. Наиболее распространенными `WKWebView` заменами являются `SFSafariViewController` (iOS 8) и (iOS 9). Если приложение по-прежнему поддерживает старые версии iOS, следует рассмотреть следующие варианты:

* Сделайте iOS 8 минимальной целевой версией (решение по времени сборки).
* Использовать `WKWebView` только в том случае, если приложение работает на iOS 8 "(решение о времени выполнения).

#### <a name="applications-not-submitted-to-apple"></a>Заявки, не поданные в Apple

Если ваше приложение не отправлено в Apple, вы должны запланировать отойти от упраздненных API, поскольку он может быть удален в будущих релизах iOS. Тем не менее, вы можете сделать этот переход, используя свой собственный график.

## <a name="related-links"></a>Связанные ссылки

- [Веб-просмотры (образец)](https://docs.microsoft.com/samples/xamarin/ios-samples/webview)
