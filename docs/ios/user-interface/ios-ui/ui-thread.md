---
title: Работа с потоком пользовательского интерфейса
ms.prod: xamarin
ms.assetid: 98762ACA-AD5A-4E1E-A536-7AF3BE36D77E
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/21/2017
ms.openlocfilehash: 72f161001509519fb02a652f23eaa7805a55f7ca
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/04/2018
---
# <a name="working-with-the-ui-thread"></a>Работа с потоком пользовательского интерфейса

Пользовательского интерфейса приложений всегда являются однопоточными, даже в многопоточных устройств — имеется только одно представление для экрана и любые изменения отображаемых необходимо согласовывать через один «точки доступа». Это предотвращает попытки обновления одного пикселя в то же время, к примеру, нескольких потоков.

Код следует добавлять только поток изменения пользовательского интерфейса элементов управления из главного (или пользовательского интерфейса). Все обновления пользовательского интерфейса, которые происходят в другом потоке (например, обратный вызов или фоновый поток) не может получить выведено на экран или даже привести к сбою.

## <a name="ui-thread-execution"></a>Выполнение потока пользовательского интерфейса

При создании элементов управления в представлении, или обработка события, инициированного пользователем, например сенсорный ввод, уже выполняется код в контексте потока пользовательского интерфейса.

Если код выполняется в фоновом потоке, в задаче или обратный вызов будет скорее всего, не сможет выполняться в основном потоке пользовательского интерфейса. В этом случае следует заключить код в вызов `InvokeOnMainThread` или `BeginInvokeOnMainThread` следующим образом:

```csharp
InvokeOnMainThread ( () => {
    // manipulate UI controls
});
```

`InvokeOnMainThread` Метод определяется для `NSObject` , его можно вызвать из методов, определенных в любом объекте UIKit (например, представление или View Controller).

Во время отладки приложения Xamarin.iOS, ошибка возникает, когда код пытается обратиться к элемента управления пользовательского интерфейса из неверного потока. Это помогает отследить и устранить проблемы с помощью метода InvokeOnMainThread. Это только во время отладки и не вызывает ошибку в сборках выпуска. Сообщение об ошибке будет отображаться следующим образом:

 ![](ui-thread-images/image10.png "Выполнение потока пользовательского интерфейса")

 <a name="Background_Thread_Example" />


## <a name="background-thread-example"></a>Пример фонового потока

Ниже приведен пример, который пытается получить доступ к элементу управления пользовательского интерфейса ( `UILabel`) из фонового потока с помощью простого потока:

```csharp
new System.Threading.Thread(new System.Threading.ThreadStart(() => {
    label1.Text = "updated in thread"; // should NOT reference UILabel on background thread!
})).Start();
```

Код создаст исключение `UIKitThreadAccessException` во время отладки. Чтобы устранить проблему и убедитесь, что элемента управления пользовательского интерфейса осуществляется только из основного потока пользовательского интерфейса, заключите любой код, который ссылается на элементы управления пользовательского интерфейса внутри `InvokeOnMainThread` выражение следующим образом:

```csharp
new System.Threading.Thread(new System.Threading.ThreadStart(() => {
    InvokeOnMainThread (() => {
        label1.Text = "updated in thread"; // this works!
    });
})).Start();
```

Не требуется сделать далее в примерах в этом документе, но это важная концепция запомнить, когда приложение выполняет запросы сети, используйте использует Центр уведомлений или других методов, которые требуют выполнения обработчик, который будет выполняться на другом поток.

 <a name="Async_Await_Example" />


## <a name="asyncawait-example"></a>Пример ASYNC/Await

При использовании ключевых слов async и await ключевые слова C# 5 `InvokeOnMainThread` не требуется, так как после завершения выполнения ожидающей задачи метод переходит в вызывающем потоке.

В этом примере кода (которая ожидает на вызов метода задержки исключительно для демонстрационных целей) показывает асинхронный метод, который вызывается в потоке пользовательского интерфейса (это обработчик TouchUpInside). Так как содержащий метод вызывается в потоке пользовательского интерфейса, пользовательского интерфейса операции, такие как задания текста на `UILabel` или отображение `UIAlertView` может быть вызван после завершения асинхронных операций в фоновых потоках.

```csharp
async partial void button2_TouchUpInside (UIButton sender)
{
    textfield1.ResignFirstResponder ();
    textfield2.ResignFirstResponder ();
    textview1.ResignFirstResponder ();
    label1.Text = "async method started";
    await Task.Delay(1000); // example purpose only
    label1.Text = "1 second passed";
    await Task.Delay(2000);
    label1.Text = "2 more seconds passed";
    await Task.Delay(1000);
    new UIAlertView("Async method complete", "This method", 
               null, "Cancel", null)
        .Show();
    label1.Text = "async method completed";
}
```

Если асинхронный метод вызывается в фоновом потоке (не основной поток пользовательского интерфейса) затем `InvokeOnMainThread` по-прежнему не требуются.


## <a name="related-links"></a>Связанные ссылки

- [Элементы управления (пример)](https://developer.xamarin.com/samples/Controls/)
- [Работа с потоками](~/ios/app-fundamentals/threading.md)
