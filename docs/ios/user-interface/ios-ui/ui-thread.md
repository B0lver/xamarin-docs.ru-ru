---
title: Работа с потоком пользовательского интерфейса в Xamarin.iOS
description: В этом документе описывается, как работать с потока пользовательского интерфейса в Xamarin.iOS. Описывает выполнение потока пользовательского интерфейса, пример фонового потока и проверяет async/await.
ms.prod: xamarin
ms.assetid: 98762ACA-AD5A-4E1E-A536-7AF3BE36D77E
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/21/2017
ms.openlocfilehash: e4485c485b708bdec06f7f1dc22f0bf33e07e982
ms.sourcegitcommit: 2eb8961dd7e2a3e06183923adab6e73ecb38a17f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/11/2019
ms.locfileid: "66827741"
---
# <a name="working-with-the-ui-thread-in-xamarinios"></a>Работа с потоком пользовательского интерфейса в Xamarin.iOS

Пользовательских интерфейсов приложений всегда являются однопоточными, даже в многопоточных устройств — имеется только одно представление для экрана и любые изменения отображаемых необходимо согласовать через один «точки доступа». Благодаря этому несколько потоков пытаются обновить же пикселу в то же время (например).

Код следует добавлять только поток изменений в элементы управления интерфейса из главного пользователя (или пользовательского интерфейса). Обновления интерфейса пользователя, которые происходят в другом потоке (например, обратный вызов или фоновый поток) не может получить отображен на экране, или даже может привести к сбою.

## <a name="ui-thread-execution"></a>Выполнение потока пользовательского интерфейса

При создании элементов управления в представлении, или обработка инициированного пользователем события, такие как сенсорного ввода, код выполняется в контексте потока пользовательского интерфейса.

Если код выполняется в фоновом потоке, в задачу или обратный вызов будет скорее всего, не выполняется в основном потоке пользовательского интерфейса. В этом случае необходимо заключить код при вызове `InvokeOnMainThread` или `BeginInvokeOnMainThread` следующим образом:

```csharp
InvokeOnMainThread ( () => {
    // manipulate UI controls
});
```

`InvokeOnMainThread` Метод определяется для `NSObject` , его можно вызвать из методов, определенных для любого объекта UIKit (например, представления или контроллера представления).

Во время отладки приложений Xamarin.iOS, ошибка возникает, если код пытается получить доступ к элемент управления пользовательского интерфейса из неправильного потока. Это поможет вам отследить и устранить проблемы с помощью метода InvokeOnMainThread. Это только происходит во время отладки и вызывает ошибку в сборках выпуска. Сообщение об ошибке будет выглядеть следующим образом:

 ![](ui-thread-images/image10.png "Выполнение потока пользовательского интерфейса")

 <a name="Background_Thread_Example" />


## <a name="background-thread-example"></a>Пример фонового потока

Ниже приведен пример, который пытается получить доступ к элементу управления пользовательского интерфейса ( `UILabel`) из фонового потока с использованием простого потока:

```csharp
new System.Threading.Thread(new System.Threading.ThreadStart(() => {
    label1.Text = "updated in thread"; // should NOT reference UILabel on background thread!
})).Start();
```

Что будет генерировать код `UIKitThreadAccessException` во время отладки. Чтобы устранить проблему (и убедитесь, что интерфейс пользовательского элемента управления осуществляется только из основного потока пользовательского интерфейса), заключите любой код, который ссылается на элементы управления пользовательского интерфейса внутри `InvokeOnMainThread` выражение следующим образом:

```csharp
new System.Threading.Thread(new System.Threading.ThreadStart(() => {
    InvokeOnMainThread (() => {
        label1.Text = "updated in thread"; // this works!
    });
})).Start();
```

Не нужно будет использовать это далее в примерах в этом документе, но он является очень важным понятием, которое следует помнить, если приложение выполняет сетевые запросы, использует Центр уведомлений или других методов, которые требуют завершения обработчик, который будет выполняться на другом поток.

 <a name="Async_Await_Example" />


## <a name="asyncawait-example"></a>Пример ASYNC/Await

При использовании C# 5 ключевых слов async/await `InvokeOnMainThread` является не обязательным, поскольку при завершении ожидаемая задача метод продолжает в вызывающем потоке.

Этот пример кода (который ожидает завершения при вызове метода задержки, исключительно для демонстрационных целей) показан асинхронный метод, который вызывается в потоке пользовательского интерфейса (это обработчик TouchUpInside). Поскольку содержащего метода вызывается в потоке пользовательского интерфейса, операций пользовательского интерфейса, такие как задания текста на `UILabel` или отображение `UIAlertView` может быть вызван после завершения асинхронных операций в фоновых потоках.

```csharp
async partial void button2_TouchUpInside (UIButton sender)
{
    textfield1.ResignFirstResponder ();
    textfield2.ResignFirstResponder ();
    textview1.ResignFirstResponder ();
    label1.Text = "async method started";
    await Task.Delay(1000); // example purpose only
    label1.Text = "1 second passed";
    await Task.Delay(2000);
    label1.Text = "2 more seconds passed";
    await Task.Delay(1000);
    new UIAlertView("Async method complete", "This method", 
               null, "Cancel", null)
        .Show();
    label1.Text = "async method completed";
}
```

Если асинхронный метод вызывается из фонового потока (не основной поток ИП) затем `InvokeOnMainThread` по-прежнему не требуются.


## <a name="related-links"></a>Связанные ссылки

- [Элементы управления (пример)](https://developer.xamarin.com/samples/monotouch/Controls/)
- [Работа с потоками](~/ios/app-fundamentals/threading.md)
