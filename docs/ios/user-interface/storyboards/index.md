---
title: Общие сведения о раскадровках в Xamarin. iOS
description: В этом документе содержатся общие сведения о раскадровках в Xamarin. iOS. Здесь описывается, как раскадровка используется для определения пользовательского интерфейса, переходов и использования конструктора iOS для изменения файлов раскадровки.
ms.prod: xamarin
ms.assetid: A3339BD2-9F56-7965-25F5-4B7C991EB775
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/22/2017
ms.openlocfilehash: b0cd3e7c851aed6f178069497665b88c1338b36b
ms.sourcegitcommit: dde593cf9dedf4a056ffef86bcf2fa0640412a4d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/28/2020
ms.locfileid: "76794746"
---
# <a name="introduction-to-storyboards-in-xamarinios"></a>Общие сведения о раскадровках в Xamarin. iOS

В этом пошаговом окне мы объясним, что такое раскадровка, и рассмотрим некоторые ключевые компоненты, например переходов. Мы рассмотрим, как можно создавать и использовать раскадровки и какие преимущества они имеют для разработчика.

Прежде чем формат файла раскадровки появился в Apple как визуальное представление пользовательского интерфейса приложения iOS, разработчики создали файлы XIB для каждого контроллера представления и запустили навигацию между представлениями вручную.  Использование раскадровки позволяет разработчику определять как контроллеры представлений, так и навигацию между ними в области конструктора и обеспечивает редактирование пользовательского интерфейса приложения в режиме WYSIWYG.

Раскадровку можно создать, открыть и изменить с помощью конструктора Xamarin iOS. В этом руководстве также приводится пошаговое руководство по созданию раскадровок с помощью C# конструктора для программирования навигации.

## <a name="requirements"></a>Требования

Раскадровки можно использовать с Xcode, конструктором iOS в Visual Studio для Mac и Visual Studio 2019 с установленными рабочими нагрузками Xamarin.

## <a name="what-is-a-storyboard"></a>Что такое раскадровка?

Раскадровка — это визуальное представление всех экранов в приложении. Он содержит последовательность сцен, где каждая сцена представляет *контроллер представления* и его *представления*. Эти представления могут содержать объекты и [элементы управления](~/ios/user-interface/controls/index.md) , позволяющие пользователю взаимодействовать с приложением. Эта коллекция представлений и элементов управления (или вложенных *представлений*) называется *иерархией представления содержимого*. Сцены соединяются объектами перехода, которые представляют переход между контроллерами представления. Обычно это достигается путем создания перехода между объектом в первоначальном представлении и представлением соединения. Связи в области конструктора показаны на рисунке ниже.

 [![](images/storyboardsview.png "The relationships on the design surface are illustrated in this image")](images/storyboardsview.png#lightbox)

Как видно, раскадровка будет размещаться в каждом из сцен с уже подготовленным содержимым и показывает соединения между ними.  На этом этапе стоит отметить, что при разговоре о сценах на iPhone можно считать, что одна *сцена* на раскадровке равна одному *экрану* содержимого на устройстве. Однако на iPad может отображаться несколько сцен, например с помощью контроллера представления контекстном меню Action.

Использование раскадровки дает множество преимуществ для создания пользовательского интерфейса приложения, особенно при использовании Xamarin. Во-первых, это визуальное представление пользовательского интерфейса, так как все объекты, включая [пользовательские элементы управления](~/ios/user-interface/designer/ios-designable-controls-overview.md) , подготавливаются во время разработки.
Это означает, что перед сборкой или развертыванием приложения можно визуализировать его внешний вид и последовательность. Возьмем приведенный выше образ, например. В области конструктора можно узнать, сколько сцен есть, макет каждого представления и как все связано. Это делает раскадровки настолько мощными.

События более управляемы с помощью раскадровок, особенно при использовании конструктора iOS. Большинство элементов управления пользовательского интерфейса будут иметь список возможных событий в Панель свойств. Обработчик событий можно добавить сюда и выполнить в разделяемом методе класса View Controllers.

Содержимое раскадровки хранится в виде XML-файла. Во время сборки все `.storyboard` файлы компилируются в двоичные файлы, известные как нибс. Во время выполнения эти нибс инициализируются и создаются с созданием экземпляров для создания новых представлений.

## <a name="segues"></a>Переходов

Объект *перехода*или *перехода*используется в разработке iOS для представления перехода между сценами. Чтобы создать перехода, удерживайте нажатой клавишу **CTRL** и перетащите ее с одной сцены на другую. По мере перетаскивания мыши появляется синий соединитель, указывающий, где перехода будет выглядеть, как показано на рисунке ниже:

 [![](images/createsegue.png "A blue connector appears, indicating where the segue will lead as demonstrated in this image")](images/createsegue.png#lightbox)

При наведении указателя мыши появится меню, позволяющее выбрать действие для нашего перехода. Он может выглядеть примерно так:

**Pre-iOS 8 и классы размера**

[![](images/segue1.png "The Action Segue dropdown without Size Classes")](images/segue1.png#lightbox)

**При использовании классов размера и адаптивных сегментов**

[![](images/16new.png "The Action Segue dropdown with Size Classes")](images/16new.png#lightbox)

> [!IMPORTANT]
> Если вы используете VMWare для виртуальной машины Windows, при нажатии _кнопки мыши по умолчанию отображается_ нажатие клавиши CTRL. Чтобы создать перехода, измените настройки клавиатуры, используя **настройки** > **клавиатуры & мыши** > **клавишами мыши** и повторного сопоставления **дополнительной кнопки** , как показано ниже:
>
> [![](images/image22.png "Keyboard and Mouse preference settings")](images/image22.png#lightbox)
>
> Теперь вы можете добавить перехода между контроллерами представления как обычно.

Существуют различные типы переходов, каждый из которых обеспечивает контроль над представлением нового контроллера представления пользователю и тем, как он взаимодействует с другими контроллерами представления в раскадровке. Они описаны ниже. Также можно создать подкласс для объекта перехода, чтобы реализовать пользовательский переход:

- **Показать/отправить** — Push-перехода добавляет контроллер представления в стек навигации. Предполагается, что контроллер представления, исходящий из отправки push, является частью того же контроллера навигации, что и контроллер представления, добавляемый в стек. Это делает то же самое, что и `pushViewController`, и обычно используется при наличии некоторой связи между данными на экранах. Использование push перехода дает вам Люкс с панелью навигации с кнопкой "назад" и заголовком, добавленными в каждое представление в стеке, что позволяет детализировать навигацию по иерархии представлений.
- **Модальный** — модальный перехода создает связь между любыми двумя контроллерами представления в проекте с возможностью отображения анимированного перехода. Контроллер дочернего представления будет полностью скрывать родительский контроллер представления при просмотре. В отличие от Push перехода, которая добавляет кнопку назад для нас; При использовании модального перехода для возврата к предыдущему контроллеру представления необходимо использовать `DismissViewController`.
- **Custom** — любой пользовательский перехода можно создать как подкласс `UIStoryboardSegue`.
- **Очистка** — перехода очистки можно использовать для перехода по Push-или модальным перехода, например путем закрытия модального контроллера представления. Помимо этого, вы можете очистить не только одну, но и серию push-и модальных переходов, а также выполнить несколько шагов в иерархии навигации с одним действием очистки. Чтобы понять, как использовать перехода очистки в iOS, прочитайте статью создание рецепта [очистки переходов](https://github.com/xamarin/recipes/tree/master/Recipes/ios/general/storyboard/unwind_segue) .
- Без **исходного кода** — перехода без исходного кода указывает на сцену, содержащую исходный контроллер представления, и поэтому представление, которое пользователь увидит первым. Он представлен перехода, показанным ниже.  

    [![](images/sourcelesssegue.png "A sourceless segue")](images/sourcelesssegue.png#lightbox)

### <a name="adaptive-segue-types"></a>Адаптивные типы перехода

 в iOS 8 появились [классы размера](~/ios/user-interface/storyboards/unified-storyboards.md#size-classes) , позволяющие файлу раскадровки iOS работать со всеми доступными размерами экрана, что позволяет разработчикам создавать один пользовательский интерфейс для всех устройств iOS. По умолчанию все новые приложения Xamarin. iOS будут использовать классы размера. Чтобы использовать классы размеров из более старых проектов, ознакомьтесь с руководством [Введение в унифицированные раскадровки](~/ios/user-interface/storyboards/unified-storyboards.md) .

В любом приложении, использующем классы размера, также будет использоваться новое [*Адаптивное переходов*](~/ios/user-interface/storyboards/unified-storyboards.md). При использовании классов размера Помните, что мы не указываем Весер напрямую, мы используем iPhone или iPad. Другими словами, мы создаем один пользовательский интерфейс, который всегда будет выглядеть одинаково, независимо от того, насколько реально он должен работать. Адаптивное переходов работает, судя среду и определяя, как лучше представлять содержимое. Ниже приведены адаптивные переходов.

[![](images/adaptivesegue.png "The Adaptive Segues dropdown")](images/adaptivesegue.png#lightbox)

|Перехода|Описание|
|--- |--- |
|Показать|Это очень похоже на Push-перехода, но оно принимает содержимое экрана в учетную запись.|
|Отобразить подробности|Если приложение отображает главное и подробное представление (например, в контроллере с разделением представлений на iPad), содержимое заменит подробное представление. Если приложение отображает только основные сведения или подробности, содержимое будет заменено верхней частью стека контроллера представления.|
|Presentation|Это похоже на модальный перехода и позволяет выбирать стили представления и перехода.|
|Контекстном меню Action презентацию|Это содержимое представлено как контекстном меню Action|

### <a name="transferring-data-with-segues"></a>Передача данных с помощью переходов

Преимущества перехода не заканчиваются переходами. Они также могут использоваться для управления переносом данных между контроллерами представления. Это достигается путем переопределения метода `PrepareForSegue` на начальном контроллере представления и обработки самих данных. При активации перехода (например, при нажатии кнопки) приложение вызывает этот метод, предоставляя возможность подготовить новый контроллер представления *перед* переходом. В коде, приведенном ниже, из примера [Phoneword](https://docs.microsoft.com/samples/xamarin/ios-samples/hello-ios) демонстрируется следующее:

```csharp
public override void PrepareForSegue (UIStoryboardSegue segue,
NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    var callHistoryController = segue.DestinationViewController
                                  as CallHistoryController;

    if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
}
```

В этом примере метод `PrepareForSegue` будет вызываться при активации перехода пользователем. Сначала необходимо создать экземпляр контроллера представления "получение" и установить его в качестве контроллера представления назначения перехода. Это делается следующей строкой кода:

```csharp
var callHistoryController = segue.DestinationViewController as CallHistoryController;
```

Теперь метод может устанавливать свойства `DestinationViewController`. В этом примере мы использовали эту возможность, передав список с именем `PhoneNumbers` `CallHistoryController` и назначив его объекту с тем же именем:

```csharp
if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
```

После завершения перехода пользователь увидит `CallHistoryController` с заполненным списком.

## <a name="adding-a-storyboard-to-a-non-storyboard-project"></a>Добавление раскадровки в проект, не являющийся раскадровкой

Иногда может потребоваться добавить раскадровку в ранее не раскадровую файл. Сделав это в Visual Studio для Mac можно упростить, выполнив следующие действия:

# <a name="visual-studio-for-mactabmacos"></a>[Visual Studio для Mac](#tab/macos)

1. Создайте файл раскадровки, перейдя в **файл > новый файл > iOS > Storyboard**, как показано ниже:

    [![](images/new-storyboard-xs.png "The new file dialog")](images/new-storyboard-xs.png#lightbox)

2. Добавьте имя раскадровки в раздел **Main интерфейса** файла **info. plist**, как показано ниже.

    [![](images/infoplist.png "The Info.plist editor")](images/infoplist.png#lightbox)

    Это эквивалентно созданию экземпляра исходного контроллера представления в методе `FinishedLaunching` в делегате приложения. Если этот параметр установлен, приложение создает экземпляр окна (см. ниже), загружает основную раскадровку и назначает экземпляр исходного контроллера представления раскадровки (рядом с перехода без источника) в качестве свойства `RootViewController` окна, а затем делает окно видимым на экране.

3. В `AppDelegate`Переопределите метод `Window` по умолчанию, дополнив следующий код, чтобы реализовать свойство Window:

    ```csharp
    public override UIWindow Window {
        get;
        set;
    }
    ```

# <a name="visual-studiotabwindows"></a>[Visual Studio](#tab/windows)

1. Создайте файл раскадровки, щелкнув правой кнопкой мыши проект, чтобы **добавить > новый файл > iOS > пустую раскадровку**, как показано ниже:

    [![](images/new-storyboard-vs.png "The new item dialog")](images/new-storyboard-vs.png#lightbox)

2. Добавьте имя раскадровки в раздел **главного интерфейса** приложения iOS, как показано ниже.

    [![](images/ios-app.png "The Info.plist editor")](images/ios-app.png#lightbox)

    Это эквивалентно созданию экземпляра исходного контроллера представления в методе `FinishedLaunching` в делегате приложения. Если этот параметр установлен, приложение создает экземпляр окна (см. ниже), загружает основную раскадровку и назначает экземпляр исходного контроллера представления раскадровки (рядом с перехода без источника) в качестве свойства `RootViewController` окна, а затем делает окно видимым на экране.

3. В `AppDelegate`Переопределите метод `Window` по умолчанию, дополнив следующий код, чтобы реализовать свойство Window:

    ```csharp
    public override UIWindow Window {
        get;
        set;
    }
    ```

-----

## <a name="creating-a-storyboard-with-xcode"></a>Создание раскадровки с помощью Xcode

Раскадровку можно создать и изменить с помощью Xcode для использования в приложениях iOS, разработанных с помощью Visual Studio для Mac.

Раскадровки полностью заменяют отдельные файлы XIB в проекте, однако отдельные контроллеры представлений в раскадровке можно по-прежнему создавать с помощью `Storyboard.InstantiateViewController`.

Иногда приложения имеют особые требования, которые не могут быть обработаны с помощью встроенных переходов раскадровки, предоставляемых конструктором. Например, если бы мы создавали приложение, которое запускает различные экраны из одной кнопки, в зависимости от текущего состояния приложения, возможно, потребуется создать экземпляры контроллеров представлений вручную и программировать сам переход.

На снимке экрана ниже показаны два контроллера представления в области конструктора без перехода между ними. В следующем разделе будет рассмотрено, как можно настроить этот переход в коде.

1. Добавить _пустую раскадровку iPhone_ в существующий проект проекта:

    [![](images/add-storyboard2.png "Adding storyboard")](images/add-storyboard2.png#lightbox)

2. Щелкните файл раскадровки правой кнопкой мыши и выберите пункт **Открыть с помощью > Xcode Interface Builder** , чтобы открыть его в Xcode.

3. В Xcode Откройте библиотеку (с помощью **представления > Показать библиотеку** или *Shift + Command + L*), чтобы отобразить список объектов, которые можно добавить в раскадровку. Добавьте `Navigation Controller` в раскадровку, перетащив объект из списка на раскадровку. По умолчанию `Navigation Controller` предоставит два экрана; экран справа является `TableViewController`, который мы будем заменять более простым представлением, поэтому его можно удалить, щелкнув представление и нажав клавишу DELETE.

    [![](images/add-navigation-controller.png "Adding a NavigationController from the Library")](images/add-navigation-controller.png#lightbox)

4. Этот контроллер представления будет иметь собственный пользовательский класс, а также должен иметь собственный идентификатор раскадровки. Если щелкнуть поле над только что добавленным представлением, появится три значка, крайний левый из которых представляет контроллер представления для представления. Выбрав этот значок, можно задать значения класса и идентификатора на вкладке удостоверение на правой панели. Задайте для этих значений значение `MainViewController` и убедитесь, что `Use Storyboard ID`.

    [![](images/identity-panel.png "Setting the MainViewController in the identity panel")](images/identity-panel.png#lightbox)

5. Снова с помощью библиотеки перетащите контроллер представления на экран. Он будет установлен в качестве контроллера корневого представления. Нажимая клавишу Control, щелкните и перетащите значок из контроллера навигации слева к добавленному контроллеру представления справа и выберите в меню пункт *контроллер корневого представления* .

    [![](images/add-view-controller.png "Adding a NavigationController from the Library and setting the MainViewController as a Root View Controller")](images/add-view-controller.png#lightbox)

6. Это приложение будет переходить к другому представлению, поэтому добавьте еще одно представление в раскадровку, как и раньше. Мы вызываем этот `PinkViewController`, и эти значения можно задать так же, как и в `MainViewController`.

    [![](images/add-additional-view-controller.png "Adding an additional View Controller")](images/add-additional-view-controller.png#lightbox)

7. Так как контроллер представления будет иметь розовый фон, это свойство можно задать на панели Атрибуты, используя раскрывающийся список рядом с `Background`.

    [![](images/set-pink-background.png "Adding an additional View Controller")](images/set-pink-background.png#lightbox)

8. Так как нам требуется, чтобы `MainViewController` переходить к `PinkViewController`, для первого из них потребуется кнопка для взаимодействия с. С помощью библиотеки мы можем добавить кнопку в `MainViewController`.

    [![](images/add-button.png "Adding a Button to the MainViewController")](images/add-button.png#lightbox)

Раскадровка завершена, но если развернуть проект сейчас, будет выведен пустой экран. Это связано с тем, что нам по-прежнему нужно сообщить интегрированной среде разработки использовать нашу раскадровку и настроить корневой контроллер представления, который будет служить первым представлением. Обычно это можно сделать с помощью наших параметров проекта, как показано выше. Однако в этом примере мы добавим тот же результат в коде, добавив следующий код в **AppDelegate**:

```csharp
public partial class AppDelegate : UIApplicationDelegate
{
    UIWindow window;
    public static UIStoryboard Storyboard = UIStoryboard.FromName ("MainStoryboard", null);
    public static UIViewController initialViewController;

    public override bool FinishedLaunching (UIApplication app, NSDictionary options)
    {
        window = new UIWindow (UIScreen.MainScreen.Bounds);

        initialViewController = Storyboard.InstantiateInitialViewController () as UIViewController;

        window.RootViewController = initialViewController;
        window.AddSubview(initialViewController.View);
        window.MakeKeyAndVisible ();
        return true;
    }
}
```

Это большой объем кода, но незнакомо всего несколько строк. Сначала мы регистрируем нашу раскадровку с помощью **AppDelegate** , передав имя раскадровки **файл mainstoryboard**. Далее мы говорим приложению создать экземпляр исходного контроллера представления из раскадровки, вызвав `InstantiateInitialViewController` в раскадровке, и мы установили этот контроллер представления в качестве корневого контроллера представления приложения. Этот метод определяет первый экран, который видит пользователь, и создает новый экземпляр этого контроллера представления.

Обратите внимание, что в области решения в интегрированной среде разработки был создан `MainViewcontroller.cs` класс, и его `corresponding designer.cs` при добавлении имени класса в Панель свойств на шаге 4. Этот класс можно увидеть, создав специальный конструктор, включающий базовый класс:

```csharp
public MainViewController (IntPtr handle) : base (handle)
{
}
```

При создании раскадровки с помощью Xcode интегрированная среда разработки автоматически добавляет атрибут [[Register]](xref:Foundation.RegisterAttribute) в начало класса `designer.cs` и передает строковый идентификатор, ИДЕНТИЧный идентификатору раскадровки, указанному на предыдущем шаге. Будет выполнена привязка C# к соответствующей сцене в раскадровке.

```csharp
[Register ("MainViewController")]
public partial class MainViewController : UIViewController
{
    public MainViewController (IntPtr handle) : base (handle)
    {
    }
    //...
}
```

Дополнительные сведения о регистрации классов и методов см. в документации [регистратора типов](https://docs.microsoft.com/xamarin/ios/internals/registrar) .

Последний шаг в этом классе — подключить кнопку и переход к контроллеру розового представления. Мы создадим экземпляр `PinkViewController` из раскадровки. Затем мы будем программировать Push-перехода с `PushViewController`, как показано в следующем примере кода:

```csharp
public partial class MainViewController : UIViewController
{
    UIViewController pinkViewController;

    public MainViewController (IntPtr handle) : base (handle)
    {
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        this.Initialize ();
    }

    public void Initialize()
    {
        //Instantiating View Controller with Storyboard ID 'PinkViewController'
        pinkViewController = Storyboard.InstantiateViewController ("PinkViewController") as PinkViewController;
    }

    public override void ViewDidLoad ()
    {
        base.ViewDidLoad ();

        //When we push the button, we will push the pinkViewController onto our current Navigation Stack
        PinkButton.TouchUpInside += (o, e) =&gt;
        {
            this.NavigationController.PushViewController (pinkViewController, true);
        };
    }
}
```

При запуске приложения создается 2-экранное приложение:

![](images/finishedstoryboard.png "Sample app run screens")

## <a name="conditional-segues"></a>Условное переходов

Часто переход с одного контроллера представления на другой зависит от определенного условия. Например, если мы представили простой экран входа, мы хотим перейти на следующий экран, только *Если* имя пользователя и пароль были проверены.

В следующем примере мы добавим поле Password (пароль) в приведенный выше пример. Пользователь сможет получить доступ к *пинквиевконтроллер* только в том случае, если он введет правильный пароль, в противном случае появится сообщение об ошибке.

Прежде чем начать, выполните шаги 1 – 8 выше. В этих шагах мы создадим нашу раскадровку, начнем с создания пользовательского интерфейса и говорим представителю приложения, какой контроллер представления следует использовать в качестве Рутвиевконтроллер.

1. Теперь создадим пользовательский интерфейс и добавим дополнительные представления, перечисленные в `MainViewController`, чтобы сделать его похожим на приведенный ниже снимок экрана:

    - UITextField
        - Имя: Пассвордтекстфиелд
        - Заполнитель: ' введите пароль для секрета '
    - UILabel
        - Текст: ошибка: неправильный пароль. Вы не должны пройти! '
        - Цвет: красный
        - Выравнивание: по центру
        - Строки: 2
        - Флажок "Hidden" установлен    

    [![](images/passwordvc.png "Center Lines")](images/passwordvc.png#lightbox)

2. Создайте перехода между кнопкой "перейти к розовый" и контроллером представления, удерживая нажатой клавишу CTRL, перетащив *пинкбуттон* в *пинквиевконтроллер*, и выбрав пункт **Push-уведомления** при помощи мыши.

3. Щелкните перехода и присвойте ему *идентификатор* `SegueToPink`:

    [![](images/namesegue.png "Click on the Segue and give it the Identifier SegueToPink")](images/namesegue.png#lightbox)  

4. Наконец, добавьте следующий метод Шаулдперформсегуе в класс `MainViewController`:

    ```csharp
    public override bool ShouldPerformSegue (string segueIdentifier, NSObject sender)
    {

        if(segueIdentifier == "SegueToPink"){
            if (PasswordTextField.Text == "password") {
                PasswordTextField.ResignFirstResponder ();
                return true;
            }
            else{
                ErrorLabel.Hidden = false;
                return false;
            }
        }
        return base.ShouldPerformSegue (segueIdentifier, sender);
    }
    ```

В этом коде мы сосегуеидентифиерся с нашим `SegueToPink` перехода, поэтому мы можем протестировать условие. допустимый пароль в этом случае. Если наше условие возвращает `true`, перехода будет выполнять и будет представлять `PinkViewController`. Если `false`, новый контроллер представления не будет представлен.

Этот подход можно применить к любому перехода в этом контроллере представления, установив значение аргумента Сегуеидентифиер в метод Шаулдперформсегуе. В этом случае у нас есть только один идентификатор перехода — `SegueToPink`.

См. условное решение Storyboard. Conditional в [примере раскадровки вручную](https://docs.microsoft.com/samples/xamarin/ios-samples/manualstoryboard) для рабочего примера.

<a name="Using-Storyboard-References" />

## <a name="using-storyboard-references"></a>Использование ссылок раскадровки

Ссылка на раскадровку позволяет использовать большую, сложную структуру раскадровки и разбивать ее на более мелкие раскадровки, на которые можно ссылаться из оригинала, тем самым удаляя сложность и делая полученные отдельные раскадровки проще в проектировании и обслуживании.

Кроме того, ссылка раскадровки может предоставлять _привязку_ к другой сцене в той же раскадровке или в определенной сцене на другом.

<a name="Referencing-an-External-Storyboard" />

### <a name="referencing-an-external-storyboard"></a>Ссылка на внешнюю раскадровку

Чтобы добавить ссылку на внешнюю раскадровку, выполните следующие действия.

1. В **Обозреватель решений**щелкните правой кнопкой мыши имя проекта и выберите **Добавить** > **новый файл...**  > **iOS** > **Storyboard**. Введите **имя** новой раскадровки и нажмите кнопку " **создать** ":

    [![](images/ref01.png "The New File Dialog")](images/ref01.png#lightbox)

2. Разработайте макет новых сцен раскадровки, как обычно и сохраняйте изменения:

    [![](images/ref02.png "The layout of the new scene")](images/ref02.png#lightbox)

3. Откройте раскадровку, в которой вы будете добавлять ссылку в конструкторе iOS.

4. Перетащите **ссылку раскадровки** из **панели элементов** на область конструктора:

    [![](images/ref03.png "A Storyboard Reference")](images/ref03.png#lightbox)

5. На вкладке **мини** -приложение **обозревателя свойств**выберите имя **раскадровки** , созданной ранее:

    [![](images/ref04.png "The Widget tab")](images/ref04.png#lightbox)

6. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **Ссылки раскадровки** :

    [![](images/ref05.png "Creating a segue")](images/ref05.png#lightbox)

7. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода:

    [![](images/ref06.png "Selecting Show to complete the Segue")](images/ref06.png#lightbox)

8. Сохраните изменения в раскадровке.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного с помощью перехода, будет отображен первоначальный контроллер представления из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-an-External-Storyboard" />

### <a name="referencing-a-specific-scene-in-an-external-storyboard"></a>Ссылка на конкретную сцену во внешней раскадровке

Чтобы добавить ссылку на конкретную сцену, внешняя Раскадровка (а не исходный контроллер представления) выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните внешнюю раскадровку, чтобы открыть ее для редактирования.

2. Добавьте новую сцену и разработайте ее макет, как обычно:

    [![](images/ref07.png "The new scene layout")](images/ref07.png#lightbox)

3. На вкладке **мини** -приложение **ОБОЗРЕВАТЕЛЯ свойств**введите **идентификатор раскадровки** для контроллера представления новой сцены:

    [![](images/ref08.png "Enter a Storyboard ID for the new Scenes View Controller")](images/ref08.png#lightbox)

4. Откройте раскадровку, в которой вы будете добавлять ссылку в конструкторе iOS.

5. Перетащите **ссылку раскадровки** из **панели элементов** на область конструктора:

    [![](images/ref03.png "A Storyboard Reference")](images/ref03.png#lightbox)

6. На вкладке **мини** -приложение **обозревателя свойств**выберите имя **раскадровки** и **идентификатор ссылки** (идентификатор раскадровки) созданной ранее сцены:

    [![](images/ref09.png "The Widget tab ")](images/ref09.png#lightbox)

7. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **Ссылки раскадровки** :

    [![](images/ref10.png "Creating a segue")](images/ref10.png#lightbox)

8. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода:

    [![](images/ref06.png "Selecting Show to complete the Segue")](images/ref06.png#lightbox)

9. Сохраните изменения в раскадровке.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным **идентификатором раскадровки** из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-the-Same-Storyboard" />

### <a name="referencing-a-specific-scene-in-the-same-storyboard"></a>Ссылка на конкретную сцену в той же раскадровке

Чтобы добавить ссылку на определенную сцену в ту же раскадровку, выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните раскадровку, чтобы открыть ее для редактирования.

2. Добавьте новую сцену и разработайте ее макет, как обычно:

    [![](images/ref11.png "The new scene layout")](images/ref11.png#lightbox)

3. На вкладке **мини** -приложение **ОБОЗРЕВАТЕЛЯ свойств**введите **идентификатор раскадровки** для контроллера представления новой сцены:

    [![](images/ref12.png "The Widget tab")](images/ref12.png#lightbox)

4. Перетащите **ссылку раскадровки** из **панели элементов** на область конструктора:

   [![](images/ref03.png "A Storyboard Reference")](images/ref03.png#lightbox)

5. На вкладке **мини** -приложение **ОБОЗРЕВАТЕЛЯ свойств**выберите **идентификатор ссылки** (идентификатор раскадровки) для сцены, созданной ранее.

    [![](images/ref13.png "The Widget tab")](images/ref13.png#lightbox)

6. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **Ссылки раскадровки** :

    [![](images/ref14.png "Creating a segue")](images/ref14.png#lightbox)

7. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода:

    [![](images/ref06.png "Selecting Show to complete the Segue")](images/ref06.png#lightbox)

8. Сохраните изменения в раскадровке.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным **идентификатором** раскадровки в той же раскадровке, которая указана в ссылке раскадровки.

## <a name="summary"></a>Сводка

В этой статье описывается концепция раскадровок и их преимущества при разработке приложений iOS. В нем обсуждаются сцены, контроллеры представлений, представления и иерархии представлений, а также принципы связывания сцен с различными типами переходов.  Кроме того, в нем рассматривается ручное создание экземпляров контроллеров представлений из раскадровки и создание условного переходов.

## <a name="related-links"></a>Связанные ссылки

- [Ручная раскадровка (образец)](https://docs.microsoft.com/samples/xamarin/ios-samples/manualstoryboard/)
- [Введение в iOS Designer](~/ios/user-interface/designer/introduction.md)
- [Преобразование в раскадровки](https://developer.apple.com/library/ios/#releasenotes/Miscellaneous/RN-AdoptingStoryboards/)
- [Справочник по классу UIStoryboard](https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIStoryboard_Class/Reference/Reference.html)
