---
title: "Общие сведения о раскадровки"
description: "Раскадровка — это визуальное представление внешнего вида и потока приложения. Xamarin внес конструктора, чтобы приложения Xamarin.iOS преимуществами раскадровки, что позволяет визуально разработать экране приложения и доступа к представлениям, контроллеры и segues с помощью C# для усиления контроля."
ms.topic: article
ms.prod: xamarin
ms.assetid: A3339BD2-9F56-7965-25F5-4B7C991EB775
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/22/2017
ms.openlocfilehash: 342e8189d9dec6eaa60a999d56a7891da845d247
ms.sourcegitcommit: 30055c534d9caf5dffcfdeafd6f08e666fb870a8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/09/2018
---
# <a name="introduction-to-storyboards"></a>Общие сведения о раскадровки

_Раскадровка - это визуальное представление о внешнем виде и потоке вашего приложения. Xamarin представил дизайнера, позволяющего приложениям Xamarin.iOS использовать раскадровки, чтобы вы могли визуально проектировать экран своего приложения и получать доступ к представлениям, контроллерам и segues с помощью C # для большего контроля._

В этом руководстве объясняется, какие раскадровки — и изучить некоторые из ключевых компонентов — например Segues. Мы рассмотрим как раскадровки можно создать и использовать, и какие преимущества имеют для разработчика.

Перед формат файла раскадровки была введена в Apple, как визуальное представление пользовательского интерфейса приложения iOS, разработчики создали XIB файлы для каждого контроллера представления и программировать навигацию между каждое представление вручную.  С помощью раскадровки позволяет разработчику определить Просмотр контроллеров и переходов между ними в рабочей области конструирования и предлагает WYSIWYG изменения пользовательского интерфейса приложения.

Раскадровка можно создать, открыть и редактировать с помощью Xamarin iOS конструктора. В этом руководстве также будет пошаговом руководстве как использовать конструктор для создания собственных раскадровок при использовании C# для программирования навигации.


## <a name="requirements"></a>Требования

Раскадровки может использоваться с iOS конструктора в Visual Studio для Mac или с Visual Studio 2015 и 2017 г. с Xamarin рабочей нагрузки.

## <a name="what-is-a-storyboard"></a>Что такое раскадровка?

Раскадровка — визуальное представление всех экранов в приложении. Он содержит последовательность сцен каждой сцены, представляющий *View Controller* и его *представления*. Эти представления могут содержать объекты и [элементов управления](~/ios/user-interface/controls/index.md) , будет разрешить пользователям взаимодействовать с приложением. Эта коллекция представления и элементы управления (или *представлений*) называется *содержимого просмотреть иерархию*. Подключенные сцен, перейти на объекты, которые представляют переход между Просмотр контроллеров. Это обычно достигается путем создания segue между объектом на исходное представление и представление подключения. На приведенном ниже рисунке показаны связи в области конструктора:

 [![](images/storyboardsview.png "Связи, в рабочей области конструирования приведены в этот образ")](images/storyboardsview.png#lightbox)

Как показано, раскадровки будет макета каждого вашей сцен с уже отображен содержимого и показаны соединения между ними.  Обратите внимание на этом этапе, когда мы говорим о сценах на iPhone, он уверенностью предположить, что один *сцены* на раскадровку равен одному *экрана* содержимого на устройстве. Тем не менее с iPad возможно иметь сцены отображаются сразу — например, с помощью Popover представление контроллера.

Есть много преимуществ, с помощью раскадровки для создания пользовательского интерфейса приложения, особенно в том случае, когда с помощью Xamarin. Во-первых, это визуальное представление пользовательского интерфейса, как все объекты — включая [пользовательские элементы управления](~/ios/user-interface/designer/ios-designable-controls-overview.md) — подготавливаются к просмотру во время разработки. Это означает, что перед построение или развертывание приложения, вы можете визуализировать его внешний вид и потока. Возьмем для примера выше изображении. Мы расскажем из кратко рассмотрим конструктора, являются поверхности сколько сцен, макет каждого представления и все, что связь. Именно это и делает раскадровки мощным средством.

События являются более управляемым с помощью раскадровки, особенно при использовании конструктора iOS. Большинство элементов управления пользовательского интерфейса будет иметь список возможных событий в панели свойств. Обработчик событий может быть добавлена здесь и заполнять разделяемого метода в класс контроллеров представления...

Содержимое раскадровки хранится в виде XML-файла. Время, сборки AT любой `.storyboard` файлы компилируются в двоичные файлы, известный как nibs. Во время выполнения эти nibs инициализирован и создания экземпляра, чтобы создавать новые представления.

## <a name="segues"></a>Segues

Объект *Segue*, или *перейти объекта*, используется при разработке операций ввода-вывода для представления переход между сцены. Чтобы создать segue, удерживая нажатой **Ctrl** ключ и щелкните и перетащите из сцены один в другой. Как мы перетаскиваем нашей мыши, голубой соединитель, показывающей, где привести segue, как показано на рисунке ниже:

 [![](images/createsegue.png "Голубой соединитель, показывающей, где привести segue, как показано на этом рисунке")](images/createsegue.png#lightbox)

В отпускания меню будет отображаться, позволяющий выбрать действие для наших segue. Он может выглядеть как изображения ниже: 

**Pre-iOS 8 и классы размера**

[![](images/segue1.png "В раскрывающемся списке перейти действие без размер классы")](images/segue1.png#lightbox)

**При использовании классов размера и адаптивных сегментов**

[![](images/16new.png "В раскрывающемся списке действие перейти с классами размер")](images/16new.png#lightbox)

> [!IMPORTANT]
> **ПРИМЕЧАНИЕ:** Если вы используете VMWare для своей виртуальной машины Windows, по умолчанию щелчок мышью по умолчанию называется _щелчком мыши правой кнопкой мыши_. Чтобы создать Segue, изменение параметров клавиатуры через **предпочтения** > **клавиатуру и мышь** > **сочетания клавиш мыши** и повторно сопоставить вашей **Вторую кнопку** как показано ниже:
> 
> [![](images/image22.png "Настройки клавиатуры и мыши")](images/image22.png#lightbox)
> 
> Теперь можно добавить segue между контроллерами представление обычным образом.

Существуют различные типы переходы, каждый выдача контролировать способ представления нового контроллера представления для пользователя и его взаимодействия с другими контроллерами представления в раскадровку. Это описано ниже. Можно также создать подкласс объект segue реализовать пользовательский переход:

-  **Показать / Push** — перейти push добавляет представление-контроллер в стеке навигации. Предполагается, что представление-контроллер, рассчитанные извещающей является частью тем же контроллером навигации, что представление-контроллер, который добавляется в стек. Это делает то же самое, как `pushViewController` и обычно используется при наличии определенные связи между данными на экранах. С помощью принудительной отправки перейти дает позволить себе иметь панель навигации с помощью кнопки "Назад" и заголовок добавлен в каждое представление в стеке, позволяя детализации углублением навигации по иерархии представления.
-  **Модальные** — модального segue создать связь между контроллеров любые два представления в проекте с параметром анимированных перехода показывается. Контроллер дочернего представления полностью скроет контроллере родительского представления при добавлены в представление. В отличие от push перейти, который добавляет кнопки "Назад" для нас; Если перейти с помощью модального `DismissViewController` должен использоваться для возврата к предыдущей представление-контроллер.
-  **관습** - 모든 맞춤 segue는의 하위 클래스로 만들 수 있습니다 ` UIStoryboardSegue`.
-  **풀다** - 예를 들어 모달로 표시된보기 컨트롤러를 닫음으로써 푸시 또는 모달보기를 통해 뒤로 탐색하는 데 unwind segue를 사용할 수 있습니다. Помимо этого можно развернуть через не только один, но ряд принудительной отправки и модальное segues и вернуться назад, что действие очистки несколько шагов в иерархии навигации с помощью одного. Чтобы понять, как использовать Очистка перейти в iOS, чтение [Создание очистки Segues](https://developer.xamarin.com/recipes/ios/general/storyboard/unwind_segue/) инструкций.
-  **Sourceless** — sourceless segue указывает сцены, содержащий исходное представление-контроллер, и таким образом представление, которое пользователь будет видеть первым. Он представлен segue, показано ниже:  

    [![](images/sourcelesssegue.png "Sourceless segue")](images/sourcelesssegue.png#lightbox)

### <a name="adaptive-segue-types"></a>Адаптивная перейти типов

 iOS 8 появился [классы размер](~/ios/user-interface/storyboards/unified-storyboards.md#size-classes) файла раскадровки iOS для работы с всех доступных размеров, позволяет разработчикам создавать одного пользовательского интерфейса для всех устройств iOS. По умолчанию все новые приложения Xamarin.iOS будет использовать классы размер. Чтобы использовать размер классы из старого проекта, см. [введение в единой раскадровки](~/ios/user-interface/storyboards/unified-storyboards.md) руководства. 
 
Все приложения, использующие классы размера будут использовать новое [ *адаптивной Segues*](~/ios/user-interface/storyboards/unified-storyboards.md). При использовании классов размер, помните, мы не указали непосредственно ли мы используем iPhone и iPad. Другими словами, мы создаем одного пользовательского интерфейса, всегда будут выглядеть одинаково, независимо от того, сколько недвижимость, он должен работать с. Адаптивный Segues работу Судя среды и определить лучший способ для представления содержимого. Адаптивная Segues приведены ниже: 

[![](images/adaptivesegue.png "В раскрывающемся списке адаптивной Segues")](images/adaptivesegue.png#lightbox)

<table>
    <thead>
        <tr>
            <th>Перейти</th>
            <th>Описание:</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Показать</td>
            <td>Это очень похоже на перейти Push, но он учитывает содержимого экрана. </td>
        </tr>
        <tr>
            <td>Показать подробности</td>
            <td>Если приложение отображает master и подробное представление (например, в контроллер представление разбиение на iPAd), содержимое будет заменен подробное представление. Если приложение отображает только образец <strong>или</strong> детализации, верхнюю часть стека контроллер представление заменяет содержимое.</td>
        </tr>
        <tr>
            <td>Presentation</td>
            <td>Это аналогично модального segue и позволяет разрешенных стилей представления и перехода.</td>
        </tr>
        <tr>
            <td>Popover презентации</td>
            <td>Это представляет содержимое в виде popover</td>
        </tr>
    </tbody>
</table>

### <a name="transferring-data-with-segues"></a>Передача данных с помощью Segues

Преимущества segue не заканчиваться переходов. Они также могут использоваться для управления передачей данных между контроллерами представления. Это достигается путем переопределения `PrepareForSegue` метод на контроллере исходного представления и обработки данных сами. При запуске segue — например, с нажатие кнопки — в приложении вызывается этот метод обеспечивает возможность подготовки новых представление-контроллер *перед* любой переходе. В коде ниже, из [Phoneword](https://developer.xamarin.com/samples/monotouch/Hello_iOS/) образца, демонстрирует это: 


```csharp
public override void PrepareForSegue (UIStoryboardSegue segue, 
NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    var callHistoryContoller = segue.DestinationViewController 
                                  as CallHistoryController;

    if (callHistoryContoller != null) {
        callHistoryContoller.PhoneNumbers = PhoneNumbers;
    }
}
```

В этом примере `PrepareForSegue` метод будет вызываться при запуске segue пользователем. Сначала нужно создать экземпляр «принимающей» представление-контроллер и настроить его как целевой segue View Controller. Это можно сделать, строка кода ниже:

```csharp
var callHistoryContoller = segue.DestinationViewController as CallHistoryController;
```

Метод теперь имеет возможность задавать свойства `DestinationViewController`. В этом примере мы использовали это, передавая список называется `PhoneNumbers` для `CallHistoryController` и присвоив его на объект с тем же именем:

```csharp
if (callHistoryContoller != null) {
        callHistoryContoller.PhoneNumbers = PhoneNumbers;
    }
```

После завершения перехода, пользователь увидит `CallHistoryController` с заполненного списка.

## <a name="adding-a-storyboard-to-a-non-storyboard-project"></a>Добавление в проект без раскадровки раскадровки

В некоторых случаях может потребоваться добавить раскадровки в файл ранее раскадровки. После этого в Visual Studio для Mac можно упростить, выполнив следующие действия:

# <a name="visual-studio-for-mactabvsmac"></a>[Visual Studio для Mac](#tab/vsmac)

1. Создайте новый файл раскадровки, перейдя к **файл > новый файл > iOS > раскадровки**, как показано ниже: 
    
    [![](images/new-storyboard-xs.png "Диалоговое окно нового файла")](images/new-storyboard-xs.png#lightbox)

2. Добавьте имя раскадровки для **главного интерфейса** раздел **Info.plist**, как показано ниже:
    
    [![](images/infoplist.png "Редактор Info.plist")](images/infoplist.png#lightbox)
    
    Это делает то же самое создания экземпляра начальное представление-контроллер в `FinishedLaunching` метода в приложении делегат. Когда этот параметр установлен, приложение создает экземпляр окна (см. ниже), загружает основной раскадровки и назначает ему экземпляр раскадровки начальной View Controller (один рядом с sourceless Segue) в качестве `RootViewController` свойство окна, а затем делает окно отображается на экране.

3. В `AppDelegate`, переопределить значение по умолчанию `Window` метод следующий код для реализации свойства окна:
        
        public override UIWindow Window {
            get;
            set;
            }
            
# <a name="visual-studiotabvswin"></a>[Visual Studio](#tab/vswin)

1. Создайте новый файл раскадровки, щелкнув проект для **Добавить > новый файл > iOS > пустой раскадровки**, как показано ниже: 
    
    [![](images/new-storyboard-vs.png "Диалоговое окно нового элемента")](images/new-storyboard-vs.png#lightbox)

2. Добавьте имя раскадровки для **главного интерфейса** раздел iOS приложения, как показано ниже:
    
    [![](images/ios-app.png "Редактор Info.plist")](images/ios-app.png#lightbox)
    
    Это делает то же самое создания экземпляра начальное представление-контроллер в `FinishedLaunching` метода в приложении делегат. Когда этот параметр установлен, приложение создает экземпляр окна (см. ниже), загружает основной раскадровки и назначает ему экземпляр раскадровки начальной View Controller (один рядом с sourceless Segue) в качестве `RootViewController` свойство окна, а затем делает окно отображается на экране.

3. В `AppDelegate`, переопределить значение по умолчанию `Window` метод следующий код для реализации свойства окна:

        public override UIWindow Window {
            get;
            set;
            }
            
-----

## <a name="creating-a-storyboard-with-the-ios-designer"></a>Создание раскадровки с iOS конструктора

Раскадровки могут создаваться с помощью конструктора Xamarin для операций ввода-вывода, который интегрирован без проблем с Visual Studio для Mac и Visual Studio.

Чтобы приступить к работе с помощью iOS конструктор для создания раскадровки, выполните [Привет, iOS (несколько экранов)](~/ios/get-started/hello-ios-multiscreen/index.md) руководства. В этом пошаговом руководстве вы узнаете переходов между контроллерами представление, используя Segues и как обрабатывать события элементов управления.

## <a name="instantiate-storyboards-manually"></a>Вручную создать раскадровки

Раскадровки полностью заменить отдельные файлы XIB в проект, однако отдельные представления контроллеров в раскадровку по-прежнему могут создаваться с помощью `Storyboard.InstantiateViewController`.

Иногда приложения имеют особые требования, которые невозможно обработать с переходами встроенных раскадровки, предоставляемый конструктором. Например если создать приложение, которое запускает другие экраны с помощью одной кнопки в зависимости от текущего состояния приложения, можно вручную создать просмотр контроллеров, а программы перехода сами.

На снимке экрана ниже показано, что два контроллера представления на нашем конструктора нет перейти между ними. Следующий раздел поможет выполнить как переход можно настроить в коде.

 [![](images/viewcontrollerspink.png "На этом снимке экрана показано, что два контроллера представления в рабочей области конструирования с нет перейти между ними")](images/viewcontrollerspink.png#lightbox)

1. Добавить _пустые iPhone раскадровки_ в существующий проект проекта:
    
    [![](images/add-storyboard1.png "Добавление раскадровки")](images/add-storyboard1.png#lightbox)

2. Дважды щелкните только что созданный раскадровки, чтобы открыть его и добавить новый **навигации контроллера** в область конструктора. Как контроллер навигации без пользовательского интерфейса, по умолчанию, он будет иметь с контроллером корневой представления, как показано ниже:

    [![](images/uinavigationcontroller.png "Просмотр контроллеров с Segues")](images/uinavigationcontroller.png#lightbox)

3. Выберите _View Controller_ , щелкнув черная полоса внизу. В конструкторе **Pad свойство**в разделе **удостоверение** можно указать пользовательский класс, а также уникальный идентификатор для представления контроллеров. Задать **имя класса** и **идентификатор раскадровки** для `MainViewController`.

    [![](images/identitypanelnew.png "Укажите настраиваемый класс")](images/identitypanelnew.png#lightbox)

4. Более поздней версии, необходимо создать экземпляр нашей Просмотр контроллеров из раскадровки и будет использовать идентификатор раскадровки для ссылки на них в коде. Задание восстановления идентификатора для сопоставления ИД раскадровки гарантирует, что правильно представление-контроллер возвращает заново, если необходимо восстановить состояние.

5. Мы сейчас только у одного контроллера в представление. Перетащите другой контроллер представления на поверхность разработки. В **Pad свойство**, удостоверением, задать класс и идентификатор раскадровки `PinkViewController`, как показано ниже:

    [![](images/pinkvcnew.png "Панель свойств")](images/pinkvcnew.png#lightbox)
    
    IDE создаст эти классы для представления контроллеров. Их можно просмотреть в **Pad решения**, как показано на снимке экрана ниже:
    
    [![](images/solution-pad.png "Панель решения")](images/solution-pad.png#lightbox)

6. В `PinkViewController`, выберите представление, щелкнув к центру контроллера кадра. В панели свойств в представлении измените **фона** для Magenta:
    
    [![](images/pinkcontroller.png "Выбор цвета фона")](images/pinkcontroller.png#lightbox)

7. Наконец, перетащите кнопку из **элементов** на `MainViewController`. В области свойств присвойте ему имя `PinkButton` и GoToPink заголовка, как показано ниже:

    [![](images/pinkbutton.png "Задайте имя кнопки")](images/pinkbutton.png#lightbox)

Раскадровка завершена, но если мы теперь развертывание проекта, их можно получить пустой экран. Это, так как мы по-прежнему должны сообщить использовать наши раскадровки и настроить контроллер корневого представления в качестве первое представление интегрированной среды разработки. Обычно это можно сделать с помощью наших параметры проекта, как показано выше. Тем не менее в этом примере мы будет сделать один и тот же результат в коде, добавив следующую команду, чтобы **AppDelegate**:

```csharp
public partial class AppDelegate : UIApplicationDelegate
    {
        UIWindow window;
        public static UIStoryboard Storyboard = UIStoryboard.FromName ("MainStoryboard", null);
        public static UIViewController initialViewController;

        public override bool FinishedLaunching (UIApplication app, NSDictionary options)
        {
            window = new UIWindow (UIScreen.MainScreen.Bounds);

            initialViewController = Storyboard.InstantiateInitialViewController () as UIViewController;

            window.RootViewController = initialViewController;
            window.MakeKeyAndVisible ();
            return true;
        }

    }
```

Это большой объем кода, но лишь несколько строк не знакомы. Во-первых, необходимо зарегистрировать нашей раскадровки с **AppDelegate** , передав имя раскадровки **MainStoryboard**. Далее мы сообщаем приложения для создания экземпляра контроллера начальное представление из раскадровки, вызвав `InstantiateInitialViewController` на нашем раскадровки и контроллера представления задается как контроллер представление корневого нашего приложения. Этот метод определяет первый экран, который видит пользователь, и создает новый экземпляр этого контроллера представления.

Обратите внимание на панели решение создания интегрированной среды разработки `MainViewcontroller.cs` класса и его `corresponding designer.cs` когда мы добавили имя класса в панель свойств на шаге 4. Мы видим этот класс создан специальный конструктор, который содержит базовый класс:

```csharp
public MainViewController (IntPtr handle) : base (handle) 
{
}
```


При создании с помощью конструктора раскадровки, интегрированная среда разработки автоматически добавит [[регистрация]](https://developer.xamarin.com/api/type/Foundation.RegisterAttribute/) атрибут в верхней части `designer.cs` и передать идентификатор строки, которое идентично раскадровки идентификатора, указанного в предыдущий шаг. Это позволит связать C# для соответствующего кадра в раскадровку.

В некоторый момент, может потребоваться добавить существующий класс, который был **не** создан в конструкторе. В этом случае необходимо зарегистрировать этот класс в обычном режиме:

```csharp
[Register ("MainViewController")]
public partial class MainViewController : UIViewController
{
public MainViewController (IntPtr handle) : base (handle) 
{
}

...
}
```

Дополнительные сведения о регистрации классов и методов посвящены [тип регистратора](http://docs.xamarin.com/guides/ios/advanced_topics/registrar/) документации.

Последним шагом в этот класс является соединять и кнопки перехода розовый представление-контроллер. Мы будем создать `PinkViewController` из раскадровки; затем мы будет писать push перейти с `PushViewController`, как показано в приведенном ниже примере кода:

```csharp
public partial class MainViewController : UIViewController
{
    UIViewController pinkViewController;

    public MainViewController (IntPtr handle) : base (handle)
    {

    }

    public override void AwakeFromNib ()
    {
    // Called when loaded from xib or storyboard.

    this.Initialize ();
    }

    public void Initialize(){

    //Instantiating View Controller with Storyboard ID 'PinkViewController'
    pinkViewController = Storyboard.InstantiateViewController ("PinkViewController") as PinkViewController;
    }

    public override void ViewDidLoad ()
    {
    base.ViewDidLoad ();

    //When we push the button, we will push the pinkViewController onto our current Navigation Stack
    PinkButton.TouchUpInside += (o, e) =&gt; {
        this.NavigationController.PushViewController (pinkViewController, true);
    };
    }

}
```

Запуск приложения создается приложение экрана 2:

![](images/finishedstoryboard.png "Пример приложения, запустите экранов")

## <a name="conditional-segues"></a>Условное Segues

Часто перемещение с одного контроллера представления в другую, зависит от определенного условия. Например, если уже им экран входа простой нам бы нужен только для перехода к следующему экрану *Если* имя пользователя и пароль проверен.

В следующем примере мы добавим поля пароля в предыдущем примере. Пользователь будет только для доступа к *PinkViewController* в случае ввода правильного пароля, в противном случае ошибка будет отображаться.

Прежде чем начать, выполните шаги 1 – 8 выше. В этом пошаговом руководстве создается нашей раскадровки, начать создание нашем пользовательском Интерфейсе и сообщить нашей делегат приложения контроллера представления как RootViewController.

1. Теперь создадим наш пользовательский интерфейс и добавить дополнительные представления, перечисленные в `MainViewController` придать похожи на снимке экрана ниже:

    - UITextField
        - Имя: PasswordTextField
        - Замещающий текст: «Введите секретный пароль»
    - UILabel
        - Текст: "Ошибка: неверный пароль. Не должен проходить! "
        - Цвета: красный
        - Выравнивание: центр
        - Строк: 2
        - Флажок «Скрытый» 
        
    [![](images/passwordvc.png "Центр строки")](images/passwordvc.png#lightbox)
    
2. Создание Segue между Go розовый кнопки и представление-контроллер, перетащив Ctrl из *PinkButton* для *PinkViewController*и выбрав **Push** на доступ к мыши . 

3. Щелкните Segue и присвойте ему *идентификатор* `SegueToPink`:

    [![](images/namesegue.png "Щелкните Segue и присвойте ему идентификатор SegueToPink")](images/namesegue.png#lightbox)  
    

4. Наконец, добавьте следующий метод ShouldPerformSegue `MainViewController` класса:

    ```csharp
    public override bool ShouldPerformSegue (string segueIdentifier, NSObject sender)
    {
        
        if(segueIdentifier == "SegueToPink"){
            if (PasswordTextField.Text == "password") {
                PasswordTextField.ResignFirstResponder ();
                return true;
            }
            else{
                ErrorLabel.Hidden = false;
                return false;
            }
        }
        return base.ShouldPerformSegue (segueIdentifier, sender);
    }
    ```

В этом коде имеются соответствующие segueIdentifier для наших `SegueToPink` перейти, чтобы затем можно проверить условие; допустимый пароль в данном случае. Если наш условие возвращает `true`, Segue выполнит и появятся `PinkViewController`. Если `false`, не увидят новое представление-контроллер.

Мы можно применять любой Segue на этом контроллере представление этот подход, проверив аргумент segueIdentifier метода ShouldPerformSegue. В этом случае у нас имеется только один идентификатор Segue — `SegueToPink`.

Ссылаться на решения в Storyboards.Conditional [пример раскадровки вручную](https://developer.xamarin.com/samples/monotouch/ManualStoryboard/) рабочий пример.

<a name="Using-Storyboard-References" />

## <a name="using-storyboard-references"></a>С помощью ссылки на раскадровки

Ссылки раскадровки позволяет использовать конструкцию раскадровки больших и сложных и разбить на более мелкие раскадровки, получение ссылки из исходного, таким образом удаление удаление сложности и принятия итоговый отдельных раскадровок проще для разработки и Ведение.

Кроме того, можно указать ссылку на раскадровку _привязки_ другой сцену в пределах того же раскадровки или конкретных сцены на другом.

<a name="Referencing-an-External-Storyboard" />

### <a name="referencing-an-external-storyboard"></a>Создание ссылок на внешние раскадровки

Чтобы добавить ссылку на внешний раскадровки, выполните следующее:

1. В **обозревателе решений**, щелкните правой кнопкой мыши имя проекта и выберите **добавить** > **новый файл...**   >  **iOS** > **раскадровки**. Введите **имя** новую раскадровку и нажмите кнопку **New** кнопки:
    
    [![](images/ref01.png "Диалоговое окно нового файла")](images/ref01.png#lightbox)
    
2. Разработка макета новая раскадровка сцен, как обычно и сохранить изменения: 
    
    [![](images/ref02.png "Макет новые сцены")](images/ref02.png#lightbox)
    
3. Откройте раскадровку, нужно добавления ссылки в конструкторе iOS.

4. Перетащите **раскадровки ссылка** из **элементов** на поверхность разработки: 
    
    [![](images/ref03.png "Ссылки раскадровки")](images/ref03.png#lightbox)
    
5. В **мини-приложение** вкладке **свойства обозревателя**, выберите имя **раскадровки** созданной выше: 

    [![](images/ref04.png "Вкладка мини-приложения")](images/ref04.png#lightbox)
    
6. Элемент управления, щелкните элемент пользовательского интерфейса (например, кнопка) на существующий сцены и создать новый Segue для **ссылки раскадровки** только что созданный: 

    [![](images/ref05.png "Создание segue")](images/ref05.png#lightbox) 
    
7. В контекстном меню выберите **Показать** для завершения Segue: 

    [![](images/ref06.png "При выборе отображения для завершения Segue")](images/ref06.png#lightbox) 
    
8. Сохраните изменения в раскадровку.

Отображается при запуске приложения, и пользователь щелкает элемент пользовательского интерфейса, созданный Segue из начальное представление-контроллер из внешних раскадровки, указанный в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-an-External-Storyboard" />

### <a name="referencing-a-specific-scene-in-an-external-storyboard"></a>Создание ссылок на определенного кадра в внешних раскадровки

Добавление ссылки на определенные сцены внешних раскадровки (и не начальное представление контроллер), выполните следующее:

1. В **обозревателе решений**, дважды щелкните внешних раскадровку, чтобы открыть его для редактирования.

2. Добавьте новую сцену и его макет обычным образом: 

    [![](images/ref07.png "Новый макет сцены")](images/ref07.png#lightbox)
    
3. В **мини-приложение** вкладке **свойства обозревателя**, введите **раскадровки идентификатор** для нового сцены View Controller: 

    [![](images/ref08.png "Введите идентификатор раскадровки для нового контроллера представления сцены")](images/ref08.png#lightbox)
    
3. Откройте раскадровку, нужно добавления ссылки в конструкторе iOS.

4. Перетащите **раскадровки ссылка** из **элементов** на поверхность разработки: 

    [![](images/ref03.png "Ссылки раскадровки")](images/ref03.png#lightbox)
    
5. В **мини-приложение** вкладке **свойства обозревателя**, выберите имя **раскадровки** и **ссылка на идентификатор** (раскадровки ID) из Сцены, созданный выше: 

    [![](images/ref09.png "Вкладка мини-приложения ")](images/ref09.png#lightbox)
    
6. Элемент управления, щелкните элемент пользовательского интерфейса (например, кнопка) на существующий сцены и создать новый Segue для **ссылки раскадровки** только что созданный: 

    [![](images/ref10.png "Создание segue")](images/ref10.png#lightbox) 
    
7. В контекстном меню выберите **Показать** для завершения Segue: 

    [![](images/ref06.png "При выборе отображения для завершения Segue")](images/ref06.png#lightbox) 
    
8. Сохраните изменения в раскадровку.

Когда приложение будет выполнения и пользователь щелкает элемент пользовательского интерфейса, который вы создали Segue из сцены с заданной **раскадровки идентификатор** из внешних раскадровки, указанный в ссылке раскадровки будет отображаться.

<a name="Referencing-a-Specific-Scene-in-the-Same-Storyboard" />

### <a name="referencing-a-specific-scene-in-the-same-storyboard"></a>Ссылки на определенные сцены в одном раскадровки

Чтобы добавить ссылку на конкретных сцены же раскадровки, выполните следующее:

1. В **обозревателе решений**, дважды щелкните раскадровку, чтобы открыть его для редактирования.

2. Добавьте новую сцену и его макет обычным образом: 

    [![](images/ref11.png "Новый макет сцены")](images/ref11.png#lightbox)

3. В **мини-приложение** вкладке **свойства обозревателя**, введите **раскадровки идентификатор** для нового сцены View Controller: 

    [![](images/ref12.png "Вкладка мини-приложения")](images/ref12.png#lightbox)
    
3. Перетащите **раскадровки ссылка** из **элементов** на поверхность разработки: 

    [![](images/ref03.png "Ссылки раскадровки")](images/ref03.png#lightbox)
    
5. В **мини-приложение** вкладка **свойства обозревателя**выберите **ссылка на идентификатор** (раскадровки ID) сцены, созданный выше: 

    [![](images/ref13.png "Вкладка мини-приложения")](images/ref13.png#lightbox)
    
6. Элемент управления, щелкните элемент пользовательского интерфейса (например, кнопка) на существующий сцены и создать новый Segue для **ссылки раскадровки** только что созданный: 

    [![](images/ref14.png "Создание segue")](images/ref14.png#lightbox) 
    
7. В контекстном меню выберите **Показать** для завершения Segue: 

    [![](images/ref06.png "При выборе отображения для завершения Segue")](images/ref06.png#lightbox) 
    
8. Сохраните изменения в раскадровку.

Когда приложение будет выполнения и пользователь щелкает элемент пользовательского интерфейса, который вы создали Segue из сцены с заданной **идентификатор раскадровки** в же раскадровки, указанный в ссылке раскадровки будет отображаться.

## <a name="summary"></a>Сводка

В этой статье рассматривается понятие раскадровки и как они могут быть полезны при разработке приложений iOS. Он описывает сцен, просмотр контроллеров, представлений и просмотр иерархий и как связаны сцен вместе с различными типами Segues.  Она также изучает контроллеров при создании представления вручную из раскадровки и создание условного Segues.



## <a name="related-links"></a>Связанные ссылки

- [Ручная раскадровка (образец)](https://developer.xamarin.com/samples/ManualStoryboard/)
- [Введение в iOS Designer](~/ios/user-interface/designer/introduction.md)
- [Преобразование в раскадровки](http://developer.apple.com/library/ios/#releasenotes/Miscellaneous/RN-AdoptingStoryboards/)
- [Справочник по классу UIStoryboard](https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIStoryboard_Class/Reference/Reference.html)
