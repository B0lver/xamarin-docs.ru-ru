---
title: Общие сведения о раскадровках в Xamarin. iOS
description: В этом документе содержатся общие сведения о раскадровках в Xamarin. iOS. Здесь описывается, как раскадровка используется для определения пользовательского интерфейса, переходов и использования конструктора iOS для изменения файлов раскадровки.
ms.prod: xamarin
ms.assetid: A3339BD2-9F56-7965-25F5-4B7C991EB775
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/22/2017
ms.openlocfilehash: b61d851e793d3fb0ae5e97718b151dd87f37da61
ms.sourcegitcommit: 008bcbd37b6c96a7be2baf0633d066931d41f61a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/22/2020
ms.locfileid: "86937050"
---
# <a name="introduction-to-storyboards-in-xamarinios"></a>Общие сведения о раскадровках в Xamarin. iOS

В этом пошаговом окне мы объясним, что такое раскадровка, и рассмотрим некоторые ключевые компоненты, например переходов. Мы рассмотрим, как можно создавать и использовать раскадровки и какие преимущества они имеют для разработчика.

Прежде чем формат файла раскадровки появился в Apple как визуальное представление пользовательского интерфейса приложения iOS, разработчики создали файлы XIB для каждого контроллера представления и запустили навигацию между представлениями вручную.  Использование раскадровки позволяет разработчику определять как контроллеры представлений, так и навигацию между ними в области конструктора и обеспечивает редактирование пользовательского интерфейса приложения в режиме WYSIWYG.

Раскадровку можно создать, открыть и изменить с помощью конструктора Xamarin iOS. Это руководство также посвящено использованию конструктора для создания раскадровок при использовании C# для программирования навигации.

## <a name="requirements"></a>Требования

Раскадровки можно использовать с Xcode, конструктором iOS в Visual Studio для Mac и Visual Studio 2019 с установленными рабочими нагрузками Xamarin.

## <a name="what-is-a-storyboard"></a>Что такое раскадровка?

Раскадровка — это визуальное представление всех экранов в приложении. Он содержит последовательность сцен, где каждая сцена представляет *контроллер представления* и его *представления*. Эти представления могут содержать объекты и [элементы управления](~/ios/user-interface/controls/index.md) , позволяющие пользователю взаимодействовать с приложением. Эта коллекция представлений и элементов управления (или вложенных *представлений*) называется *иерархией представления содержимого*. Сцены соединяются объектами перехода, которые представляют переход между контроллерами представления. Обычно это достигается путем создания перехода между объектом в первоначальном представлении и представлением соединения. Связи в области конструктора показаны на рисунке ниже.

 [![В этом изображении показаны связи в области конструктора.](images/storyboardsview.png)](images/storyboardsview.png#lightbox)

Как видно, раскадровка будет размещаться в каждом из сцен с уже подготовленным содержимым и показывает соединения между ними.  На этом этапе стоит отметить, что при разговоре о сценах на iPhone можно считать, что одна *сцена* на раскадровке равна одному *экрану* содержимого на устройстве. Однако на iPad может отображаться несколько сцен, например с помощью контроллера представления контекстном меню Action.

Использование раскадровки дает множество преимуществ для создания пользовательского интерфейса приложения, особенно при использовании Xamarin. Во-первых, это визуальное представление пользовательского интерфейса, так как все объекты, включая [пользовательские элементы управления](~/ios/user-interface/designer/ios-designable-controls-overview.md) , подготавливаются во время разработки.
Это означает, что перед сборкой или развертыванием приложения можно визуализировать его внешний вид и последовательность. Возьмем приведенный выше образ, например. В области конструктора можно узнать, сколько сцен есть, макет каждого представления и как все связано. Это делает раскадровки настолько мощными.

События более управляемы с помощью раскадровок, особенно при использовании конструктора iOS. Большинство элементов управления пользовательского интерфейса будут иметь список возможных событий в Панель свойств. Обработчик событий можно добавить сюда и выполнить в разделяемом методе класса View Controllers.

Содержимое раскадровки хранится в виде XML-файла. Во время сборки все `.storyboard` файлы компилируются в двоичные файлы, называемые нибс. Во время выполнения эти нибс инициализируются и создаются с созданием экземпляров для создания новых представлений.

## <a name="segues"></a>Переходов

Объект *перехода*или *перехода*используется в разработке iOS для представления перехода между сценами. Чтобы создать перехода, удерживайте нажатой клавишу **CTRL** и перетащите ее с одной сцены на другую. По мере перетаскивания мыши появляется синий соединитель, указывающий, где перехода будет выглядеть, как показано на рисунке ниже:

 [![Появится синий соединитель, указывающий, где перехода будет выглядеть, как показано на этом изображении.](images/createsegue.png)](images/createsegue.png#lightbox)

При наведении указателя мыши появится меню, позволяющее выбрать действие для нашего перехода. Он может выглядеть примерно так:

**Классы до iOS 8 и size**:

[![Раскрывающийся список действия перехода без классов размера](images/segue1.png)](images/segue1.png#lightbox)

**При использовании классов размера и адаптивного переходов**:

[![Раскрывающийся список действия перехода с классами size](images/16new.png)](images/16new.png#lightbox)

> [!IMPORTANT]
> Если вы используете VMWare для виртуальной машины Windows, при нажатии _кнопки мыши по умолчанию отображается_ нажатие клавиши CTRL. Чтобы создать перехода, измените параметры клавиатуры с помощью **параметров**  >  **Клавиатура & мышь**  >  **Mouse Shortcuts** и переназначьте **вторичную кнопку** , как показано ниже:
>
> [![Параметры настройки клавиатуры и мыши](images/image22.png)](images/image22.png#lightbox)
>
> Теперь вы можете добавить перехода между контроллерами представления как обычно.

Существуют различные типы переходов, каждый из которых обеспечивает контроль над представлением нового контроллера представления пользователю и тем, как он взаимодействует с другими контроллерами представления в раскадровке. Они описаны ниже. Также можно создать подкласс для объекта перехода, чтобы реализовать пользовательский переход:

- **Показать/отправить** — Push-перехода добавляет контроллер представления в стек навигации. Предполагается, что контроллер представления, исходящий из отправки push, является частью того же контроллера навигации, что и контроллер представления, добавляемый в стек. Это делает то же самое `pushViewController` , что и, и обычно используется при наличии некоторой связи между данными на экранах. Использование push перехода дает вам Люкс с панелью навигации с кнопкой "назад" и заголовком, добавленными в каждое представление в стеке, что позволяет детализировать навигацию по иерархии представлений.
- **Модальный** — модальный перехода создает связь между любыми двумя контроллерами представления в проекте с возможностью отображения анимированного перехода. Контроллер дочернего представления будет полностью скрывать родительский контроллер представления при просмотре. В отличие от Push перехода, которая добавляет кнопку назад для нас; При использовании модального перехода `DismissViewController` необходимо использовать для возврата к предыдущему контроллеру представления.
- **Custom** — любой пользовательский перехода можно создать как подкласс `UIStoryboardSegue` .
- **Очистка** — перехода очистки можно использовать для перехода по Push-или модальным перехода, например путем закрытия модального контроллера представления. Помимо этого, вы можете очистить не только одну, но и серию push-и модальных переходов, а также выполнить несколько шагов в иерархии навигации с одним действием очистки. Чтобы понять, как использовать перехода очистки в iOS, прочитайте статью создание рецепта [очистки переходов](https://github.com/xamarin/recipes/tree/master/Recipes/ios/general/storyboard/unwind_segue) .
- Без **исходного кода** — перехода без исходного кода указывает на сцену, содержащую исходный контроллер представления, и поэтому представление, которое пользователь увидит первым. Он представлен перехода, показанным ниже.  

    [![Перехода с исходным кодом](images/sourcelesssegue.png)](images/sourcelesssegue.png#lightbox)

### <a name="adaptive-segue-types"></a>Адаптивные типы перехода

 в iOS 8 появились [классы размера](~/ios/user-interface/storyboards/unified-storyboards.md#size-classes) , позволяющие файлу раскадровки iOS работать со всеми доступными размерами экрана, что позволяет разработчикам создавать один пользовательский интерфейс для всех устройств iOS. По умолчанию все новые приложения Xamarin. iOS будут использовать классы размера. Чтобы использовать классы размеров из более старых проектов, ознакомьтесь с руководством [Введение в унифицированные раскадровки](~/ios/user-interface/storyboards/unified-storyboards.md) .

В любом приложении, использующем классы размера, также будет использоваться новое [*Адаптивное переходов*](~/ios/user-interface/storyboards/unified-storyboards.md). При использовании классов размера Помните, что нам не нужно напрямую указывать Погода, мы используем iPhone или iPad. Другими словами, мы создаем один пользовательский интерфейс, который всегда будет выглядеть одинаково, независимо от того, насколько реально он должен работать. Адаптивное переходов работает, судя среду и определяя, как лучше представлять содержимое. Ниже приведены адаптивные переходов.

[![Раскрывающееся меню адаптивного переходов](images/adaptivesegue.png)](images/adaptivesegue.png#lightbox)

|Перехода|Описание|
|--- |--- |
|Показать|Это очень похоже на Push-перехода, но оно принимает содержимое экрана в учетную запись.|
|Отобразить подробности|Если приложение отображает главное и подробное представление (например, в контроллере с разделением представлений на iPad), содержимое заменит подробное представление. Если приложение отображает только основные сведения или подробности, содержимое будет заменено верхней частью стека контроллера представления.|
|Уровень представления|Это похоже на модальный перехода и позволяет выбирать стили представления и перехода.|
|Контекстном меню Action презентацию|Это содержимое представлено как контекстном меню Action|

### <a name="transferring-data-with-segues"></a>Передача данных с помощью переходов

Преимущества перехода не заканчиваются переходами. Они также могут использоваться для управления переносом данных между контроллерами представления. Это достигается путем переопределения `PrepareForSegue` метода для первоначального контроллера представления и обработки данных самих. При активации перехода (например, при нажатии кнопки) приложение вызывает этот метод, предоставляя возможность подготовить новый контроллер представления *перед* переходом. В коде, приведенном ниже, из примера [Phoneword](https://docs.microsoft.com/samples/xamarin/ios-samples/hello-ios) демонстрируется следующее:

```csharp
public override void PrepareForSegue (UIStoryboardSegue segue,
NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    var callHistoryController = segue.DestinationViewController
                                  as CallHistoryController;

    if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
}
```

В этом примере `PrepareForSegue` метод будет вызываться при активации перехода пользователем. Сначала необходимо создать экземпляр контроллера представления "получение" и установить его в качестве контроллера представления назначения перехода. Это делается следующей строкой кода:

```csharp
var callHistoryController = segue.DestinationViewController as CallHistoryController;
```

Теперь метод может задавать свойства в `DestinationViewController` . В этом примере мы воспользуемся этим методом, передав список с именем в `PhoneNumbers` `CallHistoryController` объект и назначив его объекту с таким же именем:

```csharp
if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
```

После завершения перехода пользователь увидит `CallHistoryController` список с заполненным списком.

## <a name="adding-a-storyboard-to-a-non-storyboard-project"></a>Добавление раскадровки в проект, не являющийся раскадровкой

Иногда может потребоваться добавить раскадровку в ранее не раскадровую файл. Сделав это в Visual Studio для Mac можно упростить, выполнив следующие действия:

# <a name="visual-studio-for-mac"></a>[Visual Studio для Mac](#tab/macos)

1. Создайте файл раскадровки, перейдя в **файл > новый файл > iOS > Storyboard**, как показано ниже:

    [![Диалоговое окно «Создание файла»](images/new-storyboard-xs.png)](images/new-storyboard-xs.png#lightbox)

2. Добавьте имя раскадровки в раздел **Main интерфейса** файла **info. plist**, как показано ниже.

    [![Редактор info. plist](images/infoplist.png)](images/infoplist.png#lightbox)

    Это эквивалентно созданию экземпляра исходного контроллера представления в `FinishedLaunching` методе в делегате приложения. Если этот параметр установлен, приложение создает экземпляр окна (см. ниже), загружает основную раскадровку и назначает экземпляр исходного контроллера представления раскадровки (рядом с перехода без источника) в качестве `RootViewController` Свойства окна, а затем делает окно видимым на экране.

3. В `AppDelegate` Переопределите метод по умолчанию `Window` со следующим кодом, чтобы реализовать свойство Window:

    ```csharp
    public override UIWindow Window {
        get;
        set;
    }
    ```

# <a name="visual-studio"></a>[Visual Studio](#tab/windows)

1. Создайте файл раскадровки, щелкнув правой кнопкой мыши проект, чтобы **добавить > новый файл > iOS > пустую раскадровку**, как показано ниже:

    [![Диалоговое окно "новый элемент"](images/new-storyboard-vs.png)](images/new-storyboard-vs.png#lightbox)

2. Добавьте имя раскадровки в раздел **главного интерфейса** приложения iOS, как показано ниже.

    [![Редактор info. plist](images/ios-app.png)](images/ios-app.png#lightbox)

    Это эквивалентно созданию экземпляра исходного контроллера представления в `FinishedLaunching` методе в делегате приложения. Если этот параметр установлен, приложение создает экземпляр окна (см. ниже), загружает основную раскадровку и назначает экземпляр исходного контроллера представления раскадровки (рядом с перехода без источника) в качестве `RootViewController` Свойства окна, а затем делает окно видимым на экране.

3. В `AppDelegate` Переопределите метод по умолчанию `Window` со следующим кодом, чтобы реализовать свойство Window:

    ```csharp
    public override UIWindow Window {
        get;
        set;
    }
    ```

-----

## <a name="creating-a-storyboard-with-xcode"></a>Создание раскадровки с помощью Xcode

Раскадровку можно создать и изменить с помощью Xcode для использования в приложениях iOS, разработанных с помощью Visual Studio для Mac.

Раскадровки полностью заменяют отдельные файлы XIB в проекте, однако отдельные контроллеры представлений в раскадровке можно создавать с помощью `Storyboard.InstantiateViewController` .

Иногда приложения имеют особые требования, которые не могут быть обработаны с помощью встроенных переходов раскадровки, предоставляемых конструктором. Например, если бы мы создавали приложение, которое запускает различные экраны из одной кнопки, в зависимости от текущего состояния приложения, возможно, потребуется создать экземпляры контроллеров представлений вручную и программировать сам переход.

На снимке экрана ниже показаны два контроллера представления в области конструктора без перехода между ними. В следующем разделе будет рассмотрено, как можно настроить этот переход в коде.

1. Добавить _пустую раскадровку iPhone_ в существующий проект проекта:

    [![Добавление раскадровки](images/add-storyboard2.png)](images/add-storyboard2.png#lightbox)

2. Щелкните файл раскадровки правой кнопкой мыши и выберите пункт **Открыть с помощью > Xcode Interface Builder** , чтобы открыть его в Xcode.

    *Если вы предпочитаете использовать построитель интерфейсов Xcode по умолчанию, его можно выбрать в параметрах Visual Studio для Mac в разделе **проекты > iOS**:*

![Выбор предпочтительного средства конструктора](images/set-preferred-designer-tool.png)

3. В Xcode Откройте библиотеку (с помощью **представления > Показать библиотеку** или *Shift + Command + L*), чтобы отобразить список объектов, которые можно добавить в раскадровку. Добавьте в `Navigation Controller` раскадровку, перетащив объект из списка на раскадровку. По умолчанию `Navigation Controller` выдается два экрана. экран справа — это то, `TableViewController` что мы будем заменять простым представлением, поэтому его можно удалить, щелкнув представление и нажав клавишу DELETE.

    [![Добавление Навигатионконтроллер из библиотеки](images/add-navigation-controller.png)](images/add-navigation-controller.png#lightbox)

4. Этот контроллер представления будет иметь собственный пользовательский класс, а также должен иметь собственный идентификатор раскадровки. Если щелкнуть поле над только что добавленным представлением, появится три значка, крайний левый из которых представляет контроллер представления для представления. При выборе этого значка можно задать значения класса и идентификатора на вкладке удостоверение на правой панели. Задайте для этих значений значение `MainViewController` и убедитесь, что проверка выполняется `Use Storyboard ID` .

    [![Настройка Маинвиевконтроллер на панели удостоверений](images/identity-panel.png)](images/identity-panel.png#lightbox)

5. Снова с помощью библиотеки перетащите контроллер представления на экран. Он будет установлен в качестве контроллера корневого представления. Нажимая клавишу Control, щелкните и перетащите значок из контроллера навигации слева к добавленному контроллеру представления справа и выберите в меню пункт *контроллер корневого представления* .

    [![Добавление Навигатионконтроллер из библиотеки и задание Маинвиевконтроллер в качестве корневого контроллера представления](images/add-view-controller.png)](images/add-view-controller.png#lightbox)

6. Это приложение будет переходить к другому представлению, поэтому добавьте еще одно представление в раскадровку, как и раньше. Мы вызываем это `PinkViewController` , и эти значения можно задать так же, как и в `MainViewController` .

    [![Добавление дополнительного контроллера представления](images/add-additional-view-controller.png)](images/add-additional-view-controller.png#lightbox)

7. Так как контроллер представления будет иметь розовый фон, это свойство можно задать на панели Атрибуты, используя раскрывающийся список рядом с `Background` .

    [![Добавление дополнительного контроллера представления](images/set-pink-background.png)](images/set-pink-background.png#lightbox)

8. Так как мы хотим `MainViewController` , чтобы объект мог переходить к `PinkViewController` , для первого потребуется кнопка для взаимодействия с. С помощью библиотеки мы можем добавить кнопку в `MainViewController` .

    [![Добавление кнопки в Маинвиевконтроллер](images/add-button.png)](images/add-button.png#lightbox)

Раскадровка завершена, но если развернуть проект сейчас, будет выведен пустой экран. Это связано с тем, что нам по-прежнему нужно сообщить интегрированной среде разработки использовать нашу раскадровку и настроить корневой контроллер представления, который будет служить первым представлением. Обычно это можно сделать с помощью наших параметров проекта, как показано выше. Однако в этом примере мы добавим тот же результат в коде, добавив следующий код в **AppDelegate**:

```csharp
public partial class AppDelegate : UIApplicationDelegate
{
    UIWindow window;
    public static UIStoryboard Storyboard = UIStoryboard.FromName ("MainStoryboard", null);
    public static UIViewController initialViewController;

    public override bool FinishedLaunching (UIApplication app, NSDictionary options)
    {
        window = new UIWindow (UIScreen.MainScreen.Bounds);

        initialViewController = Storyboard.InstantiateInitialViewController () as UIViewController;

        window.RootViewController = initialViewController;
        window.AddSubview(initialViewController.View);
        window.MakeKeyAndVisible ();
        return true;
    }
}
```

Это большой объем кода, но незнакомо всего несколько строк. Сначала мы регистрируем нашу раскадровку с помощью **AppDelegate** , передав имя раскадровки **файл mainstoryboard**. Далее мы говорим приложению создать экземпляр исходного контроллера представления из раскадровки, вызвав `InstantiateInitialViewController` в нашей раскадровку, и мы установили этот контроллер представления в качестве корневого контроллера представления приложения. Этот метод определяет первый экран, который видит пользователь, и создает новый экземпляр этого контроллера представления.

Обратите внимание на область решения, в которой в интегрированной среде разработки был создан `MainViewcontroller.cs` класс, и `corresponding designer.cs` при добавлении имени класса в панель свойств на шаге 4. Этот класс можно увидеть, создав специальный конструктор, включающий базовый класс:

```csharp
public MainViewController (IntPtr handle) : base (handle)
{
}
```

При создании раскадровки с помощью Xcode интегрированная среда разработки автоматически добавляет атрибут [[Register]](xref:Foundation.RegisterAttribute) в начало `designer.cs` класса и передает строковый идентификатор, идентичный идентификатору раскадровки, указанному на предыдущем шаге. При этом C# будет связан с соответствующей сценой в раскадровке.

```csharp
[Register ("MainViewController")]
public partial class MainViewController : UIViewController
{
    public MainViewController (IntPtr handle) : base (handle)
    {
    }
    //...
}
```

Дополнительные сведения о регистрации классов и методов см. в документации [регистратора типов](https://docs.microsoft.com/xamarin/ios/internals/registrar) .

Последний шаг в этом классе — подключить кнопку и переход к контроллеру розового представления. Мы создадим экземпляр `PinkViewController` из раскадровки. Затем мы будем программировать Push-перехода с помощью `PushViewController` , как показано в следующем примере кода:

```csharp
public partial class MainViewController : UIViewController
{
    UIViewController pinkViewController;

    public MainViewController (IntPtr handle) : base (handle)
    {
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        this.Initialize ();
    }

    public void Initialize()
    {
        //Instantiating View Controller with Storyboard ID 'PinkViewController'
        pinkViewController = Storyboard.InstantiateViewController ("PinkViewController") as PinkViewController;
    }

    public override void ViewDidLoad ()
    {
        base.ViewDidLoad ();

        //When we push the button, we will push the pinkViewController onto our current Navigation Stack
        PinkButton.TouchUpInside += (o, e) =&gt;
        {
            this.NavigationController.PushViewController (pinkViewController, true);
        };
    }
}
```

При запуске приложения создается 2-экранное приложение:

![Экраны запуска примера приложения](images/finishedstoryboard.png)

## <a name="conditional-segues"></a>Условное переходов

Часто переход с одного контроллера представления на другой зависит от определенного условия. Например, если мы представили простой экран входа, мы хотим перейти на следующий экран, только *Если* имя пользователя и пароль были проверены.

В следующем примере мы добавим поле Password (пароль) в приведенный выше пример. Пользователь сможет получить доступ к *пинквиевконтроллер* только в том случае, если он введет правильный пароль, в противном случае появится сообщение об ошибке.

Прежде чем начать, выполните шаги 1 – 8 выше. В этих шагах мы создадим нашу раскадровку, начнем с создания пользовательского интерфейса и говорим представителю приложения, какой контроллер представления следует использовать в качестве Рутвиевконтроллер.

1. Теперь создадим пользовательский интерфейс и добавим в него дополнительные представления `MainViewController` , чтобы сделать его похожим на следующем снимке экрана:

    - UITextField
        - Имя: Пассвордтекстфиелд
        - Заполнитель: ' введите пароль для секрета '
    - UILabel
        - Текст: ошибка: неправильный пароль. Вы не должны пройти! '
        - Цвета: красный.
        - Выравнивание: по центру
        - Строки: 2
        - Флажок "Hidden" установлен    

    [![Центрированные линии](images/passwordvc.png)](images/passwordvc.png#lightbox)

2. Создайте перехода между кнопкой "перейти к розовый" и контроллером представления, удерживая нажатой клавишу CTRL, перетащив *пинкбуттон* в *пинквиевконтроллер*, и выбрав пункт **Push-уведомления** при помощи мыши.

3. Щелкните перехода и присвойте ему *идентификатор* `SegueToPink` :

    [![Щелкните перехода и присвойте ему идентификатор Сегуетопинк](images/namesegue.png)](images/namesegue.png#lightbox)  

4. Наконец, добавьте в класс следующий метод Шаулдперформсегуе `MainViewController` :

    ```csharp
    public override bool ShouldPerformSegue (string segueIdentifier, NSObject sender)
    {

        if(segueIdentifier == "SegueToPink"){
            if (PasswordTextField.Text == "password") {
                PasswordTextField.ResignFirstResponder ();
                return true;
            }
            else{
                ErrorLabel.Hidden = false;
                return false;
            }
        }
        return base.ShouldPerformSegue (segueIdentifier, sender);
    }
    ```

В этом коде мы сосегуеидентифиерся с нашим `SegueToPink` перехода, поэтому мы можем протестировать условие, в данном случае допустимый пароль. Если наше условие возвращает `true` , перехода будет выполнять и будет представлять `PinkViewController` . Если `false` значение равно, новый контроллер представления не будет представлен.

Этот подход можно применить к любому перехода в этом контроллере представления, установив значение аргумента Сегуеидентифиер в метод Шаулдперформсегуе. В этом случае у нас есть только один идентификатор перехода — `SegueToPink` .

См. условное решение Storyboard. Conditional в [примере раскадровки вручную](https://docs.microsoft.com/samples/xamarin/ios-samples/manualstoryboard) для рабочего примера.

<a name="Using-Storyboard-References"></a>

## <a name="using-storyboard-references"></a>Использование ссылок раскадровки

Ссылка на раскадровку позволяет использовать большую, сложную структуру раскадровки и разбивать ее на более мелкие раскадровки, на которые можно ссылаться из оригинала, тем самым удаляя сложность и делая полученные отдельные раскадровки проще в проектировании и обслуживании.

Кроме того, ссылка раскадровки может предоставлять _привязку_ к другой сцене в той же раскадровке или в определенной сцене на другом.

<a name="Referencing-an-External-Storyboard"></a>

### <a name="referencing-an-external-storyboard"></a>Ссылка на внешнюю раскадровку

Чтобы добавить ссылку на внешнюю раскадровку, выполните следующие действия.

1. В **Обозреватель решений**щелкните правой кнопкой мыши имя проекта и выберите **Добавить**  >  **новый файл...**  >  **iOS**  >  **Раскадровка**. Введите **имя** новой раскадровки и нажмите кнопку " **создать** ":

    [![Диалоговое окно «Создание файла»](images/ref01.png)](images/ref01.png#lightbox)

2. Разработайте макет новых сцен раскадровки, как обычно и сохраняйте изменения:

    [![Макет новой сцены](images/ref02.png)](images/ref02.png#lightbox)

3. Откройте раскадровку, в которой вы будете добавлять ссылку в конструкторе iOS.

4. Перетащите **ссылку раскадровки** из **панели элементов** на область конструктора:

    [![Ссылка раскадровки](images/ref03.png)](images/ref03.png#lightbox)

5. На вкладке **мини** -приложение **обозревателя свойств**выберите имя **раскадровки** , созданной ранее:

    [![Вкладка мини-приложения](images/ref04.png)](images/ref04.png#lightbox)

6. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **Ссылки раскадровки** :

    [![Создание перехода](images/ref05.png)](images/ref05.png#lightbox)

7. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода:

    [![Выбор пункта "отобразить" для завершения перехода](images/ref06.png)](images/ref06.png#lightbox)

8. Сохраните изменения в раскадровке.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного с помощью перехода, будет отображен первоначальный контроллер представления из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-an-External-Storyboard"></a>

### <a name="referencing-a-specific-scene-in-an-external-storyboard"></a>Ссылка на конкретную сцену во внешней раскадровке

Чтобы добавить ссылку на конкретную сцену, внешняя Раскадровка (а не исходный контроллер представления) выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните внешнюю раскадровку, чтобы открыть ее для редактирования.

2. Добавьте новую сцену и разработайте ее макет, как обычно:

    [![Новый макет сцены](images/ref07.png)](images/ref07.png#lightbox)

3. На вкладке **мини** -приложение **ОБОЗРЕВАТЕЛЯ свойств**введите **идентификатор раскадровки** для контроллера представления новой сцены:

    [![Введите идентификатор раскадровки для нового контроллера представления сцен](images/ref08.png)](images/ref08.png#lightbox)

4. Откройте раскадровку, в которой вы будете добавлять ссылку в конструкторе iOS.

5. Перетащите **ссылку раскадровки** из **панели элементов** на область конструктора:

    [![Ссылка раскадровки](images/ref03.png)](images/ref03.png#lightbox)

6. На вкладке **мини** -приложение **обозревателя свойств**выберите имя **раскадровки** и **идентификатор ссылки** (идентификатор раскадровки) созданной ранее сцены:

    [![Вкладка мини-приложения](images/ref09.png)](images/ref09.png#lightbox)

7. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **Ссылки раскадровки** :

    [![Создание перехода](images/ref10.png)](images/ref10.png#lightbox)

8. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода:

    [![Выбор пункта "отобразить" для завершения перехода](images/ref06.png)](images/ref06.png#lightbox)

9. Сохраните изменения в раскадровке.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным **идентификатором раскадровки** из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-the-Same-Storyboard"></a>

### <a name="referencing-a-specific-scene-in-the-same-storyboard"></a>Ссылка на конкретную сцену в той же раскадровке

Чтобы добавить ссылку на определенную сцену в ту же раскадровку, выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните раскадровку, чтобы открыть ее для редактирования.

2. Добавьте новую сцену и разработайте ее макет, как обычно:

    [![Новый макет сцены](images/ref11.png)](images/ref11.png#lightbox)

3. На вкладке **мини** -приложение **ОБОЗРЕВАТЕЛЯ свойств**введите **идентификатор раскадровки** для контроллера представления новой сцены:

    [![Вкладка мини-приложения](images/ref12.png)](images/ref12.png#lightbox)

4. Перетащите **ссылку раскадровки** из **панели элементов** на область конструктора:

   [![Ссылка раскадровки](images/ref03.png)](images/ref03.png#lightbox)

5. На вкладке **мини** -приложение **ОБОЗРЕВАТЕЛЯ свойств**выберите **идентификатор ссылки** (идентификатор раскадровки) для сцены, созданной ранее.

    [![Вкладка мини-приложения](images/ref13.png)](images/ref13.png#lightbox)

6. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **Ссылки раскадровки** :

    [![Создание перехода](images/ref14.png)](images/ref14.png#lightbox)

7. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода:

    [![Выбор пункта "отобразить" для завершения перехода](images/ref06.png)](images/ref06.png#lightbox)

8. Сохраните изменения в раскадровке.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным **идентификатором** раскадровки в той же раскадровке, которая указана в ссылке раскадровки.

## <a name="summary"></a>Сводка

В этой статье описывается концепция раскадровок и их преимущества при разработке приложений iOS. В нем обсуждаются сцены, контроллеры представлений, представления и иерархии представлений, а также принципы связывания сцен с различными типами переходов.  Кроме того, в нем рассматривается ручное создание экземпляров контроллеров представлений из раскадровки и создание условного переходов.

## <a name="related-links"></a>Связанные ссылки

- [Ручная Раскадровка (пример)](https://docs.microsoft.com/samples/xamarin/ios-samples/manualstoryboard/)
- [Общие сведения о конструкторе iOS](~/ios/user-interface/designer/introduction.md)
- [Преобразование в раскадровки](https://developer.apple.com/library/ios/#releasenotes/Miscellaneous/RN-AdoptingStoryboards/)
- [Справочник по классам Уисторибоард](https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIStoryboard_Class/Reference/Reference.html)
