---
title: Работа с tvOS навигацией и фокусом в Xamarin
description: В этой статье рассматриваются концепции фокус и как она используется для представления и обработки переходов внутри приложения Xamarin.tvOS.
ms.prod: xamarin
ms.assetid: DD72E95F-AE9B-47D2-B132-5FA5FBD8026E
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/16/2017
ms.openlocfilehash: 3cb8d1c1d92146e70056c6cf562f2fa1cb028e7c
ms.sourcegitcommit: 946ce514fd6575aa6b93ff24181e02a60b24b106
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2019
ms.locfileid: "58677876"
---
# <a name="working-with-tvos-navigation-and-focus-in-xamarin"></a>Работа с tvOS навигацией и фокусом в Xamarin

_В этой статье рассматриваются концепции фокус и как она используется для представления и обработки переходов внутри приложения Xamarin.tvOS._


В этой статье рассматриваются концепции [фокус](#Focus-and-Selection) и как она используется для обработки [навигации](#Navigation) в пользовательском интерфейсе приложения Xamarin.tvOS. Мы рассмотрим, как использовать встроенные tvOS элементы управления навигацией по фокуса, выделения и выделения для обеспечения навигации приложения Xamarin.tvOS.

[![](navigation-focus-images/intro01.png "приложения tvOS навигации")](navigation-focus-images/intro01.png#lightbox)

Далее мы рассмотрим использование фокус с [фокусировки](#Focus-and-Parallax) и *многослойные образы* для предоставления визуальные подсказки для текущего состояния навигации для конечного пользователя.

Наконец, мы рассмотрим работа с [фокус](#Working-with-Focus), [обновления фокус](#Working-with-Focus-Updates), [направляющие фокус](#Working-with-Focus-Guides), [фокус в коллекциях](#Working-with-Focus-in-Collections) и [ Включение фокусировки](#enabling-parallax) на представления изображения в приложениях Xamarin.tvOS.

<a name="Navigation" />

## <a name="navigation"></a>Навигация

Пользователей приложения Xamarin.tvOS не взаимодействует с его интерфейсом непосредственно как с помощью iOS где они коснитесь изображения на экране устройства, но косвенно из в комнате с помощью [Siri Remote](~/ios/tvos/platform/remote-bluetooth.md#The-Siri-Remote). Необходимо это помнить при проектировании пользовательского интерфейса вашего приложения, чтобы он естественным образом потоки, но сохранение занимается Apple TV интерфейс пользователя.

Приложение успешно tvOS реализует навигации способом, который беспрепятственно поддерживает назначение приложения и структуры данных, которые он представляет без вызова внимание на панели навигации, сам. Проектируйте переходы, таким образом, чтобы полагают, что естественным и знакомых без тратиться пользовательского интерфейса или рисования фокуса из содержимого и взаимодействие с пользователем приложения.

[![](navigation-focus-images/nav01.png "Параметры приложения tvOS")](navigation-focus-images/nav01.png#lightbox)

Хотя обычно с помощью Apple TV, пользователь переходит по с накоплением набор экранов, каждого представления данного набора содержимого. В свою очередь, каждый новый экран может привести к один или несколько вложенных экранов содержимого с помощью стандартных элементов управления пользовательского интерфейса, такие как [кнопки](~/ios/tvos/user-interface/buttons.md), [панели вкладки](~/ios/tvos/user-interface/tab-bars.md), таблиц, [представления коллекций](~/ios/tvos/user-interface/collection-views.md) или [ Разделять представления](~/ios/tvos/user-interface/split-views.md).

Каждый новый экран данных пользователь перемещается глубже в этот стек экранов. С помощью **меню** кнопки на удаленном Siri, они могут перейти назад по стеку, чтобы вернуться к предыдущему экрану или главного меню.

Apple рекомендует придерживаться указанных, помня о следующих при разработке навигации для вашего приложения tvOS:

- **Макет навигации сделать поиск содержимого файлов и Easy** -пользователей для доступа к содержимому в приложении наименьшее число касания, щелкает и предъявляет максимально. Упрощение навигации и Упорядочивайте содержимое для минимальное число экранов.
- **Создать поток интерфейса с помощью Touch** -убедитесь, что пользователь может перемещаться между _, способному получать фокус элементов_ с минимальными трения с помощью наименьшее число возможных жестов.
- **Проектирование с фокусом в виду** -так, как пользователь взаимодействует с содержимым в комнате, им нужно переместить фокус на элемент пользовательского интерфейса до взаимодействия с ним с помощью удаленного Siri. Пользователи будут получать разочарованы с вашим приложением, если требуется слишком много жесты для них для достижения поставленных целей.
- **Укажите обратной навигации с помощью кнопки меню** , создайте простой и знакомой взаимодействие, позволяющее пользователям перемещаться назад с помощью Siri Remote **меню** кнопки. Нажав клавишу **меню** кнопки всегда следует вернуться к предыдущему экрану или вернуться в главное меню приложения. В приложения верхнего уровня, нажав клавишу **меню** кнопка должна возвращать Apple TV начального экрана.
- **Обычно следует избегать, отображение кнопки Назад** — так, как нажатие **меню** кнопки на удаленном Siri производит переход назад по стеку экрана, избежать отображения дополнительного элемента управления, которое дублирует это поведение. Исключением из этого правила является по приобретению экранов или на экранах с разрушительные действия (например, удаление содержимого) где **отменить** также должна появиться кнопка.
- **Показать больших коллекций на одном экране, а не на нескольких** -удаленного Siri предназначены для упрощения перемещения по большое количество содержимого быстро и просто выполняется с помощью жестов. Если ваше приложение поддерживает большое количество элементов, способному получать фокус, следует сохранить их на одном экране вместо остановом много экранов, которые требуют дополнительные навигации со стороны пользователя.
- **Используйте стандартные элементы управления для переходов** -еще раз, чтобы создать интерфейс пользователя простым и понятным, везде, где это возможно, воспользоваться встроенным `UIKit` элементы управления, например элементов управления на странице, панели вкладки, Сегментированные элементы управления, таблицы, представления коллекции и разбиение Представления для навигации приложения. Так как пользователь уже знакомы с этими элементами, они интуитивно будут можете перейти в приложение.
- **Предпочитать горизонтальной навигации по содержимому** -из-за природы Apple TV, проводя пальцем слева направо на удаленном Siri является более естественным, чем вверх и вниз. Рекомендуется использовать этот вариант, при разработке макетов содержимого для вашего приложения.

<a name="Focus-and-Selection" />

## <a name="focus-and-selection"></a>Фокус и выделенный фрагмент

На Apple TV, изображения, кнопки или другого элемента пользовательского интерфейса будет считаться _в фокусе_ когда она является целевым объектом текущего перехода.

[![](navigation-focus-images/focus01.png "Пример фокуса и выделения")](navigation-focus-images/focus01.png#lightbox)

В отличие от, устройства iOS, где пользователь напрямую взаимодействует с элементами на сенсорном экране устройства пользователи взаимодействуют с tvOS элементы из двух зала, с помощью удаленного Siri. Для представления и управления взаимодействием с пользователем, Apple TV использует _фокус_ модель на основе.

С помощью жестов и кнопку нажимает на [Siri Remote](~/ios/tvos/platform/remote-bluetooth.md#The-Siri-Remote), пользователь перемещает фокус от одного элемента пользовательского интерфейса в другую. После был перемещен фокус к нужному элементу, пользователь нажимает кнопку, выберите содержимое или активировать действие, представленное этого элемента.

При изменении фокуса элегантной анимации и эффектов (например, в образах эффекта фокусировки) используются для четкого определения элемент пользовательского интерфейса, который в данный момент имеет фокус.

Apple имеет следующие рекомендации по работе с фокусом.

- **Применять встроенные элементы управления пользовательского интерфейса для эффектов движения** — с помощью `UIKit` и API фокус в пользовательском интерфейсе, модель фокус будет автоматически применен движения по умолчанию и визуальные эффекты к элементы пользовательского интерфейса. Это делает приложение кажется машинного и знакомы пользователям функции платформы Apple TV и обеспечивает гибкость и интуитивно понятный перемещения между элементами, способному получать фокус.
- **Перемещение фокуса в направлениях ожидается** -на Apple TV, почти каждый элемент использует косвенную манипуляции. Например пользователь использует удаленный Siri для перемещения фокуса, и система автоматически прокручивается интерфейс, чтобы закрепить элемент, в данный момент имеющий фокус. Если приложение реализует такой тип взаимодействия, убедитесь, что фокус перемещается в направлении жест пользователя. Поэтому если пользователь прямо на считайте фокус Siri Remote следует переместить вправо (что может вызвать экрана, чтобы прокрутить влево). Единственное исключение для этого правила — во весь экран элементы, использующие непосредственной работы со (где экрану вверх перемещает элемент вверх).
- **Убедитесь, что элемент с фокусом ввода очевидна** -так, как пользователи взаимодействуют с элементы пользовательского интерфейса из удаленного местоположения, крайне важно, что элемент в фокусе выделяется среди. Обычно это выполняется автоматически по встроенному `UIKit` элементов. Для пользовательских элементов управления используйте функции, такие как размер элемента или тени для отображения фокус.
- **Использовать фокусировки, чтобы сделать фокус элементов быстрые** — мелкий, циклические жесты на удаленном Siri привести легкими, в режиме реального времени перемещения элемента, имеющего фокус. Это [эффекта фокусировки](#Focus-and-Parallax) встроена в `UIKit` _многослойные образы_ дать пользователю представление о подключения для элемента, имеющего фокус.
- **Создание, способному получать фокус элементов соответствующего размера** -крупных элементов с интервалом, можно в полной мере упрощает выбор и перемещение элементов меньшего размера.
- **Элемент пользовательского интерфейса для поиска хороший либо или отделу кадров Unfocused разработки** -обычно Apple TV представляет элемент с фокусом ввода, увеличив его размер. Убедитесь, что элементы пользовательского интерфейса в свои приложения выглядеть прекрасно справляется с любого размера представления и, при необходимости, указать ресурсы для более крупных размеров элементов.
- **Изменения фокуса гибкого представляют** -используйте анимацию плавно Исчезание между элементами **Focused** и **Unfocused** состояние для сохранения переходы препятствия резать глаз.
- **Не отображать курсор** -пользователи ожидают, что для перехода вашего приложения пользовательского интерфейса с помощью фокус и не перемещая курсор по экрану. Пользовательский интерфейс всегда следует использовать модель фокус для предоставления согласованного пользовательского интерфейса.

<a name="Working-with-Focus" />

### <a name="working-with-focus"></a>Работа с фокусом

Возможны ситуации, которые вы хотите создать настраиваемый элемент управления, который может стать, способному получать фокус элемента. Если переопределить так `CanBecomeFocused` свойства и возвращаемые `true`, в противном случае возвращаемое `false`. Пример:

```csharp
public class myView : UIView
{
    public override bool CanBecomeFocused {
        get {return true;}
    }
}
```

В любое время можно использовать `Focused` свойство `UIKit` элемента управления, является ли текущий элемент. Если `true` элемент пользовательского интерфейса в данный момент имеет фокус, в противном случае это не так. Пример:

```csharp
// Is my view in focus?
if (myView.Focused) {
    // Do something
    ...
}
```

Хотя нельзя перемещать непосредственно фокус на другой элемент пользовательского интерфейса с помощью кода, можно указать, какой элемент пользовательского интерфейса, сначала получает фокус, когда экран загружается путем задания его `PreferredFocusedView` свойства `true`. Пример:

```csharp
// Make the play button the starting focus item
playButton.PreferredFocusedView = true;
```

<a name="Working-with-Focus-Updates" />

### <a name="working-with-focus-updates"></a>Работа с обновлениями фокус 

Когда пользователь вызывает перемещение фокуса от одного элемента пользовательского интерфейса на другой (например, в ответ на жест на удаленном Siri) _событие обновления фокус_ будет отправляться элемент теряет фокус и элемента, получившего фокус.

Для пользовательских элементов, которые наследуют `UIView` или `UIViewController`, можно переопределить несколько методов для работы с событием фокус обновления:

- **DidUpdateFocus** -этот метод будет вызываться при каждом представлении Получает или теряет фокус.
- **ShouldUpdateFocus** -этот метод позволяет определить, где разрешено перемещать фокус.

Для запроса, что ядро фокус перемещается фокус обратно в `PreferredFocusedView` элемент пользовательского интерфейса, вызов `SetNeedsUpdateFocus` метод контроллера представления.

> [!IMPORTANT]
> Вызов `SetNeedsUpdateFocus` действует, только если он вызывается для контроллера представления содержит представление, которое в данный момент имеет фокус.




<a name="Working-with-Focus-Guides" />

### <a name="working-with-focus-guides"></a>Работа с направляющими фокус

Ядро фокус, встроенные в tvOS отлично обработки перемещения между элементами, приходящиеся на и горизонтальной сетки. Как правило необходимо ничего не делать больше, чем добавить элементы пользовательского интерфейса для дизайн интерфейса и ядро фокус автоматически будет обрабатывать перемещение между этими элементами, не привлекая разработчиков.

Однако возможны ситуации, из-за вещах конструкции пользовательского интерфейса, когда элементы пользовательского интерфейса, не попадающие в горизонтальной и вертикальной сетки и могут быть недоступны, поскольку они являются диагональный друг с другом. Это происходит, так как ядро фокус был разработан для обработки простых вверх, вниз, влево и вправо перемещения между только элементы пользовательского интерфейса.

Выполните следующий пример макета пользовательского интерфейса.

 [![](navigation-focus-images/guide01.png "Работа с примером направляющие фокус")](navigation-focus-images/guide01.png#lightbox)
 
Так как **детали** кнопки не попадает в сетка с горизонтальной и вертикальной **купить** кнопки, он станет недоступным для пользователя. Тем не менее, это можно легко исправить с помощью _руководство по_ указания перемещения в подсистему фокус. 

Руководство по фокус (`UIFocusGuide`) предоставляет невидимые область представления, как и Focusable обработчик фокус, таким образом, фокус перенаправить в другое представление.

Таким образом, чтобы решить, приведенном выше примере, следующий код удалось добавить контроллер представления для создания структуры фокус между **детали** и **купить** кнопки:

```csharp
public UIFocusGuide FocusGuide = new UIFocusGuide ();
...

public override void ViewDidLoad ()
{
    base.ViewDidLoad ();

    // Add Focus Guide to layout
    View.AddLayoutGuide (FocusGuide);

    // Define Focus Guide that will allow the user to move
    // between the More Info and Buy buttons.
    FocusGuide.LeftAnchor.ConstraintEqualTo (BuyButton.LeftAnchor).Active = true;
    FocusGuide.TopAnchor.ConstraintEqualTo (MoreInfoButton.TopAnchor).Active = true;
    FocusGuide.WidthAnchor.ConstraintEqualTo (BuyButton.WidthAnchor).Active = true;
    FocusGuide.HeightAnchor.ConstraintEqualTo (MoreInfoButton.HeightAnchor).Active = true;
}
```

Во-первых, новый `UIFocusGuide` создается и добавляется в коллекцию направляющая макета представления с помощью `AddLayoutGuide` метод.

Далее в руководстве по фокус верхней, слева, ширины и высоты привязки настраиваются относительно **детали** и **купить** расположите его между ними. Пример

[![](navigation-focus-images/guide02.png "Руководство с примерами фокус")](navigation-focus-images/guide02.png#lightbox)

Также важно отметить, что новых ограничений активируются при их создании, задав их `Active` свойства `true`:

```csharp
FocusGuide.LeftAnchor.ConstraintEqualTo (...).Active = true;
```

С новой структуры фокус устанавливается и добавить представления, контроллер представления `DidUpdateFocus` метод может быть переопределен и добавлен следующий код для перемещения между **детали** и **купить** кнопки:

```csharp
public override void DidUpdateFocus (UIFocusUpdateContext context, UIFocusAnimationCoordinator coordinator)
{
    base.DidUpdateFocus (context, coordinator);

    // Get next focusable item from context
    var nextFocusableItem = context.NextFocusedView;

    // Anything to process?
    if (nextFocusableItem == null) return;

    // Decide the next focusable item based on the current
    // item with focus
    if (nextFocusableItem == MoreInfoButton) {
        // Move from the More Info to Buy button
        FocusGuide.PreferredFocusedView = BuyButton;
    } else if (nextFocusableItem == BuyButton) {
        // Move from the Buy to the More Info button
        FocusGuide.PreferredFocusedView = MoreInfoButton;
    } else {
        // No valid move
        FocusGuide.PreferredFocusedView = null;
    }
}
```

Во-первых, этот код get `NextFocusedView` из `UIFocusUpdateContext` , были переданы (`context`). Если это представление является `null`, обработка не требуется и выход из метода.

Далее, `nextFocusableItem` вычисляется. Если он соответствует либо **детали** или **купить** кнопки, фокус отправляется противоположной кнопки с помощью структуре фокус `PreferredFocusedView` свойство. Пример:

```csharp
// Move from the More Info to Buy button
FocusGuide.PreferredFocusedView = BuyButton;
```

В случае, если ни одна из кнопок является источником смены фокуса, `PreferredFocusedView` свойство:

```csharp
// No valid move
FocusGuide.PreferredFocusedView = null;
```

<a name="Working-with-Focus-in-Collections" />

### <a name="working-with-focus-in-collections"></a>Работа с фокусом в коллекциях

При выборе отдельного элемента можно ли фокус в `UICollectionView` или `UITableView`, будет переопределить методы `UICollectionViewDelegate` или `UITableViewDelegate` соответственно. Пример:

```csharp
public class CardHandDelegate : UICollectionViewDelegateFlowLayout
{
    ...
    public override bool CanFocusItem (UICollectionView collectionView, NSIndexPath indexPath)
    {
        if (indexPath == null) {
            return false;
        } else {
            var controller = collectionView as CardHandViewController;
            return !controller.Hand [indexPath.Row].IsFaceDown;
        }
    }
}
```

`CanFocusItem` Возвращает `true` Если текущий элемент не находится в фокусе, в противном случае он возвращает `false`.

Если вы хотите, чтобы `UICollectionView` или `UITableView` запоминать и вернуть фокус до последнего элемента при потере и снова получит фокус, задайте `RemembersLastFocusedIndexPath` свойства `true`.

<a name="Focus-and-Parallax" />

## <a name="focus-and-parallax"></a>Фокус и фокусировки

Как уже говорилось выше, это элемент пользовательского интерфейса будет считаться _в фокусе_ когда это текущий элемент во время события навигации. Как правило, как элемент поступает от фокуса немного изменением его размера и ее визуально повышения с помощью тень. 

Если пользователь делает жест медленно, циклические на удаленном Siri, элемент с фокусом ввода будет sway в режиме реального времени, в ответ на это перемещение. По мере sway оформленный sheen применяется к своего изображения, делая области отображаются в разметке. После заданного периода бездействия любое содержимое в фокусе out затемняется и фокуса элемента будет увеличиваться еще больше. 

Эти эффекты работают вместе для обеспечения умственной соединения между содержимое на экране ТВ и пользователь, взаимодействующий с Apple TV, хранящиеся на диске.

На Apple TV этот эффект фокусировки для передачи чувства глубину объемной и dynamics и фокус элементов используется во всей системе. tvOS с помощью серии прозрачным, [многослойные образы](~/ios/tvos/app-fundamentals/icons-images.md#Layered-Images) которого он перемещается в соответствии с динамически создать этот эффект.

Многоуровневые образы являются обязательными для значка приложения tvOS и поддерживается для динамических Top Shelf содержимого. Не обязательно, Apple настоятельно советует реализация многослойные образы в других, способному получать фокус элементов в пользовательском Интерфейсе приложения.

### <a name="enabling-parallax"></a>Включение фокусировки

`UIImageView` Управления (или любой элемент управления, который наследует от `UIImageView`) автоматически поддерживает эффекта фокусировки. По умолчанию эта поддержка отключена, чтобы включить его, используйте следующий код:

```csharp
myImageView.AdjustsImageWhenAncestorFocused = true;
```

С помощью этого свойства задано `true`, представление изображений автоматически получат эффекта фокусировки, когда он выбран пользователем и в фокусе.

<a name="Summary" />

## <a name="summary"></a>Сводка

В этой статье подробно рассматривается концепция фокус и как она используется для обработки навигации в пользовательском интерфейсе приложения Xamarin.tvOS. Его изучить, как использовать встроенные tvOS элементы управления для перемещения фокуса, выделения и выделения для обеспечения навигации. Затем его рассматривали как фокус может использоваться с фокусировки и многослойные образы для предоставляют визуальные подсказки для текущего состояния навигации для конечного пользователя. Наконец он проверяет работу с фокус, фокус обновлений, фокус в коллекции и включение фокусировки.




## <a name="related-links"></a>Связанные ссылки

- [Примеры tvOS](https://developer.xamarin.com/samples/tvos/all/)
- [tvOS](https://developer.apple.com/tvos/)
- [Человека направляющие интерфейса tvOS](https://developer.apple.com/tvos/human-interface-guidelines/)
- [Приложение руководство по программированию для tvOS](https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/)
