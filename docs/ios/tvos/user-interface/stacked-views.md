---
title: Работа с представлениями с накоплением tvOS в Xamarin
description: В этом документе описывается работали с tvOS с накоплением представления в приложении, созданном с помощью Xamarin. Он представлен общий обзор с накоплением представлений и обсуждаются автоматический макет, положения и размера представления с накоплением, распространенные использует, интеграция с раскадровками и многое другое.
ms.prod: xamarin
ms.assetid: 00B07F85-F30B-4DD4-8664-A61D0A1CDB0E
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/16/2017
ms.openlocfilehash: f51ed3d6dbbfc8a7e430c2949485838a7471e545
ms.sourcegitcommit: e268fd44422d0bbc7c944a678e2cc633a0493122
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50110769"
---
# <a name="working-with-tvos-stacked-views-in-xamarin"></a>Работа с представлениями с накоплением tvOS в Xamarin

Элемент управления представление стека (`UIStackView`) использует возможности автоматического макета и размеры для управления стек представлений, горизонтально или вертикально, который динамически реагирует на изменения содержимого и размера экрана устройства Apple TV.

В зависимости от разработчика определенные свойства, такие как оси, распространение, выравнивание и интервал управляются макет всех вложенных представлений, прикреплено к представлению стека:

[![](stacked-views-images/stacked01.png "Вложенное представление Макет схемы")](stacked-views-images/stacked01.png#lightbox)

При использовании `UIStackView` в приложении Xamarin.tvOS, разработчик может определить либо вложенных представлений, либо внутри раскадровки в конструкторе iOS, или путем добавления и удаления представлений в C# кода.

## <a name="about-stacked-view-controls"></a>Сведения об элементах управления представления с накоплением 

`UIStackView` Разработан как представление не визуализируемых контейнера и таким образом, для ее правильной ориентации на холст, как и другие подклассы `UIView`. Установка свойств, таких как `BackgroundColor` или переопределение `DrawRect` не будет действовать visual.

Существует несколько свойств, определяющих, как представление стека всей коллекции вложенных представлений.

- **Оси** — определяет, если представление стека упорядочивает вложенные представления либо **горизонтально** или **вертикально**.
- **Выравнивание** — управляет выравниванием вложенные представления в виде стека.
- **Распределение** — определяет способ изменения размеров вложенные представления в виде стека.
- **Интервал между** — определяет минимальное расстояние между каждой вложенное представление в представление стека.
- **Относительно базовых показателей** — Если `true`, вертикальный интервал каждого вложенное представление будет получен из его базовых показателей.
- **Макет поля относительный** — помещает вложенные представления относительно полей стандартным макетом.

Обычно для размещения небольшого числа вложенных представлений используется представление стека. Более сложные пользовательские интерфейсы могут создаваться путем вложения одно или несколько представлений стек друг в друга.

Дополнительно можно точно настроить внешний пользовательских интерфейсов, добавив дополнительные ограничения вложенные представления (например, элементу управления, высоты или ширины). Однако следует соблюдать осторожность не будет включать конфликтующими ограничениями на появляющиеся, представление стека сам.

<a name="Auto-Layout-and-Size-Classes" />

## <a name="auto-layout-and-size-classes"></a>Автоматический макет и размеры

При добавлении в представление стека вложенное представление макета полностью управляется, представление стека, с помощью автоматического макета и размеры позиция и размер упорядоченный представления.

Представление стека будет _ПИН-код_ вложенное представление первый и последний в своей коллекции, чтобы **верхней** и **нижней** границы для создания представления по вертикали стека или **слева**и **справа** границы для создания представлений по горизонтали стека. Если задать `LayoutMarginsRelativeArrangement` свойства `true`, а затем представление фиксирует вложенные представления на соответствующие поля, а не в edge.

Представление стека использует вложенное представление `IntrinsicContentSize` свойство при вычислении размера вложенных представлений вдоль определенного `Axis` (за исключением `FillEqually Distribution`). `FillEqually Distribution` Изменяет размер всех вложенных представлений, чтобы они имеют одинаковый размер, таким образом, заполняя представление стека вдоль `Axis`.

За исключением элемента `Fill Alignment`, представление стека использует вложенное представление `IntrinsicContentSize` свойство для вычисления размера представления перпендикулярно заданного `Axis`. Для `Fill Alignment`, все вложенные представления имеют размер, чтобы они полностью заполняли представление стека, перпендикулярно заданного `Axis`.

<a name="Positioning-and-Sizing-the-Stack-View" />

## <a name="positioning-and-sizing-the-stack-view"></a>Изменение положения и размера представление стека

Хотя представление стека имеет полный контроль над макетом любой вложенное представление (на основе свойств таких как `Axis` и `Distribution`), по-прежнему необходимо разместить представление стека (`UIStackView`) в рамках его родительского представления, с помощью автоматического макета и размеры.

Как правило это означает, по крайней мере две границы представления Stack, чтобы разворачивать и сворачивать, определив тем самым его положение закрепления. Без дополнительных ограничений представление стека будет изменяться автоматически для всех вложенных представлений следующим образом:

* Размер вдоль ее `Axis` будет суммой всех размеров вложенное представление, а также любое пространство, который был определен между каждой вложенное представление.
* Если `LayoutMarginsRelativeArrangement` свойство `true`, размер стека представления также будет содержать место для поля.
* Размер перпендикулярно `Axis` будет указано значение наибольшего вложенное представление в коллекции.

Кроме того, можно задать ограничения для представления Stack **высота** и **ширины**. В этом случае вложенные представления будут размещены (размера) для заполнения пространства согласно заданному значению представление стека, что определяется `Distribution` и `Alignment` свойства.

Если `BaselineRelativeArrangement` свойство `true`, вложенные представления будут размещены зависимости от базового плана первой или последней вложенное представление элемента, вместо использования **верхней**, **нижней** или **Center* -  **Y** позиции. Они вычисляются в содержимом представление стека следующим образом:

* Возвращает вертикальное представление стека первый вложенное представление для базового плана первой и последней последнего. Если любой из этих представлений, сами стек представлений, то будет использоваться первый или последний базовому плану.
* Горизонтальное представление стека будет использовать его высокого вложенное представление для первого и последнего базового плана. Если высокого представление является также представление стека, он будет использовать его высокого вложенное представление в качестве базовых показателей.

> [!IMPORTANT]
> Выравнивание базового плана работает на вложенное представление растянутым или сжатый размер базового плана вычисляется в неправильное расположение. Выравнивание базового плана, убедитесь, что вложенное представление **высота** соответствие встроенных содержимого представления **высота**.




<a name="Common-Stack-View-Uses" />

## <a name="common-stack-view-uses"></a>Наиболее частые способы представление стека

Существует несколько типов макета, которые подходят для элементов управления в представление стека. В соответствии с Apple ниже приведены некоторые из наиболее распространенных.

- **Определить размер вдоль оси** — путем закрепления к обеим границам вдоль представление стека `Axis` и одной из смежных границ, чтобы установить позицию, стек будет увеличиваться представления вдоль оси в соответствии с пространство, определяемое вложенных представлений.
*  **Определить положение вложенное представление** —, закрепив на смежные края представление стека для его родительского представления, представление стека будет увеличиваться обоим измерениям в соответствии с его содержащего вложенных представлений.
- **Определить размер и положение стека** – закрепление всех четырех краев представление стека родительскому представлению, представление стека упорядочивает вложенных представлений, в зависимости от места, определенные в представление стека.
*  **Определить размер перпендикулярной осью** — путем закрепления обе границы перпендикулярно представление стека `Axis` и одной из границ вдоль оси, чтобы установить позицию, стека, представление будет увеличиваться перпендикулярно оси в соответствии с пространству, определенному его вложенные представления.

<a name="Stack-Views-and-Storyboards" />

## <a name="stack-views-and-storyboards"></a>Стек представлений и раскадровки

Для работы с представлениями стека в приложении Xamarin.tvOS проще всего добавить их в пользовательском Интерфейсе приложения с помощью конструктора iOS.

# <a name="visual-studio-for-mactabmacos"></a>[Visual Studio для Mac](#tab/macos)

1. В **панели решения**, дважды щелкните `Main.storyboard` и откройте его для редактирования.
1. Разработка макета на отдельные элементы, которые нужно добавить в представление стека: 

    [![](stacked-views-images/layout01.png "Пример макета элемента")](stacked-views-images/layout01.png#lightbox)
1. Добавьте все необходимые ограничения для элементов, чтобы убедиться, что они правильно масштабировать. Этот шаг важен, когда элемент добавляется в представление стека.
1. Внесите необходимое количество копий (четыре в данном случае). 

    [![](stacked-views-images/layout02.png "Необходимое количество копий")](stacked-views-images/layout02.png#lightbox)
1. Перетащите **представление стека** из **элементов** и поместите его в представлении: 

    [![](stacked-views-images/layout03.png "Представление стека")](stacked-views-images/layout03.png#lightbox)
1. Выберите представление стека, в **вкладку графического** из **панели свойств** выберите **заполнения** для **выравнивание**, **заполнения Столь же** для **распространения** и введите `25` для **интервал**: 

    [![](stacked-views-images/layout04.png "На вкладке мини-приложения")](stacked-views-images/layout04.png#lightbox)
1. Поместите представление стека на экране, где его и добавить ограничения, чтобы сохранить в требуемом месте.
1. Выбирать отдельные элементы и перетащите их в представление стека: 

    [![](stacked-views-images/layout05.png "Отдельные элементы в представление стопки")](stacked-views-images/layout05.png#lightbox)
1. Макет будет впоследствии скорректирована и элементы будут расположены в представление стека, исходя из атрибутов, заданных выше.
1. Назначить **имена** в **вкладку графического** из **обозревателе свойств** для работы с элементами управления пользовательского интерфейса в C# кода.
1. Сохраните изменения.

# <a name="visual-studiotabwindows"></a>[Visual Studio](#tab/windows)

1. В **обозревателе решений**, дважды щелкните `Main.storyboard` и откройте его для редактирования.
1. Разработка макета на отдельные элементы, которые нужно добавить в представление стека: 

    [![](stacked-views-images/layout01.png "Пример размещения элемента")](stacked-views-images/layout01.png#lightbox)
1. Добавьте все необходимые ограничения для элементов, чтобы убедиться, что они правильно масштабировать. Этот шаг важен, когда элемент добавляется в представление стека.
1. Внесите необходимое количество копий (четыре в данном случае). 

    [![](stacked-views-images/layout02.png "Необходимое количество копий")](stacked-views-images/layout02.png#lightbox)
1. Перетащите **представление стека** из **элементов** и поместите его в представлении: 

    [![](stacked-views-images/layout03-vs.png "Представление стека")](stacked-views-images/layout03-vs.png#lightbox)
1. Выберите представление стека, в **вкладку графического** из **обозревателе свойств** выберите **заполнения** для **выравнивание**, **заполнения Столь же** для **распространения** и введите `25` для **интервал**: 

    [![](stacked-views-images/layout04-vs.png "На вкладке мини-приложения")](stacked-views-images/layout04-vs.png#lightbox)
1. Поместите представление стека на экране, где его и добавить ограничения, чтобы сохранить в требуемом месте.
1. Выбирать отдельные элементы и перетащите их в представление стека: 

    [![](stacked-views-images/layout05-vs.png "Отдельные элементы в представление стопки")](stacked-views-images/layout05-vs.png#lightbox)
1. Макет будет впоследствии скорректирована и элементы будут расположены в представление стека, исходя из атрибутов, заданных выше.
1. Назначить **имена** в **вкладку графического** из **обозревателе свойств** для работы с элементами управления пользовательского интерфейса в C# кода.
1. Сохраните изменения.

-----

> [!IMPORTANT]
> Хотя можно назначить действия, такие как `TouchUpInside` элемента пользовательского интерфейса (такие как `UIButton`) в iOS Designer, при создании обработчика событий, он никогда не вызывается так, как Apple TV нет на сенсорном экране или поддерживает события касания. Следует всегда использовать значение по умолчанию `Action Type` при создании действия для tvOS элементы пользовательского интерфейса.

Дополнительные сведения о работе с раскадровками, см. в разделе наших [по Tvos краткое руководство по](~/ios/tvos/get-started/hello-tvos.md).

В нашем примере мы предоставили розетки и действие для элемента управления сегмента и переменной экземпляра для каждой» карточки player». В коде мы скрытие и отображение проигрывателя на основе текущего сегмента. Пример:

```csharp
partial void PlayerCountChanged (Foundation.NSObject sender) {

    // Take Action based on the segment
    switch(PlayerCount.SelectedSegment) {
    case 0:
        Player1.Hidden = false;
        Player2.Hidden = true;
        Player3.Hidden = true;
        Player4.Hidden = true;
        break;
    case 1:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = true;
        Player4.Hidden = true;
        break;
    case 2:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = false;
        Player4.Hidden = true;
        break;
    case 3:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = false;
        Player4.Hidden = false;
        break;
    }
}
```

При запуске приложения, четырех элементов одинаково распространяются в наше представление стека:

[![](stacked-views-images/layout06.png "При запуске приложения, четырех элементов одинаково распространяются в наше представление стека")](stacked-views-images/layout06.png#lightbox)

Если число исполнителей уменьшилось, скрыты неиспользуемого представления и представление стека измените макет в соответствии с:

[![](stacked-views-images/layout07.png "Если число исполнителей уменьшилось, скрыты неиспользуемого представления и представление стека настроить макет в соответствии с")](stacked-views-images/layout07.png#lightbox)

<a name="Populate-a-Stack-View-from-Code" />

### <a name="populate-a-stack-view-from-code"></a>Заполнить представление стека из кода

Кроме определения полностью содержимое и макет представления стека в конструкторе iOS, можно создать и удалить его из динамически C# кода.

Рассмотрим следующий пример, использующий представление стека для обработки «звезды» при проверке (от 1 до 5):

```csharp
public int Rating { get; set;} = 0;
...

partial void IncreaseRating (Foundation.NSObject sender) {

    // Maximum of 5 "stars"
    if (++Rating > 5 ) {
        // Abort
        Rating = 5;
        return;
    }

    // Create new rating icon and add it to stack
    var icon = new UIImageView (new UIImage("icon.png"));
    icon.ContentMode = UIViewContentMode.ScaleAspectFit;
    RatingView.AddArrangedSubview(icon);

    // Animate stack
    UIView.Animate(0.25, ()=>{
        // Adjust stack view
        RatingView.LayoutIfNeeded();
    });

}

partial void DecreaseRating (Foundation.NSObject sender) {

    // Minimum of zero "stars"
    if (--Rating < 0) {
        // Abort
        Rating =0;
        return;
    }

    // Get the last subview added
    var icon = RatingView.ArrangedSubviews[RatingView.ArrangedSubviews.Length-1];

    // Remove from stack and screen
    RatingView.RemoveArrangedSubview(icon);
    icon.RemoveFromSuperview();

    // Animate stack
    UIView.Animate(0.25, ()=>{
        // Adjust stack view
        RatingView.LayoutIfNeeded();
    });
}
```

Давайте взглянем на несколько частей этого кода подробно. Во-первых, мы используем `if` инструкции, чтобы проверить, что существует не более пяти «звезды» или меньше нуля.

Чтобы добавить новый «звезда» сейчас загрузить изображения и задайте его **режиме содержимого** для **помещаются аспект масштабирования**:

```csharp
var icon = new UIImageView (new UIImage("icon.png"));
icon.ContentMode = UIViewContentMode.ScaleAspectFit;
```

Это предотвращает искажено, при добавлении в представление стека значок «звезда».

Далее мы добавим значок "Создать «"типа звезда "»" представление стека коллекцию вложенных представлений:

```csharp
RatingView.AddArrangedSubview(icon);
```

Вы заметите, что мы добавили `UIImageView` для `UIStackView` `ArrangedSubviews` свойства, а не `SubView`. Необходимо добавить любое представление, что нужно добавить представление стека для управления макета `ArrangedSubviews` свойство.

Сначала удалить вложенное представление из представления Stack, мы получаем вложенное представление для удаления:

```csharp
var icon = RatingView.ArrangedSubviews[RatingView.ArrangedSubviews.Length-1];
```

Затем нам нужно удалить его из обоих `ArrangedSubviews` коллекции и представления Super:

```csharp
// Remove from stack and screen
RatingView.RemoveArrangedSubview(icon);
icon.RemoveFromSuperview();
```

Удаление вложенное представление с только что `ArrangedSubviews` коллекции принимает его выход из элемента управления представление стека, но не удаляет ее на экране.

<a name="Dynamically-Changing-Content" />

## <a name="dynamically-changing-content"></a>Динамическое изменение содержимого

Представление стека автоматически настроит макет вложенных представлений, каждый раз, когда вложенное представление добавлены, удалены или скрыт. Макет будет впоследствии также скорректирована если корректируется представление стека любого свойства (такие как его `Axis`).

Изменения макета могут быть анимированы, поместив их внутри блока анимации, например:

```csharp
// Animate stack
UIView.Animate(0.25, ()=>{
    // Adjust stack view
    RatingView.LayoutIfNeeded();
});
```

Многие из свойств этого представления стека можно указать с помощью классов размера в раскадровке. Эти свойства будут автоматически анимации является ответ на изменения размера или ориентации.

<a name="Summary" />

## <a name="summary"></a>Сводка

В этой статье подробно рассматривается проектирование и работать с представлением с накоплением внутри приложения Xamarin.tvOS.



## <a name="related-links"></a>Связанные ссылки

- [Примеры tvOS](https://developer.xamarin.com/samples/tvos/all/)
- [tvOS](https://developer.apple.com/tvos/)
- [Человека направляющие интерфейса tvOS](https://developer.apple.com/tvos/human-interface-guidelines/)
- [Приложение руководство по программированию для tvOS](https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/)
