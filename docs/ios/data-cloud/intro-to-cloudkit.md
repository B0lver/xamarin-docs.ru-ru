---
title: CloudKit в Xamarin. iOS
description: В этом документе описывается работа с CloudKit в Xamarin. iOS. Он содержит общие сведения о CloudKit и рассказывает о том, как его включить, удобный API CloudKit, масштабируемость, учетные записи пользователей, а также среды разработки и рабочей среде.
ms.prod: xamarin
ms.assetid: 66B207F2-FAA0-4551-B43B-3DB9F620C397
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 05/11/2016
ms.openlocfilehash: a01f0075ec7f47d6653313ea50047b7f89529bc6
ms.sourcegitcommit: 00e6a61eb82ad5b0dd323d48d483a74bedd814f2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/29/2020
ms.locfileid: "91431388"
---
# <a name="cloudkit-in-xamarinios"></a>CloudKit в Xamarin. iOS

Платформа CloudKit упрощает разработку приложений, обращающихся к iCloud. Сюда входит получение данных приложения и права доступа к ресурсам, а также возможность безопасного хранения сведений о приложении. Этот пакет обеспечивает пользователям уровень анонимности, предоставляя доступ к приложениям с помощью идентификаторов iCloud без предоставления персональных данных.

Разработчики могут сосредоточиться на клиентских приложениях и позволить iCloud устранять необходимость написания серверной логики приложения. CloudKit обеспечивает проверку подлинности, частные и общедоступные базы данных, а также структурированные данные и службы хранилища ресурсов.

> [!IMPORTANT]
> Компания Apple [предоставляет инструменты](https://developer.apple.com/support/allowing-users-to-manage-data/), которые помогают разработчикам надлежащим образом соблюдать Общий регламент по защите данных Европейского союза (GDPR).

## <a name="requirements"></a>Требования

Для выполнения действий, описанных в этой статье, необходимо выполнить следующие действия.

- **Xcode и пакет SDK для iOS** — API-интерфейсы Apple Xcode и iOS 8 должны быть установлены и настроены на компьютере разработчика.
- **Visual Studio для Mac** — на устройстве пользователя должна быть установлена и настроена последняя версия Visual Studio для Mac.
- **устройство iOS 8** — устройство iOS, на котором запущена последняя версия iOS 8 для тестирования.

## <a name="what-is-cloudkit"></a>Что такое CloudKit?

CloudKit — это способ предоставить разработчикам доступ к серверам iCloud. Он предоставляет основу для диска iCloud и библиотеки фотографий iCloud. CloudKit поддерживается на устройствах macOS и iOS.

[![Как CloudKit поддерживается на устройствах macOS и iOS](intro-to-cloudkit-images/image1.png)](intro-to-cloudkit-images/image1.png#lightbox)

CloudKit использует инфраструктуру учетных записей iCloud. Если пользователь вошел в учетную запись iCloud на устройстве, CloudKit будет использовать идентификатор для идентификации пользователя. Если учетная запись недоступна, будет предоставлен ограниченный доступ только для чтения.

CloudKit поддерживает концепцию общедоступных и частных баз данных. Общедоступные базы данных предоставляют «полный курс» всех данных, к которым у пользователя есть доступ. Частные базы данных предназначены для хранения частных данных, привязанных к определенному пользователю.

CloudKit поддерживает как структурированные, так и групповые данные. Она может легко обрабатывать передачу больших файлов. CloudKit обеспечивает эффективную передачу больших файлов на серверы iCloud в фоновом режиме и обратно, освобождая разработчика, чтобы сосредоточиться на других задачах.

> [!NOTE]
> Важно отметить, что CloudKit — это _транспортная технология_. Он не обеспечивает сохраняемость; Он позволяет приложению эффективно отправлять и получать данные с серверов.

На момент написания этой статьи компания Apple изначально предоставляет CloudKit бесплатно с высоким пределом пропускной способности и емкости хранилища. Для больших проектов или приложений с большой базой пользователей компания Apple предоставила, что будет предоставлена доступная ценовая шкала.

## <a name="enabling-cloudkit-in-a-xamarin-application"></a>Включение CloudKit в приложении Xamarin

Прежде чем приложение Xamarin сможет использовать CloudKit Framework, приложение должно быть правильно подготовлено, как описано в статьях [Работа с возможностями](~/ios/deploy-test/provisioning/capabilities/icloud-capabilities.md) и [Работа с](~/ios/deploy-test/provisioning/entitlements.md) руководствами по обеспечению прав.

Чтобы получить доступ к CloudKit, файл прав **. plist** должен включать разрешения **iCloud**, **хранилище ключей**и **CloudKit** .

### <a name="sample-app"></a>Пример приложения

В [примере клаудкитатлас](/samples/xamarin/ios-samples/ios8-cloudkitatlas) показано, как использовать CloudKit с Xamarin. Ниже показано, как настроить пример. он требует дополнительных параметров, помимо тех, которые требуются только для CloudKit:

1. Откройте проект в Visual Studio для Mac или Visual Studio.
2. В **Обозреватель решений**откройте файл **info. plist** и убедитесь, что **идентификатор пакета** соответствует тому, который был определен в **идентификаторе приложения** , созданном в процессе настройки подготовки.
3. Прокрутите вниз до нижней части файла **info. plist** и выберите **включенные фоновые режимы**, **обновления расположения**и **Удаленные уведомления**.
4. Щелкните правой кнопкой мыши проект iOS в решении и выберите пункт **Параметры**.
5. Выберите **Подписывание пакета iOS**, а затем выберите **удостоверение разработчика** и **профиль подготовки** , созданные выше.
6. Убедитесь, что в **plist** включены права на **Включение iCloud**, **хранение ключей**и **CloudKit**.
7. Убедитесь, что для приложения существует **контейнер для повсеместного** существования. Например, `iCloud.com.your-company.CloudKitAtlas`.
8. Сохраните изменения в файле.

После этих настроек пример приложения готов к доступу к API-интерфейсам CloudKit Framework, а также к службам фона, расположению и уведомлениям.

## <a name="cloudkit-api-overview"></a>Общие сведения об API CloudKit

Перед реализацией CloudKit в приложении Xamarin iOS в этой статье рассматриваются основные принципы CloudKit Framework, в которых рассматриваются следующие темы:

1. **Контейнеры** — изолированные приемники, взаимосвязь с iCloud.
2. **Базы данных** — общедоступные и частные — доступны для приложения.
3. **Записи** — механизм, в котором структурированные данные перемещаются в CloudKit и обратно.
4. **Зоны** записей — это группы записей.
5. **Идентификаторы записей** — полностью нормализованные и представляют конкретное расположение записи.
6. **Ссылка** — предоставление связей типа "родители-потомки" между связанными записями в заданной базе данных.
7. **Активы** — позволяют отправлять файлы больших и неструктурированных данных в iCloud и связывать их с заданной записью.

### <a name="containers"></a>Контейнеры

Данное приложение, работающее на устройстве iOS, всегда работает с другими приложениями и службами на этом устройстве. На клиентском устройстве приложение будет находиться в некотором или изолированном виде. В некоторых случаях это литеральная песочница, а в других — приложение просто выполняется в собственном пространстве памяти.

Понятие о том, что клиентское приложение и его выполнение, отделенное от других клиентов, является очень мощным и предоставляет следующие преимущества:

1. **Безопасность** — одно приложение не может мешать работе других клиентских приложений или самой ОС.
1. **Стабильность** — если клиентское приложение аварийно завершается, оно не может использовать другие приложения операционной системы.
1. **Конфиденциальность** — каждое клиентское приложение имеет ограниченный доступ к личным сведениям, хранящимся на устройстве.

CloudKit был разработан таким образом, чтобы предоставить те же преимущества, что и приведенный выше, и применить их для работы с облачной информацией:

 [![Приложения CloudKit обмениваются данными с помощью контейнеров](intro-to-cloudkit-images/image31.png)](intro-to-cloudkit-images/image31.png#lightbox)

Точно так же, как приложение выполняется на устройстве на одном компьютере, это взаимосвязь приложения с iCloud "один ко многим". Каждый из этих различных приемников соединений называется контейнерами.

Контейнеры представлены в платформе CloudKit с помощью `CKContainer` класса. По умолчанию одно приложение обращается к одному контейнеру, и этот контейнер разделяет данные для этого приложения. Это означает, что несколько приложений могут хранить информацию в одной учетной записи iCloud, но эта информация никогда не будет запутанной.

Контейнеры данных iCloud также позволяют CloudKit инкапсулировать сведения о пользователе. Таким образом, приложение будет иметь ограниченный доступ к учетной записи iCloud и сведениям о пользователях, хранящимся в, в то же время защищая конфиденциальность и безопасность пользователя.

Контейнеры полностью управляются разработчиком приложения через портал ВВДР. Пространство имен контейнера является глобальным по отношению ко всем разработчикам Apple, поэтому контейнер должен быть не только уникальным для приложений конкретного разработчика, но и для всех разработчиков и приложений Apple.

Компания Apple предлагает использовать обратную нотацию DNS при создании пространства имен для контейнеров приложений. Например, `iCloud.com.company-name.application-name`.

Хотя контейнеры по умолчанию привязаны один к одному приложению, они могут совместно использоваться разными приложениями. Так что несколько приложений могут координировать один контейнер. Одно приложение также может взаимодействовать с несколькими контейнерами.

### <a name="databases"></a>Базы данных

Одной из основных функций CloudKit является получение модели данных приложения и репликации, которая моделируется до серверов iCloud. Некоторые сведения предназначены для пользователя, который его создал, а другие — как открытые данные, которые могут быть созданы пользователем для общего использования (например, отзыв о ресторане), или сведения, опубликованные разработчиком для приложения. В любом случае аудитория является не только одним пользователем, но и сообществом людей.

 [![Схема контейнера CloudKit](intro-to-cloudkit-images/image32.png)](intro-to-cloudkit-images/image32.png#lightbox)

В контейнере первая и самое главное являются общедоступной базой данных. Здесь все общедоступные сведения существуют и совместно минглес. Кроме того, существует несколько отдельных частных баз данных для каждого пользователя приложения.

При запуске на устройстве iOS приложение будет иметь доступ только к информации для текущего пользователя iCloud, вошедшего в систему. Итак, представление приложения контейнера будет выглядеть следующим образом:

 [![Представление "приложения" контейнера](intro-to-cloudkit-images/image33.png)](intro-to-cloudkit-images/image33.png#lightbox)

Она может видеть только общедоступную базу данных и закрытую базу данных, связанную с текущим пользователем iCloud, вошедшим в систему.

Базы данных представлены в платформе CloudKit с помощью `CKDatabase` класса. Каждое приложение имеет доступ к двум базам данных: общедоступной базе данных и частной.

Контейнер является начальной точкой входа в CloudKit. Следующий код можно использовать для доступа к общей и частной базе данных из контейнера приложения по умолчанию:

```csharp
using CloudKit;
//...

public CKDatabase PublicDatabase { get; set; }
public CKDatabase PrivateDatabase { get; set; }
//...

// Get the default public and private databases for
// the application
PublicDatabase = CKContainer.DefaultContainer.PublicCloudDatabase;
PrivateDatabase = CKContainer.DefaultContainer.PrivateCloudDatabase;
```

Ниже приведены различия между типами базы данных.

||Общедоступная база данных|Частная база данных|
|---|--- |--- |
|**Тип данных**|Общие данные|Данные текущего пользователя|
|**Квота**|Учитывается в квоте разработчика|Учитывается в квоте пользователя|
|**Разрешения по умолчанию**|Мир для чтения|Пользователь, доступный для чтения|
|**Изменение разрешений**|Роли панели мониторинга iCloud через уровень класса записи|Недоступно|

### <a name="records"></a>Записи

Контейнеры содержат базы данных, а в базах данных — записи. Записи — это механизм, в котором структурированные данные перемещаются в CloudKit и обратно.

 [![Контейнеры содержат базы данных, а в базах данных — записи](intro-to-cloudkit-images/image34.png)](intro-to-cloudkit-images/image34.png#lightbox)

Записи предоставляются в платформе CloudKit с помощью `CKRecord` класса, который заключает пары "ключ-значение" в оболочку. Экземпляр объекта в приложении эквивалентен объекту `CKRecord` в CloudKit. Кроме того, каждый из них `CKRecord` имеет тип записи, эквивалентный классу объекта.

Записи имеют JIT-схему, поэтому данные будут описаны в CloudKit перед передачей для обработки. С этого момента CloudKit будет интерпретировать информацию и обрабатывать логистику хранения и извлечения записи.

`CKRecord`Класс также поддерживает широкий спектр метаданных. Например, запись содержит сведения о том, когда она была создана, и пользователя, создавшего ее. Запись также содержит сведения о времени последнего изменения и пользователе, который ее изменил.

Записи содержат понятие тега изменения. Это Предыдущая версия данной записи. Тег Change используется как облегченный способ определения того, имеет ли клиент и сервер одну и ту же версию заданной записи.

Как упоминалось выше, `CKRecords` заключите пары "ключ-значение" в тип данных, которые могут храниться в записи:

1. `NSString`
1. `NSNumber`
1. `NSData`
1. `NSDate`
1. `CLLocation`
1. `CKReferences`
1. `CKAssets`

В дополнение к одному типу значения, запись может содержать однородный массив любого из перечисленных выше типов.

Следующий код можно использовать для создания новой записи и ее сохранения в базе данных:

```csharp
using CloudKit;
//...

private const string ReferenceItemRecordName = "ReferenceItems";
//...

var newRecord = new CKRecord (ReferenceItemRecordName);
newRecord ["name"] = (NSString)nameTextField.Text;
await CloudManager.SaveAsync (newRecord);
```

### <a name="record-zones"></a>Зоны записей

Записи в данной базе данных не существуют — группы записей существуют вместе внутри зоны записей. Зоны записей можно рассматривать как таблицы в традиционных реляционных базах данных:

 [![Группы записей существуют вместе внутри зоны записи.](intro-to-cloudkit-images/image35.png)](intro-to-cloudkit-images/image35.png#lightbox)

В пределах одной зоны записи и нескольких зон записей в пределах одной базы данных может быть несколько записей. Каждая база данных содержит зону записей по умолчанию.

 [![Каждая база данных содержит зону записей по умолчанию и пользовательскую зону.](intro-to-cloudkit-images/image36.png)](intro-to-cloudkit-images/image36.png#lightbox)

В этом случае записи сохраняются по умолчанию. Кроме того, можно создавать пользовательские зоны записей. Зоны записей представляют собой базовую гранулярность, при которой выполняются атомарные фиксации и Отслеживание изменений.

## <a name="record-identifiers"></a>Идентификаторы записей

Идентификаторы записей представляются в виде кортежа, содержащего имя записи, предоставленную клиентом, и зону, в которой существует запись. Идентификаторы записей имеют следующие характеристики.

- Они создаются клиентским приложением.
- Они полностью нормализованы и представляют конкретное расположение записи.
- Назначив уникальный идентификатор записи в внешней базе данных имени записи, они могут использоваться для моста локальных баз данных, которые не хранятся в CloudKit.

Когда разработчики создают новые записи, они могут передавать идентификатор записи. Если идентификатор записи не указан, идентификатор UUID будет автоматически создан и назначен записи.

Когда разработчики создают новые идентификаторы записей, они могут указать зону записей, к которой будет принадлежать каждая запись. Если значение не указано, будет использоваться зона записей по умолчанию.

Идентификаторы записей представлены в платформе CloudKit с помощью `CKRecordID` класса. Для создания нового идентификатора записи можно использовать следующий код:

```csharp
var recordID =  new CKRecordID("My Record");
```

### <a name="references"></a>Ссылки

Ссылки предоставляют связи между связанными записями в заданной базе данных:

 [![Ссылки предоставляют связи между связанными записями в заданной базе данных](intro-to-cloudkit-images/image37.png)](intro-to-cloudkit-images/image37.png#lightbox)

В приведенном выше примере родительские дочерние элементы являются дочерними записями родительской записи. Связь поступает от дочерней записи к родительской записи и называется *обратной ссылкой*.

Ссылки представлены в платформе CloudKit с помощью `CKReference` класса. Они позволяют серверу iCloud понять отношения между записями.

Ссылки обеспечивают механизм, лежащий в основе каскадных удалений. Если родительская запись удаляется из базы данных, все дочерние записи (указанные в связи) автоматически удаляются из базы данных.

> [!NOTE]
> Висячие указатели являются возможными при использовании CloudKit. Например, когда приложение извлекает список указателей на записи, выбирает запись, а затем запрашивает запись, запись может больше не существовать в базе данных. Приложение должно быть закодировано для корректной обработки этой ситуации.

При работе с платформой CloudKit предпочтительнее использовать обратные ссылки. Компания Apple настраивает систему так, чтобы она стала наиболее эффективным типом ссылок.

При создании ссылки разработчик может либо предоставить запись, которая уже находится в памяти, либо создать ссылку на идентификатор записи. Если используется идентификатор записи и указанная ссылка не существовала в базе данных, будет создан висячий указатель.

Ниже приведен пример создания ссылки на известную запись.

```csharp
var reference = new CKReference(newRecord, new CKReferenceAction());
```

### <a name="assets"></a>Активы

Активы позволяют отправлять файлы больших и неструктурированных данных в iCloud и связывать их с заданной записью:

 [![Активы позволяют отправлять файлы больших, неструктурированных данных в iCloud и связывать их с заданной записью.](intro-to-cloudkit-images/image38.png)](intro-to-cloudkit-images/image38.png#lightbox)

На клиенте `CKRecord` создается, описывающий файл, который будет отправлен на сервер iCloud. `CKAsset`Создается для хранения файла и связывается с записью, описывающей его.

Когда файл передается на сервер, запись помещается в базу данных, а файл копируется в специальную базу данных хранилища больших объемов. Между указателем на запись и отправленным файлом создается ссылка.

Активы предоставляются в CloudKit Framework через `CKAsset` класс и используются для хранения больших, неструктурированных данных. Поскольку разработчик никогда не хочет иметь большие, неструктурированные данные в памяти, ресурсы реализуются с помощью файлов на диске.

Активы принадлежат записям, что позволяет получать ресурсы из iCloud, используя запись в качестве указателя. Таким образом, при удалении записи, владеющей ресурсом, сервер может производить сбор ресурсов.

Поскольку `CKAssets` предназначены для работы с большими файлами данных, компания Apple разработана CloudKit для эффективной отправки и загрузки ресурсов.

Следующий код можно использовать для создания ресурса и его связывания с записью:

```csharp
var fileUrl = new NSUrl("LargeFile.mov");
var asset = new CKAsset(fileUrl);
newRecord ["name"] = asset;
```

Теперь мы рассмотрели все фундаментальные объекты в CloudKit. Контейнеры связаны с приложениями и содержат базы данных. Базы данных содержат записи, сгруппированные в зоны записей и на которые указывают идентификаторы записей. Связи типа «родители-потомки» определяются между записями с помощью ссылок. Наконец, большие файлы можно передать и связать с записями с помощью ресурсов.

## <a name="cloudkit-convenience-api"></a>Удобный API CloudKit

Компания Apple предлагает два разных набора API для работы с CloudKit:

- **Операционный API** — предоставляет каждую отдельную функцию CloudKit. Для более сложных приложений этот API обеспечивает детализированный контроль над CloudKit.
- **Удобный API** — предлагает стандартное, предварительно настроенное подмножество функций CloudKit. Он предоставляет удобное и простое решение для включения функций CloudKit в приложение iOS.

Удобный API обычно является лучшим выбором для большинства приложений iOS, и компания Apple предлагает начать с него. В оставшейся части этого раздела будут рассмотрены следующие темы API:

- Сохранение записи.
- Получение записи.
- Обновление записи.

### <a name="common-setup-code"></a>Распространенный код настройки

Прежде чем приступить к работе с удобным интерфейсом API CloudKit, необходимо выполнить стандартный код установки. Начните с изменения `AppDelegate.cs` файла приложения и сделайте его следующим:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Foundation;
using UIKit;
using CloudKit;

namespace CloudKitAtlas
{
    [Register ("AppDelegate")]
    public partial class AppDelegate : UIApplicationDelegate
    {
        public override UIWindow Window { get; set;}
        public CKDatabase PublicDatabase { get; set; }
        public CKDatabase PrivateDatabase { get; set; }

        public override bool FinishedLaunching (UIApplication application, NSDictionary launchOptions)
        {
            application.RegisterForRemoteNotifications ();

            // Get the default public and private databases for
            // the application
            PublicDatabase = CKContainer.DefaultContainer.PublicCloudDatabase;
            PrivateDatabase = CKContainer.DefaultContainer.PrivateCloudDatabase;

            return true;
        }

        public override void RegisteredForRemoteNotifications (UIApplication application, NSData deviceToken)
        {
            Console.WriteLine ("Registered for Push notifications with token: {0}", deviceToken);
        }

        public override void FailedToRegisterForRemoteNotifications (UIApplication application, NSError error)
        {
            Console.WriteLine ("Push subscription failed");
        }

        public override void ReceivedRemoteNotification (UIApplication application, NSDictionary userInfo)
        {
            Console.WriteLine ("Push received");
        }
    }
}
```

Приведенный выше код предоставляет открытые и закрытые базы данных CloudKit как ярлыки для упрощения работы с ними в оставшейся части приложения.

Затем добавьте следующий код в любое представление или контейнер представления, которые будут использовать CloudKit:

```csharp
using CloudKit;
//...

public AppDelegate ThisApp {
    get { return (AppDelegate)UIApplication.SharedApplication.Delegate; }
}
```

При этом добавляется ярлык для получения `AppDelegate` доступа к созданным ранее ярлыкам базы данных public и Private.

Используя этот код, давайте посмотрим, как реализовать удобный API CloudKit в приложении Xamarin iOS 8.

### <a name="saving-a-record"></a>Сохранение записи

Используя приведенный выше шаблон при обсуждении записей, следующий код создаст новую запись и будет использовать удобный API для сохранения его в общедоступной базе данных:

```csharp
private const string ReferenceItemRecordName = "ReferenceItems";
...

// Create a new record
var newRecord = new CKRecord (ReferenceItemRecordName);
newRecord ["name"] = (NSString)nameTextField.Text;

// Save it to the database
ThisApp.PublicDatabase.SaveRecord(newRecord, (record, err) => {
    // Was there an error?
    if (err != null) {
        ...
    }
});
```

Обратите внимание на три вещи, касающиеся приведенного выше кода.

1. Вызывая  `SaveRecord` метод класса  `PublicDatabase` , разработчику не нужно указывать, каким способом отправляются данные, какая зона записывается и т. д. Удобный API отвечает за все эти сведения.
1. Вызов является асинхронным и предоставляет подпрограммы обратного вызова, когда вызов завершается успешно или неудачно. В случае сбоя вызова будет предоставлено сообщение об ошибке.
1. CloudKit не предоставляет локальное хранилище или сохраняемость; Это только носитель передачи. Поэтому при запросе на сохранение записи она немедленно отправляется на серверы iCloud.

> [!NOTE]
> Из-за потери данных в связи с мобильными сетями, когда подключения постоянно удаляются или прерываются, одно из первых соображений, которые необходимо выполнить разработчику при работе с CloudKit, — обработка ошибок.

### <a name="fetching-a-record"></a>Получение записи

Если запись создана и успешно сохранена на сервере iCloud, используйте следующий код для получения записи:

```csharp
// Create a record ID and fetch the record from the database
var recordID = new CKRecordID("MyRecordName");
ThisApp.PublicDatabase.FetchRecord(recordID, (record, err) => {
    // Was there an error?
    if (err != null) {
        ...
    }
});
```

Так же, как и при сохранении записи, приведенный выше код является асинхронным, простым и требует отличной обработки ошибок.

### <a name="updating-a-record"></a>Обновление записи

После того как запись получена с серверов iCloud, можно использовать следующий код для изменения записи и сохранения изменений в базе данных.

```csharp
// Create a record ID and fetch the record from the database
var recordID = new CKRecordID("MyRecordName");
ThisApp.PublicDatabase.FetchRecord(recordID, (record, err) => {
    // Was there an error?
    if (err != null) {

    } else {
        // Modify the record
        record["name"] = (NSString)"New Name";

        // Save changes to database
        ThisApp.PublicDatabase.SaveRecord(record, (r, e) => {
            // Was there an error?
            if (e != null) {
                 ...
            }
        });
    }
});
```

`FetchRecord`Метод `PublicDatabase` возвращает значение, `CKRecord` Если вызов был успешным. Затем приложение изменяет запись и вызывает `SaveRecord` повторно, чтобы записать изменения обратно в базу данных.

В этом разделе показан типичный цикл, который будет использоваться приложением при работе с удобным API-интерфейсом CloudKit. Приложение будет сохранять записи в iCloud, получать эти записи из iCloud, изменять записи и сохранять эти изменения обратно в iCloud.

## <a name="designing-for-scalability"></a>Проектирование для масштабируемости

До сих пор в этой статье мы рассматривали хранение и извлечение всей объектной модели приложения с серверов iCloud каждый раз, когда она будет работать. Хотя этот подход хорошо работает с небольшим объемом данных и очень небольшим пользовательским, он плохо масштабируется при увеличении объема информации и (или) базовой базы пользователей.

### <a name="big-data-tiny-device"></a>Большие данные, крошечные устройства

Чем больше популярно приложение, тем больше данных в базе данных, тем меньше вероятность того, что он будет иметь кэш всех данных на устройстве. Для решения этой проблемы можно использовать следующие методы.

- **Используйте большие данные в облаке** — CloudKit был разработан для эффективного управления большими объемами данных.
- **Клиент должен только просматривать срез этих данных** — выделять минимум данных, необходимых для выполнения задач в определенный момент времени.
- **Клиентские представления могут измениться** — так как каждый пользователь имеет разные настройки, срез отображаемых данных может меняться от пользователя к пользователю, а отдельное представление любого отдельного среза может отличаться.
- **Клиент использует запросы для фокусировки точки зрения** — запросы позволяют пользователю просматривать небольшое подмножество большего набора данных, существующего в облаке.

### <a name="queries"></a>Запросы

Как упоминалось выше, запросы позволяют разработчику выбрать небольшое подмножество большего набора данных, существующего в облаке. Запросы представлены в платформе CloudKit с помощью `CKQuery` класса.

Запрос объединяет три различных вещи: тип записи ( `RecordType` ), предикат ( `NSPredicate` ) и (необязательно) дескриптор сортировки ( `NSSortDescriptors` ). CloudKit поддерживает большинство из них `NSPredicate` .

#### <a name="supported-predicates"></a>Поддерживаемые предикаты

CloudKit поддерживает следующие типы `NSPredicates` при работе с запросами:

1. Совпадающие записи, в которых имя равно значению, хранящемуся в переменной:

    ```csharp
    NSPredicate.FromFormat(string.Format("name = '{0}'", recordName))
    ```

2. Позволяет использовать сопоставление на основе динамического значения ключа, чтобы ключ не знал во время компиляции:

    ```csharp
    NSPredicate.FromFormat(string.Format("{0} = '{1}'", key, value))
    ```

3. Совпадающие записи, в которых значение записи больше заданного значения:

    ```csharp
    NSPredicate.FromFormat(string.Format("start > {0}", (NSDate)date))
    ```

4. Совпадающие записи, где расположение записи находится в пределах 100 м указанного расположения:

    ```csharp
    var location = new CLLocation(37.783,-122.404);
    var predicate = NSPredicate.FromFormat(string.Format("distanceToLocation:fromLocation(Location,{0}) < 100", location));
    ```

5. CloudKit поддерживает маркерный Поиск. Этот вызов создаст два токена: один для `after` и другой для `session` . Он вернет запись, содержащую эти два токена:

    ```csharp
    NSPredicate.FromFormat(string.Format("ALL tokenize({0}, 'Cdl') IN allTokens", "after session"))
    ```

6. CloudKit поддерживает составные предикаты, соединяемые с помощью `AND` оператора.

    ```csharp
    NSPredicate.FromFormat(string.Format("start > {0} AND name = '{1}'", (NSDate)date, recordName))
    ```

#### <a name="creating-queries"></a>Создание запросов

Следующий код можно использовать для создания `CKQuery` в приложении Xamarin iOS 8:

```csharp
var recordName = "MyRec";
var predicate = NSPredicate.FromFormat(string.Format("name = '{0}'", recordName));
var query = new CKQuery("CloudRecords", predicate);
```

Во-первых, он создает предикат для выбора только тех записей, которые соответствуют заданному имени. Затем создается запрос, который выберет записи с заданным типом записи, которые соответствуют предикату.

#### <a name="performing-a-query"></a>Выполнение запроса

После создания запроса используйте следующий код, чтобы выполнить запрос и обработать возвращенные записи:

```csharp
var recordName = "MyRec";
var predicate = NSPredicate.FromFormat(string.Format("name = {0}", recordName));
var query = new CKQuery("CloudRecords", predicate);

ThisApp.PublicDatabase.PerformQuery(query, CKRecordZone.DefaultRecordZone().ZoneId, (NSArray results, NSError err) => {
    // Was there an error?
    if (err != null) {
       ...
    } else {
        // Process the returned records
        for(nint i = 0; i < results.Count; ++i) {
            var record = (CKRecord)results[i];
        }
    }
});
```

Приведенный выше код принимает запрос, созданный выше, и выполняет его в общедоступной базе данных. Так как зона записи не указана, поиск выполняется во всех зонах. Если ошибки не возникли, `CKRecords` будет возвращен массив, соответствующий параметрам запроса.

Способ думать о запросах заключается в том, что они являются опросами и отлично подходят для срезов по большим наборам данных. Однако запросы плохо подходят для больших, в основном статических наборов данных по следующим причинам.

- Они недопустимы для времени работы батареи устройства.
- Они недопустимы для сетевого трафика.
- Они плохо работают для пользователей, так как отображаемые ими сведения ограничены тем, как часто приложение опрашивает базу данных. Сегодня пользователи предполагают push-уведомления при изменении.

### <a name="subscriptions"></a>Подписки

При работе с большими, главными статическими наборами данных запрос не должен выполняться на клиентском устройстве, он должен выполняться на сервере от имени клиента. Запрос должен выполняться в фоновом режиме и должен выполняться после каждой отдельной записи, будь то текущее устройство или другое устройство, затрагивающие одну и ту же базу данных.

Наконец, при выполнении запроса на стороне сервера на каждое устройство, подключенное к базе данных, должно отправляться push-уведомление.

Подписки предоставляются в платформе CloudKit с помощью `CKSubscription` класса. Они объединяют тип записи ( `RecordType` ), предикат ( `NSPredicate` ) и push-уведомление Apple ( `Push` ).

> [!NOTE]
> CloudKit push-уведомления немного дополняются, так как они содержат полезную нагрузку, содержащую CloudKit информацию, например, что привело к возникновению принудительной отправки.

#### <a name="how-subscriptions-work"></a>Принцип работы подписок

Перед реализацией подписки в коде C# давайте краткий обзор работы подписок.

 [![Общие сведения о работе подписок](intro-to-cloudkit-images/image39.png)](intro-to-cloudkit-images/image39.png#lightbox)

На приведенной выше диаграмме показан типичный процесс подписки следующим образом.

1. Клиентское устройство создает новую подписку, содержащую набор условий, которые будут активировать подписку, и push-уведомление, которое будет отправлено при возникновении триггера.
2. Подписка отправляется в базу данных, в которую она добавляется в коллекцию существующих подписок.
3. Второе устройство создает новую запись и сохраняет эту запись в базе данных.
4. База данных выполняет поиск по списку подписок, чтобы узнать, совпадает ли новая запись с любым из своих условий.
5. Если совпадение найдено, push-уведомление отправляется на устройство, которое зарегистрировало подписку с информацией о записи, вызвавшей ее срабатывание.

Зная эти знания, давайте взглянем на создание подписок в приложении Xamarin iOS 8.

#### <a name="creating-subscriptions"></a>Создание подписок

Для создания подписки можно использовать следующий код:

```csharp
// Create a new subscription
DateTime date;
var predicate = NSPredicate.FromFormat(string.Format("start > {0}", (NSDate)date));
var subscription = new CKSubscription("RecordType", predicate, CKSubscriptionOptions.FiresOnRecordCreation);

// Describe the type of notification
var notificationInfo = new CKNotificationInfo();
notificationInfo.AlertLocalizationKey = "LOCAL_NOTIFICATION_KEY";
notificationInfo.SoundName = "ping.aiff";
notificationInfo.ShouldBadge = true;

// Attach the notification info to the subscription
subscription.NotificationInfo = notificationInfo;
```

Во-первых, он создает предикат, который предоставляет условие для активации подписки. Затем она создает подписку для определенного типа записи и задает параметр при тестировании триггера. Наконец, он определяет тип уведомления, которое будет происходить при активации подписки и присоединении ее к подписке.

### <a name="saving-subscriptions"></a>Сохранение подписок

После создания подписки следующий код сохранит его в базе данных:

```csharp
// Save the subscription to the database
ThisApp.PublicDatabase.SaveSubscription(subscription, (s, err) => {
    // Was there an error?
    if (err != null) {

    }
});
```

Используя удобный API, вызов является асинхронным, простым и обеспечивает простую обработку ошибок.

#### <a name="handling-push-notifications"></a>Обработка push-уведомлений

Если разработчик ранее использовал push-уведомления Apple (ТД), то должны быть знакомы процессы работы с уведомлениями, созданными CloudKit.

В `AppDelegate.cs` Переопределите `ReceivedRemoteNotification` класс следующим образом:

```csharp
public override void ReceivedRemoteNotification (UIApplication application, NSDictionary userInfo)
{
    // Parse the notification into a CloudKit Notification
    var notification = CKNotification.FromRemoteNotificationDictionary (userInfo);

    // Get the body of the message
    var alertBody = notification.AlertBody;

    // Was this a query?
    if (notification.NotificationType == CKNotificationType.Query) {
        // Yes, convert to a query notification and get the record ID
        var query = notification as CKQueryNotification;
        var recordID = query.RecordId;
    }
}
```

Приведенный выше код запрашивает CloudKit, чтобы разобрать userInfo в уведомлении CloudKit. Далее извлекаются сведения о предупреждении. Наконец, проверяется тип уведомления, и уведомление обрабатывается соответствующим образом.

В этом разделе показано, как ответить на большие данные, проблему с небольшими устройствами, представленную выше, с помощью запросов и подписок. Приложение оставляет большие данные в облаке и использует эти технологии для предоставления представлений в этот набор данных.

## <a name="cloudkit-user-accounts"></a>CloudKit учетные записи пользователей

Как отмечалось в начале этой статьи, CloudKit строится на основе существующей инфраструктуры iCloud. В следующем разделе подробно рассматривается, как учетные записи предоставляются разработчику с помощью API CloudKit.

### <a name="authentication"></a>Аутентификация

При работе с учетными записями пользователей первым вопросом является проверка подлинности. CloudKit поддерживает проверку подлинности с помощью текущего пользователя iCloud, вошедшего на устройство. Проверка подлинности выполняется в фоновом режиме и обрабатывается iOS. Таким образом разработчикам не придется беспокоиться о реализации проверки подлинности. Они проверяют, вошел ли пользователь в систему.

### <a name="user-account-information"></a>Информация об учетной записи пользователя

CloudKit предоставляет разработчику следующие сведения о пользователе:

- **Identity** — способ уникальной идентификации пользователя.
- **Метаданные** — возможность сохранять и получать сведения о пользователях.
- **Конфиденциальность** — вся информация обрабатывается с учетом конфиденциальности Манор. Ничего не предоставляется, если пользователь не согласен с ним.
- **Обнаружение** . дает пользователям возможность находить своих друзей, использующих одно и то же приложение.

Далее мы рассмотрим эти темы подробно.

#### <a name="identity"></a>Идентификация

Как упоминалось выше, CloudKit предоставляет приложению возможность однозначно идентифицировать данного пользователя:

 [![Уникально отправляемых данного пользователя](intro-to-cloudkit-images/image40.png)](intro-to-cloudkit-images/image40.png#lightbox)

Клиентское приложение работает на устройствах пользователя и всех частных базах данных конкретного пользователя в контейнере CloudKit. Клиентское приложение будет связано с одним из указанных пользователей. Это зависит от пользователя, который вошел в iCloud локально на устройстве.

Так как это поступает из iCloud, существует большое резервное хранилище сведений о пользователе. И, поскольку в iCloud фактически размещается контейнер, он может сопоставлять пользователей. На приведенном выше рисунке пользователь, чья учетная запись iCloud  `user@icloud.com` связана с текущим клиентом.

В контейнере по контейнеру создается уникальный идентификатор пользователя, который создается случайным образом и связывается с учетной записью iCloud пользователя (адрес электронной почты). Этот идентификатор пользователя возвращается в приложение и может использоваться любым способом, который видит разработчик.

> [!NOTE]
> Разные приложения, работающие на одном устройстве с одним и тем же пользователем iCloud, будут иметь разные идентификаторы пользователей, так как они подключены к разным контейнерам CloudKit.

Следующий код получает идентификатор пользователя CloudKit для текущего пользователя в системе iCloud, зарегистрированного на устройстве.

```csharp
public CKRecordID UserID { get; set; }
...

// Get the CloudKit User ID
CKContainer.DefaultContainer.FetchUserRecordId ((recordID, err) => {
    // Was there an error?
    if (err!=null) {
        Console.WriteLine("Error: {0}", err.LocalizedDescription);
    } else {
        // Save user ID
        UserID = recordID;
    }
});
```

Приведенный выше код запрашивает у контейнера CloudKit идентификатор текущего пользователя, вошедшего в систему. Поскольку эти сведения поступают с сервера iCloud, вызов является асинхронным и требуется обработка ошибок.

#### <a name="metadata"></a>Метаданные

Каждый пользователь в CloudKit имеет определенные метаданные, которые их описывают. Эти метаданные представлены в виде записи CloudKit:

 [![Каждый пользователь в CloudKit имеет определенные метаданные, описывающие их](intro-to-cloudkit-images/image41.png)](intro-to-cloudkit-images/image41.png#lightbox)

Поиск в частной базе данных для конкретного пользователя контейнера содержит одну запись, определяющую этого пользователя. В общей базе данных имеется много записей пользователей, по одной для каждого пользователя контейнера. Один из них будет иметь идентификатор записи, соответствующий ИДЕНТИФИКАТОРу записи текущего пользователя, вошедшего в систему.

Записи пользователей в общедоступной базе данных доступны для чтения в мире. Они рассматриваются в основном как обычная запись и имеют тип `CKRecordTypeUserRecord` . Эти записи зарезервированы системой и недоступны для запросов.

Используйте следующий код для доступа к записи пользователя:

```csharp
public CKRecord UserRecord { get; set; }
...

// Get the user's record
PublicDatabase.FetchRecord(UserID, (record ,er) => {
    //was there an error?
    if (er != null) {
        Console.WriteLine("Error: {0}", er.LocalizedDescription);
    } else {
        // Save the user record
        UserRecord = record;
    }
});
```

Приведенный выше код запрашивает у общедоступной базы данных запрос на получение записи пользователя для пользователя с ИДЕНТИФИКАТОРом, к которому мы обратились. Поскольку эти сведения поступают с сервера iCloud, вызов является асинхронным и требуется обработка ошибок.

#### <a name="privacy"></a>Конфиденциальность

CloudKit был разработан по умолчанию для защиты конфиденциальности пользователя, выполнившего вход в систему. Никакая идентификационная информация о пользователе не предоставляется по умолчанию. В некоторых случаях приложению потребуется лишь ограниченная информация о пользователе.

В таких случаях приложение может запросить, что пользователь раскроет эту информацию. Пользователю будет предоставлено диалоговое окно с запросом на предоставление сведений об учетной записи.

#### <a name="discovery"></a>Обнаружение

Предполагая, что пользователь в качестве включенного для предоставления приложению ограниченного доступа к сведениям об учетной записи пользователя, они могут быть обнаруживаемыми для других пользователей приложения:

 [![Пользователь может быть обнаруживаемым для других пользователей приложения.](intro-to-cloudkit-images/image42.png)](intro-to-cloudkit-images/image42.png#lightbox)

Клиентское приложение обращается к контейнеру, и контейнер взаимодействуют с iCloud для доступа к сведениям о пользователях. Пользователь может предоставить адрес электронной почты, и можно использовать обнаружение для получения сведений о пользователе. При необходимости можно также использовать идентификатор пользователя для получения сведений о пользователе.

CloudKit также позволяет получить сведения обо всех пользователях, которые могут быть друзьями текущего пользователя в системе iCloud, запросив всю адресную книгу. Процесс CloudKit будет извлекать в контактную книгу пользователя и использовать адреса электронной почты, чтобы узнать, может ли он найти другого пользователя приложения, соответствующего этим адресам.

Это позволяет приложению использовать контактную книгу пользователя без предоставления доступа к ней или запроса пользователя на утверждение доступа к контактам. В настоящее время доступ к контактным данным, доступным приложению, предоставляется только процессу CloudKit.

Итак, существует три различных типа входных данных, доступных для обнаружения пользователей:

- **Идентификатор записи пользователя** — обнаружение можно выполнить по идентификатору текущего пользователя, вошедшего в систему CloudKit пользователя.
- **Адрес электронной почты пользователя** — пользователь может указать адрес электронной почты, который можно использовать для обнаружения.
- **Контактная книга** — адресная книга пользователя может использоваться для обнаружения пользователей приложения, имеющих тот же адрес электронной почты, который указан в контактах.

Обнаружение пользователя вернет следующие сведения:

- **Идентификатор записи пользователя** — уникальный идентификатор пользователя в общедоступной базе данных.
- **Имя и фамилия** — как хранится в общедоступной базе данных.

Эти сведения будут возвращены только пользователям, которые участвуют в обнаружении.

В следующем коде будут обнаружены сведения о пользователе, который в настоящее время вошел в iCloud на устройстве:

```csharp
public CKDiscoveredUserInfo UserInfo { get; set; }
//...

// Get the user's metadata
CKContainer.DefaultContainer.DiscoverUserInfo(UserID, (info, e) => {
    // Was there an error?
    if (e != null) {
        Console.WriteLine("Error: {0}", e.LocalizedDescription);
    } else {
        // Save the user info
        UserInfo = info;
    }
});
```

Используйте следующий код, чтобы запросить всех пользователей в контактной книге:

```csharp
// Ask CloudKit for all of the user's friends information
CKContainer.DefaultContainer.DiscoverAllContactUserInfos((info, er) => {
    // Was there an error
    if (er != null) {
        Console.WriteLine("Error: {0}", er.LocalizedDescription);
    } else {
        // Process all returned records
        for(int i = 0; i < info.Count(); ++i) {
            // Grab a user
            var userInfo = info[i];
        }
    }
});
```

В этом разделе мы рассмотрели четыре основных области доступа к учетной записи пользователя, которую CloudKit может предоставить приложению. От получения удостоверений и метаданных пользователя на политики конфиденциальности, встроенные в CloudKit, и, наконец, возможность обнаруживать других пользователей приложения.

## <a name="the-development-and-production-environments"></a>Среда разработки и рабочие среды

CloudKit предоставляет отдельную среду разработки и рабочей среды для типов записей и данных приложения. Среда разработки является более гибкой средой, доступной только членам группы разработчиков. Когда приложение добавляет новое поле в запись и сохраняет эту запись в среде разработки, сервер автоматически обновляет сведения о схеме.

Разработчик может использовать эту функцию для внесения изменений в схему во время разработки, что экономит время. Одно из предостережений состоит в том, что после добавления поля в запись тип данных, связанный с этим полем, нельзя изменить программным способом. Чтобы изменить тип поля, разработчик должен удалить поле на [панели мониторинга CloudKit](https://icloud.developer.apple.com/dashboard/) и добавить его снова с новым типом.

Перед развертыванием приложения разработчик может перенести свою схему и данные в рабочую среду с помощью **панели мониторинга CloudKit**. При выполнении в рабочей среде сервер не допускают изменения схемы приложением программным способом. Разработчик по-прежнему может вносить изменения с помощью **панели мониторинга CloudKit** , но попытки добавить поля в запись в рабочей среде приведут к ошибкам.

> [!NOTE]
> Симулятор iOS работает только с **средой разработки**. Когда разработчик готов к тестированию приложения в **рабочей среде**, требуется физическое устройство iOS.

## <a name="shipping-a-cloudkit-enabled-app"></a>Доставка приложения с поддержкой CloudKit

Перед отправкой приложения, использующего CloudKit, необходимо настроить целевую **среду рабочей среды CloudKit** или приложение будет отклонено компанией Apple.

Выполните следующие действия.

1. В Visual Studio для MA скомпилируйте приложение для **выпуска**  >  **устройства iOS**:

    [![Компиляция приложения для выпуска](intro-to-cloudkit-images/shipping01.png)](intro-to-cloudkit-images/shipping01.png#lightbox)

2. В меню **Сборка** выберите пункт **Архив**:

    [![Выбор архива](intro-to-cloudkit-images/shipping02.png)](intro-to-cloudkit-images/shipping02.png#lightbox)

3. **Архив** будет создан и отображен в Visual Studio для Mac:

    [![Архив будет создан и отображен](intro-to-cloudkit-images/shipping03.png)](intro-to-cloudkit-images/shipping03.png#lightbox)

4. Запустите **Xcode**.
5. В меню **окно** выберите **Организатор**:

    [![Выбор организатора](intro-to-cloudkit-images/shipping04.png)](intro-to-cloudkit-images/shipping04.png#lightbox)

6. Выберите архив приложения и нажмите кнопку **Export... (экспорт...** ):

    [![Архив приложения](intro-to-cloudkit-images/shipping05.png)](intro-to-cloudkit-images/shipping05.png#lightbox)

7. Выберите метод экспорта и нажмите кнопку **Далее** :

    [![Выбор метода экспорта](intro-to-cloudkit-images/shipping06.png)](intro-to-cloudkit-images/shipping06.png#lightbox)

8. Выберите команду **разработчиков** в раскрывающемся списке и нажмите кнопку **выбрать** :

    [![Выберите команду разработчиков в раскрывающемся списке.](intro-to-cloudkit-images/shipping07.png)](intro-to-cloudkit-images/shipping07.png#lightbox)

9. Выберите **Production** из раскрывающегося списка и нажмите кнопку **Далее** :

    [![Выберите рабочую среду из раскрывающегося списка.](intro-to-cloudkit-images/shipping08.png)](intro-to-cloudkit-images/shipping08.png#lightbox)

10. Проверьте параметр и нажмите кнопку **Экспорт** :

    [![Проверка параметра](intro-to-cloudkit-images/shipping09.png)](intro-to-cloudkit-images/shipping09.png#lightbox)

11. Выберите расположение для создания результирующего файла приложения `.ipa` .

Процесс аналогичен отправке приложения непосредственно в iTunes Connect, просто нажмите кнопку **Отправить...** , а не экспортировать... После выбора архива в окне органайзера.

## <a name="when-to-use-cloudkit"></a>Когда следует использовать CloudKit

Как мы видели в этой статье, CloudKit предоставляет приложению простой способ хранения и извлечения информации с серверов iCloud. С другой стороны, CloudKit не является устаревшим или не является устаревшим ни для одного из существующих средств или платформ.

### <a name="use-cases"></a>Варианты использования

Следующие варианты использования должны помочь разработчику решить, когда следует использовать конкретную платформу или технологию iCloud:

- **хранилище значений "ключ iCloud** " — Асинхронное сохранение небольшого объема данных и отлично подходит для работы с предпочтениями приложения. Однако он ограничивается очень небольшим объемом информации.
- **диск iCloud** основан на существующих API документов iCloud и предоставляет простой API для синхронизации неструктурированных данных из файловой системы. Он обеспечивает полный кэш вне сети на Mac OS X и отлично подходит для ориентированных на документы приложений.
- **данные ядра iCloud** — позволяют реплицировать данные между всеми устройствами пользователя. Данные являются одним пользователем и отлично подходят для хранения конфиденциальных структурированных данных.
- **CloudKit** — предоставляет общедоступные данные как в виде структуры, так и в пакетной среде и может обрабатывать как большие, так и большие неструктурированные файлы. Он связан с учетной записью iCloud пользователя и обеспечивает пересылку данных, направляемую клиентом.

Учитывая эти случаи использования, разработчик должен выбрать правильную технологию iCloud для предоставления как текущих требуемых функций приложения, так и обеспечить хорошую масштабируемость для будущего роста.

## <a name="summary"></a>Сводка

В этой статье было рассмотрено краткое введение в API CloudKit. В нем показано, как подготавливать и настраивать приложение Xamarin iOS для использования CloudKit. В нем были рассмотрены функции API CloudKit. В нем показано, как спроектировать приложение с поддержкой CloudKit для масштабируемости с помощью запросов и подписок. И, наконец, он показывает сведения об учетной записи пользователя, предоставляемые приложению CloudKit.

## <a name="related-links"></a>Связанные ссылки

- [CloudKit (Apple)](https://developer.apple.com/icloud/cloudkit/)
- [Клаудкитатлас (пример)](/samples/xamarin/ios-samples/ios8-cloudkitatlas)
- [Создание профиля подготовки](~/ios/get-started/installation/device-provisioning/index.md)