---
title: CloudKit
description: iCloud интерфейсы API позволяют приложениям iOS 8 для хранения данных в iCloud с поддержкой для автоматической синхронизации в учетной записи пользователя. С помощью CloudKit предоставляет пользователям согласованного и эффективной работы на устройствах с поддержкой iCloud. В этой статье описывается включение CloudKit в приложении iOS 8, с помощью API удобства.
ms.prod: xamarin
ms.assetid: 66B207F2-FAA0-4551-B43B-3DB9F620C397
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 05/11/2016
ms.openlocfilehash: 33ceff4549e4afbb1e5fecf3bd380fdb9a3df5f2
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/04/2018
---
# <a name="cloudkit"></a>CloudKit

_iCloud интерфейсы API позволяют приложениям iOS 8 для хранения данных в iCloud с поддержкой для автоматической синхронизации в учетной записи пользователя. С помощью CloudKit предоставляет пользователям согласованного и эффективной работы на устройствах с поддержкой iCloud. В этой статье описывается включение CloudKit в приложении iOS 8, с помощью API удобства._

CloudKit framework упрощает разработку приложений, iCloud доступ. Сюда входят методы для получения данных приложений и средств права, а также возможность безопасного хранения сведений о приложении. Этот комплект предоставляет пользователям слоя анонимности, разрешив доступ к приложениям с их идентификаторами iCloud без совместного использования личных сведений.

Разработчики могут сосредоточиться на своих клиентских приложений и позволить iCloud устраняет необходимость написания логики приложения на стороне сервера. CloudKit предоставляет проверки подлинности, частных и общедоступных баз данных и структурированных данных и служб хранилища активов.

## <a name="requirements"></a>Требования

Для завершения действия, описанные в этой статье требуется следующее:

-  **Xcode и пакет SDK для iOS** — Xcode и iOS 8 Apple API-интерфейсы должны быть установлен и настроен на компьютере разработчика.
-  **Visual Studio для Mac** — последнюю версию Visual Studio для Mac должен быть установлен и настроен на устройстве пользователя.
-  **iOS 8 устройства** — самая последняя версия iOS 8 для тестирования устройства iOS.

## <a name="what-is-cloudkit"></a>Что такое CloudKit?

CloudKit способ для предоставления доступа разработчика в iCloud серверов. Он предоставляет основу для iCloud диска и iCloud фотографии. CloudKit поддерживается для устройств с Mac OS X и Apple iOS.

 [![](intro-to-cloudkit-images/image1.png "Каким образом CloudKit поддерживается на устройствах Apple iOS и Mac OS X")](intro-to-cloudkit-images/image1.png#lightbox)

CloudKit использует инфраструктуру учетной записи iCloud. Если пользователь, вошедший в iCloud запись на устройстве, CloudKit будет использовать свой идентификатор для идентификации пользователя. Если учетная запись отсутствует, будет предоставлен ограниченный доступ только для чтения.

CloudKit поддерживает концепцию общедоступных и частных баз данных. Открытые базы данных предоставляют «soup» все данные, которые пользователь имеет доступ к. Закрытый баз данных предназначены для хранения личных данных, привязанный к конкретному пользователю.

CloudKit поддерживает структурированных и массовом данных. Это может легко обрабатывать файлы большого размера. CloudKit отвечает за эффективно передавать большие файлы и из iCloud серверы в фоновом режиме, освобождая разработчику сосредоточиться на другие задачи.

> [!NOTE]
> Обратите внимание, что CloudKit важно _транспорта технологии_. Он не предоставляет все сохраняемости; он только позволяет приложению отправлять и получать сведения с серверов эффективно.

На момент написания этой статьи Apple изначально предоставляет CloudKit бесплатно верхний предел емкости, пропускной способности и хранилища. Для крупных проектов или приложений с базовым большое число пользователей Apple управляемая будет предоставляться недорогим ценообразования шкалы.


## <a name="enabling-cloudkit-in-a-xamarin-application"></a>Включение CloudKit в приложении Xamarin

Для приложений Xamarin можно использовать платформу CloudKit, приложение необходимо правильно подготовить, подробно описанные в [работа с возможностями](~/ios/deploy-test/provisioning/capabilities/icloud-capabilities.md) и [работа с данными](~/ios/deploy-test/provisioning/entitlements.md) направляющие

1.  Откройте проект в Visual Studio для Mac или Visual Studio.
2.  В **обозревателе решений**откройте **Info.plist** файл и убедитесь, **идентификатор пакета** совпадает со структурой, которое было определено в **идентификатор приложения**создана как часть инициализации настройки:
 
    [![](intro-to-cloudkit-images/image26a.png "Введите идентификатор пакета")](intro-to-cloudkit-images/image26a-orig.png#lightbox "Info.plist file displaying Bundle Identifier")

3.  Прокрутите список вниз до нижней части **Info.plist** файла и выберите **включена фоновые режимы**, **обновления расположения** и **удаленного уведомления**:

    [![](intro-to-cloudkit-images/image27a.png "Выберите включена фоновых режимов, расположение обновлений и удаленных уведомления")](intro-to-cloudkit-images/image27a-orig.png#lightbox "Info.plist file displaying background modes")
4.  Щелкните правой кнопкой мыши проект iOS в решение и выберите **параметры**.
5.  Выберите **подписывание пакета iOS**выберите **удостоверение разработчика** и **профиль подготовки** созданной выше.
6.  Убедитесь, **Entitlements.plist** включает **включить iCloud** , **значение ключа хранилища** и **CloudKit** .
7.  Убедитесь, **контейнера распространенности** существует для приложения (как созданных ранее). Пример: `iCloud.com.your-company.CloudKitAtlas`
8.  Сохраните изменения в файле.


С этими параметрами на месте приложения готова для доступа к API-интерфейсы CloudKit Framework.

## <a name="cloudkit-api-overview"></a>Обзор интерфейса API CloudKit

Перед реализацией CloudKit в приложении Xamarin iOS, в этой статье предполагается об основах CloudKit Framework, которая будет включать следующие разделы:

1.  **Контейнеры** — изолированных приемников связи iCloud.
2.  **Базы данных** — частных и общедоступных доступны для приложения.
3.  **Записи** — механизм, в которой структурированные данные перемещаются в и из CloudKit.
4.  **Записи зоны** — это группы записи.
5.  **Запишите идентификаторы** — полностью нормализуются и представляют конкретное расположение записи.
6.  **Справочник по** — предоставить родители потомки связями между записями в данной базе данных.
7.  **Активы** — разрешить файлу больших, неструктурированных данных в iCloud и связанные с данной записью.


### <a name="containers"></a>Контейнеры

Данного приложения, работающего на устройстве iOS всегда работает вместе стороне других приложений и служб на этом устройстве. На клиентском устройстве приложение будет бессистемного или изолированных иным образом. В некоторых случаях это литерал "песочницы", а в других — приложение является просто работает в его собственной памяти.

Понятие занимает клиентское приложение и запустив его отделен от других клиентов очень мощный инструмент и обеспечивает следующие преимущества:

1.  **Безопасность** — одно приложение не оказывает влияния на другие клиентские приложения или самой ОС.
1.  **Стабильность** — Если клиентское приложение аварийно завершает работу, он не может принимать out другие приложения, операционной системы.
1.  **Конфиденциальность** — каждое клиентское приложение имеет ограниченный доступ к личной информации, хранящейся в устройстве.


CloudKit был разработан для дает те же преимущества, как указано выше и применить их к работа с данными на основе облака:

 [![](intro-to-cloudkit-images/image31.png "Приложения CloudKit взаимодействовать с помощью контейнеров")](intro-to-cloudkit-images/image31.png#lightbox)

Так же, как приложение, находящееся в один из многих запущены на устройстве, случае связь приложения с iCloud один из многих. Каждый из этих приемников коммуникационных называются контейнерами.

Контейнеры, представлены в CloudKit Framework через `CKContainer` класса. По умолчанию обсуждения одно приложение для одного контейнера и этот контейнер отделяющее данных для этого приложения. Это означает, что несколько приложений, которые можно хранить сведения для одной и той же учетной записью iCloud, но эти данные никогда не будет иметь их объединения.

Создание контейнеров iCloud данных также позволяет CloudKit для инкапсуляции сведений о пользователе. Таким образом приложение будет иметь ограниченный доступ к учетной записи iCloud и данные пользователя, которые хранятся в то же время обеспечивая защиту конфиденциальности и безопасности пользователя.

Разработчик приложения на портале WWDR полностью управляются контейнеров. Пространство имен контейнер является глобальной для всех разработчиков Apple, он должен не только быть уникальным для данного разработчика приложений, но для всех разработчиков Apple и приложений.

Apple предлагает с помощью обратную нотацию DNS при создании пространства имен для приложения контейнеров. Пример

```csharp
iCloud.com.company-name.application-name
```

Хотя контейнеров, по умолчанию привязан один к одному конкретному приложению, они могут совместно использоваться приложениями. Так, чтобы несколько приложений можно управлять в одном контейнере. Одно приложение также можно обратиться к нескольким контейнерам.

### <a name="databases"></a>Databases

Одно из основных функций CloudKit является отключение модели данных приложения и репликации этой модели до серверов iCloud. Некоторые сведения предназначены для пользователя, который его создал, другие сведения — открытые данные, которые удалось созданным пользователем для открытого использования (например, отзыв о ресторане) или это может быть сведения, которые опубликованы разработчик приложения. В любом случае аудитории не только один пользователь, но — сообщество пользователей.

 [![](intro-to-cloudkit-images/image32.png "Схема CloudKit контейнера")](intro-to-cloudkit-images/image32.png#lightbox)

Внутри контейнера первое и самое главное является общей базы данных. Это, где все сведения об открытом живет и совместно mingles. Кроме того существует несколько отдельных баз данных частной для каждого пользователя приложения.

При выполнении на устройстве iOS, приложение будет достаточно доступа к информации для пользователя, вошедшего в iCloud. Поэтому представления приложения контейнера будет выглядеть следующим образом:

 [![](intro-to-cloudkit-images/image33.png "Представление приложения контейнера")](intro-to-cloudkit-images/image33.png#lightbox)

Он может просматривать только базы данных общих и частных базы данных, связанной с iCloud текущего пользователя.

Базы данных представляются в структуре CloudKit через `CKDatabase` класса. Каждое приложение имеет доступ к две базы данных: базы данных public и один закрытый.

Точка входа начальной в CloudKit является контейнер. Для доступа к базе открытых и закрытых из приложения по умолчанию контейнер можно использовать следующий код:

```csharp
using CloudKit;
...

public CKDatabase PublicDatabase { get; set; }
public CKDatabase PrivateDatabase { get; set; }
...

// Get the default public and private databases for
// the application
PublicDatabase = CKContainer.DefaultContainer.PublicCloudDatabase;
PrivateDatabase = CKContainer.DefaultContainer.PrivateCloudDatabase;
```

Ниже приведены различия между типами базы данных.

||Базы данных Public|Личная база данных|
|---|--- |--- |
|**Тип данных**|Общие данные|Данные текущего пользователя|
|**Квоты**|Учитываются в квоте разработчика|Учитываются в квоте пользователя|
|**Разрешения по умолчанию**|World для чтения|Пользователь для чтения|
|**Изменение разрешений**|iCloud ролей панели мониторинга через уровень класса записей|Н/Д|

### <a name="records"></a>Записи

Контейнеры содержат базы данных, и в базах данных записей. Записи представляют собой механизм, в которой структурированные данные перемещаются в и из CloudKit:

 [![](intro-to-cloudkit-images/image34.png "Контейнеры содержат базы данных, и в базах данных записей")](intro-to-cloudkit-images/image34.png#lightbox)

Записи представляются в структуре CloudKit через `CKRecord` класс, который создает оболочку для пар "ключ значение". Экземпляр объекта в приложении эквивалентно `CKRecord` в CloudKit. Кроме того каждый `CKRecord` может иметь тип записи, который эквивалентен классу объекта.

Записи имеют схему just-in-time, поэтому данные описываются CloudKit перед передан для обработки. С этого момента CloudKit будет интерпретировать данные и обрабатывать материально-технического обеспечения хранения и извлечения записи.

`CKRecord` Класс также поддерживает широкий набор метаданных. Например запись содержит сведения о при его создании и пользователь, создавший его. Запись также содержит сведения о его последней модификации и пользователю, он изменен.

Записи содержат понятие тег изменений. Это предыдущую версию данной записи версии. Изменение тегов используется как легкий способ определения того, если клиент и сервер имеют ту же версию данной записи.

Как упоминалось выше, `CKRecords` wrap пары "ключ значение", и таким образом, следующие типы данных могут храниться в записи:

1.   `NSString`
1.   `NSNumber`
1.   `NSData`
1.   `NSDate`
1.   `CLLocation`
1.   `CKReferences`
1.   `CKAssets`


Помимо типов одно значение запись может содержать однородные массив любого из перечисленных выше типов.

Для создания новой записи и их сохранения в базе данных можно использовать следующий код:

```csharp
using CloudKit;
...

private const string ReferenceItemRecordName = "ReferenceItems";
...

var newRecord = new CKRecord (ReferenceItemRecordName);
newRecord ["name"] = (NSString)nameTextField.Text;
await CloudManager.SaveAsync (newRecord);
```

### <a name="record-zones"></a>Записи зоны

Записи не существует сами по себе в данной базе данных, совместно существуют группы записей в зоне записи. Записи зоны можно рассматривать как таблицы в традиционных реляционных баз данных:

 [![](intro-to-cloudkit-images/image35.png "Набор записей сосуществовать в зоне записи")](intro-to-cloudkit-images/image35.png#lightbox)

Может существовать несколько записей в конкретной зоне записи и множественные записи зоны в данной базе данных. В каждой базе данных содержит записи зоны по умолчанию:

 [![](intro-to-cloudkit-images/image36.png "В каждой базе данных содержит записи зоны по умолчанию и пользовательские зоны")](intro-to-cloudkit-images/image36.png#lightbox)

Это значение по умолчанию, где хранятся записи. Кроме того можно создать пользовательские записи зоны. Базовый гранулярности, на какие Atomic фиксации и отслеживания изменений выполняется представляют собой записи зоны.

## <a name="record-identifiers"></a>Идентификаторы записи

Запись идентификаторы представляются в виде кортежа, содержащий оба клиента получает имя записи и зону, в которой существует запись. Идентификаторы записи имеют следующие характеристики:

-  Они создаются в клиентском приложении.
-  Они полностью нормализуются и представляют конкретное расположение записи.
-  Присваивался уникальный идентификатор записи в базе данных внешнего имени записи, их можно использовать для локальных баз данных, которые не хранятся в CloudKit мост.


Когда разработчики создают новые записи, их можно передать идентификатор записи. Если не указан идентификатор записи, UUID будет автоматически создан и назначен для этой записи.

Если разработчик создает новые идентификаторы записи, их можно выбрать для указания записи зоны, в которой будет принадлежать каждой записи. Если не указано, будет использоваться зона по умолчанию записи.

Идентификаторы записи, представлены в CloudKit Framework через `CKRecordID` класса. Для создания нового идентификатора записи можно использовать следующий код:

```csharp
var recordID =  new CKRecordID("My Record");
```

### <a name="references"></a>Ссылки

По ссылкам можно найти связи между записями в пределах конкретной базы данных:

 [![](intro-to-cloudkit-images/image37.png "По ссылкам можно найти связи между записями в пределах конкретной базы данных")](intro-to-cloudkit-images/image37.png#lightbox)

В приведенном выше примере родителей владельцем дочерних элементов, таким образом, чтобы дочерний дочерней записи родительской записи. Связь переходит из дочерней записи родительской записи и называется *обратно ссылка*.

Ссылки, предоставленные CloudKit Framework через `CKReference` класса. Они представляют собой способ позволить серверу iCloud взаимосвязь между записями.

Ссылки предоставляют механизм за каскадное удаление. Если родительскую запись удаляется из базы данных, все дочерние записи (как указано в отношении) будет автоматически удалено из базы данных также.

> [!NOTE]
> Несвязанные указатели, вероятность того, при использовании CloudKit. Например к моменту приложение извлечь список указателей записей, выбирает запись и затем предложено для записи, запись может больше не существует в базе данных. Приложения должны быть реализованы для корректной обработки этой ситуации.

Хотя это не обязательно обратно ссылки являются предпочтительными при работе с платформой CloudKit. Apple детально настраивать системы, чтобы сделать это наиболее эффективный тип ссылки.

При создании ссылки, разработчик может указать запись, которая уже находится в памяти или создать ссылку на идентификатор записи. Если с помощью идентификатора записи и указанная ссылка не существует в базе данных, будут создаваться указатель висячего.

Ниже приведен пример создания ссылки от известных записи:

```csharp
var reference = new CKReference(newRecord, new CKReferenceAction());
```

### <a name="assets"></a>Ресурсы

Активы разрешить для файла больших, неструктурированных данных в iCloud и связанные с данной записью.

 [![](intro-to-cloudkit-images/image38.png "Активы разрешить файлу больших, неструктурированных данных в iCloud и связанные с данной записью")](intro-to-cloudkit-images/image38.png#lightbox)

На стороне клиента `CKRecord` создается, описывающий файл, который будет отправлен на сервер iCloud. Объект `CKAsset` создается в файле и связан с записью, описывающей его.

При отправке файла на сервер, запись помещается в базе данных и файл копируется в специальных большое хранилище базы данных. Создается связь между записью указателя и загруженный файл.

Активы, представлены в CloudKit Framework через `CKAsset` класса и используются для хранения больших, неструктурированных данных. Поскольку разработчик хочет никогда не имеют большой, неструктурированных данных в памяти, активы реализуются с помощью файлов на диске.

Активы, принадлежащие записей, которые позволяет активы должно быть извлечено из iCloud, с помощью записи как указатель. В этом случае сервер можно средств сбора мусора, при удалении записи, которой принадлежит ресурс.

Поскольку `CKAssets` предназначены обработки больших файлов данных, Apple предназначен CloudKit эффективно отправлять и загружать необходимые активы.

Чтобы создать актив и связать его с записью можно использовать следующий код:

```csharp
var fileUrl = new NSUrl("LargeFile.mov");
var asset = new CKAsset(fileUrl);
newRecord ["name"] = asset;
```

Теперь рассмотренных все основные объекты в пределах CloudKit. Контейнеры связаны в приложения и базы данных. Базы данных содержат записи, которые группируются в записи зоны и указывает идентификаторы записи. Определенные родительско дочерних отношений между записей с помощью ссылки. Наконец большие файлы можно загрузить и связанных с записей с помощью средств.

## <a name="cloudkit-convenience-api"></a>CloudKit удобный API

Apple предоставляет два различных набора API для работы с CloudKit:

-  **Оперативной API** — каждые одной функции CloudKit. Для более сложных приложений этот API предоставляет возможность точного управления CloudKit.
-  **Удобный API** — предоставляет подмножество функций CloudKit общий, предварительно настроенных. Обеспечивает удобный и быстрый доступ решение для включения функции CloudKit в приложения iOS.


API удобства обычно больше подходит для большинства приложений iOS и Apple предлагает начиная с ним. В оставшейся части этого раздела рассматривается в следующих разделах удобства API:

-  Сохранение записи.
-  Извлечение записи.
-  Обновление записи.


### <a name="common-setup-code"></a>Общий код установки

Перед началом работы с API удобства CloudKit имеется некоторый код стандартной установки требуется. Начать с изменения приложения `AppDelegate.cs` файла и сделать его выглядеть следующим образом:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Foundation;
using UIKit;
using CloudKit;

namespace CloudKitAtlas
{
    [Register ("AppDelegate")]
    public partial class AppDelegate : UIApplicationDelegate
    {
        #region Computed Properties
        public override UIWindow Window { get; set;}
        public CKDatabase PublicDatabase { get; set; }
        public CKDatabase PrivateDatabase { get; set; }
        #endregion

        #region Override Methods
        public override bool FinishedLaunching (UIApplication application, NSDictionary launchOptions)
        {
            application.RegisterForRemoteNotifications ();

            // Get the default public and private databases for
            // the application
            PublicDatabase = CKContainer.DefaultContainer.PublicCloudDatabase;
            PrivateDatabase = CKContainer.DefaultContainer.PrivateCloudDatabase;

            return true;
        }

        public override void RegisteredForRemoteNotifications (UIApplication application, NSData deviceToken)
        {
            Console.WriteLine ("Registered for Push notifications with token: {0}", deviceToken);
        }

        public override void FailedToRegisterForRemoteNotifications (UIApplication application, NSError error)
        {
            Console.WriteLine ("Push subscription failed");
        }

        public override void ReceivedRemoteNotification (UIApplication application, NSDictionary userInfo)
        {
            Console.WriteLine ("Push received");
        }
        #endregion
    }
}
```

Приведенный выше код предоставляет открытых и закрытых CloudKit баз данных в виде сочетания клавиш, чтобы облегчить их для работы в остальной части приложения.

Добавьте следующий код для любого контейнера представление, в которых будет использоваться CloudKit или представления.

```csharp
using CloudKit;
...

#region Computed Properties
public AppDelegate ThisApp {
    get { return (AppDelegate)UIApplication.SharedApplication.Delegate; }
}
#endregion
```

При этом добавляется ярлык для получения `AppDelegate` и получить доступ к клавиш открытых и закрытых базы данных, созданной ранее.

Этот код в месте давайте рассмотрим реализация API удобства CloudKit в приложении iOS 8 Xamarin.

### <a name="saving-a-record"></a>Сохранение записи

При использовании шаблона, представленные выше при обсуждении записей следующий код создает новую запись и использовать API удобства сохранить его базы данных public:

```csharp
private const string ReferenceItemRecordName = "ReferenceItems";
...

// Create a new record
var newRecord = new CKRecord (ReferenceItemRecordName);
newRecord ["name"] = (NSString)nameTextField.Text;

// Save it to the database
ThisApp.PublicDatabase.SaveRecord(newRecord, (record, err) => {
    // Was there an error?
    if (err != null) {
        ...
    }
});
```

Три действия по поводу приведенный выше код:

1.  Путем вызова `SaveRecord` метод `PublicDatabase`, разработчику не придется указать способ отправки данных какой зоны, он записывается, и т. д. API удобства внимание все эти сведения о самой.
1.  Вызов выполняется в асинхронном режиме и предоставляет процедура обратного вызова после завершения вызова, либо с успешное выполнение или сбой. Если вызов завершается ошибкой, будет отображено сообщение об ошибке.
1.  CloudKit не предоставляет хранилища или сохраняемости; Это только на носителе передачи. Поэтому при запросе на сохранение записи немедленно отправкой серверов iCloud.


> [!NOTE]
> Из-за ««вероятны сети мобильной связи, где соединений постоянно, удаляются или прервана, один из первого вопросы, которые необходимо внести разработчику при работе с CloudKit обработки ошибок.

### <a name="fetching-a-record"></a>Выборке записи

С помощью записи создаются и успешно хранятся на сервере iCloud используйте следующий код для извлечения записи:

```csharp
// Create a record ID and fetch the record from the database
var recordID = new CKRecordID("MyRecordName");
ThisApp.PublicDatabase.FetchRecord(recordID, (record, err) => {
    // Was there an error?
    if (err != null) {
        ...
    }
});
```

Как сохранение записи, приведенный выше код асинхронной, простой и требует обработки ошибок отлично.

### <a name="updating-a-record"></a>Обновление записи

После записи получило от серверов iCloud, измените запись и сохранить изменения в базе данных можно использовать следующий код:

```csharp
// Create a record ID and fetch the record from the database
var recordID = new CKRecordID("MyRecordName");
ThisApp.PublicDatabase.FetchRecord(recordID, (record, err) => {
    // Was there an error?
    if (err != null) {

    } else {
        // Modify the record
        record["name"] = (NSString)"New Name";

        // Save changes to database
        ThisApp.PublicDatabase.SaveRecord(record, (r, e) => {
            // Was there an error?
            if (e != null) {
                 ...
            }
        });
    }
});
```

`FetchRecord` Метод `PublicDatabase` возвращает `CKRecord` Если вызов был успешным. Затем приложение изменяет записи и вызывает `SaveRecord` еще раз, чтобы записывать изменения обратно в базу данных.

В этом разделе на примере типичный цикл, что приложение будет использовать при работе с API удобства CloudKit. Приложение будет сохранить записи в iCloud, извлечение этих записей из iCloud, изменить записи и сохранить эти изменения обратно в iCloud.

## <a name="designing-for-scalability"></a>Проектирование для масштабируемости.

До сих в этой статье рассмотрела хранения и извлечения всей объектной модели приложения с iCloud серверов, каждый раз, он будет работать. Хотя этот подход хорошо работает с небольшой объем данных и очень мало пользовательской базы, он плохо масштабируется при объем информации, или пользователь базовый увеличивается.

### <a name="big-data-tiny-device"></a>Большие данные очень мала устройства

Популярные приложения становится, чем больше данных в базе данных и тем меньше нецелесообразно, является использование кэша, все данные на устройстве. Чтобы решить эту проблему, можно использовать следующие методы:

-  **Хранить большие объемы данных в облаке** — CloudKit был разработан для эффективной обработки больших объемов данных.
-  **Клиент должен просматривать только срез данных** — привести к остановке минимальный набор данных, необходимый для обработки любых задач в определенный момент времени.
-  **Можно изменить представления клиентов** — так как у каждого пользователя есть различные предпочтения, срез отображаемых данных можно изменить для пользователей и пользователей с отдельных представление любого заданного фрагмента могут быть разными.
-  **Клиент использует запросы для поиска точки зрения** — запросы позволяют пользователю просматривать небольшое подмножество большего набора данных, который существует в облаке.


### <a name="queries"></a>Запросы

Как уже говорилось выше, запросы позволяют разработчику выберите небольшое подмножество большего набора данных, который существует в облаке. Запросы, представлены в CloudKit Framework через `CKQuery` класса.

Запрос объединяет три разные вещи: тип записи ( `RecordType`), предикат ( `NSPredicate`) и, при необходимости сортировкой дескрипторов ( `NSSortDescriptors`). CloudKit поддерживает большинство `NSPredicate`.

#### <a name="supported-predicates"></a>Поддерживаемые предикатов

CloudKit поддерживает следующие типы `NSPredicates` при работе с запросами:


1. Подходящие записи, где имя — значение хранится в переменной:
    
    ```
    NSPredicate.FromFormat(string.Format("name = '{0}'", recordName))
    ```
   
2. Позволяет сопоставления должна быть основана на динамическое значение ключа, чтобы ключ не должен быть известен во время компиляции:
    
    ```
    NSPredicate.FromFormat(string.Format("{0} = '{1}'", key, value))
    ```
    
3. Подходящие записи, где значения записи больше, чем указанное значение:
   
    ```
    NSPredicate.FromFormat(string.Format("start > {0}", (NSDate)date))
    ```

4. Подходящие записи, где записи находится в пределах 100 метров заданного расположения:
    
    ```
    var location = new CLLocation(37.783,-122.404);
    var predicate = NSPredicate.FromFormat(string.Format("distanceToLocation:fromLocation(Location,{0}) < 100", location));
    ```

5. CloudKit поддерживает поиск токенами. Этот вызов создаст два маркера, один для `after` , а другой `session`. Возвращает запись, которая содержит эти два маркера:
    
    ```
    NSPredicate.FromFormat(string.Format("ALL tokenize({0}, 'Cdl') IN allTokens", "after session"))
    ```
    
 6. Поддерживает CloudKit составные соединены с помощью предикатов `AND` оператор.
    
    ```
    NSPredicate.FromFormat(string.Format("start > {0} AND name = '{1}'", (NSDate)date, recordName))
    ```
    


#### <a name="creating-queries"></a>Создание запросов

Следующий код может быть использован для создания `CKQuery` в приложении Xamarin iOS 8:

```csharp
var recordName = "MyRec";
var predicate = NSPredicate.FromFormat(string.Format("name = '{0}'", recordName));
var query = new CKQuery("CloudRecords", predicate);
```

Во-первых он создает предикат для выбора только тех записей, которые удовлетворяют заданным именем. Затем он создает запрос, который будет выбирать записи данного типа записи, соответствующие предикату.

#### <a name="performing-a-query"></a>Выполнение запроса

После создания запроса, используйте следующий код для выполнения запроса и обработки возвращаемых записях:

```csharp
var recordName = "MyRec";
var predicate = NSPredicate.FromFormat(string.Format("name = {0}", recordName));
var query = new CKQuery("CloudRecords", predicate);

ThisApp.PublicDatabase.PerformQuery(query, CKRecordZone.DefaultRecordZone().ZoneId, (NSArray results, NSError err) => {
    // Was there an error?
    if (err != null) {
       ...
    } else {
        // Process the returned records
        for(nint i = 0; i < results.Count; ++i) {
            var record = (CKRecord)results[i];
        }
    }
});
```

Приведенный выше код принимает запрос, созданный выше и выполняет ее в общей базе данных. Поскольку зона запись не указана, производится поиск всех зон. Если ошибок нет, массив `CKRecords` будут возвращены, совпадающих с параметрами запроса.

Способ подумать о запросах — они являются опросов и предназначены для создания срезов через больших наборов данных. Запросы, однако не подходит для больших, чаще всего статические наборы данных по следующим причинам:

-  Это плохо сказывается на времени работы батареи устройства.
-  Они предназначены для сетевого трафика.
-  Это неправильный для взаимодействия с пользователем, так как сведения, которые они видят ограничен, как часто приложение опрашивает базу данных. Сегодня пользователи ожидаемых push-уведомления, при каких-либо изменений.


### <a name="subscriptions"></a>Подписки

При работе с большой, чаще всего статические наборы данных, запрос не должно выполняться на клиентском устройстве, оно должно выполняться на сервере от имени клиента. Запрос должен выполняться в фоновом режиме и должны быть выполнены после сохранения каждой отдельной записи с текущего устройства или другого устройства, работая непосредственно с той же базе данных.

Наконец push-уведомление будет передан каждого устройства, подключенного к базе данных при выполнении запроса стороны сервера.

Подписки доступны в платформе CloudKit через `CKSubscription` класса. Они объединяют тип записи ( `RecordType`), предикат ( `NSPredicate`) и Push-уведомлений Apple ( `Push`).

> [!NOTE]
> Push-уведомлений CloudKit дополняются немного, содержащих полезные данные, содержащими специальные сведения CloudKit, например, что вызвало принудительную перезагрузку.

#### <a name="how-subscriptions-work"></a>Как работают подписок

Перед реализацией подписки в коде C#, давайте краткий обзор принципов работы подписки:

 [![](intro-to-cloudkit-images/image39.png "Обзор принципов работы подписки")](intro-to-cloudkit-images/image39.png#lightbox)

Выше диаграмме показан процесс обычной подписке следующим образом:

1.  Клиентское устройство создает новую подписку, содержащую набор условий запуска подписки и Push-уведомлений, будут отправлены после выполнения триггера.
2.  Подписки отправляется в базу данных, где он добавляется в коллекцию существующие подписки.
3.  Второе устройство создает новую запись и сохраняет эту запись в базу данных.
4.  Его список подписок новую запись соответствует любой из их условия поиска базы данных.
5.  Если соответствие найдено, устройств, которые зарегистрированы подписки со сведениями о записи, вызвавшей ее, чтобы оно запускалось отправляется Push-уведомлений.


Обладая такими сведениями в месте давайте взглянем на создание подписок в Xamarin iOS 8 приложения.

#### <a name="creating-subscriptions"></a>Создание подписок

Для создания подписки можно использовать следующий код:

```csharp
// Create a new subscription
DateTime date;
var predicate = NSPredicate.FromFormat(string.Format("start > {0}", (NSDate)date));
var subscription = new CKSubscription("RecordType", predicate, CKSubscriptionOptions.FiresOnRecordCreation);

// Describe the type of notification
var notificationInfo = new CKNotificationInfo();
notificationInfo.AlertLocalizationKey = "LOCAL_NOTIFICATION_KEY";
notificationInfo.SoundName = "ping.aiff";
notificationInfo.ShouldBadge = true;

// Attach the notification info to the subscription
subscription.NotificationInfo = notificationInfo;
```

Во-первых он создает предикат, который содержит условие для активации подписки. Затем создается подписка, для определенного типа записи и задает параметр при тестировании триггер. Наконец он определяет тип уведомления, которые будут происходить при подписки запускается и присоединяет его подписки.

### <a name="saving-subscriptions"></a>Сохранение подписки

Создать подписки следующий код он сохраняется в базу данных:

```csharp
// Save the subscription to the database
ThisApp.PublicDatabase.SaveSubscription(subscription, (s, err) => {
    // Was there an error?
    if (err != null) {

    }
});
```

С помощью API удобства, вызов асинхронной, простой и обеспечивает обработку ошибок легко.

#### <a name="handling-push-notifications"></a>Обработка Push-уведомлений

Если разработчик использовал ранее Push-уведомлений Apple (APS), процесс обработки уведомления, созданные CloudKit должны быть знакомы.

В `AppDelegate.cs`, переопределите `ReceivedRemoteNotification` следующим образом:

```csharp
public override void ReceivedRemoteNotification (UIApplication application, NSDictionary userInfo)
{
    // Parse the notification into a CloudKit Notification
    var notification = CKNotification.FromRemoteNotificationDictionary (userInfo);

    // Get the body of the message
    var alertBody = notification.AlertBody;

    // Was this a query?
    if (notification.NotificationType == CKNotificationType.Query) {
        // Yes, convert to a query notification and get the record ID
        var query = notification as CKQueryNotification;
        var recordID = query.RecordId;
    }
}
```

Приведенный выше код запрашивает CloudKit выполнить синтаксический анализ сведений о пользователях в CloudKit уведомление. Затем извлекается информация о предупреждении. Наконец проверяется тип уведомления и уведомление будет обрабатывать их соответствующим образом.

В этом разделе показано, как ответить на большие наборы данных, проблема очень мала устройства, представленные выше, с помощью запросов и подписок. Приложение будет оставлять его больших объемов данных в облаке и использовать эти технологии для создания представлений в этот набор данных.

## <a name="cloudkit-user-accounts"></a>Учетные записи пользователей CloudKit

Как уже отмечалось в начале этой статьи, CloudKit построено на основе существующей инфраструктуры iCloud. Ниже мы рассмотрим, подробно способ предоставления учетных записей с помощью CloudKit API разработчик.

### <a name="authentication"></a>Проверка подлинности

При работе с учетными записями пользователей, прежде всего проходит проверку подлинности. CloudKit поддерживает проверку подлинности с помощью iCloud вошедшего в систему пользователя на устройстве. Проверка подлинности выполняется в фоновом и обрабатывается операций ввода-вывода. Таким образом разработчики не пропустите подробные сведения о реализации проверки подлинности. Они проверяют только для просмотра, если пользователь вошел в систему.

### <a name="user-account-information"></a>Сведения об учетной записи пользователя

CloudKit предоставляет следующие сведения о пользователе для разработчика.

-  **Удостоверение** — позволяют уникально идентифицировать пользователя.
-  **Метаданные** — возможность сохранять и извлекать сведения о пользователях.
-  **Конфиденциальность** — все сведения обрабатывается в манор обоснованное конфиденциальности. Ничего не предоставляется, если пользователь согласился его.
-  **Обнаружение** — дает пользователям возможность обнаружения друзей, использующие то же приложение.


Далее мы рассмотрим эти разделы, подробно.

#### <a name="identity"></a>идентификации

Как уже говорилось выше, CloudKit предоставляет способ для приложения для идентификации данного пользователя:

 [![](intro-to-cloudkit-images/image40.png "Идентификация однозначно данного пользователя")](intro-to-cloudkit-images/image40.png#lightbox)

Отсутствует клиентское приложение, работающее на пользователя устройства и всех баз данных конкретного пользователя закрытого внутри контейнера CloudKit. Клиентское приложение будет связать с одной из этих конкретных пользователей. Следующий пример основан на пользователя, который выполнил вход в iCloud локально на устройстве.

Поскольку это поступает из iCloud, нет форматированного резервное хранилище сведения пользователя. И поскольку iCloud размещается фактически контейнер, его можно сопоставлять пользователей. Приведенная выше, пользователь, учетная запись которого iCloud `user@icloud.com` связана с текущего клиента.

На основе контейнера по Идентификатору пользователя уникальный, созданный случайным образом создается и связанные с записью пользователя iCloud (адрес электронной почты). Этот идентификатор пользователя возвращается приложению и может использоваться любым способом усмотрению разработчика.

> [!NOTE]
> Приложениями, запущенными на одном устройстве для одного пользователя iCloud будет иметь разные идентификаторы пользователя, так как они связаны в другие контейнеры CloudKit.

Следующий программный код получает идентификатор пользователя CloudKit для пользователя в iCloud пользователя на устройстве:

```csharp
public CKRecordID UserID { get; set; }
...

// Get the CloudKit User ID
CKContainer.DefaultContainer.FetchUserRecordId ((recordID, err) => {
    // Was there an error?
    if (err!=null) {
        Console.WriteLine("Error: {0}", err.LocalizedDescription);
    } else {
        // Save user ID
        UserID = recordID;
    }
});
```

Приведенный выше код запрашивает контейнер CloudKit так, чтобы указать идентификатор текущего пользователя. Так как эта информация поступает из iCloud сервера, вызов выполняется асинхронно, и обработка ошибок не требуется.

#### <a name="metadata"></a>Метаданные

Каждый пользователь в CloudKit имеет определенные метаданные, которые описывают их. Эти метаданные, представлены в виде записи CloudKit:

 [![](intro-to-cloudkit-images/image41.png "Каждый пользователь в CloudKit имеет определенные метаданные, которые описывают их")](intro-to-cloudkit-images/image41.png#lightbox)

Поиск конкретного пользователя контейнер существует внутри личная база данных по одной записи, определяющий этого пользователя. Существует много записей пользователя внутри базы данных Public, для каждого пользователя контейнера. Один из них будет иметь идентификатор записи, соответствующий текущему идентификатор записи пользователя.

Записи пользователя в общей базы данных являются world для чтения. Они обрабатываются, в большинстве случаев, как запись обычного и имеющие тип `CKRecordTypeUserRecord`. Эти записи зарезервировано системой и не доступны для запросов.

Для доступа к записи пользователя, используйте следующий код:

```csharp
public CKRecord UserRecord { get; set; }
...

// Get the user's record
PublicDatabase.FetchRecord(UserID, (record ,er) => {
    //was there an error?
    if (er != null) {
        Console.WriteLine("Error: {0}", er.LocalizedDescription);
    } else {
        // Save the user record
        UserRecord = record;
    }
});
```

Приведенный выше код запрашивает возвращать записи пользователя для пользователя, который является Идентификатором, мы доступ выше общей базы данных. Так как эта информация поступает из iCloud сервера, вызов выполняется асинхронно, и обработка ошибок не требуется.

#### <a name="privacy"></a>Конфиденциальность

CloudKit был конструктора по умолчанию для защиты конфиденциальности пользователя, выполнившего вход. По умолчанию предоставляется не персональные идентификационные сведения о пользователе. Существуют случаи, где приложение будет требовать ограниченные сведения о пользователе.

В таких случаях приложение может запросить, что пользователь раскрывает эти сведения. Диалоговое окно отображается для пользователей, запрашиваются, чтобы согласиться на предоставление доступа к их сведения об учетной записи.

#### <a name="discovery"></a>Обнаружение

При условии, что пользователь как согласился на приложения ограниченный доступ к своей учетной записи пользователя, не могут быть обнаружены другим пользователям приложения:

 [![](intro-to-cloudkit-images/image42.png "Пользователь может быть доступной для обнаружения приложения другим пользователям")](intro-to-cloudkit-images/image42.png#lightbox)

Клиентское приложение осуществляет обмен данными в контейнер, а контейнер разговаривает iCloud для доступа к данным пользователя. Пользователь может указать адрес электронной почты и обнаружение может быть использовано для получения сведений о пользователя. При необходимости код пользователя может также использоваться для получения сведений о пользователе.

CloudKit также предоставляет способ для получения сведений о любой пользователь, который может быть друзьях текущего зарегистрированного на пользователя iCloud запросив всей адресной книги. Процесс CloudKit по запросу в книге контактов пользователя и использовать адреса электронной почты для просмотра, если он может найти другие приложения, соответствующие этим адресам пользователя.

Это позволяет приложению использовать обратитесь к книге пользователя без предоставления доступа к нему или запросом на утверждение доступ к контактам. Не допускайте одновременной контактные данные доступны в приложение только CloudKit процесс имеет доступ.

Напомню, имеются следующие три типа входных данных для обнаружения пользователей.

-  **Идентификатор записи пользователя** — обнаружение может выполняться на наличие идентификатора пользователя текущего зарегистрированного в CloudKit пользователя.
-  **Адрес электронной почты пользователя** — пользователь может предоставить адрес электронной почты, и он может использоваться для обнаружения.
-  **Обратитесь к книге** — адресной книге пользователя может использоваться для обнаружения пользователей приложения, которые имеют один и тот же адрес электронной почты, как указано в их контактов.


Обнаружение пользователей возвращаются следующие сведения:

-  **Идентификатор записи пользователя** -уникальный идентификатор пользователя в общей базе данных.
-  **Первый и Фамилия** — в соответствии с общей базы данных.


Эта информация будет возвращаться только для пользователей, имеющих обнаружения исключены в.

Следующий код будет обнаруживать сведения о пользователе, вошедшем в iCloud на устройстве:

```csharp
public CKDiscoveredUserInfo UserInfo { get; set; }
...

// Get the user's metadata
CKContainer.DefaultContainer.DiscoverUserInfo(UserID, (info, e) => {
    // Was there an error?
    if (e != null) {
        Console.WriteLine("Error: {0}", e.LocalizedDescription);
    } else {
        // Save the user info
        UserInfo = info;
    }
});
```

Используйте следующий код для запроса всех пользователей в книге контакта:

```csharp
// Ask CloudKit for all of the user's friends information
CKContainer.DefaultContainer.DiscoverAllContactUserInfos((info, er) => {
    // Was there an error
    if (er != null) {
        Console.WriteLine("Error: {0}", er.LocalizedDescription);
    } else {
        // Process all returned records
        for(int i = 0; i < info.Count(); ++i) {
            // Grab a user
            var userInfo = info[i];
        }
    }
});
```

В этом разделе мы рассмотрели четыре основных областей доступа к учетной записи пользователя, который CloudKit может предоставить к приложению. Получение метаданных и удостоверения пользователя, для политики конфиденциальности, встроенные в CloudKit и, наконец, возможность обнаружения других пользователей приложения.

## <a name="the-development-and-production-environments"></a>Разработка приложений и рабочих средах

CloudKit предоставляет отдельные среды разработки и эксплуатации для типов записей и данных приложения. Среда разработки является более гибкую среду, которая доступна только для членов команды разработчиков. Когда приложение добавляет новое поле к записи и сохраняет эту запись в среде разработки, сервер автоматически обновляет сведения о схеме.

Разработчик может использовать эту функцию для внесения изменений в схему во время разработки, что экономит время. Один оговорка заключается в том, что после добавления поля к записи, тип данных, связанный с этим полем не может изменяться программно. Чтобы изменить тип поля, разработчик должен удалить поле в [CloudKit мониторинга](https://icloud.developer.apple.com/dashboard/) и добавьте его повторно с новым типом.

Перед развертыванием приложения разработчик можно перенести свои схемы и данных в рабочей среде с помощью **CloudKit мониторинга**. При запуске для рабочей среды, сервер не позволяет приложению изменять схемы программным путем. Разработчик может производить изменения с **CloudKit мониторинга** , но пытается добавить поля в записи в рабочей среде приводят к ошибкам.

> [!NOTE]
> IOS Simulator работает только с **среды разработки**. Когда разработчик будет готов для тестирования приложения в **рабочей среде**, физических операций ввода-вывода устройства не требуется.


## <a name="shipping-a-cloudkit-enabled-app"></a>Приложения с поддержкой доставки CloudKit

Перед доставкой приложение, использующее CloudKit, его необходимо настроить целевой объект **CloudKit рабочей среде** или приложения, будут отклонены Apple.

Выполните следующие действия:

1. В Visual Studio для Ma компиляция **выпуска** > **устройства iOS**: 

    [![](intro-to-cloudkit-images/shipping01.png "Компиляция приложения для выпуска")](intro-to-cloudkit-images/shipping01.png#lightbox)

2. Из **построения** последовательно выберите пункты **архив**: 

    [![](intro-to-cloudkit-images/shipping02.png "Выберите архив")](intro-to-cloudkit-images/shipping02.png#lightbox)

3. **Архив** будет создан и отображается в Visual Studio для Mac: 

    [![](intro-to-cloudkit-images/shipping03.png "Архив будет создан и отображается")](intro-to-cloudkit-images/shipping03.png#lightbox)

4. Запустите **Xcode**.
5. Из **окна** последовательно выберите пункты **Организатор**: 

    [![](intro-to-cloudkit-images/shipping04.png "Выберите Организатор")](intro-to-cloudkit-images/shipping04.png#lightbox)

6. Выберите архив приложения и нажмите кнопку **экспорт...**  кнопки: 

    [![](intro-to-cloudkit-images/shipping05.png "Архив приложения")](intro-to-cloudkit-images/shipping05.png#lightbox)
    
7. Выберите метод для экспорта и нажмите кнопку **Далее** кнопки: 

    [![](intro-to-cloudkit-images/shipping06.png "Выберите метод для экспорта")](intro-to-cloudkit-images/shipping06.png#lightbox)

8. Выберите **разработчиков** из раскрывающегося списка и нажмите кнопку **Выбор** кнопки: 

    [![](intro-to-cloudkit-images/shipping07.png "Выберите из раскрывающегося списка команды разработчиков")](intro-to-cloudkit-images/shipping07.png#lightbox)

9. Выберите **рабочей** из раскрывающегося списка и нажмите кнопку **Далее** кнопки: 

    [![](intro-to-cloudkit-images/shipping08.png "Выберите из раскрывающегося списка производства")](intro-to-cloudkit-images/shipping08.png#lightbox)

10. Проверьте параметр и нажмите кнопку **Экспорт** кнопки: 

    [![](intro-to-cloudkit-images/shipping09.png "Проверьте параметр")](intro-to-cloudkit-images/shipping09.png#lightbox)

11. Выберите расположение для создания результирующего приложения `.ipa` файла.

Процесс аналогичен для отправки приложения непосредственно в iTunes Connect, просто нажав кнопку **отправить...**  кнопки, вместо экспорта..., после выбора архива в окне «Организатор».

## <a name="when-to-use-cloudkit"></a>Когда следует использовать CloudKit

Как мы видели в этой статье, CloudKit предоставляет простой способ для приложения для хранения и извлечения информации из серверов iCloud. Таким образом, выполняется CloudKit не является устаревшей и устаревание любые существующие средства и платформы.

### <a name="use-cases"></a>Варианты использования

В следующих вариантах применения должно помочь разработчику по использованию определенного iCloud framework или технологии:

-  **iCloud хранилищу ключей и значений** — асинхронно поддерживает небольшой объем данных в актуальном состоянии и отлично подходит для работы с установки приложения. Тем не менее ограничен для очень небольшой объем информации.
-  **iCloud диск** — построена на базе существующего iCloud API-интерфейсы документы и предоставляет простой API для синхронизации неструктурированные данные из файловой системы. Он предоставляет полную версию автономной кэша в Mac OS X и отлично подходит для приложения, ориентированные на документ.
-  **iCloud основных данных** — позволяет данные реплицируются между всеми устройства пользователя. Данные находятся в однопользовательском режиме и отлично подходит для хранения закрытого структурированных данных синхронизации.
-  **CloudKit** — предоставляет общедоступные данные обоих структуру и массового и возможность обработки больших наборов данных и больших неструктурированных файлов. Его привязан к пользователю, iCloud учетной записи и предоставляет клиент перенаправлен передачи данных.


Хранение этих помнить варианты использования, разработчик должны быть выбраны правильные iCloud технологии обеспечивают текущая функциональность нужного вам приложения и улучшения масштабируемости для будущего роста.

## <a name="summary"></a>Сводка

В этой статье был проиллюстрирован Краткое введение в CloudKit API. Он показано, как подготовить и настроить приложение Xamarin iOS для использования CloudKit. Он был проиллюстрирован функции API CloudKit удобства. Он имеет Показать как спроектировать CloudKit установлено приложение для обеспечения масштабируемости с помощью запросов и подписок. И наконец показали данные учетной записи пользователя, представленного CloudKit в приложение.

## <a name="related-links"></a>Связанные ссылки

- [CloudKitAtlas (пример)](https://developer.xamarin.com/samples/monotouch/ios8/CloudKitAtlas/)
- [Введение в iOS 8](~/ios/platform/introduction-to-ios8.md)
- [Создайте профиль подготовки](~/ios/get-started/installation/device-provisioning/index.md)
