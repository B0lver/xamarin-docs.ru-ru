---
title: "Начальное руководство по C# для разработчиков Objective-C"
description: "Xamarin.iOS позволяет использовать платформенно-независимый код, созданный на языке C#, на нескольких платформах. Но иногда нужно применить в существующих приложениях iOS уже готовый код на Objective-C. Эта статья быстро введет в курс дела тех разработчиков, которые уже знакомы с Objective-C и намерены перейти к использованию Xamarin и C#."
ms.topic: article
ms.prod: xamarin
ms.assetid: 00285CBD-AE5E-4126-8F22-6B231B9467EA
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.openlocfilehash: bfc91ba92b2ed62e61d7ba99dec03784933295bd
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="c-primer-for-objective-c-developers"></a>Начальное руководство по C# для разработчиков Objective-C

_Xamarin.iOS позволяет использовать платформенно-независимый код, созданный на языке C#, на нескольких платформах. Но иногда нужно применить в существующих приложениях iOS уже готовый код на Objective-C. Эта статья быстро введет в курс дела тех разработчиков, которые уже знакомы с Objective-C и намерены перейти к использованию Xamarin и C#._

Xamarin позволяет применять код на C# в приложениях iOS и OS X, разработанных на Objective-C, в тех случаях, когда код платформы не является обязательным. Это дает возможность использовать такой код не только на устройствах Apple. Благодаря такому механизму можно применять на нескольких платформах разные элементы, например веб-службы, средства анализа JSON и (или) XML, любые пользовательские алгоритмы.

Чтобы воспользоваться преимуществами Xamarin, сохраняя существующие ресурсы Objective-C, код Objective-C можно сделать доступным из управляемого кода C# с помощью реализованной в Xamarin технологии привязок. Также вы всегда можете портировать код на C#, преобразовав каждую строку. Независимо от того, какой подход вы выберете (привязка или портирование), чтобы эффективного применять существующий код Objective-C для Xamarin.iOS, потребуются определенные знания языков Objective-C и C#.

## <a name="objective-c-interop"></a>Взаимодействие с Objective-C

В настоящее время не существует механизмов, позволяющих создать в Xamarin.iOS библиотеку на C#, которую можно вызвать из Objective-C. В первую очередь это связано с тем, что, помимо привязки, потребуется и среда выполнения Mono. Но вы можете создать большую часть логики приложения в Objective-C, в том числе пользовательские интерфейсы. Для этого поместите код Objective-C в библиотеку и создайте привязку к ней. Xamarin.iOS потребуется только для начальной загрузки приложения (чтобы создать точку входа `Main`). Вся логика, выполняемая после этого, может быть написана на Objective-C и предоставлена в C# через привязку (или с помощью P/Invoke). Такой механизм позволит вам сохранить на Objective-C всю логику работы с конкретной платформой, а на C# создать платформенно-независимые компоненты.

В нашей статье выделены некоторые важные сходства и различия двух обсуждаемых языков. Это руководство поможет вам перейти к применению C# на платформе Xamarin.iOS любым из двух способов: создать привязку существующего кода на Objective-C или портировать его в C#.

Дополнительные сведения о создании привязок есть в других документах о [привязке Objective-C](~/ios/platform/binding-objective-c/index.md).

## <a name="language-comparison"></a>Сравнение языков

Objective-C и C# значительно отличаются друг от друга синтаксически и по концепциям среды выполнения. Objective-C является динамическим языком со схемой передачи сообщений, а C# использует статическую типизацию. По синтаксису Objective-C очень похож на Smalltalk, тогда как C# унаследовал почти весь базовый синтаксис от Java, хотя за последние годы появилось множество дополнительных возможностей и отличий от Java.

Но все же в Objective-C и C# есть несколько почти аналогичных языковых возможностей. Понимание различий полезно при создании привязки для кода Objective-C из C# и (или) при портировании Objective-C в C#.

### <a name="protocols-vs-interfaces"></a>Сравнение протоколов и интерфейсов,

В Objective-C и C# используется одиночное наследование. Однако оба этих языка позволяют реализовать в одном классе сразу несколько интерфейсов. В Objective-C эти логические объекты именуются *протоколами* а в C# — *интерфейсами*. Реализация интерфейсов в C# отличается от протоколов в Objective-C в первую очередь тем, что для протоколы могут иметь необязательные методы. Дополнительные сведения см в статье о [событиях, делегатах и протоколах](~/ios/app-fundamentals/delegates-protocols-and-events.md).

### <a name="categories-vs-extension-methods"></a>Категории и Методы расширения

Objective-C позволяет добавлять в класс методы, для которых нет кода реализации, используя *категории*. В C# похожая концепция применяется через *методы расширения*.

Методы расширения позволяют добавить в класс статические методы, а статические методы в C# аналогичны методам класса в Objective-C. Например, в приведенном ниже коде метод с именем `ScrollToBottom` добавляется в класс `UITextView`, который является управляемым классом и привязан к классу `UITextView` Objective-C через UIKit:

```csharp
public static class UITextViewExtensions
{
    public static void ScrollToBottom (this UITextView textView)
    {
        // code to scroll textView
    }
}
```

Теперь, когда в коде создан экземпляр `UITextView`, этот метод будет доступен в списке автозаполнения, как показано ниже:

 ![](primer-images/01-extensionmethodintellisense.png "Метод, доступный в списке автозаполнения")

При вызове метода расширения экземпляр передается в качестве аргумента, как, например, `textView` в этом примере.

### <a name="frameworks-vs-assemblies"></a>Сравнение платформ и Сборки

В Objective-C есть "платформы", которые представляют собой связанные с пакетами классы, размещенные в специальных каталогах. В C# и .NET вместо них используются сборки, которые позволяют многократно использовать заранее скомпилированный код. В других средах (не iOS) сборки содержат код на промежуточном языке (IL). Этот код компилируется по требованию (JIT) во время выполнения программы. Но в компании Apple не поддерживается применение JIT в приложениях iOS. Поэтому код C#, создаваемый в Xamarin для iOS, заранее компилируется в один исполняемый файл Unix вместе с файлами метаданных, включенными в пакет приложения.

### <a name="selectors-vs-named-parameters"></a>Сравнение селекторов и именованных параметров

Методы Objective-C обязательно включают имена параметров в селекторы. Например, селектор `AddCrayon:WithColor:` четко указывает назначение каждого параметра при использовании в коде. C# также предлагает дополнительную поддержку именованных аргументов.

Например, представленный выше код можно реализовать в C# с помощью именованных аргументов следующим образом:

```csharp
AddCrayon (crayon: myCrayon, color: UIColor.Blue);
```

В C# версии 4.0 реализована поддержка этой возможности, но на практике она применяется довольно редко. Тем не менее при необходимости вы всегда можете ею воспользоваться.

### <a name="headers-and-namespaces"></a>Заголовки и пространства имен

Objective-C является супермножеством языка C. Это значит, что для открытых объявлений используются заголовки, размещенные отдельно от файла реализации. В C# не используются файлы заголовков. В отличие от Objective-C, код C# содержится в пространствах имен. Чтобы включить код, существующий в определенном пространстве имен, вы можете добавить в начало файла реализации директиву using или указать использовать полное имя типа вместе с пространством имен.

Например, следующий код включает пространство имен `UIKit`, то есть делает все классы этого пространства имен доступными в текущей реализации:

```csharp
using UIKit
namespace MyAppNamespace
{
    // implementation of classes
}
```

Кроме того, ключевое слово namespace в приведенном выше коде задает пространство имен, используемое для самого файла реализации. Если несколько файлов реализации используют одно пространство имен, то это пространство имен не обязательно включать в директиву using, так как такое включение подразумевается по умолчанию.

### <a name="properties"></a>Свойства

Как в Objective-C, так и в C# используется концепция свойств, чтобы предоставить абстракции высокого уровня для методов доступа. В Objective-C методы доступа автоматически создаются при помощи директивы компилятора @property. А в C# свойства поддерживаются в самом языке. В C# свойство можно реализовать двумя способами: длинный синтаксис для обращения к резервному полю или более короткий синтаксис автоматического свойства. Эти способы представлены в следующих примерах:

```csharp
// automatic property syntax
public string Name { get; set; }

// property implemented with a backing field
string address;
public string Address {
    get {
        // could add additional code here
        return address;
    }
    set {
        address = value;
    }
}
```

### <a name="static-keyword"></a>Ключевое слово static

Ключевое слово *static* в Objective-C и C# имеет кардинально разные значения. В Objective-C статические функции позволяют ограничить область действия текущим файлом. А в C# области поддерживается через ключевые слова *public*, *private* и *internal*.

Переменная в Objective-C, к которой применено ключевое слово static, сохраняет свое значение для разных вызовов функций.

В C# также используется ключевое слово static. При применении к методу здесь оно фактически имеет то же назначение, что и модификатор `+` в Objective-C. Проще говоря, это ключевое слово используется, чтобы создать метод класса. Его можно применить и к другим конструкциям, например к полям, свойствам и событиям. В таком случае они становятся частью самого типа, в котором объявлены, а не частью экземпляра этого типа. Вы можете даже создать статический класс, в котором все определенные методы также должны быть статическими.

### <a name="nsarray-vs-list-initialization"></a>Сравнение NSArray и Инициализация списка

Теперь Objective-C позволяет использовать литеральный синтаксис совместно с `NSArray`. Это упрощает инициализацию. Но в C# есть тип `List` с еще более богатыми возможностями — *универсальный* тип списка. Это означает, что тип его элементов задается в коде, предназначенном для создания списка (аналогично шаблонам в C++). Кроме того, списки поддерживают синтаксис автоматической инициализации, как показано ниже:

```csharp
MyClass object1 = new MyClass ();
MyClass object2 = new MyClass ();
List<MyClass> myList = new List<MyClass>{ object1, object2 };
```

### <a name="blocks-vs-lambda-expressions"></a>Сравнение блоков и Лямбда-выражения

В Objective-C *блоки* используются для создания замыканий. Это позволяет определить встроенную функцию с учетом состояния того фрагмента, в который она включена. В C# схожая концепция реализована при помощи лямбда-выражений. Лямбда-выражения в C# создаются с использованием оператора `=>`, как показано ниже:

```csharp
(args) => {
    //  implementation code
};
```

Дополнительные сведения о лямбда-выражениях см. в [руководстве по программированию на C#](http://msdn.microsoft.com/en-us/library/vstudio/bb397687.aspx), предоставленном корпорацией Майкрософт.

## <a name="summary"></a>Сводка

В этой статье мы сравнили широкий набор возможностей языков Objective-C и C#. Некоторые из этих возможностей в обоих языках практически идентичны, например блоки и лямбда-выражения или категории и методы расширения. Но есть несколько аспектов, по которым языки заметно различаются, например концепция пространства имен в C# и значение ключевого слова static.
