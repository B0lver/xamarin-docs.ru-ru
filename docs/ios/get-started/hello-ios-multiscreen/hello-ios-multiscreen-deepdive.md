---
title: 'Привет, iOS (несколько экранов): теперь подробнее'
description: Этот документ более подробно рассматривает расширенное приложение Phoneword, более подробно знакомя читателя со структурой модель-представление-контроллер (MVC), навигацией iOS и другими ключевыми концепциями по разработке для iOS.
ms.topic: quickstart
ms.prod: xamarin
ms.assetid: c866e5f4-8154-4342-876e-efa0693d66f5
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 10/05/2018
ms.openlocfilehash: 953f626774c02a2861d0d9b3be1f1234f181c622
ms.sourcegitcommit: 57e8a0a10246ff9a4bd37f01d67ddc635f81e723
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/08/2019
ms.locfileid: "57670601"
---
# <a name="hello-ios-multiscreen--deep-dive"></a>Привет, iOS (несколько экранов): теперь подробнее

В этом пошаговом руководстве мы создадим и запустим первое приложение Xamarin.iOS с поддержкой нескольких экранов. Пришло время для расширения знаний о навигации и архитектуре iOS.

В этом руководстве мы опишем шаблон *MVC (модель-представление-контроллер)* и его роль в архитектуре и навигации iOS.
Затем мы подробно рассмотрим контроллер навигации и научимся использовать его для создания привычной навигации iOS.

## <a name="model-view-controller-mvc"></a>Модель-представление-контроллер (MVC)

В руководстве [Привет, iOS](~/ios/get-started/hello-ios/index.md) мы узнали, что у приложений iOS есть только одно *окно*, в которое контроллеры представления могут загружать свои *иерархии представления содержимого*. Во втором пошаговом руководстве по созданию приложения Phoneword мы добавим второй экран для нашего приложения и настроим обмен данными (список телефонных номеров) между экранами, как показано на следующей схеме:

 [![](hello-ios-multiscreen-deepdive-images/08.png "Схема иллюстрирует передачу данных между двумя экранами")](hello-ios-multiscreen-deepdive-images/08.png#lightbox)

В нашем примере данные собираются на первом экране, передаются из первого контроллера представления во второй и отображаются на втором экране. Такое разделение экранов, данных и контроллеров представлений соответствует шаблону *MVC (Модель — представление — контроллер)*. В следующих разделах мы рассмотрим преимущества этого шаблона и его компонентов, а также применим его в нашем приложении Phoneword.

### <a name="benefits-of-the-mvc-pattern"></a>Преимущества шаблона MVC

Модель-представление-контроллер (MVC) — это *шаблон проектирования*, многократно используемое архитектурное решение типовых проблем или сценариев использования в коде. MVC — это архитектура для приложений с *графическим интерфейсом пользователя (GUI)*. В этой архитектуре объектам приложения назначается одна из трех ролей: *модель* (данные или логика приложения), *представление* (интерфейс пользователя) и *контроллер* (код программной части). На следующей схеме показаны связи между тремя элементами шаблона MVC и пользователем:

 [![](hello-ios-multiscreen-deepdive-images/00.png "Схема иллюстрирует связи между тремя элементами шаблона MVC и пользователем")](hello-ios-multiscreen-deepdive-images/00.png#lightbox)

Преимущество использования шаблона MVC в том, что он обеспечивает логическое разделение между разными частями приложения с графическим интерфейсом и упрощает повторное использование кода и представлений. Давайте начнем и рассмотрим каждую из трех ролей более подробно.

> [!NOTE]
> Шаблон MVC — это аналог структуры страницы ASP.NET или приложения WPF. В этих примерах представление — это компонент, который фактически отвечает за описание пользовательского интерфейса и соответствует странице ASPX (HTML) в ASP.NET или XAML в приложении WPF. Контроллер — это компонент, который отвечает за управление представлением, он соответствует коду программной части в ASP.NET или WPF.

### <a name="model"></a>Модель

Объект типа модель обычно описывает способ представления данных в конкретном приложении, которые должны отображаться или вводиться в представлении. Модель часто задается свободно, например, в нашем приложении **Phoneword_iOS** моделью является список номеров телефонов (в виде списка строк). Если мы создаем кроссплатформенное приложение, то код **PhonewordTranslator** мы можем совместно использовать как в iOS, так и в приложениях.Android. Можно считать, что общий код и есть модель.

Для MVC абсолютно неважно, как в модели *хранятся данные* и как *обеспечивается доступ*. Другими словами, MVC безразлично, как выглядят наши данные или как они хранятся, важно только, как данные *представлены*. Например, мы можем хранить данные в базе данных SQL, в облачном хранилище или просто использовать `List<string>`. В MVC в шаблон включается только способ представления данных сам по себе.

В некоторых случаях модельная часть MVC может быть пустой. Например, мы можем добавить статические страницы в наше приложение с информацией о том, как работает преобразователь телефонных номеров, почему мы создали его и как с нами связаться, чтобы сообщить об ошибках. Экраны такого приложения по-прежнему необходимо создавать с помощью представлений и контроллеров, но они не будут содержать никаких реальных данных модели.

> [!NOTE]
> Иногда модельной частью шаблона MVC называют всю внутреннюю часть приложения, а не только данные, которые отображаются в пользовательском интерфейсе. В этом руководстве мы придерживались современной интерпретации понятия модель, но различия не очень значительные.

### <a name="view"></a>Просмотр

Представление — это компонент, отвечающий за отображение пользовательского интерфейса. Практически во всех платформах, использующих шаблон MVC, пользовательский интерфейс представляет собой иерархию представлений. Можно считать, что представление в MVC является иерархией с одним представлением (называемым корневым представлением) на верхнем уровне иерархии и любым количеством дочерних представлений в нем (называемыми подчиненными представлениями). В iOS компонент экрана "иерархия представления содержимого" соответствует компоненту "представление" в MVC.

### <a name="controller"></a>Контроллер

Объект типа контроллер — компонент, который связывает все вместе и представлен в iOS классом `UIViewController`. Можно считать контроллер вспомогательным кодом для экрана или набора представлений. Контроллер отвечает за ожидание запросов от пользователя и возврат соответствующей иерархии представлений. Он ожидает запросы из представления (нажатие кнопки, ввода текста и т. д.) и выполняет соответствующую обработку, изменение и обновление представления. Контроллер также отвечает за создание или получение модели из любого существующего в приложении внутреннего хранилища данных и заполнение представления этими данными.

Помимо этого контроллеры могут управлять другими контроллерами. Например, один контроллер может загрузить другой контроллер, если это необходимо для отображения другого экрана, или управлять стеком контроллеров для отслеживания их порядка и переходами между ними. В следующем разделе мы рассмотрим пример контроллера, который управляет другими контроллерами; это, как мы уже говорили, специальный тип контроллера представления, называемый *контроллером навигации*.

## <a name="navigation-controller"></a>Контроллер навигации

В приложении Phoneword мы использовали контроллер навигации для управления навигацией между несколькими экранами. Контроллер навигации — это специализированный класс `UIViewController`, представленный классом `UINavigationController`. Вместо управления одной иерархией представления содержимого контроллер навигации управляет другими контроллерами представления, а также своей собственной особой иерархией представления содержимого в виде панели инструментов навигации, которая включает в себя заголовок, кнопку возврата и другие дополнительные возможности.

Контроллер навигации часто используется в iOS и обеспечивает навигацию в основных приложениях, например в приложении **Настройки**, как показано на рисунке ниже:

 [![](hello-ios-multiscreen-deepdive-images/01.png "Контроллер навигации обеспечивает навигацию для приложений iOS, таких как изображенное здесь приложение \"Параметры\"")](hello-ios-multiscreen-deepdive-images/01.png#lightbox)

Контроллер навигации выполняет три основные функции:

-  **Обеспечивает привязку при переходах вперед** — контроллер навигации использует метафору иерархической навигации, согласно которой иерархии содержимого представления *помещаются*  в *стек навигации*. Мы можем представить стек навигации в виде стопки игральных карт, в которой видна только самая верхняя карта, как показано на приведенной ниже схеме:  

    [![](hello-ios-multiscreen-deepdive-images/02.png "Схема иллюстрирует навигацию в виде стопки игральных карт")](hello-ios-multiscreen-deepdive-images/02.png#lightbox)


-  **При необходимости отображает кнопку возврата** — когда мы отправляем новый элемент в стек навигации, в строке заголовка может автоматически отображаться *кнопка возврата*, позволяющая при навигации возвращаться назад. Нажатие кнопки возврата *извлекает* текущий контроллер представления из стека навигации и загружает в окно предыдущую иерархию представлений содержимого:  

    [![](hello-ios-multiscreen-deepdive-images/03.png "Схема иллюстрирует извлечение карты из стопки")](hello-ios-multiscreen-deepdive-images/03.png#lightbox)


-  **Отображает строку заголовка** — верхняя часть контроллера навигации называется *заголовком*. Он отвечает за отображение заголовка контроллера представления, как показано на следующей схеме:  

    [![](hello-ios-multiscreen-deepdive-images/04.png "В заголовке отображается заголовок контроллера представления")](hello-ios-multiscreen-deepdive-images/04.png#lightbox)

### <a name="root-view-controller"></a>Корневой контроллер представления

Контроллер навигации не управляет иерархией представлений содержимого, поэтому сам по себе он ничего не отображает.
Вместо этого контроллер навигации сопряжен с *корневым контроллером представления*:

 [![](hello-ios-multiscreen-deepdive-images/05.png "Контроллер навигации сопряжен с корневым контроллером представления")](hello-ios-multiscreen-deepdive-images/05.png#lightbox)

Корневой контроллер представления является первым контроллером представления в стеке контроллеров навигации, а иерархия представлений содержимого корневого контроллера загружается в окно первой. Если требуется поместить в стек контроллеров навигации приложение целиком, можно переместить переход без источника в контроллер навигации и установить контроллер представления первого экрана в качестве корневого контроллера представления, как мы сделали в приложении Phoneword:

 [![](hello-ios-multiscreen-deepdive-images/06.png "Переход без источника устанавливает контроллер представления первого экрана в качестве корневого контроллера представления")](hello-ios-multiscreen-deepdive-images/06.png#lightbox)

### <a name="additional-navigation-options"></a>Дополнительные возможности навигации

Контроллер навигации является стандартным способом управления навигацией в iOS, но существуют и другие способы. Например, [контроллер панели вкладок](~/ios/user-interface/controls/creating-tabbed-applications.md) может разделить приложение на различные функциональные области, а [контроллер разделения представления](https://github.com/xamarin/recipes/tree/master/Recipes/ios/content_controls/split_view/use_split_view_to_show_two_controllers) может использоваться для создания основного и подробного представлений. Объединение контроллеров навигации с другими принципами навигации позволяет получить гибкие возможности для представления содержимого и навигации по содержимому в iOS.

## <a name="handling-transitions"></a>Обработка переходов

В руководстве по созданию приложения Phoneword мы обрабатывали переходы между двумя контроллерами представлений двумя способами — сначала с раскадровкой перехода, а затем программными средствами. Рассмотрим оба этих способа более подробно.

### <a name="prepareforsegue"></a>PrepareForSegue

Когда мы добавляем переход к раскадровке при помощи действия **Show**, мы даем команду операционной системе iOS для отправки второго контроллера представления в стек контроллеров навигации:

 [![](hello-ios-multiscreen-deepdive-images/09.png "Выбор типа перехода из раскрывающегося списка")](hello-ios-multiscreen-deepdive-images/09.png#lightbox)

Добавления перехода в раскадровку достаточно для создания простого перехода между экранами. Если нам необходимо передавать данные между контроллерами представления, то необходимо переопределить метод `PrepareForSegue` и обрабатывать данные самим:

```csharp
public override void PrepareForSegue (UIStoryboardSegue segue, NSObject sender)
{
    base.PrepareForSegue (segue, sender);
    ...
}
```

iOS вызывает метод `PrepareForSegue` непосредственно перед выполнением перехода и передает в метод созданный нами в раскадровке объект перехода.
На этом этапе нам нужно вручную задать для перехода целевой контроллер представления. Следующий код получает дескриптор контроллера представления назначения и приводит его к необходимому классу, в данном случае к классу CallHistoryController:

```csharp
CallHistoryController callHistoryController = segue.DestinationViewController as CallHistoryController;
```

Наконец, мы передаем список номеров телефонов (модель) из `ViewController` в `CallHistoryController`, присвоив свойству `PhoneHistory` класса `CallHistoryController` список набранных номеров телефонов:

```csharp
callHistoryController.PhoneNumbers = PhoneNumbers;
```

Ниже приведен полный код для передачи данных с помощью объекта перехода:

```csharp
public override void PrepareForSegue (UIStoryboardSegue segue, NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    var callHistoryController = segue.DestinationViewController as CallHistoryController;

    if (callHistoryController != null) {
         callHistoryController.PhoneNumbers = PhoneNumbers;
    }
 }
```

### <a name="navigation-without-segues"></a>Навигация без использования объекта Segue

Создание перехода от первого контроллера представления ко второму при помощи кода совпадает с созданием перехода при помощи объекта Segue, но необходимо выполнить некоторые действия вручную.
Во-первых, воспользуемся методом `this.NavigationController`, чтобы получить ссылку на контроллер навигации, в стеке которого мы сейчас находимся. Затем с помощью метода контроллера навигации `PushViewController` вручную отправим в стек следующий контроллер представления, передавая контроллер представления и параметр для анимации перехода (установим его в значение `true`).

Следующий код обрабатывает переход с экрана Phoneword на экран журнала звонков:

```csharp
this.NavigationController.PushViewController (callHistory, true);
```

Прежде чем мы сможем перейти к следующему контроллеру представления, нам нужно создать его экземпляр вручную из раскадровки, вызвав метод `this.Storyboard.InstantiateViewController` и передав идентификатор раскадровки `CallHistoryController`:

```csharp
CallHistoryController callHistory =
this.Storyboard.InstantiateViewController
("CallHistoryController") as CallHistoryController;
```

Наконец, мы передаем список номеров телефонов (модель) из `ViewController` в `CallHistoryController`, присвоив свойству `PhoneHistory` класса `CallHistoryController` список набранных номеров телефонов, как мы это делали, когда обрабатывали переход при помощи Segue:

```csharp
callHistory.PhoneNumbers = PhoneNumbers;
```

Ниже приведен полный код программного перехода:

```csharp
CallHistoryButton.TouchUpInside += (object sender, EventArgs e) => {
    // Launches a new instance of CallHistoryController
    CallHistoryController callHistory = this.Storyboard.InstantiateViewController ("CallHistoryController") as CallHistoryController;
    if (callHistory != null) {
     callHistory.PhoneNumbers = PhoneNumbers;
     this.NavigationController.PushViewController (callHistory, true);
    }
};
```

## <a name="additional-concepts-introduced-in-phoneword"></a>Дополнительные понятия, представленные в Phoneword

В приложении Phoneword представлено несколько понятий, не охваченных этим руководством. В их число входят следующие:

-  **Автоматическое создание контроллеров представлений** — когда мы вводим имя класса для контроллера представления на **панели свойств**, конструктор iOS проверяет, существует ли этот класс, и затем создает соответствующий класс контроллера представления. Дополнительные сведения об этой и других возможностях конструктора iOS см. в руководстве [Введение в конструктор iOS](~/ios/user-interface/designer/introduction.md).
-  **Контроллер представления таблицы** — класс `CallHistoryController` является контроллером представления таблицы. Контроллер представления таблицы содержит представление таблицы, наиболее распространенный макет и инструмент отображения данных в iOS. Обсуждение таблиц выходит за рамки данного руководства. Дополнительные сведения о контроллере представления таблицы см. в руководстве [Работа с таблицами и ячейками](~/ios/user-interface/controls/tables/index.md).
-   **Идентификатор раскадровки** — в Objective-C указание идентификатора раскадровки создает класс контроллера представления, содержащий код программной части для контроллера представления в раскадровке. Мы используем идентификатор раскадровки для нахождения класса Objective-C и создания экземпляра контроллера представления в раскадровке. Дополнительные сведения об идентификаторах раскадровок см. в руководстве [Введение в раскадровки](~/ios/user-interface/storyboards/index.md).

## <a name="summary"></a>Сводка

Поздравляем! Вы создали свое первое приложение iOS с несколькими экранами!

В этом руководстве мы рассказали о шаблоне MVC и о том, как его использовать для создания приложений с несколькими экранами. Мы также изучили контроллеры навигации и их роль в работе навигации iOS. Теперь у вас есть прочные знания, необходимые для разработки своих собственных приложений Xamarin.iOS.

Далее в руководствах [Введение в разработку мобильных приложений](~/cross-platform/get-started/introduction-to-mobile-development.md) и [Разработка кроссплатформенных приложений](~/cross-platform/app-fundamentals/building-cross-platform-applications/index.md) мы научимся создавать кроссплатформенные приложения с помощью Xamarin.

## <a name="related-links"></a>Связанные ссылки

- [Привет, iOS (пример)](https://developer.xamarin.com/samples/monotouch/Hello_iOS/)
- [Рекомендации по работе с человеческим интерфейсом iOS](https://developer.apple.com/library/ios/#documentation/UserExperience/Conceptual/MobileHIG/Introduction/Introduction.html)
- [Портал подготовки iOS](https://developer.apple.com/ios/manage/overview/index.action)
